
(function(l, r) { if (l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (window.location.host || 'localhost').split(':')[0] + ':6000/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(window.document);
(function () {
    'use strict';

    function noop() { }
    const identity = x => x;
    function assign(tar, src) {
        // @ts-ignore
        for (const k in src)
            tar[k] = src[k];
        return tar;
    }
    function add_location(element, file, line, column, char) {
        element.__svelte_meta = {
            loc: { file, line, column, char }
        };
    }
    function run(fn) {
        return fn();
    }
    function blank_object() {
        return Object.create(null);
    }
    function run_all(fns) {
        fns.forEach(run);
    }
    function is_function(thing) {
        return typeof thing === 'function';
    }
    function safe_not_equal(a, b) {
        return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
    }
    function is_empty(obj) {
        return Object.keys(obj).length === 0;
    }
    function validate_store(store, name) {
        if (store != null && typeof store.subscribe !== 'function') {
            throw new Error(`'${name}' is not a store with a 'subscribe' method`);
        }
    }
    function subscribe(store, ...callbacks) {
        if (store == null) {
            return noop;
        }
        const unsub = store.subscribe(...callbacks);
        return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
    }
    function component_subscribe(component, store, callback) {
        component.$$.on_destroy.push(subscribe(store, callback));
    }
    function create_slot(definition, ctx, $$scope, fn) {
        if (definition) {
            const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
            return definition[0](slot_ctx);
        }
    }
    function get_slot_context(definition, ctx, $$scope, fn) {
        return definition[1] && fn
            ? assign($$scope.ctx.slice(), definition[1](fn(ctx)))
            : $$scope.ctx;
    }
    function get_slot_changes(definition, $$scope, dirty, fn) {
        if (definition[2] && fn) {
            const lets = definition[2](fn(dirty));
            if ($$scope.dirty === undefined) {
                return lets;
            }
            if (typeof lets === 'object') {
                const merged = [];
                const len = Math.max($$scope.dirty.length, lets.length);
                for (let i = 0; i < len; i += 1) {
                    merged[i] = $$scope.dirty[i] | lets[i];
                }
                return merged;
            }
            return $$scope.dirty | lets;
        }
        return $$scope.dirty;
    }
    function update_slot(slot, slot_definition, ctx, $$scope, dirty, get_slot_changes_fn, get_slot_context_fn) {
        const slot_changes = get_slot_changes(slot_definition, $$scope, dirty, get_slot_changes_fn);
        if (slot_changes) {
            const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
            slot.p(slot_context, slot_changes);
        }
    }
    function exclude_internal_props(props) {
        const result = {};
        for (const k in props)
            if (k[0] !== '$')
                result[k] = props[k];
        return result;
    }
    function null_to_empty(value) {
        return value == null ? '' : value;
    }
    function set_store_value(store, ret, value = ret) {
        store.set(value);
        return ret;
    }
    function action_destroyer(action_result) {
        return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;
    }

    const is_client = typeof window !== 'undefined';
    let now = is_client
        ? () => window.performance.now()
        : () => Date.now();
    let raf = is_client ? cb => requestAnimationFrame(cb) : noop;

    const tasks = new Set();
    function run_tasks(now) {
        tasks.forEach(task => {
            if (!task.c(now)) {
                tasks.delete(task);
                task.f();
            }
        });
        if (tasks.size !== 0)
            raf(run_tasks);
    }
    /**
     * Creates a new task that runs on each raf frame
     * until it returns a falsy value or is aborted
     */
    function loop(callback) {
        let task;
        if (tasks.size === 0)
            raf(run_tasks);
        return {
            promise: new Promise(fulfill => {
                tasks.add(task = { c: callback, f: fulfill });
            }),
            abort() {
                tasks.delete(task);
            }
        };
    }

    function append(target, node) {
        target.appendChild(node);
    }
    function insert(target, node, anchor) {
        target.insertBefore(node, anchor || null);
    }
    function detach(node) {
        node.parentNode.removeChild(node);
    }
    function destroy_each(iterations, detaching) {
        for (let i = 0; i < iterations.length; i += 1) {
            if (iterations[i])
                iterations[i].d(detaching);
        }
    }
    function element(name) {
        return document.createElement(name);
    }
    function svg_element(name) {
        return document.createElementNS('http://www.w3.org/2000/svg', name);
    }
    function text(data) {
        return document.createTextNode(data);
    }
    function space() {
        return text(' ');
    }
    function empty() {
        return text('');
    }
    function listen(node, event, handler, options) {
        node.addEventListener(event, handler, options);
        return () => node.removeEventListener(event, handler, options);
    }
    function prevent_default(fn) {
        return function (event) {
            event.preventDefault();
            // @ts-ignore
            return fn.call(this, event);
        };
    }
    function stop_propagation(fn) {
        return function (event) {
            event.stopPropagation();
            // @ts-ignore
            return fn.call(this, event);
        };
    }
    function attr(node, attribute, value) {
        if (value == null)
            node.removeAttribute(attribute);
        else if (node.getAttribute(attribute) !== value)
            node.setAttribute(attribute, value);
    }
    function set_attributes(node, attributes) {
        // @ts-ignore
        const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);
        for (const key in attributes) {
            if (attributes[key] == null) {
                node.removeAttribute(key);
            }
            else if (key === 'style') {
                node.style.cssText = attributes[key];
            }
            else if (key === '__value') {
                node.value = node[key] = attributes[key];
            }
            else if (descriptors[key] && descriptors[key].set) {
                node[key] = attributes[key];
            }
            else {
                attr(node, key, attributes[key]);
            }
        }
    }
    function to_number(value) {
        return value === '' ? null : +value;
    }
    function children(element) {
        return Array.from(element.childNodes);
    }
    function set_data(text, data) {
        data = '' + data;
        if (text.wholeText !== data)
            text.data = data;
    }
    function set_input_value(input, value) {
        input.value = value == null ? '' : value;
    }
    function set_style(node, key, value, important) {
        node.style.setProperty(key, value, important ? 'important' : '');
    }
    function select_option(select, value) {
        for (let i = 0; i < select.options.length; i += 1) {
            const option = select.options[i];
            if (option.__value === value) {
                option.selected = true;
                return;
            }
        }
    }
    function select_value(select) {
        const selected_option = select.querySelector(':checked') || select.options[0];
        return selected_option && selected_option.__value;
    }
    // unfortunately this can't be a constant as that wouldn't be tree-shakeable
    // so we cache the result instead
    let crossorigin;
    function is_crossorigin() {
        if (crossorigin === undefined) {
            crossorigin = false;
            try {
                if (typeof window !== 'undefined' && window.parent) {
                    void window.parent.document;
                }
            }
            catch (error) {
                crossorigin = true;
            }
        }
        return crossorigin;
    }
    function add_resize_listener(node, fn) {
        const computed_style = getComputedStyle(node);
        const z_index = (parseInt(computed_style.zIndex) || 0) - 1;
        if (computed_style.position === 'static') {
            node.style.position = 'relative';
        }
        const iframe = element('iframe');
        iframe.setAttribute('style', `display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; ` +
            `overflow: hidden; border: 0; opacity: 0; pointer-events: none; z-index: ${z_index};`);
        iframe.setAttribute('aria-hidden', 'true');
        iframe.tabIndex = -1;
        const crossorigin = is_crossorigin();
        let unsubscribe;
        if (crossorigin) {
            iframe.src = `data:text/html,<script>onresize=function(){parent.postMessage(0,'*')}</script>`;
            unsubscribe = listen(window, 'message', (event) => {
                if (event.source === iframe.contentWindow)
                    fn();
            });
        }
        else {
            iframe.src = 'about:blank';
            iframe.onload = () => {
                unsubscribe = listen(iframe.contentWindow, 'resize', fn);
            };
        }
        append(node, iframe);
        return () => {
            if (crossorigin) {
                unsubscribe();
            }
            else if (unsubscribe && iframe.contentWindow) {
                unsubscribe();
            }
            detach(iframe);
        };
    }
    function toggle_class(element, name, toggle) {
        element.classList[toggle ? 'add' : 'remove'](name);
    }
    function custom_event(type, detail) {
        const e = document.createEvent('CustomEvent');
        e.initCustomEvent(type, false, false, detail);
        return e;
    }

    const active_docs = new Set();
    let active = 0;
    // https://github.com/darkskyapp/string-hash/blob/master/index.js
    function hash(str) {
        let hash = 5381;
        let i = str.length;
        while (i--)
            hash = ((hash << 5) - hash) ^ str.charCodeAt(i);
        return hash >>> 0;
    }
    function create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {
        const step = 16.666 / duration;
        let keyframes = '{\n';
        for (let p = 0; p <= 1; p += step) {
            const t = a + (b - a) * ease(p);
            keyframes += p * 100 + `%{${fn(t, 1 - t)}}\n`;
        }
        const rule = keyframes + `100% {${fn(b, 1 - b)}}\n}`;
        const name = `__svelte_${hash(rule)}_${uid}`;
        const doc = node.ownerDocument;
        active_docs.add(doc);
        const stylesheet = doc.__svelte_stylesheet || (doc.__svelte_stylesheet = doc.head.appendChild(element('style')).sheet);
        const current_rules = doc.__svelte_rules || (doc.__svelte_rules = {});
        if (!current_rules[name]) {
            current_rules[name] = true;
            stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);
        }
        const animation = node.style.animation || '';
        node.style.animation = `${animation ? `${animation}, ` : ``}${name} ${duration}ms linear ${delay}ms 1 both`;
        active += 1;
        return name;
    }
    function delete_rule(node, name) {
        const previous = (node.style.animation || '').split(', ');
        const next = previous.filter(name
            ? anim => anim.indexOf(name) < 0 // remove specific animation
            : anim => anim.indexOf('__svelte') === -1 // remove all Svelte animations
        );
        const deleted = previous.length - next.length;
        if (deleted) {
            node.style.animation = next.join(', ');
            active -= deleted;
            if (!active)
                clear_rules();
        }
    }
    function clear_rules() {
        raf(() => {
            if (active)
                return;
            active_docs.forEach(doc => {
                const stylesheet = doc.__svelte_stylesheet;
                let i = stylesheet.cssRules.length;
                while (i--)
                    stylesheet.deleteRule(i);
                doc.__svelte_rules = {};
            });
            active_docs.clear();
        });
    }

    let current_component;
    function set_current_component(component) {
        current_component = component;
    }
    function get_current_component() {
        if (!current_component)
            throw new Error(`Function called outside component initialization`);
        return current_component;
    }
    function beforeUpdate(fn) {
        get_current_component().$$.before_update.push(fn);
    }
    function onMount(fn) {
        get_current_component().$$.on_mount.push(fn);
    }
    function onDestroy(fn) {
        get_current_component().$$.on_destroy.push(fn);
    }
    function createEventDispatcher() {
        const component = get_current_component();
        return (type, detail) => {
            const callbacks = component.$$.callbacks[type];
            if (callbacks) {
                // TODO are there situations where events could be dispatched
                // in a server (non-DOM) environment?
                const event = custom_event(type, detail);
                callbacks.slice().forEach(fn => {
                    fn.call(component, event);
                });
            }
        };
    }
    // TODO figure out if we still want to support
    // shorthand events, or if we want to implement
    // a real bubbling mechanism
    function bubble(component, event) {
        const callbacks = component.$$.callbacks[event.type];
        if (callbacks) {
            callbacks.slice().forEach(fn => fn(event));
        }
    }

    const dirty_components = [];
    const binding_callbacks = [];
    const render_callbacks = [];
    const flush_callbacks = [];
    const resolved_promise = Promise.resolve();
    let update_scheduled = false;
    function schedule_update() {
        if (!update_scheduled) {
            update_scheduled = true;
            resolved_promise.then(flush);
        }
    }
    function tick() {
        schedule_update();
        return resolved_promise;
    }
    function add_render_callback(fn) {
        render_callbacks.push(fn);
    }
    function add_flush_callback(fn) {
        flush_callbacks.push(fn);
    }
    let flushing = false;
    const seen_callbacks = new Set();
    function flush() {
        if (flushing)
            return;
        flushing = true;
        do {
            // first, call beforeUpdate functions
            // and update components
            for (let i = 0; i < dirty_components.length; i += 1) {
                const component = dirty_components[i];
                set_current_component(component);
                update(component.$$);
            }
            set_current_component(null);
            dirty_components.length = 0;
            while (binding_callbacks.length)
                binding_callbacks.pop()();
            // then, once components are updated, call
            // afterUpdate functions. This may cause
            // subsequent updates...
            for (let i = 0; i < render_callbacks.length; i += 1) {
                const callback = render_callbacks[i];
                if (!seen_callbacks.has(callback)) {
                    // ...so guard against infinite loops
                    seen_callbacks.add(callback);
                    callback();
                }
            }
            render_callbacks.length = 0;
        } while (dirty_components.length);
        while (flush_callbacks.length) {
            flush_callbacks.pop()();
        }
        update_scheduled = false;
        flushing = false;
        seen_callbacks.clear();
    }
    function update($$) {
        if ($$.fragment !== null) {
            $$.update();
            run_all($$.before_update);
            const dirty = $$.dirty;
            $$.dirty = [-1];
            $$.fragment && $$.fragment.p($$.ctx, dirty);
            $$.after_update.forEach(add_render_callback);
        }
    }

    let promise;
    function wait() {
        if (!promise) {
            promise = Promise.resolve();
            promise.then(() => {
                promise = null;
            });
        }
        return promise;
    }
    function dispatch(node, direction, kind) {
        node.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));
    }
    const outroing = new Set();
    let outros;
    function group_outros() {
        outros = {
            r: 0,
            c: [],
            p: outros // parent group
        };
    }
    function check_outros() {
        if (!outros.r) {
            run_all(outros.c);
        }
        outros = outros.p;
    }
    function transition_in(block, local) {
        if (block && block.i) {
            outroing.delete(block);
            block.i(local);
        }
    }
    function transition_out(block, local, detach, callback) {
        if (block && block.o) {
            if (outroing.has(block))
                return;
            outroing.add(block);
            outros.c.push(() => {
                outroing.delete(block);
                if (callback) {
                    if (detach)
                        block.d(1);
                    callback();
                }
            });
            block.o(local);
        }
    }
    const null_transition = { duration: 0 };
    function create_in_transition(node, fn, params) {
        let config = fn(node, params);
        let running = false;
        let animation_name;
        let task;
        let uid = 0;
        function cleanup() {
            if (animation_name)
                delete_rule(node, animation_name);
        }
        function go() {
            const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;
            if (css)
                animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);
            tick(0, 1);
            const start_time = now() + delay;
            const end_time = start_time + duration;
            if (task)
                task.abort();
            running = true;
            add_render_callback(() => dispatch(node, true, 'start'));
            task = loop(now => {
                if (running) {
                    if (now >= end_time) {
                        tick(1, 0);
                        dispatch(node, true, 'end');
                        cleanup();
                        return running = false;
                    }
                    if (now >= start_time) {
                        const t = easing((now - start_time) / duration);
                        tick(t, 1 - t);
                    }
                }
                return running;
            });
        }
        let started = false;
        return {
            start() {
                if (started)
                    return;
                delete_rule(node);
                if (is_function(config)) {
                    config = config();
                    wait().then(go);
                }
                else {
                    go();
                }
            },
            invalidate() {
                started = false;
            },
            end() {
                if (running) {
                    cleanup();
                    running = false;
                }
            }
        };
    }
    function create_out_transition(node, fn, params) {
        let config = fn(node, params);
        let running = true;
        let animation_name;
        const group = outros;
        group.r += 1;
        function go() {
            const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;
            if (css)
                animation_name = create_rule(node, 1, 0, duration, delay, easing, css);
            const start_time = now() + delay;
            const end_time = start_time + duration;
            add_render_callback(() => dispatch(node, false, 'start'));
            loop(now => {
                if (running) {
                    if (now >= end_time) {
                        tick(0, 1);
                        dispatch(node, false, 'end');
                        if (!--group.r) {
                            // this will result in `end()` being called,
                            // so we don't need to clean up here
                            run_all(group.c);
                        }
                        return false;
                    }
                    if (now >= start_time) {
                        const t = easing((now - start_time) / duration);
                        tick(1 - t, t);
                    }
                }
                return running;
            });
        }
        if (is_function(config)) {
            wait().then(() => {
                // @ts-ignore
                config = config();
                go();
            });
        }
        else {
            go();
        }
        return {
            end(reset) {
                if (reset && config.tick) {
                    config.tick(1, 0);
                }
                if (running) {
                    if (animation_name)
                        delete_rule(node, animation_name);
                    running = false;
                }
            }
        };
    }
    function create_bidirectional_transition(node, fn, params, intro) {
        let config = fn(node, params);
        let t = intro ? 0 : 1;
        let running_program = null;
        let pending_program = null;
        let animation_name = null;
        function clear_animation() {
            if (animation_name)
                delete_rule(node, animation_name);
        }
        function init(program, duration) {
            const d = program.b - t;
            duration *= Math.abs(d);
            return {
                a: t,
                b: program.b,
                d,
                duration,
                start: program.start,
                end: program.start + duration,
                group: program.group
            };
        }
        function go(b) {
            const { delay = 0, duration = 300, easing = identity, tick = noop, css } = config || null_transition;
            const program = {
                start: now() + delay,
                b
            };
            if (!b) {
                // @ts-ignore todo: improve typings
                program.group = outros;
                outros.r += 1;
            }
            if (running_program || pending_program) {
                pending_program = program;
            }
            else {
                // if this is an intro, and there's a delay, we need to do
                // an initial tick and/or apply CSS animation immediately
                if (css) {
                    clear_animation();
                    animation_name = create_rule(node, t, b, duration, delay, easing, css);
                }
                if (b)
                    tick(0, 1);
                running_program = init(program, duration);
                add_render_callback(() => dispatch(node, b, 'start'));
                loop(now => {
                    if (pending_program && now > pending_program.start) {
                        running_program = init(pending_program, duration);
                        pending_program = null;
                        dispatch(node, running_program.b, 'start');
                        if (css) {
                            clear_animation();
                            animation_name = create_rule(node, t, running_program.b, running_program.duration, 0, easing, config.css);
                        }
                    }
                    if (running_program) {
                        if (now >= running_program.end) {
                            tick(t = running_program.b, 1 - t);
                            dispatch(node, running_program.b, 'end');
                            if (!pending_program) {
                                // we're done
                                if (running_program.b) {
                                    // intro — we can tidy up immediately
                                    clear_animation();
                                }
                                else {
                                    // outro — needs to be coordinated
                                    if (!--running_program.group.r)
                                        run_all(running_program.group.c);
                                }
                            }
                            running_program = null;
                        }
                        else if (now >= running_program.start) {
                            const p = now - running_program.start;
                            t = running_program.a + running_program.d * easing(p / running_program.duration);
                            tick(t, 1 - t);
                        }
                    }
                    return !!(running_program || pending_program);
                });
            }
        }
        return {
            run(b) {
                if (is_function(config)) {
                    wait().then(() => {
                        // @ts-ignore
                        config = config();
                        go(b);
                    });
                }
                else {
                    go(b);
                }
            },
            end() {
                clear_animation();
                running_program = pending_program = null;
            }
        };
    }

    const globals = (typeof window !== 'undefined'
        ? window
        : typeof globalThis !== 'undefined'
            ? globalThis
            : global);

    function destroy_block(block, lookup) {
        block.d(1);
        lookup.delete(block.key);
    }
    function outro_and_destroy_block(block, lookup) {
        transition_out(block, 1, 1, () => {
            lookup.delete(block.key);
        });
    }
    function update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block, next, get_context) {
        let o = old_blocks.length;
        let n = list.length;
        let i = o;
        const old_indexes = {};
        while (i--)
            old_indexes[old_blocks[i].key] = i;
        const new_blocks = [];
        const new_lookup = new Map();
        const deltas = new Map();
        i = n;
        while (i--) {
            const child_ctx = get_context(ctx, list, i);
            const key = get_key(child_ctx);
            let block = lookup.get(key);
            if (!block) {
                block = create_each_block(key, child_ctx);
                block.c();
            }
            else if (dynamic) {
                block.p(child_ctx, dirty);
            }
            new_lookup.set(key, new_blocks[i] = block);
            if (key in old_indexes)
                deltas.set(key, Math.abs(i - old_indexes[key]));
        }
        const will_move = new Set();
        const did_move = new Set();
        function insert(block) {
            transition_in(block, 1);
            block.m(node, next);
            lookup.set(block.key, block);
            next = block.first;
            n--;
        }
        while (o && n) {
            const new_block = new_blocks[n - 1];
            const old_block = old_blocks[o - 1];
            const new_key = new_block.key;
            const old_key = old_block.key;
            if (new_block === old_block) {
                // do nothing
                next = new_block.first;
                o--;
                n--;
            }
            else if (!new_lookup.has(old_key)) {
                // remove old block
                destroy(old_block, lookup);
                o--;
            }
            else if (!lookup.has(new_key) || will_move.has(new_key)) {
                insert(new_block);
            }
            else if (did_move.has(old_key)) {
                o--;
            }
            else if (deltas.get(new_key) > deltas.get(old_key)) {
                did_move.add(new_key);
                insert(new_block);
            }
            else {
                will_move.add(old_key);
                o--;
            }
        }
        while (o--) {
            const old_block = old_blocks[o];
            if (!new_lookup.has(old_block.key))
                destroy(old_block, lookup);
        }
        while (n)
            insert(new_blocks[n - 1]);
        return new_blocks;
    }
    function validate_each_keys(ctx, list, get_context, get_key) {
        const keys = new Set();
        for (let i = 0; i < list.length; i++) {
            const key = get_key(get_context(ctx, list, i));
            if (keys.has(key)) {
                throw new Error(`Cannot have duplicate keys in a keyed each`);
            }
            keys.add(key);
        }
    }

    function get_spread_update(levels, updates) {
        const update = {};
        const to_null_out = {};
        const accounted_for = { $$scope: 1 };
        let i = levels.length;
        while (i--) {
            const o = levels[i];
            const n = updates[i];
            if (n) {
                for (const key in o) {
                    if (!(key in n))
                        to_null_out[key] = 1;
                }
                for (const key in n) {
                    if (!accounted_for[key]) {
                        update[key] = n[key];
                        accounted_for[key] = 1;
                    }
                }
                levels[i] = n;
            }
            else {
                for (const key in o) {
                    accounted_for[key] = 1;
                }
            }
        }
        for (const key in to_null_out) {
            if (!(key in update))
                update[key] = undefined;
        }
        return update;
    }

    function bind(component, name, callback) {
        const index = component.$$.props[name];
        if (index !== undefined) {
            component.$$.bound[index] = callback;
            callback(component.$$.ctx[index]);
        }
    }
    function create_component(block) {
        block && block.c();
    }
    function mount_component(component, target, anchor) {
        const { fragment, on_mount, on_destroy, after_update } = component.$$;
        fragment && fragment.m(target, anchor);
        // onMount happens before the initial afterUpdate
        add_render_callback(() => {
            const new_on_destroy = on_mount.map(run).filter(is_function);
            if (on_destroy) {
                on_destroy.push(...new_on_destroy);
            }
            else {
                // Edge case - component was destroyed immediately,
                // most likely as a result of a binding initialising
                run_all(new_on_destroy);
            }
            component.$$.on_mount = [];
        });
        after_update.forEach(add_render_callback);
    }
    function destroy_component(component, detaching) {
        const $$ = component.$$;
        if ($$.fragment !== null) {
            run_all($$.on_destroy);
            $$.fragment && $$.fragment.d(detaching);
            // TODO null out other refs, including component.$$ (but need to
            // preserve final state?)
            $$.on_destroy = $$.fragment = null;
            $$.ctx = [];
        }
    }
    function make_dirty(component, i) {
        if (component.$$.dirty[0] === -1) {
            dirty_components.push(component);
            schedule_update();
            component.$$.dirty.fill(0);
        }
        component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));
    }
    function init(component, options, instance, create_fragment, not_equal, props, dirty = [-1]) {
        const parent_component = current_component;
        set_current_component(component);
        const prop_values = options.props || {};
        const $$ = component.$$ = {
            fragment: null,
            ctx: null,
            // state
            props,
            update: noop,
            not_equal,
            bound: blank_object(),
            // lifecycle
            on_mount: [],
            on_destroy: [],
            before_update: [],
            after_update: [],
            context: new Map(parent_component ? parent_component.$$.context : []),
            // everything else
            callbacks: blank_object(),
            dirty,
            skip_bound: false
        };
        let ready = false;
        $$.ctx = instance
            ? instance(component, prop_values, (i, ret, ...rest) => {
                const value = rest.length ? rest[0] : ret;
                if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
                    if (!$$.skip_bound && $$.bound[i])
                        $$.bound[i](value);
                    if (ready)
                        make_dirty(component, i);
                }
                return ret;
            })
            : [];
        $$.update();
        ready = true;
        run_all($$.before_update);
        // `false` as a special case of no DOM component
        $$.fragment = create_fragment ? create_fragment($$.ctx) : false;
        if (options.target) {
            if (options.hydrate) {
                const nodes = children(options.target);
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.l(nodes);
                nodes.forEach(detach);
            }
            else {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                $$.fragment && $$.fragment.c();
            }
            if (options.intro)
                transition_in(component.$$.fragment);
            mount_component(component, options.target, options.anchor);
            flush();
        }
        set_current_component(parent_component);
    }
    class SvelteComponent {
        $destroy() {
            destroy_component(this, 1);
            this.$destroy = noop;
        }
        $on(type, callback) {
            const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
            callbacks.push(callback);
            return () => {
                const index = callbacks.indexOf(callback);
                if (index !== -1)
                    callbacks.splice(index, 1);
            };
        }
        $set($$props) {
            if (this.$$set && !is_empty($$props)) {
                this.$$.skip_bound = true;
                this.$$set($$props);
                this.$$.skip_bound = false;
            }
        }
    }

    function dispatch_dev(type, detail) {
        document.dispatchEvent(custom_event(type, Object.assign({ version: '3.29.0' }, detail)));
    }
    function append_dev(target, node) {
        dispatch_dev("SvelteDOMInsert", { target, node });
        append(target, node);
    }
    function insert_dev(target, node, anchor) {
        dispatch_dev("SvelteDOMInsert", { target, node, anchor });
        insert(target, node, anchor);
    }
    function detach_dev(node) {
        dispatch_dev("SvelteDOMRemove", { node });
        detach(node);
    }
    function listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation) {
        const modifiers = options === true ? ["capture"] : options ? Array.from(Object.keys(options)) : [];
        if (has_prevent_default)
            modifiers.push('preventDefault');
        if (has_stop_propagation)
            modifiers.push('stopPropagation');
        dispatch_dev("SvelteDOMAddEventListener", { node, event, handler, modifiers });
        const dispose = listen(node, event, handler, options);
        return () => {
            dispatch_dev("SvelteDOMRemoveEventListener", { node, event, handler, modifiers });
            dispose();
        };
    }
    function attr_dev(node, attribute, value) {
        attr(node, attribute, value);
        if (value == null)
            dispatch_dev("SvelteDOMRemoveAttribute", { node, attribute });
        else
            dispatch_dev("SvelteDOMSetAttribute", { node, attribute, value });
    }
    function set_data_dev(text, data) {
        data = '' + data;
        if (text.wholeText === data)
            return;
        dispatch_dev("SvelteDOMSetData", { node: text, data });
        text.data = data;
    }
    function validate_each_argument(arg) {
        if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg)) {
            let msg = '{#each} only iterates over array-like objects.';
            if (typeof Symbol === 'function' && arg && Symbol.iterator in arg) {
                msg += ' You can use a spread to convert this iterable into an array.';
            }
            throw new Error(msg);
        }
    }
    function validate_slots(name, slot, keys) {
        for (const slot_key of Object.keys(slot)) {
            if (!~keys.indexOf(slot_key)) {
                console.warn(`<${name}> received an unexpected slot "${slot_key}".`);
            }
        }
    }
    class SvelteComponentDev extends SvelteComponent {
        constructor(options) {
            if (!options || (!options.target && !options.$$inline)) {
                throw new Error(`'target' is a required option`);
            }
            super();
        }
        $destroy() {
            super.$destroy();
            this.$destroy = () => {
                console.warn(`Component was already destroyed`); // eslint-disable-line no-console
            };
        }
        $capture_state() { }
        $inject_state() { }
    }

    function cubicInOut(t) {
        return t < 0.5 ? 4.0 * t * t * t : 0.5 * Math.pow(2.0 * t - 2.0, 3.0) + 1.0;
    }
    function cubicOut(t) {
        const f = t - 1.0;
        return f * f * f + 1.0;
    }
    function quintOut(t) {
        return --t * t * t * t * t + 1;
    }

    function blur(node, { delay = 0, duration = 400, easing = cubicInOut, amount = 5, opacity = 0 }) {
        const style = getComputedStyle(node);
        const target_opacity = +style.opacity;
        const f = style.filter === 'none' ? '' : style.filter;
        const od = target_opacity * (1 - opacity);
        return {
            delay,
            duration,
            easing,
            css: (_t, u) => `opacity: ${target_opacity - (od * u)}; filter: ${f} blur(${u * amount}px);`
        };
    }
    function fade(node, { delay = 0, duration = 400, easing = identity }) {
        const o = +getComputedStyle(node).opacity;
        return {
            delay,
            duration,
            easing,
            css: t => `opacity: ${t * o}`
        };
    }
    function fly(node, { delay = 0, duration = 400, easing = cubicOut, x = 0, y = 0, opacity = 0 }) {
        const style = getComputedStyle(node);
        const target_opacity = +style.opacity;
        const transform = style.transform === 'none' ? '' : style.transform;
        const od = target_opacity * (1 - opacity);
        return {
            delay,
            duration,
            easing,
            css: (t, u) => `
			transform: ${transform} translate(${(1 - t) * x}px, ${(1 - t) * y}px);
			opacity: ${target_opacity - (od * u)}`
        };
    }
    function slide(node, { delay = 0, duration = 400, easing = cubicOut }) {
        const style = getComputedStyle(node);
        const opacity = +style.opacity;
        const height = parseFloat(style.height);
        const padding_top = parseFloat(style.paddingTop);
        const padding_bottom = parseFloat(style.paddingBottom);
        const margin_top = parseFloat(style.marginTop);
        const margin_bottom = parseFloat(style.marginBottom);
        const border_top_width = parseFloat(style.borderTopWidth);
        const border_bottom_width = parseFloat(style.borderBottomWidth);
        return {
            delay,
            duration,
            easing,
            css: t => `overflow: hidden;` +
                `opacity: ${Math.min(t * 20, 1) * opacity};` +
                `height: ${t * height}px;` +
                `padding-top: ${t * padding_top}px;` +
                `padding-bottom: ${t * padding_bottom}px;` +
                `margin-top: ${t * margin_top}px;` +
                `margin-bottom: ${t * margin_bottom}px;` +
                `border-top-width: ${t * border_top_width}px;` +
                `border-bottom-width: ${t * border_bottom_width}px;`
        };
    }
    function scale(node, { delay = 0, duration = 400, easing = cubicOut, start = 0, opacity = 0 }) {
        const style = getComputedStyle(node);
        const target_opacity = +style.opacity;
        const transform = style.transform === 'none' ? '' : style.transform;
        const sd = 1 - start;
        const od = target_opacity * (1 - opacity);
        return {
            delay,
            duration,
            easing,
            css: (_t, u) => `
			transform: ${transform} scale(${1 - (sd * u)});
			opacity: ${target_opacity - (od * u)}
		`
        };
    }

    function oe(n){return l=>{const o=Object.keys(n.$$.callbacks),i=[];return o.forEach(o=>i.push(listen(l,o,e=>bubble(n,e)))),{destroy:()=>{i.forEach(e=>e());}}}}function ie(){return "undefined"!=typeof window&&!(window.CSS&&window.CSS.supports&&window.CSS.supports("(--foo: red)"))}function se(e){var t;return "r"===e.charAt(0)?e=(t=(t=e).match(/^rgba?[\s+]?\([\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?/i))&&4===t.length?"#"+("0"+parseInt(t[1],10).toString(16)).slice(-2)+("0"+parseInt(t[2],10).toString(16)).slice(-2)+("0"+parseInt(t[3],10).toString(16)).slice(-2):"":"transparent"===e.toLowerCase()&&(e="#00000000"),e}const{document:re}=globals;function ae(e){let t;return {c(){t=element("div"),attr(t,"class","ripple svelte-po4fcb");},m(n,l){insert(n,t,l),e[5](t);},p:noop,i:noop,o:noop,d(n){n&&detach(t),e[5](null);}}}function ce(e,t){e.style.transform=t,e.style.webkitTransform=t;}function de(e,t){e.style.opacity=t.toString();}const ue=function(e,t){const n=["touchcancel","mouseleave","dragstart"];let l=t.currentTarget||t.target;if(l&&!l.classList.contains("ripple")&&(l=l.querySelector(".ripple")),!l)return;const o=l.dataset.event;if(o&&o!==e)return;l.dataset.event=e;const i=document.createElement("span"),{radius:s,scale:r,x:a,y:c,centerX:d,centerY:u}=((e,t)=>{const n=t.getBoundingClientRect(),l=function(e){return "TouchEvent"===e.constructor.name}(e)?e.touches[e.touches.length-1]:e,o=l.clientX-n.left,i=l.clientY-n.top;let s=0,r=.3;const a=t.dataset.center;t.dataset.circle?(r=.15,s=t.clientWidth/2,s=a?s:s+Math.sqrt((o-s)**2+(i-s)**2)/4):s=Math.sqrt(t.clientWidth**2+t.clientHeight**2)/2;const c=(t.clientWidth-2*s)/2+"px",d=(t.clientHeight-2*s)/2+"px";return {radius:s,scale:r,x:a?c:o-s+"px",y:a?d:i-s+"px",centerX:c,centerY:d}})(t,l),p=l.dataset.color,f=2*s+"px";i.className="animation",i.style.width=f,i.style.height=f,i.style.background=p,i.classList.add("animation--enter"),i.classList.add("animation--visible"),ce(i,`translate(${a}, ${c}) scale3d(${r},${r},${r})`),de(i,0),i.dataset.activated=String(performance.now()),l.appendChild(i),setTimeout(()=>{i.classList.remove("animation--enter"),i.classList.add("animation--in"),ce(i,`translate(${d}, ${u}) scale3d(1,1,1)`),de(i,.25);},0);const v="mousedown"===e?"mouseup":"touchend",h=function(){document.removeEventListener(v,h),n.forEach(e=>{document.removeEventListener(e,h);});const e=performance.now()-Number(i.dataset.activated),t=Math.max(250-e,0);setTimeout(()=>{i.classList.remove("animation--in"),i.classList.add("animation--out"),de(i,0),setTimeout(()=>{i&&l.removeChild(i),0===l.children.length&&delete l.dataset.event;},300);},t);};document.addEventListener(v,h),n.forEach(e=>{document.addEventListener(e,h,{passive:!0});});},pe=function(e){0===e.button&&ue(e.type,e);},fe=function(e){if(e.changedTouches)for(let t=0;t<e.changedTouches.length;++t)ue(e.type,e.changedTouches[t]);};function ve(e,t,n){let l,o,{center:i=!1}=t,{circle:s=!1}=t,{color:r="currentColor"}=t;return onMount(async()=>{await tick();try{i&&n(0,l.dataset.center="true",l),s&&n(0,l.dataset.circle="true",l),n(0,l.dataset.color=r,l),o=l.parentElement;}catch(e){}if(!o)return void console.error("Ripple: Trigger element not found.");let e=window.getComputedStyle(o);0!==e.position.length&&"static"!==e.position||(o.style.position="relative"),o.addEventListener("touchstart",fe,{passive:!0}),o.addEventListener("mousedown",pe,{passive:!0});}),onDestroy(()=>{o&&(o.removeEventListener("mousedown",pe),o.removeEventListener("touchstart",fe));}),e.$set=e=>{"center"in e&&n(1,i=e.center),"circle"in e&&n(2,s=e.circle),"color"in e&&n(3,r=e.color);},[l,i,s,r,o,function(e){binding_callbacks[e?"unshift":"push"](()=>{n(0,l=e);});}]}class he extends SvelteComponent{constructor(e){var t;super(),re.getElementById("svelte-po4fcb-style")||((t=element("style")).id="svelte-po4fcb-style",t.textContent=".ripple.svelte-po4fcb{display:block;position:absolute;top:0;left:0;right:0;bottom:0;overflow:hidden;border-radius:inherit;color:inherit;pointer-events:none;z-index:0;contain:strict}.ripple.svelte-po4fcb .animation{color:inherit;position:absolute;top:0;left:0;border-radius:50%;opacity:0;pointer-events:none;overflow:hidden;will-change:transform, opacity}.ripple.svelte-po4fcb .animation--enter{transition:none}.ripple.svelte-po4fcb .animation--in{transition:opacity 0.1s cubic-bezier(0.4, 0, 0.2, 1);transition:transform 0.25s cubic-bezier(0.4, 0, 0.2, 1),\n\t\t\topacity 0.1s cubic-bezier(0.4, 0, 0.2, 1)}.ripple.svelte-po4fcb .animation--out{transition:opacity 0.3s cubic-bezier(0.4, 0, 0.2, 1)}",append(re.head,t)),init(this,e,ve,ae,safe_not_equal,{center:1,circle:2,color:3});}}function ge(e){let t;const n=new he({props:{center:e[3],circle:e[3]}});return {c(){create_component(n.$$.fragment);},m(e,l){mount_component(n,e,l),t=!0;},p(e,t){const l={};8&t&&(l.center=e[3]),8&t&&(l.circle=e[3]),n.$set(l);},i(e){t||(transition_in(n.$$.fragment,e),t=!0);},o(e){transition_out(n.$$.fragment,e),t=!1;},d(e){destroy_component(n,e);}}}function me(t){let n,l,o,i,a,d;const p=t[22].default,v=create_slot(p,t,t[21],null);let h=t[10]&&ge(t),b=[{class:t[1]},{style:t[2]},t[14]],E={};for(let e=0;e<b.length;e+=1)E=assign(E,b[e]);return {c(){n=element("button"),v&&v.c(),l=space(),h&&h.c(),set_attributes(n,E),toggle_class(n,"raised",t[6]),toggle_class(n,"outlined",t[8]&&!(t[6]||t[7])),toggle_class(n,"shaped",t[9]&&!t[3]),toggle_class(n,"dense",t[5]),toggle_class(n,"fab",t[4]&&t[3]),toggle_class(n,"icon-button",t[3]),toggle_class(n,"toggle",t[11]),toggle_class(n,"active",t[11]&&t[0]),toggle_class(n,"full-width",t[12]&&!t[3]),toggle_class(n,"svelte-6bcb3a",!0);},m(s,u){insert(s,n,u),v&&v.m(n,null),append(n,l),h&&h.m(n,null),t[23](n),i=!0,a||(d=[listen(n,"click",t[16]),action_destroyer(o=t[15].call(null,n))],a=!0);},p(e,[t]){v&&v.p&&2097152&t&&update_slot(v,p,e,e[21],t,null,null),e[10]?h?(h.p(e,t),1024&t&&transition_in(h,1)):(h=ge(e),h.c(),transition_in(h,1),h.m(n,null)):h&&(group_outros(),transition_out(h,1,1,()=>{h=null;}),check_outros()),set_attributes(n,E=get_spread_update(b,[2&t&&{class:e[1]},4&t&&{style:e[2]},16384&t&&e[14]])),toggle_class(n,"raised",e[6]),toggle_class(n,"outlined",e[8]&&!(e[6]||e[7])),toggle_class(n,"shaped",e[9]&&!e[3]),toggle_class(n,"dense",e[5]),toggle_class(n,"fab",e[4]&&e[3]),toggle_class(n,"icon-button",e[3]),toggle_class(n,"toggle",e[11]),toggle_class(n,"active",e[11]&&e[0]),toggle_class(n,"full-width",e[12]&&!e[3]),toggle_class(n,"svelte-6bcb3a",!0);},i(e){i||(transition_in(v,e),transition_in(h),i=!0);},o(e){transition_out(v,e),transition_out(h),i=!1;},d(e){e&&detach(n),v&&v.d(e),h&&h.d(),t[23](null),a=!1,run_all(d);}}}function be(e,t,n){const l=createEventDispatcher(),o=oe(current_component);let i,{class:s=""}=t,{style:r=null}=t,{icon:a=!1}=t,{fab:c=!1}=t,{dense:d=!1}=t,{raised:u=!1}=t,{unelevated:f=!1}=t,{outlined:v=!1}=t,{shaped:h=!1}=t,{color:g=null}=t,{ripple:m=!0}=t,{toggle:b=!1}=t,{active:x=!1}=t,{fullWidth:w=!1}=t,$={};beforeUpdate(()=>{if(!i)return;let e=i.getElementsByTagName("svg"),t=e.length;for(let n=0;n<t;n++)e[n].setAttribute("width",z+(b&&!a?2:0)),e[n].setAttribute("height",z+(b&&!a?2:0));n(13,i.style.backgroundColor=u||f?g:"transparent",i);let l=getComputedStyle(i).getPropertyValue("background-color");n(13,i.style.color=u||f?function(e="#ffffff"){let t,n,l,o,i,s;if(0===e.length&&(e="#ffffff"),e=se(e),e=String(e).replace(/[^0-9a-f]/gi,""),!new RegExp(/^(?:[0-9a-f]{3}){1,2}$/i).test(e))throw new Error("Invalid HEX color!");e.length<6&&(e=e[0]+e[0]+e[1]+e[1]+e[2]+e[2]);const r=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(e);return t=parseInt(r[1],16)/255,n=parseInt(r[2],16)/255,l=parseInt(r[3],16)/255,o=t<=.03928?t/12.92:Math.pow((t+.055)/1.055,2.4),i=n<=.03928?n/12.92:Math.pow((n+.055)/1.055,2.4),s=l<=.03928?l/12.92:Math.pow((l+.055)/1.055,2.4),.2126*o+.7152*i+.0722*s}(l)>.5?"#000":"#fff":g,i);});let z,{$$slots:k={},$$scope:D}=t;return e.$set=e=>{n(20,t=assign(assign({},t),exclude_internal_props(e))),"class"in e&&n(1,s=e.class),"style"in e&&n(2,r=e.style),"icon"in e&&n(3,a=e.icon),"fab"in e&&n(4,c=e.fab),"dense"in e&&n(5,d=e.dense),"raised"in e&&n(6,u=e.raised),"unelevated"in e&&n(7,f=e.unelevated),"outlined"in e&&n(8,v=e.outlined),"shaped"in e&&n(9,h=e.shaped),"color"in e&&n(17,g=e.color),"ripple"in e&&n(10,m=e.ripple),"toggle"in e&&n(11,b=e.toggle),"active"in e&&n(0,x=e.active),"fullWidth"in e&&n(12,w=e.fullWidth),"$$scope"in e&&n(21,D=e.$$scope);},e.$$.update=()=>{{const{style:e,icon:l,fab:o,dense:i,raised:s,unelevated:r,outlined:a,shaped:c,color:d,ripple:u,toggle:p,active:f,fullWidth:v,...h}=t;!h.disabled&&delete h.disabled,delete h.class,n(14,$=h);}56&e.$$.dirty&&(z=a?c?24:d?20:24:d?16:18),139264&e.$$.dirty&&("primary"===g?n(17,g=ie()?"#1976d2":"var(--primary, #1976d2)"):"accent"==g?n(17,g=ie()?"#f50057":"var(--accent, #f50057)"):!g&&i&&n(17,g=i.style.color||i.parentElement.style.color||(ie()?"#333":"var(--color, #333)")));},t=exclude_internal_props(t),[x,s,r,a,c,d,u,f,v,h,m,b,w,i,$,o,function(e){b&&(n(0,x=!x),l("change",x));},g,z,l,t,D,k,function(e){binding_callbacks[e?"unshift":"push"](()=>{n(13,i=e);});}]}class ye extends SvelteComponent{constructor(e){var t;super(),document.getElementById("svelte-6bcb3a-style")||((t=element("style")).id="svelte-6bcb3a-style",t.textContent="button.svelte-6bcb3a:disabled{cursor:default}button.svelte-6bcb3a{cursor:pointer;font-family:Roboto, Helvetica, sans-serif;font-family:var(--button-font-family, Roboto, Helvetica, sans-serif);font-size:0.875rem;font-weight:500;letter-spacing:0.75px;text-decoration:none;text-transform:uppercase;will-change:transform, opacity;margin:0;padding:0 16px;display:-ms-inline-flexbox;display:inline-flex;position:relative;align-items:center;justify-content:center;box-sizing:border-box;height:36px;border:none;outline:none;line-height:inherit;user-select:none;overflow:hidden;vertical-align:middle;border-radius:4px}button.svelte-6bcb3a::-moz-focus-inner{border:0}button.svelte-6bcb3a:-moz-focusring{outline:none}button.svelte-6bcb3a:before{box-sizing:inherit;border-radius:inherit;color:inherit;bottom:0;content:'';left:0;opacity:0;pointer-events:none;position:absolute;right:0;top:0;transition:0.2s cubic-bezier(0.25, 0.8, 0.5, 1);will-change:background-color, opacity}.toggle.svelte-6bcb3a:before{box-sizing:content-box}.active.svelte-6bcb3a:before{background-color:currentColor;opacity:0.3}.raised.svelte-6bcb3a{box-shadow:0 3px 1px -2px rgba(0, 0, 0, 0.2), 0 2px 2px 0 rgba(0, 0, 0, 0.14),\n\t\t\t0 1px 5px 0 rgba(0, 0, 0, 0.12)}.outlined.svelte-6bcb3a{padding:0 14px;border-style:solid;border-width:2px}.shaped.svelte-6bcb3a{border-radius:18px}.dense.svelte-6bcb3a{height:32px}.icon-button.svelte-6bcb3a{line-height:0.5;border-radius:50%;padding:8px;width:40px;height:40px;vertical-align:middle}.icon-button.outlined.svelte-6bcb3a{padding:6px}.icon-button.fab.svelte-6bcb3a{border:none;width:56px;height:56px;box-shadow:0 3px 5px -1px rgba(0, 0, 0, 0.2), 0 6px 10px 0 rgba(0, 0, 0, 0.14),\n\t\t\t0 1px 18px 0 rgba(0, 0, 0, 0.12)}.icon-button.dense.svelte-6bcb3a{width:36px;height:36px}.icon-button.fab.dense.svelte-6bcb3a{width:40px;height:40px}.outlined.svelte-6bcb3a:not(.shaped) .ripple{border-radius:0 !important}.full-width.svelte-6bcb3a{width:100%}@media(hover: hover){button.svelte-6bcb3a:hover:not(.toggle):not([disabled]):not(.disabled):before{background-color:currentColor;opacity:0.15}button.focus-visible.svelte-6bcb3a:focus:not(.toggle):not([disabled]):not(.disabled):before{background-color:currentColor;opacity:0.3}button.focus-visible.toggle.svelte-6bcb3a:focus:not(.active):not([disabled]):not(.disabled):before{background-color:currentColor;opacity:0.15}}",append(document.head,t)),init(this,e,be,me,safe_not_equal,{class:1,style:2,icon:3,fab:4,dense:5,raised:6,unelevated:7,outlined:8,shaped:9,color:17,ripple:10,toggle:11,active:0,fullWidth:12});}}function xe(e){let t,n,l;const o=e[3].default,i=create_slot(o,e,e[2],null);return {c(){t=element("div"),i&&i.c(),attr(t,"class","button-group svelte-x6hf3e"),attr(t,"style",n=e[0]?`color: ${e[0]};`:""+e[1]);},m(e,n){insert(e,t,n),i&&i.m(t,null),l=!0;},p(e,[s]){i&&i.p&&4&s&&update_slot(i,o,e,e[2],s,null,null),(!l||3&s&&n!==(n=e[0]?`color: ${e[0]};`:""+e[1]))&&attr(t,"style",n);},i(e){l||(transition_in(i,e),l=!0);},o(e){transition_out(i,e),l=!1;},d(e){e&&detach(t),i&&i.d(e);}}}function we(e,t,n){let{color:l=""}=t,{style:o=""}=t,{$$slots:i={},$$scope:s}=t;return e.$set=e=>{"color"in e&&n(0,l=e.color),"style"in e&&n(1,o=e.style),"$$scope"in e&&n(2,s=e.$$scope);},e.$$.update=()=>{1&e.$$.dirty&&("primary"===l?n(0,l=ie()?"#1976d2":"var(--primary, #1976d2)"):"accent"==l&&n(0,l=ie()?"#f50057":"var(--accent, #f50057)"));},[l,o,s,i]}class $e extends SvelteComponent{constructor(e){var t;super(),document.getElementById("svelte-x6hf3e-style")||((t=element("style")).id="svelte-x6hf3e-style",t.textContent=".button-group.svelte-x6hf3e{display:inline-flex;flex-wrap:wrap}.button-group.svelte-x6hf3e button{padding:0 8px}.button-group.svelte-x6hf3e button:first-child{border-top-right-radius:0;border-bottom-right-radius:0}.button-group.svelte-x6hf3e button:last-child{border-top-left-radius:0;border-bottom-left-radius:0}.button-group.svelte-x6hf3e .shaped:first-child{padding-left:12px}.button-group.svelte-x6hf3e .shaped:last-child{padding-right:12px}.button-group.svelte-x6hf3e button:not(:first-child):not(:last-child){border-radius:0}.button-group.svelte-x6hf3e button:not(:first-child){border-left:none}.button-group.svelte-x6hf3e .outlined{border-width:1px}",append(document.head,t)),init(this,e,we,xe,safe_not_equal,{color:0,style:1});}}function ze(e){let t;const n=e[13].default,l=create_slot(n,e,e[12],null);return {c(){l&&l.c();},m(e,n){l&&l.m(e,n),t=!0;},p(e,t){l&&l.p&&4096&t&&update_slot(l,n,e,e[12],t,null,null);},i(e){t||(transition_in(l,e),t=!0);},o(e){transition_out(l,e),t=!1;},d(e){l&&l.d(e);}}}function ke(e){let t,n;return {c(){t=svg_element("svg"),n=svg_element("path"),attr(n,"d",e[1]),attr(t,"xmlns","http://www.w3.org/2000/svg"),attr(t,"viewBox",e[2]),attr(t,"class","svelte-h2unzw");},m(e,l){insert(e,t,l),append(t,n);},p(e,l){2&l&&attr(n,"d",e[1]),4&l&&attr(t,"viewBox",e[2]);},i:noop,o:noop,d(e){e&&detach(t);}}}function De(e){let t,n,l,o,i,r,a;const d=[ke,ze],p=[];function f(e,t){return "string"==typeof e[1]?0:1}n=f(e),l=p[n]=d[n](e);let v=[{class:"icon "+e[0]},e[7]],h={};for(let e=0;e<v.length;e+=1)h=assign(h,v[e]);return {c(){t=element("i"),l.c(),set_attributes(t,h),toggle_class(t,"flip",e[3]&&"boolean"==typeof e[3]),toggle_class(t,"flip-h","h"===e[3]),toggle_class(t,"flip-v","v"===e[3]),toggle_class(t,"spin",e[4]),toggle_class(t,"pulse",e[5]&&!e[4]),toggle_class(t,"svelte-h2unzw",!0);},m(l,s){insert(l,t,s),p[n].m(t,null),e[14](t),i=!0,r||(a=action_destroyer(o=e[8].call(null,t)),r=!0);},p(e,[o]){let i=n;n=f(e),n===i?p[n].p(e,o):(group_outros(),transition_out(p[i],1,1,()=>{p[i]=null;}),check_outros(),l=p[n],l||(l=p[n]=d[n](e),l.c()),transition_in(l,1),l.m(t,null)),set_attributes(t,h=get_spread_update(v,[1&o&&{class:"icon "+e[0]},128&o&&e[7]])),toggle_class(t,"flip",e[3]&&"boolean"==typeof e[3]),toggle_class(t,"flip-h","h"===e[3]),toggle_class(t,"flip-v","v"===e[3]),toggle_class(t,"spin",e[4]),toggle_class(t,"pulse",e[5]&&!e[4]),toggle_class(t,"svelte-h2unzw",!0);},i(e){i||(transition_in(l),i=!0);},o(e){transition_out(l),i=!1;},d(l){l&&detach(t),p[n].d(),e[14](null),r=!1,a();}}}function Ce(e,t,n){const l=oe(current_component);let o,{class:i=""}=t,{path:s=null}=t,{size:r=24}=t,{viewBox:a="0 0 24 24"}=t,{color:c="currentColor"}=t,{flip:d=!1}=t,{spin:u=!1}=t,{pulse:f=!1}=t,v={},{$$slots:h={},$$scope:g}=t;return e.$set=e=>{n(11,t=assign(assign({},t),exclude_internal_props(e))),"class"in e&&n(0,i=e.class),"path"in e&&n(1,s=e.path),"size"in e&&n(9,r=e.size),"viewBox"in e&&n(2,a=e.viewBox),"color"in e&&n(10,c=e.color),"flip"in e&&n(3,d=e.flip),"spin"in e&&n(4,u=e.spin),"pulse"in e&&n(5,f=e.pulse),"$$scope"in e&&n(12,g=e.$$scope);},e.$$.update=()=>{{const{path:e,size:l,viewBox:o,color:i,flip:s,spin:r,pulse:a,...c}=t;delete c.class,n(7,v=c);}1600&e.$$.dirty&&o&&(o.firstChild.setAttribute("width",r),o.firstChild.setAttribute("height",r),c&&o.firstChild.setAttribute("fill",c));},t=exclude_internal_props(t),[i,s,a,d,u,f,o,v,l,r,c,t,g,h,function(e){binding_callbacks[e?"unshift":"push"](()=>{n(6,o=e);});}]}class Me extends SvelteComponent{constructor(e){var t;super(),document.getElementById("svelte-h2unzw-style")||((t=element("style")).id="svelte-h2unzw-style",t.textContent=".icon.svelte-h2unzw.svelte-h2unzw{display:inline-block;position:relative;vertical-align:middle;line-height:0.5}.icon.svelte-h2unzw>svg.svelte-h2unzw{display:inline-block}.flip.svelte-h2unzw.svelte-h2unzw{transform:scale(-1, -1)}.flip-h.svelte-h2unzw.svelte-h2unzw{transform:scale(-1, 1)}.flip-v.svelte-h2unzw.svelte-h2unzw{transform:scale(1, -1)}.spin.svelte-h2unzw.svelte-h2unzw{animation:svelte-h2unzw-spin 1s 0s infinite linear}.pulse.svelte-h2unzw.svelte-h2unzw{animation:svelte-h2unzw-spin 1s infinite steps(8)}@keyframes svelte-h2unzw-spin{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}",append(document.head,t)),init(this,e,Ce,De,safe_not_equal,{class:0,path:1,size:9,viewBox:2,color:10,flip:3,spin:4,pulse:5});}}function Le(e){let t;const n=new he({props:{center:!0,circle:!0}});return {c(){create_component(n.$$.fragment);},m(e,l){mount_component(n,e,l),t=!0;},i(e){t||(transition_in(n.$$.fragment,e),t=!0);},o(e){transition_out(n.$$.fragment,e),t=!1;},d(e){destroy_component(n,e);}}}function Ee(t){let n,l,o,i,d,p,E,Y,j,N,B,I,F,S=[{type:"checkbox"},{__value:t[9]},t[10]],q={};for(let e=0;e<S.length;e+=1)q=assign(q,S[e]);const _=new Me({props:{path:t[2]?Ae:t[0]?Ye:je}});let H=t[7]&&Le();const O=t[17].default,P=create_slot(O,t,t[16],null);return {c(){n=element("label"),l=element("input"),i=space(),d=element("div"),create_component(_.$$.fragment),p=space(),H&&H.c(),Y=space(),j=element("div"),P&&P.c(),set_attributes(l,q),void 0!==t[0]&&void 0!==t[2]||add_render_callback(()=>t[18].call(l)),toggle_class(l,"svelte-1idh7xl",!0),attr(d,"class","mark svelte-1idh7xl"),attr(d,"style",E="color: "+(t[2]||t[0]?t[1]:"#9a9a9a")),attr(j,"class","label-text svelte-1idh7xl"),attr(n,"class",N=null_to_empty(t[3])+" svelte-1idh7xl"),attr(n,"style",t[4]),attr(n,"title",t[8]),toggle_class(n,"right",t[6]),toggle_class(n,"disabled",t[5]);},m(s,a){insert(s,n,a),append(n,l),l.checked=t[0],l.indeterminate=t[2],append(n,i),append(n,d),mount_component(_,d,null),append(d,p),H&&H.m(d,null),append(n,Y),append(n,j),P&&P.m(j,null),B=!0,I||(F=[listen(l,"change",t[18]),listen(l,"change",t[12]),action_destroyer(o=t[11].call(null,l))],I=!0);},p(e,[t]){set_attributes(l,q=get_spread_update(S,[{type:"checkbox"},512&t&&{__value:e[9]},1024&t&&e[10]])),1&t&&(l.checked=e[0]),4&t&&(l.indeterminate=e[2]),toggle_class(l,"svelte-1idh7xl",!0);const o={};5&t&&(o.path=e[2]?Ae:e[0]?Ye:je),_.$set(o),e[7]?H?128&t&&transition_in(H,1):(H=Le(),H.c(),transition_in(H,1),H.m(d,null)):H&&(group_outros(),transition_out(H,1,1,()=>{H=null;}),check_outros()),(!B||7&t&&E!==(E="color: "+(e[2]||e[0]?e[1]:"#9a9a9a")))&&attr(d,"style",E),P&&P.p&&65536&t&&update_slot(P,O,e,e[16],t,null,null),(!B||8&t&&N!==(N=null_to_empty(e[3])+" svelte-1idh7xl"))&&attr(n,"class",N),(!B||16&t)&&attr(n,"style",e[4]),(!B||256&t)&&attr(n,"title",e[8]),72&t&&toggle_class(n,"right",e[6]),40&t&&toggle_class(n,"disabled",e[5]);},i(e){B||(transition_in(_.$$.fragment,e),transition_in(H),transition_in(P,e),B=!0);},o(e){transition_out(_.$$.fragment,e),transition_out(H),transition_out(P,e),B=!1;},d(e){e&&detach(n),destroy_component(_),H&&H.d(),P&&P.d(e),I=!1,run_all(F);}}}let Ye="M19 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.11 0 2-.9 2-2V5c0-1.1-.89-2-2-2zm-9 14l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z",je="M19 5v14H5V5h14m0-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2z",Ae="M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-2 10H7v-2h10v2z";function Te(e,t,n){const l=oe(current_component);let{checked:o=!1}=t,{class:i=""}=t,{style:s=null}=t,{color:r="primary"}=t,{disabled:a=!1}=t,{group:c=null}=t,{indeterminate:d=!1}=t,{right:u=!1}=t,{ripple:p=!0}=t,{title:f=null}=t,{value:v="on"}=t,h={};function g(){setTimeout(()=>{n(0,o=c.indexOf(v)>=0);},0);}let{$$slots:m={},$$scope:b}=t;return e.$set=e=>{n(15,t=assign(assign({},t),exclude_internal_props(e))),"checked"in e&&n(0,o=e.checked),"class"in e&&n(3,i=e.class),"style"in e&&n(4,s=e.style),"color"in e&&n(1,r=e.color),"disabled"in e&&n(5,a=e.disabled),"group"in e&&n(13,c=e.group),"indeterminate"in e&&n(2,d=e.indeterminate),"right"in e&&n(6,u=e.right),"ripple"in e&&n(7,p=e.ripple),"title"in e&&n(8,f=e.title),"value"in e&&n(9,v=e.value),"$$scope"in e&&n(16,b=e.$$scope);},e.$$.update=()=>{{const{checked:e,style:l,color:o,group:i,indeterminate:s,right:r,ripple:a,title:c,value:d,...u}=t;!u.disabled&&delete u.disabled,delete u.class,n(10,h=u);}8192&e.$$.dirty&&null!==c&&g(),2&e.$$.dirty&&("primary"!==r&&r?"accent"===r&&n(1,r=ie()?"#f50057":"var(--accent, #f50057)"):n(1,r=ie()?"#1976d2":"var(--primary, #1976d2)"));},t=exclude_internal_props(t),[o,r,d,i,s,a,u,p,f,v,h,l,function(){if(null!==c){let e=c.indexOf(v);o?e<0&&c.push(v):e>=0&&c.splice(e,1),n(13,c);}},c,g,t,b,m,function(){o=this.checked,d=this.indeterminate,n(0,o),n(2,d);}]}class Ne extends SvelteComponent{constructor(e){var t;super(),document.getElementById("svelte-1idh7xl-style")||((t=element("style")).id="svelte-1idh7xl-style",t.textContent="label.svelte-1idh7xl.svelte-1idh7xl{width:100%;align-items:center;display:flex;margin:0;position:relative;cursor:pointer;line-height:40px;user-select:none}input.svelte-1idh7xl.svelte-1idh7xl{cursor:inherit;width:100%;height:100%;position:absolute;top:0;left:0;margin:0;padding:0;opacity:0 !important}.mark.svelte-1idh7xl.svelte-1idh7xl{display:flex;position:relative;justify-content:center;align-items:center;border-radius:50%;width:40px;height:40px}.mark.svelte-1idh7xl.svelte-1idh7xl:before{background-color:currentColor;border-radius:inherit;bottom:0;color:inherit;content:'';left:0;opacity:0;pointer-events:none;position:absolute;right:0;top:0;transition:0.3s cubic-bezier(0.25, 0.8, 0.5, 1)}@media not all and (min-resolution: 0.001dpcm){@supports (-webkit-appearance: none) and (stroke-color: transparent){.mark.svelte-1idh7xl.svelte-1idh7xl:before{transition:none}}}.label-text.svelte-1idh7xl.svelte-1idh7xl{margin-left:4px;white-space:nowrap;overflow:hidden}.right.svelte-1idh7xl .label-text.svelte-1idh7xl{margin-left:0;margin-right:auto;order:-1}@media(hover: hover){label.svelte-1idh7xl:hover:not([disabled]):not(.disabled) .mark.svelte-1idh7xl:before{opacity:0.15}.focus-visible:focus:not([disabled]):not(.disabled)~.mark.svelte-1idh7xl.svelte-1idh7xl:before{opacity:0.3}}",append(document.head,t)),init(this,e,Te,Ee,safe_not_equal,{checked:0,class:3,style:4,color:1,disabled:5,group:13,indeterminate:2,right:6,ripple:7,title:8,value:9});}}function He(e){let t;return {c(){t=element("span"),t.textContent="*",attr(t,"class","required svelte-1dzu4e7");},m(e,n){insert(e,t,n);},d(e){e&&detach(t);}}}function Oe(e){let t,n,l;return {c(){t=element("div"),n=space(),l=element("div"),attr(t,"class","input-line svelte-1dzu4e7"),attr(l,"class","focus-line svelte-1dzu4e7");},m(e,o){insert(e,t,o),insert(e,n,o),insert(e,l,o);},d(e){e&&detach(t),e&&detach(n),e&&detach(l);}}}function Pe(e){let t,n,l,o=(e[11]||e[10])+"";return {c(){t=element("div"),n=element("div"),l=text(o),attr(n,"class","message"),attr(t,"class","help svelte-1dzu4e7"),toggle_class(t,"persist",e[9]),toggle_class(t,"error",e[11]);},m(e,o){insert(e,t,o),append(t,n),append(n,l);},p(e,n){3072&n&&o!==(o=(e[11]||e[10])+"")&&set_data(l,o),512&n&&toggle_class(t,"persist",e[9]),2048&n&&toggle_class(t,"error",e[11]);},d(e){e&&detach(t);}}}function We(t){let n,l,o,i,p,f,v,h,g,m,b,k,D,C,E=[{class:"input"},t[12]],Y={};for(let e=0;e<E.length;e+=1)Y=assign(Y,E[e]);let j=t[2]&&!t[0].length&&He(),A=(!t[7]||t[8])&&Oe(),F=(!!t[10]||!!t[11])&&Pe(t);return {c(){n=element("div"),l=element("input"),i=space(),p=element("div"),f=space(),v=element("div"),h=text(t[6]),g=space(),j&&j.c(),m=space(),A&&A.c(),b=space(),F&&F.c(),set_attributes(l,Y),toggle_class(l,"svelte-1dzu4e7",!0),attr(p,"class","focus-ring svelte-1dzu4e7"),attr(v,"class","label svelte-1dzu4e7"),attr(n,"class",k=null_to_empty(`text-field ${t[7]&&!t[8]?"outlined":"baseline"} ${t[3]}`)+" svelte-1dzu4e7"),attr(n,"style",t[4]),attr(n,"title",t[5]),toggle_class(n,"filled",t[8]),toggle_class(n,"dirty",t[13]),toggle_class(n,"disabled",t[1]);},m(s,a){insert(s,n,a),append(n,l),set_input_value(l,t[0]),append(n,i),append(n,p),append(n,f),append(n,v),append(v,h),append(v,g),j&&j.m(v,null),append(n,m),A&&A.m(n,null),append(n,b),F&&F.m(n,null),D||(C=[listen(l,"input",t[19]),action_destroyer(o=t[14].call(null,l))],D=!0);},p(e,[t]){set_attributes(l,Y=get_spread_update(E,[{class:"input"},4096&t&&e[12]])),1&t&&l.value!==e[0]&&set_input_value(l,e[0]),toggle_class(l,"svelte-1dzu4e7",!0),64&t&&set_data(h,e[6]),e[2]&&!e[0].length?j||(j=He(),j.c(),j.m(v,null)):j&&(j.d(1),j=null),!e[7]||e[8]?A||(A=Oe(),A.c(),A.m(n,b)):A&&(A.d(1),A=null),e[10]||e[11]?F?F.p(e,t):(F=Pe(e),F.c(),F.m(n,null)):F&&(F.d(1),F=null),392&t&&k!==(k=null_to_empty(`text-field ${e[7]&&!e[8]?"outlined":"baseline"} ${e[3]}`)+" svelte-1dzu4e7")&&attr(n,"class",k),16&t&&attr(n,"style",e[4]),32&t&&attr(n,"title",e[5]),392&t&&toggle_class(n,"filled",e[8]),8584&t&&toggle_class(n,"dirty",e[13]),394&t&&toggle_class(n,"disabled",e[1]);},i:noop,o:noop,d(e){e&&detach(n),j&&j.d(),A&&A.d(),F&&F.d(),D=!1,run_all(C);}}}function Xe(e,t,n){const l=oe(current_component);let o,{value:i=""}=t,{disabled:s=!1}=t,{required:r=!1}=t,{class:a=""}=t,{style:c=null}=t,{title:d=null}=t,{label:u=""}=t,{outlined:p=!1}=t,{filled:f=!1}=t,{messagePersist:v=!1}=t,{message:h=""}=t,{error:g=""}=t,m={};const b=["date","datetime-local","email","month","number","password","search","tel","text","time","url","week"],x=["date","datetime-local","month","time","week"];let w;return e.$set=e=>{n(18,t=assign(assign({},t),exclude_internal_props(e))),"value"in e&&n(0,i=e.value),"disabled"in e&&n(1,s=e.disabled),"required"in e&&n(2,r=e.required),"class"in e&&n(3,a=e.class),"style"in e&&n(4,c=e.style),"title"in e&&n(5,d=e.title),"label"in e&&n(6,u=e.label),"outlined"in e&&n(7,p=e.outlined),"filled"in e&&n(8,f=e.filled),"messagePersist"in e&&n(9,v=e.messagePersist),"message"in e&&n(10,h=e.message),"error"in e&&n(11,g=e.error);},e.$$.update=()=>{{const{value:e,style:l,title:i,label:s,outlined:r,filled:a,messagePersist:c,message:d,error:u,...p}=t;!p.readonly&&delete p.readonly,!p.disabled&&delete p.disabled,delete p.class,p.type=b.indexOf(p.type)<0?"text":p.type,n(15,o=p.placeholder),n(12,m=p);}36865&e.$$.dirty&&n(13,w="string"==typeof i&&i.length>0||"number"==typeof i||o||x.indexOf(m.type)>=0);},t=exclude_internal_props(t),[i,s,r,a,c,d,u,p,f,v,h,g,m,w,l,o,b,x,t,function(){i=this.value,n(0,i);}]}class Ve extends SvelteComponent{constructor(e){var t;super(),document.getElementById("svelte-1dzu4e7-style")||((t=element("style")).id="svelte-1dzu4e7-style",t.textContent=".text-field.svelte-1dzu4e7.svelte-1dzu4e7{font-family:Roboto, 'Segoe UI', sans-serif;font-weight:400;font-size:inherit;text-decoration:inherit;text-transform:inherit;box-sizing:border-box;margin:0 0 20px;position:relative;width:100%;background-color:inherit;will-change:opacity, transform, color}.outlined.svelte-1dzu4e7.svelte-1dzu4e7{margin-top:12px}.required.svelte-1dzu4e7.svelte-1dzu4e7{position:relative;top:0.175em;left:0.125em;color:#ff5252}.input.svelte-1dzu4e7.svelte-1dzu4e7{box-sizing:border-box;font:inherit;width:100%;min-height:32px;background:none;text-align:left;color:#333;color:var(--color, #333);caret-color:#1976d2;caret-color:var(--primary, #1976d2);border:none;margin:0;padding:2px 0 0;outline:none}.input.svelte-1dzu4e7.svelte-1dzu4e7::placeholder{color:rgba(0, 0, 0, 0.3755);color:var(--label, rgba(0, 0, 0, 0.3755));font-weight:100}.input.svelte-1dzu4e7.svelte-1dzu4e7::-moz-focus-inner{padding:0;border:0}.input.svelte-1dzu4e7.svelte-1dzu4e7:-moz-focusring{outline:none}.input.svelte-1dzu4e7.svelte-1dzu4e7:required{box-shadow:none}.input.svelte-1dzu4e7.svelte-1dzu4e7:invalid{box-shadow:none}.input.svelte-1dzu4e7.svelte-1dzu4e7:active{outline:none}.input:hover~.input-line.svelte-1dzu4e7.svelte-1dzu4e7{background:#333;background:var(--color, #333)}.label.svelte-1dzu4e7.svelte-1dzu4e7{font:inherit;display:inline-flex;position:absolute;left:0;top:28px;padding-right:0.2em;color:rgba(0, 0, 0, 0.3755);color:var(--label, rgba(0, 0, 0, 0.3755));background-color:inherit;pointer-events:none;-webkit-backface-visibility:hidden;backface-visibility:hidden;overflow:hidden;max-width:90%;white-space:nowrap;transform-origin:left top;transition:0.18s cubic-bezier(0.25, 0.8, 0.5, 1)}.focus-ring.svelte-1dzu4e7.svelte-1dzu4e7{pointer-events:none;margin:0;padding:0;border:2px solid transparent;border-radius:4px;position:absolute;left:0;top:0;right:0;bottom:0}.input-line.svelte-1dzu4e7.svelte-1dzu4e7{position:absolute;left:0;right:0;bottom:0;margin:0;height:1px;background:rgba(0, 0, 0, 0.3755);background:var(--label, rgba(0, 0, 0, 0.3755))}.focus-line.svelte-1dzu4e7.svelte-1dzu4e7{position:absolute;bottom:0;left:0;right:0;height:2px;-webkit-transform:scaleX(0);transform:scaleX(0);transition:transform 0.18s cubic-bezier(0.4, 0, 0.2, 1),\n\t\t\topacity 0.18s cubic-bezier(0.4, 0, 0.2, 1),\n\t\t\t-webkit-transform 0.18s cubic-bezier(0.4, 0, 0.2, 1);transition:transform 0.18s cubic-bezier(0.4, 0, 0.2, 1),\n\t\t\topacity 0.18s cubic-bezier(0.4, 0, 0.2, 1);opacity:0;z-index:2;background:#1976d2;background:var(--primary, #1976d2)}.help.svelte-1dzu4e7.svelte-1dzu4e7{position:absolute;left:0;right:0;bottom:-18px;display:flex;justify-content:space-between;font-size:12px;line-height:normal;letter-spacing:0.4px;color:rgba(0, 0, 0, 0.3755);color:var(--label, rgba(0, 0, 0, 0.3755));opacity:0;overflow:hidden;max-width:90%;white-space:nowrap}.persist.svelte-1dzu4e7.svelte-1dzu4e7,.error.svelte-1dzu4e7.svelte-1dzu4e7,.input:focus~.help.svelte-1dzu4e7.svelte-1dzu4e7{opacity:1}.error.svelte-1dzu4e7.svelte-1dzu4e7{color:#ff5252}.baseline.dirty.svelte-1dzu4e7 .label.svelte-1dzu4e7{letter-spacing:0.4px;top:6px;bottom:unset;font-size:13px}.baseline .input:focus~.label.svelte-1dzu4e7.svelte-1dzu4e7{letter-spacing:0.4px;top:6px;bottom:unset;font-size:13px;color:#1976d2;color:var(--primary, #1976d2)}.baseline .input:focus~.focus-line.svelte-1dzu4e7.svelte-1dzu4e7{transform:scaleX(1);opacity:1}.baseline.svelte-1dzu4e7 .input.svelte-1dzu4e7{height:52px;padding-top:22px}.baseline.filled.svelte-1dzu4e7.svelte-1dzu4e7{background:rgba(0, 0, 0, 0.0555);background:var(--bg-input-filled, rgba(0, 0, 0, 0.0555));border-radius:4px 4px 0 0}.baseline.filled.svelte-1dzu4e7 .label.svelte-1dzu4e7{background:none}.baseline.filled.svelte-1dzu4e7 .input.svelte-1dzu4e7,.baseline.filled.svelte-1dzu4e7 .label.svelte-1dzu4e7{padding-left:8px;padding-right:8px}.baseline.filled .input:focus~.label.svelte-1dzu4e7.svelte-1dzu4e7{top:6px}.baseline.filled.svelte-1dzu4e7 .help.svelte-1dzu4e7{padding-left:8px}.filled.svelte-1dzu4e7 .input.svelte-1dzu4e7:hover,.filled.svelte-1dzu4e7 .input.svelte-1dzu4e7:focus{background:rgba(0, 0, 0, 0.0555);background:var(--bg-input-filled, rgba(0, 0, 0, 0.0555))}.outlined.svelte-1dzu4e7 .help.svelte-1dzu4e7{left:18px}.outlined.svelte-1dzu4e7 .input.svelte-1dzu4e7{padding:11px 16px 9px;border-radius:4px;border:1px solid;border-color:rgba(0, 0, 0, 0.3755);border-color:var(--label, rgba(0, 0, 0, 0.3755))}.outlined.svelte-1dzu4e7 .label.svelte-1dzu4e7{top:12px;bottom:unset;left:17px}.outlined.dirty.svelte-1dzu4e7 .label.svelte-1dzu4e7{top:-6px;bottom:unset;font-size:12px;letter-spacing:0.4px;padding:0 4px;left:13px}.outlined.svelte-1dzu4e7 .input.svelte-1dzu4e7:hover{border-color:#333;border-color:var(--color, #333)}.outlined .input:focus~.label.svelte-1dzu4e7.svelte-1dzu4e7{top:-6px;bottom:unset;font-size:12px;letter-spacing:0.4px;padding:0 4px;left:13px;color:#1976d2;color:var(--primary, #1976d2)}.outlined .input:focus~.focus-ring.svelte-1dzu4e7.svelte-1dzu4e7,.outlined .input.focus-visible~.focus-ring.svelte-1dzu4e7.svelte-1dzu4e7{border-color:#1976d2;border-color:var(--primary, #1976d2)}",append(document.head,t)),init(this,e,Xe,We,safe_not_equal,{value:0,disabled:1,required:2,class:3,style:4,title:5,label:6,outlined:7,filled:8,messagePersist:9,message:10,error:11});}}function Re(e,t){if("Tab"!==e.key&&9!==e.keyCode)return;let n=function(e=document){return Array.prototype.slice.call(e.querySelectorAll('button, [href], select, textarea, input:not([type="hidden"]), [tabindex]:not([tabindex="-1"])')).filter((function(e){const t=window.getComputedStyle(e);return !e.disabled&&!e.getAttribute("disabled")&&!e.classList.contains("disabled")&&"none"!==t.display&&"hidden"!==t.visibility&&t.opacity>0}))}(t);if(0===n.length)return void e.preventDefault();let l=document.activeElement,o=n.indexOf(l);e.shiftKey?o<=0&&(n[n.length-1].focus(),e.preventDefault()):o>=n.length-1&&(n[0].focus(),e.preventDefault());}const{window:Ze}=globals;function Ue(t){let n,l,o,i,r,d,p,v;const h=t[23].default,b=create_slot(h,t,t[22],null);return {c(){n=element("div"),b&&b.c(),attr(n,"class",l=null_to_empty("popover "+t[1])+" svelte-5k22n0"),attr(n,"style",t[2]),attr(n,"tabindex","-1");},m(l,i){insert(l,n,i),b&&b.m(n,null),t[26](n),d=!0,p||(v=[listen(n,"introstart",t[24]),listen(n,"introend",t[25]),action_destroyer(o=t[4].call(null,n))],p=!0);},p(e,t){b&&b.p&&4194304&t&&update_slot(b,h,e,e[22],t,null,null),(!d||2&t&&l!==(l=null_to_empty("popover "+e[1])+" svelte-5k22n0"))&&attr(n,"class",l),(!d||4&t)&&attr(n,"style",e[2]);},i(e){d||(transition_in(b,e),add_render_callback(()=>{r&&r.end(1),i||(i=create_in_transition(n,t[5],{})),i.start();}),d=!0);},o(e){transition_out(b,e),i&&i.invalidate(),r=create_out_transition(n,t[6],{}),d=!1;},d(e){e&&detach(n),b&&b.d(e),t[26](null),e&&r&&r.end(),p=!1,run_all(v);}}}function Ge(t){let n,l,o,i,s=t[0]&&Ue(t);return {c(){s&&s.c(),n=empty();},m(r,a){s&&s.m(r,a),insert(r,n,a),l=!0,o||(i=[listen(Ze,"scroll",t[8],{passive:!0}),listen(Ze,"resize",t[9],{passive:!0}),listen(Ze,"keydown",t[10],!0),listen(Ze,"click",t[11],!0)],o=!0);},p(e,[t]){e[0]?s?(s.p(e,t),1&t&&transition_in(s,1)):(s=Ue(e),s.c(),transition_in(s,1),s.m(n.parentNode,n)):s&&(group_outros(),transition_out(s,1,1,()=>{s=null;}),check_outros());},i(e){l||(transition_in(s),l=!0);},o(e){transition_out(s),l=!1;},d(e){s&&s.d(e),e&&detach(n),o=!1,run_all(i);}}}function Ke(e,t,n){const l=oe(current_component),o=createEventDispatcher();let i,s,{class:r=""}=t,{style:a=null}=t,{origin:c="top left"}=t,{dx:d=0}=t,{dy:u=0}=t,{visible:f=!1}=t,{duration:v=300}=t;async function h({target:e}){setTimeout(()=>{e.style.transitionDuration=v+"ms",e.style.transitionProperty="opacity, transform",e.style.transform="scale(1)",e.style.opacity=null;},0);}function g(e,t){let l=0;n(12,d=+d);const o=window.innerWidth-8-e;return l=l=c.indexOf("left")>=0?t.left+d:t.left+t.width-e-d,l=Math.min(o,l),l=Math.max(8,l),l}function m(e,t){let l=0;n(13,u=+u);const o=window.innerHeight-8-e;return l=l=c.indexOf("top")>=0?t.top+u:t.top+t.height-e-u,l=Math.min(o,l),l=Math.max(8,l),l}function b(){if(!f||!i||!s)return;const e=s.getBoundingClientRect();e.top<-e.height||e.top>window.innerHeight?y("overflow"):(n(3,i.style.top=m(i.offsetHeight,e)+"px",i),n(3,i.style.left=g(i.offsetWidth,e)+"px",i));}function y(e){o("close",e),n(0,f=!1);}beforeUpdate(()=>{s=i?i.parentElement:null,s&&b();});let{$$slots:x={},$$scope:w}=t;return e.$set=e=>{"class"in e&&n(1,r=e.class),"style"in e&&n(2,a=e.style),"origin"in e&&n(14,c=e.origin),"dx"in e&&n(12,d=e.dx),"dy"in e&&n(13,u=e.dy),"visible"in e&&n(0,f=e.visible),"duration"in e&&n(15,v=e.duration),"$$scope"in e&&n(22,w=e.$$scope);},[f,r,a,i,l,function(e){return e.style.transformOrigin=c,e.style.transform="scale(0.6)",e.style.opacity="0",{duration:+v}},function(e){return e.style.transformOrigin=c,e.style.transitionDuration=v+"ms",e.style.transitionProperty="opacity, transform",e.style.transform="scale(0.6)",e.style.opacity="0",{duration:+v}},h,function(){b();},function(){b();},function(e){f&&(27===e.keyCode&&(e.stopPropagation(),y("escape")),Re(e,i));},function(e){f&&s&&!s.contains(e.target)&&(e.stopPropagation(),y("clickOutside"));},d,u,c,v,s,o,g,m,b,y,w,x,e=>h(e),e=>function({target:e}){e.style.transformOrigin=null,e.style.transitionDuration=null,e.style.transitionProperty=null,e.style.transform=null,e.focus();}(e),function(e){binding_callbacks[e?"unshift":"push"](()=>{n(3,i=e);});}]}class Je extends SvelteComponent{constructor(e){var t;super(),document.getElementById("svelte-5k22n0-style")||((t=element("style")).id="svelte-5k22n0-style",t.textContent=".popover.svelte-5k22n0{color:#333;color:var(--color, #333);background:#fff;background:var(--bg-popover, #fff);backface-visibility:hidden;position:fixed;border-radius:2px;max-height:100%;max-width:80%;overflow:auto;outline:none;box-shadow:0 3px 3px -2px rgba(0, 0, 0, 0.2), 0 3px 4px 0 rgba(0, 0, 0, 0.14),\n\t\t\t0 1px 8px 0 rgba(0, 0, 0, 0.12);z-index:50}",append(document.head,t)),init(this,e,Ke,Ge,safe_not_equal,{class:1,style:2,origin:14,dx:12,dy:13,visible:0,duration:15});}}function tn(e){let t="hidden"===document.body.style.overflow;if(e&&t){let e=Math.abs(parseInt(document.body.style.top));document.body.style.cssText=null,document.body.removeAttribute("style"),window.scrollTo(0,e);}else e||t||(document.body.style.top="-"+Math.max(document.body.scrollTop,document.documentElement&&document.documentElement.scrollTop||0)+"px",document.body.style.position="fixed",document.body.style.width="100%",document.body.style.overflow="hidden");}const nn=e=>({}),ln=e=>({}),on=e=>({}),sn=e=>({}),rn=e=>({}),an=e=>({});function cn(t){let n,l,o,i,d,p,v,h,b,D,C,E,Y;const j=t[19].title,T=create_slot(j,t,t[18],an),N=t[19].default,B=create_slot(N,t,t[18],null),I=t[19].actions,S=create_slot(I,t,t[18],sn),q=t[19].footer,_=create_slot(q,t,t[18],ln);let H=[{class:"dialog "+t[1]},{style:`width: ${t[3]}px;${t[2]}`},{tabindex:"-1"},t[6]],O={};for(let e=0;e<H.length;e+=1)O=assign(O,H[e]);return {c(){n=element("div"),l=element("div"),o=element("div"),T&&T.c(),i=space(),d=element("div"),B&&B.c(),p=space(),S&&S.c(),v=space(),_&&_.c(),attr(o,"class","title svelte-1pkw9hl"),attr(d,"class","content svelte-1pkw9hl"),set_attributes(l,O),toggle_class(l,"svelte-1pkw9hl",!0),attr(n,"class","overlay svelte-1pkw9hl");},m(s,a){insert(s,n,a),append(n,l),append(l,o),T&&T.m(o,null),append(l,i),append(l,d),B&&B.m(d,null),append(l,p),S&&S.m(l,null),append(l,v),_&&_.m(l,null),t[21](l),C=!0,E||(Y=[action_destroyer(h=t[8].call(null,l)),listen(l,"mousedown",stop_propagation(t[20])),listen(l,"mouseenter",t[22]),listen(n,"mousedown",t[23]),listen(n,"mouseup",t[24])],E=!0);},p(e,t){T&&T.p&&262144&t&&update_slot(T,j,e,e[18],t,rn,an),B&&B.p&&262144&t&&update_slot(B,N,e,e[18],t,null,null),S&&S.p&&262144&t&&update_slot(S,I,e,e[18],t,on,sn),_&&_.p&&262144&t&&update_slot(_,q,e,e[18],t,nn,ln),set_attributes(l,O=get_spread_update(H,[2&t&&{class:"dialog "+e[1]},12&t&&{style:`width: ${e[3]}px;${e[2]}`},{tabindex:"-1"},64&t&&e[6]])),toggle_class(l,"svelte-1pkw9hl",!0);},i(e){C||(transition_in(T,e),transition_in(B,e),transition_in(S,e),transition_in(_,e),b||add_render_callback(()=>{b=create_in_transition(l,scale,{duration:180,opacity:.5,start:.75,easing:quintOut}),b.start();}),add_render_callback(()=>{D||(D=create_bidirectional_transition(n,fade,{duration:180},!0)),D.run(1);}),C=!0);},o(e){transition_out(T,e),transition_out(B,e),transition_out(S,e),transition_out(_,e),D||(D=create_bidirectional_transition(n,fade,{duration:180},!1)),D.run(0),C=!1;},d(e){e&&detach(n),T&&T.d(e),B&&B.d(e),S&&S.d(e),_&&_.d(e),t[21](null),e&&D&&D.end(),E=!1,run_all(Y);}}}function dn(t){let n,l,o,i,s=t[0]&&cn(t);return {c(){s&&s.c(),n=empty();},m(r,a){s&&s.m(r,a),insert(r,n,a),l=!0,o||(i=[listen(window,"keydown",t[10]),listen(window,"popstate",t[11])],o=!0);},p(e,[t]){e[0]?s?(s.p(e,t),1&t&&transition_in(s,1)):(s=cn(e),s.c(),transition_in(s,1),s.m(n.parentNode,n)):s&&(group_outros(),transition_out(s,1,1,()=>{s=null;}),check_outros());},i(e){l||(transition_in(s),l=!0);},o(e){transition_out(s),l=!1;},d(e){s&&s.d(e),e&&detach(n),o=!1,run_all(i);}}}function un(e,n,l){const o=createEventDispatcher(),i=oe(current_component);let s,{class:r=""}=n,{style:a=""}=n,{visible:c=!1}=n,{width:d=320}=n,{modal:u=!1}=n,{closeByEsc:f=!0}=n,{beforeClose:v=(()=>!0)}=n,h=!1,g={},m=!1;function b(e){v()&&(o("close",e),l(0,c=!1));}async function x(){if(!s)return;await tick();let e=s.querySelectorAll('input:not([type="hidden"])'),t=e.length,n=0;for(;n<t&&!e[n].getAttribute("autofocus");n++);n<t?e[n].focus():t>0?e[0].focus():s.focus(),o("open");}onMount(async()=>{await tick(),l(14,m=!0);}),onDestroy(()=>{m&&tn(!0);});let{$$slots:w={},$$scope:$}=n;return e.$set=e=>{l(17,n=assign(assign({},n),exclude_internal_props(e))),"class"in e&&l(1,r=e.class),"style"in e&&l(2,a=e.style),"visible"in e&&l(0,c=e.visible),"width"in e&&l(3,d=e.width),"modal"in e&&l(4,u=e.modal),"closeByEsc"in e&&l(12,f=e.closeByEsc),"beforeClose"in e&&l(13,v=e.beforeClose),"$$scope"in e&&l(18,$=e.$$scope);},e.$$.update=()=>{{const{style:e,visible:t,width:o,modal:i,closeByEsc:s,beforeClose:r,...a}=n;l(6,g=a);}16385&e.$$.dirty&&(c?(m&&tn(!1),x()):(l(5,h=!1),m&&tn(!0)));},n=exclude_internal_props(n),[c,r,a,d,u,h,g,s,i,b,function(e){const t="Escape";27!==e.keyCode&&e.key!==t&&e.code!==t||f&&b(t),c&&Re(e,s);},function(){l(0,c=!1);},f,v,m,o,x,n,$,w,function(n){bubble(e,n);},function(e){binding_callbacks[e?"unshift":"push"](()=>{l(7,s=e);});},()=>{l(5,h=!1);},()=>{l(5,h=!0);},()=>{h&&!u&&b("clickOutside");}]}class pn extends SvelteComponent{constructor(e){var t;super(),document.getElementById("svelte-1pkw9hl-style")||((t=element("style")).id="svelte-1pkw9hl-style",t.textContent=".overlay.svelte-1pkw9hl{background-color:rgba(0, 0, 0, 0.5);cursor:pointer;position:fixed;left:0;top:0;right:0;bottom:0;z-index:30;display:flex;justify-content:center;align-items:center}.dialog.svelte-1pkw9hl{position:relative;font-size:1rem;background:#eee;background:var(--bg-panel, #eee);border-radius:4px;cursor:auto;box-shadow:0 11px 15px -7px rgba(0, 0, 0, 0.2), 0 24px 38px 3px rgba(0, 0, 0, 0.14),\n\t\t\t0 9px 46px 8px rgba(0, 0, 0, 0.12);z-index:40;max-height:80%;overflow-x:hidden;overflow-y:auto}.dialog.svelte-1pkw9hl:focus{outline:none}.dialog.svelte-1pkw9hl::-moz-focus-inner{border:0}.dialog.svelte-1pkw9hl:-moz-focusring{outline:none}div.svelte-1pkw9hl .actions{min-height:48px;padding:8px;display:flex;align-items:center}div.svelte-1pkw9hl .center{justify-content:center}div.svelte-1pkw9hl .left{justify-content:flex-start}div.svelte-1pkw9hl .right{justify-content:flex-end}.title.svelte-1pkw9hl{padding:16px 16px 12px;font-size:24px;line-height:36px;background:rgba(0, 0, 0, 0.1);background:var(--divider, rgba(0, 0, 0, 0.1))}.content.svelte-1pkw9hl{margin:16px}",append(document.head,t)),init(this,e,un,dn,safe_not_equal,{class:1,style:2,visible:0,width:3,modal:4,closeByEsc:12,beforeClose:13});}}const fn=e=>({}),vn=e=>({});function hn(e){let t,n,l;const o=e[14].default,i=create_slot(o,e,e[13],null);return {c(){t=element("div"),i&&i.c(),attr(t,"class","content svelte-duf4ie");},m(e,n){insert(e,t,n),i&&i.m(t,null),l=!0;},p(e,t){i&&i.p&&8192&t&&update_slot(i,o,e,e[13],t,null,null);},i(e){l||(transition_in(i,e),e&&add_render_callback(()=>{n||(n=create_bidirectional_transition(t,slide,{duration:250},!0)),n.run(1);}),l=!0);},o(e){transition_out(i,e),e&&(n||(n=create_bidirectional_transition(t,slide,{duration:250},!1)),n.run(0)),l=!1;},d(e){e&&detach(t),i&&i.d(e),e&&n&&n.end();}}}function gn(t){let n,l,o,i,d,p,v,h,b,E;const Y=t[14].icon,j=create_slot(Y,t,t[13],vn),A=j||function(e){let t;return {c(){t=element("i"),t.innerHTML='<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24" fill="currentColor"><path d="M16.59 8.59L12 13.17 7.41 8.59 6 10l6 6 6-6z"></path></svg>',attr(t,"class","icon svelte-duf4ie");},m(e,n){insert(e,t,n);},d(e){e&&detach(t);}}}();let T=t[6]&&hn(t),I=[{class:"panel "+t[0]},t[5]],F={};for(let e=0;e<I.length;e+=1)F=assign(F,I[e]);return {c(){n=element("div"),l=element("button"),o=element("span"),i=text(t[1]),d=space(),A&&A.c(),p=space(),T&&T.c(),attr(o,"class","svelte-duf4ie"),attr(l,"class","header svelte-duf4ie"),l.disabled=t[4],toggle_class(l,"rotate",t[3]),set_attributes(n,F),toggle_class(n,"dense",t[2]),toggle_class(n,"active",t[6]),toggle_class(n,"svelte-duf4ie",!0);},m(s,a){insert(s,n,a),append(n,l),append(l,o),append(o,i),append(l,d),A&&A.m(l,null),append(n,p),T&&T.m(n,null),h=!0,b||(E=[listen(l,"click",t[8]),action_destroyer(v=t[7].call(null,n))],b=!0);},p(e,[t]){(!h||2&t)&&set_data(i,e[1]),j&&j.p&&8192&t&&update_slot(j,Y,e,e[13],t,fn,vn),(!h||16&t)&&(l.disabled=e[4]),8&t&&toggle_class(l,"rotate",e[3]),e[6]?T?(T.p(e,t),64&t&&transition_in(T,1)):(T=hn(e),T.c(),transition_in(T,1),T.m(n,null)):T&&(group_outros(),transition_out(T,1,1,()=>{T=null;}),check_outros()),set_attributes(n,F=get_spread_update(I,[1&t&&{class:"panel "+e[0]},32&t&&e[5]])),toggle_class(n,"dense",e[2]),toggle_class(n,"active",e[6]),toggle_class(n,"svelte-duf4ie",!0);},i(e){h||(transition_in(A,e),transition_in(T),h=!0);},o(e){transition_out(A,e),transition_out(T),h=!1;},d(e){e&&detach(n),A&&A.d(e),T&&T.d(),b=!1,run_all(E);}}}function mn(e,t,n){const l=oe(current_component),o=createEventDispatcher();let{class:i=""}=t,{name:s="?"}=t,{group:r=""}=t,{dense:a=!1}=t,{rotate:c=!0}=t,{expand:d=!1}=t,{disabled:u=!1}=t,p={};let f,{$$slots:v={},$$scope:h}=t;return e.$set=e=>{n(12,t=assign(assign({},t),exclude_internal_props(e))),"class"in e&&n(0,i=e.class),"name"in e&&n(1,s=e.name),"group"in e&&n(9,r=e.group),"dense"in e&&n(2,a=e.dense),"rotate"in e&&n(3,c=e.rotate),"expand"in e&&n(10,d=e.expand),"disabled"in e&&n(4,u=e.disabled),"$$scope"in e&&n(13,h=e.$$scope);},e.$$.update=()=>{{const{name:e,group:l,dense:o,rotate:i,expand:s,disabled:r,...a}=t;delete a.class,n(5,p=a);}1026&e.$$.dirty&&d&&n(9,r=s),514&e.$$.dirty&&n(6,f=r===s),66&e.$$.dirty&&o("change",{expanded:f,name:s});},t=exclude_internal_props(t),[i,s,a,c,u,p,f,l,function(e){n(9,r=r===s?"":s),e.target.classList.remove("focus-visible");},r,d,o,t,h,v]}class bn extends SvelteComponent{constructor(e){var t;super(),document.getElementById("svelte-duf4ie-style")||((t=element("style")).id="svelte-duf4ie-style",t.textContent=".panel.svelte-duf4ie.svelte-duf4ie{position:relative;box-sizing:border-box;background:var(--bg-color, #fbfbfb);box-shadow:0px 2px 1px -1px rgba(0, 0, 0, 0.2), 0px 1px 1px 0px rgba(0, 0, 0, 0.14),\n\t\t\t0px 1px 3px 0px var(--border, #dfdfdf);transition:margin 0.25s}.panel.svelte-duf4ie.svelte-duf4ie::before{position:absolute;top:-1px;left:0;right:0;height:1px;content:'';background-color:var(--divider, rgba(0, 0, 0, 0.1))}.panel.svelte-duf4ie.svelte-duf4ie:first-child{border-top:none;border-top-left-radius:inherit;border-top-right-radius:inherit}.panel.svelte-duf4ie.svelte-duf4ie:last-child{border-bottom-left-radius:inherit;border-bottom-right-radius:inherit}.panel.svelte-duf4ie.svelte-duf4ie:first-child::before{display:none}.panel.active.svelte-duf4ie.svelte-duf4ie:not(:first-child):not(.dense),.panel.active:not(.dense)+.panel.svelte-duf4ie.svelte-duf4ie{margin-top:16px}.panel.active.svelte-duf4ie.svelte-duf4ie:not(.dense)::before{display:none}.panel.active:not(.dense)+.panel.svelte-duf4ie.svelte-duf4ie:before{display:none}.header.svelte-duf4ie.svelte-duf4ie{display:flex;align-items:flex-start;width:100%;min-height:48px;cursor:pointer;background:none;color:inherit;font-size:16px;line-height:1;border:2px solid transparent;outline:none;margin:0;padding:10px 22px;text-align:left;outline:none;transition:min-height 0.25s}.header.svelte-duf4ie.svelte-duf4ie:active{background:none}.header.svelte-duf4ie span.svelte-duf4ie{flex:1;line-height:24px}.icon.svelte-duf4ie.svelte-duf4ie{display:inline-block;line-height:0.5}.panel.svelte-duf4ie.svelte-duf4ie .icon{transition:0.25s linear}.active.svelte-duf4ie .header.svelte-duf4ie{min-height:64px}.active.svelte-duf4ie .rotate.svelte-duf4ie .icon{transform:rotate(-180deg)}.content.svelte-duf4ie.svelte-duf4ie{overflow:auto;margin:0;padding:0 24px 16px}@media(hover: hover){.header.focus-visible.svelte-duf4ie.svelte-duf4ie:focus:not([disabled]):not(.disabled){outline:none;border:2px solid var(--focus-color, rgba(25, 118, 210, 0.5))}}",append(document.head,t)),init(this,e,mn,gn,safe_not_equal,{class:0,name:1,group:9,dense:2,rotate:3,expand:10,disabled:4});}}const yn=e=>({}),xn=e=>({});function wn(e){let t,n,l;const o=e[11].default,i=create_slot(o,e,e[14],null);return {c(){t=element("ul"),i&&i.c(),attr(t,"style",n=`min-width: ${e[5]}px`),attr(t,"class","svelte-1vc5q8h");},m(e,n){insert(e,t,n),i&&i.m(t,null),l=!0;},p(e,s){i&&i.p&&16384&s&&update_slot(i,o,e,e[14],s,null,null),(!l||32&s&&n!==(n=`min-width: ${e[5]}px`))&&attr(t,"style",n);},i(e){l||(transition_in(i,e),l=!0);},o(e){transition_out(i,e),l=!1;},d(e){e&&detach(t),i&&i.d(e);}}}function $n(t){let n,l,o,i,d,y,w;const $=t[11].activator,D=create_slot($,t,t[14],xn),C=D||function(e){let t;return {c(){t=element("span");},m(e,n){insert(e,t,n);},d(e){e&&detach(t);}}}();function M(e){t[12].call(null,e);}let E={class:t[0],style:t[1],origin:t[4],dx:t[2],dy:t[3],$$slots:{default:[wn]},$$scope:{ctx:t}};void 0!==t[6]&&(E.visible=t[6]);const Y=new Je({props:E});return binding_callbacks.push(()=>bind(Y,"visible",M)),Y.$on("click",t[10]),{c(){n=element("div"),C&&C.c(),l=space(),create_component(Y.$$.fragment),attr(n,"class","menu svelte-1vc5q8h");},m(o,s){insert(o,n,s),C&&C.m(n,null),append(n,l),mount_component(Y,n,null),t[13](n),d=!0,y||(w=[listen(n,"click",t[9]),action_destroyer(i=t[8].call(null,n))],y=!0);},p(e,[t]){D&&D.p&&16384&t&&update_slot(D,$,e,e[14],t,yn,xn);const n={};1&t&&(n.class=e[0]),2&t&&(n.style=e[1]),16&t&&(n.origin=e[4]),4&t&&(n.dx=e[2]),8&t&&(n.dy=e[3]),16416&t&&(n.$$scope={dirty:t,ctx:e}),!o&&64&t&&(o=!0,n.visible=e[6],add_flush_callback(()=>o=!1)),Y.$set(n);},i(e){d||(transition_in(C,e),transition_in(Y.$$.fragment,e),d=!0);},o(e){transition_out(C,e),transition_out(Y.$$.fragment,e),d=!1;},d(e){e&&detach(n),C&&C.d(e),destroy_component(Y),t[13](null),y=!1,run_all(w);}}}function zn(e,t,n){const l=oe(current_component);let o,{class:i=""}=t,{style:s=null}=t,{dx:r=0}=t,{dy:a=0}=t,{origin:c="top left"}=t,{width:d=112}=t,u=!1;let{$$slots:f={},$$scope:v}=t;return e.$set=e=>{"class"in e&&n(0,i=e.class),"style"in e&&n(1,s=e.style),"dx"in e&&n(2,r=e.dx),"dy"in e&&n(3,a=e.dy),"origin"in e&&n(4,c=e.origin),"width"in e&&n(5,d=e.width),"$$scope"in e&&n(14,v=e.$$scope);},[i,s,r,a,c,d,u,o,l,function(e){try{o.childNodes[0].contains(e.target)?n(6,u=!u):e.target===o&&n(6,u=!1);}catch(e){console.error(e);}},function(e){e.target.classList.contains("menu-item")&&n(6,u=!1);},f,function(e){u=e,n(6,u);},function(e){binding_callbacks[e?"unshift":"push"](()=>{n(7,o=e);});},v]}class kn extends SvelteComponent{constructor(e){var t;super(),document.getElementById("svelte-1vc5q8h-style")||((t=element("style")).id="svelte-1vc5q8h-style",t.textContent="@supports (-webkit-overflow-scrolling: touch){html{cursor:pointer}}.menu.svelte-1vc5q8h{position:relative;display:inline-block;vertical-align:middle}ul.svelte-1vc5q8h{margin:0;padding:8px 0;width:100%;position:relative;overflow-x:hidden;overflow-y:visible}",append(document.head,t)),init(this,e,zn,$n,safe_not_equal,{class:0,style:1,dx:2,dy:3,origin:4,width:5});}}function Dn(t){let n,l,o,i,a,d;const p=t[10].default,v=create_slot(p,t,t[9],null);let h=t[1]&&Mn(),b=[{class:"menu-item "+t[0]},{tabindex:t[2]?"-1":"0"},t[4]],E={};for(let e=0;e<b.length;e+=1)E=assign(E,b[e]);return {c(){n=element("li"),v&&v.c(),l=space(),h&&h.c(),set_attributes(n,E),toggle_class(n,"svelte-mmrniu",!0);},m(s,u){insert(s,n,u),v&&v.m(n,null),append(n,l),h&&h.m(n,null),t[12](n),i=!0,a||(d=[listen(n,"keydown",t[7]),action_destroyer(o=t[6].call(null,n))],a=!0);},p(e,t){v&&v.p&&512&t&&update_slot(v,p,e,e[9],t,null,null),e[1]?h?2&t&&transition_in(h,1):(h=Mn(),h.c(),transition_in(h,1),h.m(n,null)):h&&(group_outros(),transition_out(h,1,1,()=>{h=null;}),check_outros()),set_attributes(n,E=get_spread_update(b,[1&t&&{class:"menu-item "+e[0]},4&t&&{tabindex:e[2]?"-1":"0"},16&t&&e[4]])),toggle_class(n,"svelte-mmrniu",!0);},i(e){i||(transition_in(v,e),transition_in(h),i=!0);},o(e){transition_out(v,e),transition_out(h),i=!1;},d(e){e&&detach(n),v&&v.d(e),h&&h.d(),t[12](null),a=!1,run_all(d);}}}function Cn(t){let n,l,o,i,d,p,v;const h=t[10].default,b=create_slot(h,t,t[9],null);let E=t[1]&&Ln(),Y=[{class:"menu-item "+t[0]},{href:t[3]},{tabindex:t[2]?"-1":"0"},t[4]],j={};for(let e=0;e<Y.length;e+=1)j=assign(j,Y[e]);return {c(){n=element("li"),l=element("a"),b&&b.c(),o=space(),E&&E.c(),set_attributes(l,j),toggle_class(l,"svelte-mmrniu",!0),attr(n,"class","svelte-mmrniu");},m(s,a){insert(s,n,a),append(n,l),b&&b.m(l,null),append(l,o),E&&E.m(l,null),t[11](l),d=!0,p||(v=[listen(l,"keydown",t[7]),action_destroyer(i=t[6].call(null,l))],p=!0);},p(e,t){b&&b.p&&512&t&&update_slot(b,h,e,e[9],t,null,null),e[1]?E?2&t&&transition_in(E,1):(E=Ln(),E.c(),transition_in(E,1),E.m(l,null)):E&&(group_outros(),transition_out(E,1,1,()=>{E=null;}),check_outros()),set_attributes(l,j=get_spread_update(Y,[1&t&&{class:"menu-item "+e[0]},8&t&&{href:e[3]},4&t&&{tabindex:e[2]?"-1":"0"},16&t&&e[4]])),toggle_class(l,"svelte-mmrniu",!0);},i(e){d||(transition_in(b,e),transition_in(E),d=!0);},o(e){transition_out(b,e),transition_out(E),d=!1;},d(e){e&&detach(n),b&&b.d(e),E&&E.d(),t[11](null),p=!1,run_all(v);}}}function Mn(e){let t;const n=new he({});return {c(){create_component(n.$$.fragment);},m(e,l){mount_component(n,e,l),t=!0;},i(e){t||(transition_in(n.$$.fragment,e),t=!0);},o(e){transition_out(n.$$.fragment,e),t=!1;},d(e){destroy_component(n,e);}}}function Ln(e){let t;const n=new he({});return {c(){create_component(n.$$.fragment);},m(e,l){mount_component(n,e,l),t=!0;},i(e){t||(transition_in(n.$$.fragment,e),t=!0);},o(e){transition_out(n.$$.fragment,e),t=!1;},d(e){destroy_component(n,e);}}}function En(e){let t,n,l,o;const i=[Cn,Dn],s=[];function r(e,t){return e[3]?0:1}return t=r(e),n=s[t]=i[t](e),{c(){n.c(),l=empty();},m(e,n){s[t].m(e,n),insert(e,l,n),o=!0;},p(e,[o]){let a=t;t=r(e),t===a?s[t].p(e,o):(group_outros(),transition_out(s[a],1,1,()=>{s[a]=null;}),check_outros(),n=s[t],n||(n=s[t]=i[t](e),n.c()),transition_in(n,1),n.m(l.parentNode,l));},i(e){o||(transition_in(n),o=!0);},o(e){transition_out(n),o=!1;},d(e){s[t].d(e),e&&detach(l);}}}function Yn(e,t,n){const l=oe(current_component);let o,{class:i=""}=t,{ripple:s=!0}=t,r=!1,a=null,c={};let{$$slots:d={},$$scope:u}=t;return e.$set=e=>{n(8,t=assign(assign({},t),exclude_internal_props(e))),"class"in e&&n(0,i=e.class),"ripple"in e&&n(1,s=e.ripple),"$$scope"in e&&n(9,u=e.$$scope);},e.$$.update=()=>{{const{href:e,ripple:l,...o}=t;delete o.class,!1===o.disabled&&delete o.disabled,n(2,r=!!o.disabled),n(3,a=e&&!r?e:null),n(4,c=o);}},t=exclude_internal_props(t),[i,s,r,a,c,o,l,function(e){if(13===e.keyCode||32===e.keyCode){e.stopPropagation(),e.preventDefault();const t=new MouseEvent("click",{bubbles:!0,cancelable:!0});o.dispatchEvent(t),o.blur();}},t,u,d,function(e){binding_callbacks[e?"unshift":"push"](()=>{n(5,o=e);});},function(e){binding_callbacks[e?"unshift":"push"](()=>{n(5,o=e);});}]}class jn extends SvelteComponent{constructor(e){var t;super(),document.getElementById("svelte-mmrniu-style")||((t=element("style")).id="svelte-mmrniu-style",t.textContent="li.svelte-mmrniu{display:block}a.svelte-mmrniu,a.svelte-mmrniu:hover{text-decoration:none}.menu-item.svelte-mmrniu{position:relative;color:inherit;cursor:pointer;height:44px;user-select:none;display:flex;align-items:center;padding:0 16px;white-space:nowrap}.menu-item.svelte-mmrniu:focus{outline:none}.menu-item.svelte-mmrniu::-moz-focus-inner{border:0}.menu-item.svelte-mmrniu:-moz-focusring{outline:none}.menu-item.svelte-mmrniu:before{background-color:currentColor;color:inherit;bottom:0;content:'';left:0;opacity:0;pointer-events:none;position:absolute;right:0;top:0;transition:0.3s cubic-bezier(0.25, 0.8, 0.5, 1)}@media(hover: hover){.menu-item.svelte-mmrniu:hover:not([disabled]):not(.disabled):before{opacity:0.15}.focus-visible.menu-item:focus:not([disabled]):not(.disabled):before{opacity:0.3}}",append(document.head,t)),init(this,e,Yn,En,safe_not_equal,{class:0,ripple:1});}}function An(e){let t;const n=new he({props:{center:!0,circle:!0}});return {c(){create_component(n.$$.fragment);},m(e,l){mount_component(n,e,l),t=!0;},i(e){t||(transition_in(n.$$.fragment,e),t=!0);},o(e){transition_out(n.$$.fragment,e),t=!1;},d(e){destroy_component(n,e);}}}function Tn(t){let n,l,o,i,d,p,y,w,M,E,Y,j,A;const N=new Me({props:{path:t[0]===t[2]?Nn:Bn}});let B=t[7]&&An();const I=t[14].default,F=create_slot(I,t,t[13],null);return {c(){n=element("label"),l=element("input"),i=space(),d=element("div"),create_component(N.$$.fragment),p=space(),B&&B.c(),w=space(),M=element("div"),F&&F.c(),attr(l,"type","radio"),l.disabled=t[5],l.__value=t[2],l.value=l.__value,attr(l,"class","svelte-j29u99"),t[16][0].push(l),attr(d,"class","mark svelte-j29u99"),attr(d,"style",y="color: "+(t[2]===t[0]?t[1]:"#9a9a9a")),attr(M,"class","label-text svelte-j29u99"),attr(n,"class",E=null_to_empty(t[3])+" svelte-j29u99"),attr(n,"style",t[4]),attr(n,"title",t[8]),toggle_class(n,"right",t[6]),toggle_class(n,"disabled",t[5]);},m(s,a){insert(s,n,a),append(n,l),l.checked=l.__value===t[0],t[17](l),append(n,i),append(n,d),mount_component(N,d,null),append(d,p),B&&B.m(d,null),append(n,w),append(n,M),F&&F.m(M,null),Y=!0,j||(A=[listen(l,"change",t[15]),action_destroyer(o=t[10].call(null,l))],j=!0);},p(e,[t]){(!Y||32&t)&&(l.disabled=e[5]),(!Y||4&t)&&(l.__value=e[2]),l.value=l.__value,1&t&&(l.checked=l.__value===e[0]);const o={};5&t&&(o.path=e[0]===e[2]?Nn:Bn),N.$set(o),e[7]?B?128&t&&transition_in(B,1):(B=An(),B.c(),transition_in(B,1),B.m(d,null)):B&&(group_outros(),transition_out(B,1,1,()=>{B=null;}),check_outros()),(!Y||7&t&&y!==(y="color: "+(e[2]===e[0]?e[1]:"#9a9a9a")))&&attr(d,"style",y),F&&F.p&&8192&t&&update_slot(F,I,e,e[13],t,null,null),(!Y||8&t&&E!==(E=null_to_empty(e[3])+" svelte-j29u99"))&&attr(n,"class",E),(!Y||16&t)&&attr(n,"style",e[4]),(!Y||256&t)&&attr(n,"title",e[8]),72&t&&toggle_class(n,"right",e[6]),40&t&&toggle_class(n,"disabled",e[5]);},i(e){Y||(transition_in(N.$$.fragment,e),transition_in(B),transition_in(F,e),Y=!0);},o(e){transition_out(N.$$.fragment,e),transition_out(B),transition_out(F,e),Y=!1;},d(e){e&&detach(n),t[16][0].splice(t[16][0].indexOf(l),1),t[17](null),destroy_component(N),B&&B.d(),F&&F.d(e),j=!1,run_all(A);}}}let Nn="M12 7c-2.76 0-5 2.24-5 5s2.24 5 5 5 5-2.24 5-5-2.24-5-5-5zm0-5C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z",Bn="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z";function In(e,t,n){const l=oe(current_component);let o,{group:i=null}=t,{value:s="on"}=t,{class:r=""}=t,{style:a=null}=t,{color:c="primary"}=t,{disabled:d=!1}=t,{right:u=!1}=t,{ripple:f=!0}=t,{title:v=null}=t,h={};onMount(async()=>{if(await tick(),o)for(let e in h)o.setAttribute(e,h[e]);});let{$$slots:g={},$$scope:m}=t;return e.$set=e=>{n(12,t=assign(assign({},t),exclude_internal_props(e))),"group"in e&&n(0,i=e.group),"value"in e&&n(2,s=e.value),"class"in e&&n(3,r=e.class),"style"in e&&n(4,a=e.style),"color"in e&&n(1,c=e.color),"disabled"in e&&n(5,d=e.disabled),"right"in e&&n(6,u=e.right),"ripple"in e&&n(7,f=e.ripple),"title"in e&&n(8,v=e.title),"$$scope"in e&&n(13,m=e.$$scope);},e.$$.update=()=>{{const{group:e,value:n,style:l,color:o,disabled:i,right:s,ripple:r,title:a,...c}=t;delete c.class,h=c;}2&e.$$.dirty&&("primary"!==c&&c?"accent"===c&&n(1,c=ie()?"#f50057":"var(--accent, #f50057)"):n(1,c=ie()?"#1976d2":"var(--primary, #1976d2)"));},t=exclude_internal_props(t),[i,c,s,r,a,d,u,f,v,o,l,h,t,m,g,function(){i=this.__value,n(0,i);},[[]],function(e){binding_callbacks[e?"unshift":"push"](()=>{n(9,o=e);});}]}class Fn extends SvelteComponent{constructor(e){var t;super(),document.getElementById("svelte-j29u99-style")||((t=element("style")).id="svelte-j29u99-style",t.textContent="label.svelte-j29u99.svelte-j29u99{cursor:pointer;width:100%;align-items:center;display:flex;margin:0;position:relative;line-height:40px;user-select:none}input.svelte-j29u99.svelte-j29u99{cursor:inherit;width:100%;height:100%;position:absolute;top:0;left:0;margin:0;padding:0;opacity:0 !important}.mark.svelte-j29u99.svelte-j29u99{display:flex;position:relative;justify-content:center;align-items:center;border-radius:50%;width:40px;height:40px}.mark.svelte-j29u99.svelte-j29u99:before{background:currentColor;border-radius:inherit;bottom:0;color:inherit;content:'';left:0;opacity:0;pointer-events:none;position:absolute;right:0;top:0;transition:0.3s cubic-bezier(0.25, 0.8, 0.5, 1)}@media not all and (min-resolution: 0.001dpcm){@supports (-webkit-appearance: none) and (stroke-color: transparent){.mark.svelte-j29u99.svelte-j29u99:before{transition:none}}}.label-text.svelte-j29u99.svelte-j29u99{margin-left:4px;white-space:nowrap;overflow:hidden}.right.svelte-j29u99 .label-text.svelte-j29u99{margin-left:0;margin-right:auto;order:-1}@media(hover: hover){label.svelte-j29u99:hover:not([disabled]):not(.disabled) .mark.svelte-j29u99:before{opacity:0.15}.focus-visible:focus:not([disabled]):not(.disabled)~.mark.svelte-j29u99.svelte-j29u99:before{opacity:0.3}}",append(document.head,t)),init(this,e,In,Tn,safe_not_equal,{group:0,value:2,class:3,style:4,color:1,disabled:5,right:6,ripple:7,title:8});}}const{window:Sn}=globals;function qn(t){let n,l,o,i,r;return {c(){n=element("div"),attr(n,"class","overlay svelte-1o2jp7l");},m(l,s){insert(l,n,s),o=!0,i||(r=listen(n,"click",t[4]),i=!0);},p:noop,i(e){o||(add_render_callback(()=>{l||(l=create_bidirectional_transition(n,fade,{duration:300},!0)),l.run(1);}),o=!0);},o(e){l||(l=create_bidirectional_transition(n,fade,{duration:300},!1)),l.run(0),o=!1;},d(e){e&&detach(n),e&&l&&l.end(),i=!1,r();}}}function _n(t){let n,l,o,i,r,d,p,v=t[0]&&qn(t);const h=t[14].default,b=create_slot(h,t,t[13],null);return {c(){n=space(),v&&v.c(),l=space(),o=element("aside"),b&&b.c(),attr(o,"class","side-panel svelte-1o2jp7l"),attr(o,"tabindex","-1"),toggle_class(o,"left",!t[1]),toggle_class(o,"right",t[1]),toggle_class(o,"visible",t[0]);},m(s,a){insert(s,n,a),v&&v.m(s,a),insert(s,l,a),insert(s,o,a),b&&b.m(o,null),t[15](o),r=!0,d||(p=[listen(Sn,"keydown",t[8]),listen(document.body,"touchstart",t[6]),listen(document.body,"touchend",t[7]),listen(o,"transitionend",t[5]),action_destroyer(i=t[3].call(null,o))],d=!0);},p(e,[t]){e[0]?v?(v.p(e,t),1&t&&transition_in(v,1)):(v=qn(e),v.c(),transition_in(v,1),v.m(l.parentNode,l)):v&&(group_outros(),transition_out(v,1,1,()=>{v=null;}),check_outros()),b&&b.p&&8192&t&&update_slot(b,h,e,e[13],t,null,null),2&t&&toggle_class(o,"left",!e[1]),2&t&&toggle_class(o,"right",e[1]),1&t&&toggle_class(o,"visible",e[0]);},i(e){r||(transition_in(v),transition_in(b,e),r=!0);},o(e){transition_out(v),transition_out(b,e),r=!1;},d(e){e&&detach(n),v&&v.d(e),e&&detach(l),e&&detach(o),b&&b.d(e),t[15](null),d=!1,run_all(p);}}}let Hn=!1;function On(e,t,n){const l=oe(current_component);let o,{right:i=!1}=t,{visible:s=!1}=t,{disableScroll:r=!1}=t,a={x:null,y:null},c=!1;function d(){n(0,s=!1),setTimeout(()=>{Hn=!1;},20);}function u(){n(0,s=!0);}onMount(async()=>{await tick(),n(11,c=!0);});let{$$slots:f={},$$scope:v}=t;return e.$set=e=>{"right"in e&&n(1,i=e.right),"visible"in e&&n(0,s=e.visible),"disableScroll"in e&&n(9,r=e.disableScroll),"$$scope"in e&&n(13,v=e.$$scope);},e.$$.update=()=>{2561&e.$$.dirty&&(s?(Hn=!0,c&&r&&tn(!1)):(c&&tn(!0),d()));},[s,i,o,l,d,function(e){s&&"visibility"===e.propertyName&&o.focus();},function(e){a.x=e.changedTouches[0].clientX,a.y=e.changedTouches[0].clientY;},function(e){const t=e.changedTouches[0].clientX-a.x,n=e.changedTouches[0].clientY-a.y;if(Math.abs(t)>50){if(Math.abs(n)<100)if(s)(t>0&&i||t<0&&!i)&&d();else {if(Hn)return;t>0&&a.x<=20?i||u():a.x>=window.innerWidth-20&&i&&u();}}},function(e){s&&(27!==e.keyCode&&"Escape"!==e.key&&"Escape"!==e.code||d(),s&&Re(e,o));},r,a,c,u,v,f,function(e){binding_callbacks[e?"unshift":"push"](()=>{n(2,o=e);});}]}class Pn extends SvelteComponent{constructor(e){var t;super(),document.getElementById("svelte-1o2jp7l-style")||((t=element("style")).id="svelte-1o2jp7l-style",t.textContent=".side-panel.svelte-1o2jp7l{background:#fbfbfb;background:var(--bg-color, #fbfbfb);position:fixed;visibility:hidden;width:256px;top:0;height:100%;box-shadow:0 0 10px rgba(0, 0, 0, 0.2);z-index:40;overflow-x:hidden;overflow-y:auto;transform-style:preserve-3d;will-change:transform, visibility;transition-duration:0.2s;transition-timing-function:cubic-bezier(0.4, 0, 0.2, 1);transition-property:transform, visibility}.side-panel.svelte-1o2jp7l:focus{outline:none}.side-panel.svelte-1o2jp7l::-moz-focus-inner{border:0}.side-panel.svelte-1o2jp7l:-moz-focusring{outline:none}.left.svelte-1o2jp7l{left:0;transform:translateX(-256px)}.right.svelte-1o2jp7l{left:auto;right:0;transform:translateX(256px)}.visible.svelte-1o2jp7l{visibility:visible;transform:translateX(0)}.overlay.svelte-1o2jp7l{background-color:rgba(0, 0, 0, 0.5);cursor:pointer;position:fixed;left:0;top:0;right:0;bottom:0;z-index:30}",append(document.head,t)),init(this,e,On,_n,safe_not_equal,{right:1,visible:0,disableScroll:9});}}

    /* src\components\Menu.svelte generated by Svelte v3.29.0 */
    const file = "src\\components\\Menu.svelte";
    const get_activador_slot_changes = dirty => ({});
    const get_activador_slot_context = ctx => ({});

    // (12:0) {#if mostrarMenu}
    function create_if_block(ctx) {
    	let ul;
    	let ul_intro;
    	let ul_outro;
    	let current;
    	let mounted;
    	let dispose;
    	const default_slot_template = /*#slots*/ ctx[2].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[1], null);

    	const block = {
    		c: function create() {
    			ul = element("ul");
    			if (default_slot) default_slot.c();
    			attr_dev(ul, "class", "menu svelte-134df7t");
    			add_location(ul, file, 12, 4, 280);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, ul, anchor);

    			if (default_slot) {
    				default_slot.m(ul, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(ul, "mouseleave", /*mouseleave_handler*/ ctx[4], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 2) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[1], dirty, null, null);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);

    			if (local) {
    				add_render_callback(() => {
    					if (ul_outro) ul_outro.end(1);
    					if (!ul_intro) ul_intro = create_in_transition(ul, fly, { x: -100 });
    					ul_intro.start();
    				});
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			if (ul_intro) ul_intro.invalidate();

    			if (local) {
    				ul_outro = create_out_transition(ul, fly, { x: 100 });
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(ul);
    			if (default_slot) default_slot.d(detaching);
    			if (detaching && ul_outro) ul_outro.end();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block.name,
    		type: "if",
    		source: "(12:0) {#if mostrarMenu}",
    		ctx
    	});

    	return block;
    }

    function create_fragment(ctx) {
    	let span;
    	let t;
    	let if_block_anchor;
    	let current;
    	let mounted;
    	let dispose;
    	const activador_slot_template = /*#slots*/ ctx[2].activador;
    	const activador_slot = create_slot(activador_slot_template, ctx, /*$$scope*/ ctx[1], get_activador_slot_context);
    	let if_block = /*mostrarMenu*/ ctx[0] && create_if_block(ctx);

    	const block = {
    		c: function create() {
    			span = element("span");
    			if (activador_slot) activador_slot.c();
    			t = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    			add_location(span, file, 8, 0, 168);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);

    			if (activador_slot) {
    				activador_slot.m(span, null);
    			}

    			insert_dev(target, t, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(span, "click", /*click_handler*/ ctx[3], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (activador_slot) {
    				if (activador_slot.p && dirty & /*$$scope*/ 2) {
    					update_slot(activador_slot, activador_slot_template, ctx, /*$$scope*/ ctx[1], dirty, get_activador_slot_changes, get_activador_slot_context);
    				}
    			}

    			if (/*mostrarMenu*/ ctx[0]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*mostrarMenu*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(activador_slot, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(activador_slot, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			if (activador_slot) activador_slot.d(detaching);
    			if (detaching) detach_dev(t);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Menu", slots, ['activador','default']);
    	let { mostrarMenu = false } = $$props;
    	const writable_props = ["mostrarMenu"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Menu> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => $$invalidate(0, mostrarMenu = true);
    	const mouseleave_handler = () => $$invalidate(0, mostrarMenu = false);

    	$$self.$$set = $$props => {
    		if ("mostrarMenu" in $$props) $$invalidate(0, mostrarMenu = $$props.mostrarMenu);
    		if ("$$scope" in $$props) $$invalidate(1, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		Menu: kn,
    		Ripple: he,
    		Button: ye,
    		Icon: Me,
    		fly,
    		mostrarMenu
    	});

    	$$self.$inject_state = $$props => {
    		if ("mostrarMenu" in $$props) $$invalidate(0, mostrarMenu = $$props.mostrarMenu);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [mostrarMenu, $$scope, slots, click_handler, mouseleave_handler];
    }

    class Menu_1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance, create_fragment, safe_not_equal, { mostrarMenu: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Menu_1",
    			options,
    			id: create_fragment.name
    		});
    	}

    	get mostrarMenu() {
    		throw new Error("<Menu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set mostrarMenu(value) {
    		throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    const subscriber_queue = [];
    /**
     * Create a `Writable` store that allows both updating and reading by subscription.
     * @param {*=}value initial value
     * @param {StartStopNotifier=}start start and stop notifications for subscriptions
     */
    function writable(value, start = noop) {
        let stop;
        const subscribers = [];
        function set(new_value) {
            if (safe_not_equal(value, new_value)) {
                value = new_value;
                if (stop) { // store is ready
                    const run_queue = !subscriber_queue.length;
                    for (let i = 0; i < subscribers.length; i += 1) {
                        const s = subscribers[i];
                        s[1]();
                        subscriber_queue.push(s, value);
                    }
                    if (run_queue) {
                        for (let i = 0; i < subscriber_queue.length; i += 2) {
                            subscriber_queue[i][0](subscriber_queue[i + 1]);
                        }
                        subscriber_queue.length = 0;
                    }
                }
            }
        }
        function update(fn) {
            set(fn(value));
        }
        function subscribe(run, invalidate = noop) {
            const subscriber = [run, invalidate];
            subscribers.push(subscriber);
            if (subscribers.length === 1) {
                stop = start(set) || noop;
            }
            run(value);
            return () => {
                const index = subscribers.indexOf(subscriber);
                if (index !== -1) {
                    subscribers.splice(index, 1);
                }
                if (subscribers.length === 0) {
                    stop();
                    stop = null;
                }
            };
        }
        return { set, update, subscribe };
    }

    var comentarioStore = writable('');

    /* src\components\Tiempo.svelte generated by Svelte v3.29.0 */

    const file$1 = "src\\components\\Tiempo.svelte";

    function create_fragment$1(ctx) {
    	let span;
    	let t_value = /*tiempoRelativo*/ ctx[1].short + "";
    	let t;
    	let span_title_value;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = text(t_value);
    			attr_dev(span, "title", span_title_value = /*tiempoRelativo*/ ctx[1].long + "\n" + new Date(/*date*/ ctx[0]));
    			add_location(span, file$1, 61, 0, 2239);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*tiempoRelativo*/ 2 && t_value !== (t_value = /*tiempoRelativo*/ ctx[1].short + "")) set_data_dev(t, t_value);

    			if (dirty & /*tiempoRelativo, date*/ 3 && span_title_value !== (span_title_value = /*tiempoRelativo*/ ctx[1].long + "\n" + new Date(/*date*/ ctx[0]))) {
    				attr_dev(span, "title", span_title_value);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$1.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function relativeTime(date, horaActual) {
    	if (horaActual == undefined) horaActual = new Date();
    	if (typeof date === "string") date = Date.parse(date);
    	let current = horaActual.getTime();
    	let previous = date;
    	const msPerMinute = 60 * 1000;
    	const msPerHour = msPerMinute * 60;
    	const msPerDay = msPerHour * 24;
    	const msPerMonth = msPerDay * 30;
    	const msPerYear = msPerDay * 365;
    	let elapsed = current - previous;

    	if (elapsed < msPerMinute) {
    		return {
    			short: Math.round(elapsed / 1000) + " s",
    			long: Math.round(elapsed / 1000) + " segundos",
    			diferencia: elapsed
    		};
    	} else if (elapsed < msPerHour) {
    		return {
    			short: Math.round(elapsed / msPerMinute) + " m",
    			long: Math.round(elapsed / msPerMinute) + " minutos",
    			diferencia: elapsed
    		};
    	} else if (elapsed < msPerDay) {
    		return {
    			short: Math.round(elapsed / msPerHour) + " h",
    			long: Math.round(elapsed / msPerHour) + " horas",
    			diferencia: elapsed
    		};
    	} else if (elapsed < msPerMonth) {
    		return {
    			short: Math.round(elapsed / msPerDay) + " d",
    			long: Math.round(elapsed / msPerDay) + " dias",
    			diferencia: elapsed
    		};
    	} else if (elapsed < msPerYear) {
    		return {
    			short: Math.round(elapsed / msPerMonth) + " M",
    			long: Math.round(elapsed / msPerMonth) + " meses",
    			diferencia: elapsed
    		};
    	} else {
    		return {
    			short: Math.round(elapsed / msPerYear) + " a",
    			long: Math.round(elapsed / msPerYear) + " años",
    			diferencia: elapsed
    		};
    	}
    }

    function instance$1($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Tiempo", slots, []);
    	let { date } = $$props;
    	let horaActual = new Date();

    	setInterval(() => $$invalidate(2, horaActual = new Date()), relativeTime(date, horaActual).diferencia < 60000
    	? 1000
    	: 6000);

    	const writable_props = ["date"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Tiempo> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("date" in $$props) $$invalidate(0, date = $$props.date);
    	};

    	$$self.$capture_state = () => ({
    		date,
    		horaActual,
    		relativeTime,
    		tiempoRelativo
    	});

    	$$self.$inject_state = $$props => {
    		if ("date" in $$props) $$invalidate(0, date = $$props.date);
    		if ("horaActual" in $$props) $$invalidate(2, horaActual = $$props.horaActual);
    		if ("tiempoRelativo" in $$props) $$invalidate(1, tiempoRelativo = $$props.tiempoRelativo);
    	};

    	let tiempoRelativo;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*date, horaActual*/ 5) {
    			 $$invalidate(1, tiempoRelativo = relativeTime(date, horaActual));
    		}
    	};

    	return [date, tiempoRelativo];
    }

    class Tiempo extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$1, create_fragment$1, safe_not_equal, { date: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Tiempo",
    			options,
    			id: create_fragment$1.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*date*/ ctx[0] === undefined && !("date" in props)) {
    			console.warn("<Tiempo> was created without expected prop 'date'");
    		}
    	}

    	get date() {
    		throw new Error("<Tiempo>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set date(value) {
    		throw new Error("<Tiempo>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    let sfw = window.config.categorias
        .filter(c => !c.nsfw).sort((c1, c2) => c1.nombre.localeCompare(c2.nombre));

    let nsfw = window.config.categorias
        .filter(c => c.nsfw).sort((c1, c2) => c1.nombre.localeCompare(c2.nombre));

    let categoriasOrdenadas = [...sfw, ...nsfw];

    class config {
        static categorias =  categoriasOrdenadas

        static categoriaPorId(id)
        {
            return config.categorias.filter(c => c.id==id)[0]
        }


        static general = window.config.general

        static getCategoriaById(id){ return this.categorias[id - 1]} 
    }

    function createCommonjsModule(fn, basedir, module) {
    	return module = {
    	  path: basedir,
    	  exports: {},
    	  require: function (path, base) {
          return commonjsRequire(path, (base === undefined || base === null) ? module.path : base);
        }
    	}, fn(module, module.exports), module.exports;
    }

    function commonjsRequire () {
    	throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
    }

    var js_cookie = createCommonjsModule(function (module, exports) {
    (function (factory) {
    	var registeredInModuleLoader;
    	{
    		module.exports = factory();
    		registeredInModuleLoader = true;
    	}
    	if (!registeredInModuleLoader) {
    		var OldCookies = window.Cookies;
    		var api = window.Cookies = factory();
    		api.noConflict = function () {
    			window.Cookies = OldCookies;
    			return api;
    		};
    	}
    }(function () {
    	function extend () {
    		var i = 0;
    		var result = {};
    		for (; i < arguments.length; i++) {
    			var attributes = arguments[ i ];
    			for (var key in attributes) {
    				result[key] = attributes[key];
    			}
    		}
    		return result;
    	}

    	function decode (s) {
    		return s.replace(/(%[0-9A-Z]{2})+/g, decodeURIComponent);
    	}

    	function init (converter) {
    		function api() {}

    		function set (key, value, attributes) {
    			if (typeof document === 'undefined') {
    				return;
    			}

    			attributes = extend({
    				path: '/'
    			}, api.defaults, attributes);

    			if (typeof attributes.expires === 'number') {
    				attributes.expires = new Date(new Date() * 1 + attributes.expires * 864e+5);
    			}

    			// We're using "expires" because "max-age" is not supported by IE
    			attributes.expires = attributes.expires ? attributes.expires.toUTCString() : '';

    			try {
    				var result = JSON.stringify(value);
    				if (/^[\{\[]/.test(result)) {
    					value = result;
    				}
    			} catch (e) {}

    			value = converter.write ?
    				converter.write(value, key) :
    				encodeURIComponent(String(value))
    					.replace(/%(23|24|26|2B|3A|3C|3E|3D|2F|3F|40|5B|5D|5E|60|7B|7D|7C)/g, decodeURIComponent);

    			key = encodeURIComponent(String(key))
    				.replace(/%(23|24|26|2B|5E|60|7C)/g, decodeURIComponent)
    				.replace(/[\(\)]/g, escape);

    			var stringifiedAttributes = '';
    			for (var attributeName in attributes) {
    				if (!attributes[attributeName]) {
    					continue;
    				}
    				stringifiedAttributes += '; ' + attributeName;
    				if (attributes[attributeName] === true) {
    					continue;
    				}

    				// Considers RFC 6265 section 5.2:
    				// ...
    				// 3.  If the remaining unparsed-attributes contains a %x3B (";")
    				//     character:
    				// Consume the characters of the unparsed-attributes up to,
    				// not including, the first %x3B (";") character.
    				// ...
    				stringifiedAttributes += '=' + attributes[attributeName].split(';')[0];
    			}

    			return (document.cookie = key + '=' + value + stringifiedAttributes);
    		}

    		function get (key, json) {
    			if (typeof document === 'undefined') {
    				return;
    			}

    			var jar = {};
    			// To prevent the for loop in the first place assign an empty array
    			// in case there are no cookies at all.
    			var cookies = document.cookie ? document.cookie.split('; ') : [];
    			var i = 0;

    			for (; i < cookies.length; i++) {
    				var parts = cookies[i].split('=');
    				var cookie = parts.slice(1).join('=');

    				if (!json && cookie.charAt(0) === '"') {
    					cookie = cookie.slice(1, -1);
    				}

    				try {
    					var name = decode(parts[0]);
    					cookie = (converter.read || converter)(cookie, name) ||
    						decode(cookie);

    					if (json) {
    						try {
    							cookie = JSON.parse(cookie);
    						} catch (e) {}
    					}

    					jar[name] = cookie;

    					if (key === name) {
    						break;
    					}
    				} catch (e) {}
    			}

    			return key ? jar[key] : jar;
    		}

    		api.set = set;
    		api.get = function (key) {
    			return get(key, false /* read as raw */);
    		};
    		api.getJSON = function (key) {
    			return get(key, true /* read as json */);
    		};
    		api.remove = function (key, attributes) {
    			set(key, '', extend(attributes, {
    				expires: -1
    			}));
    		};

    		api.defaults = {};

    		api.withConverter = init;

    		return api;
    	}

    	return init(function () {});
    }));
    });

    let data = Object.assign({
        mostrarLogin: false,
        mostrarRegistro: false,
        debug: true,
        fondo: 'url(/imagenes/rosed.png)'
    }, window.globalState);

    //Categorias 
    data.categoriasActivas = config.categorias.filter(c => !c.nsfw).map(c => c.id);

    if(js_cookie.getJSON('categoriasActivas'))
        data.categoriasActivas = js_cookie.getJSON('categoriasActivas');
    else
        js_cookie.set('categoriasActivas', data.categoriasActivas);

    //Hide comentarios
    let comentariosOcultosStorage = localStorage.getItem('comentariosOcultos');
    if(!comentariosOcultosStorage) comentariosOcultosStorage = JSON.stringify(['test']);
    data.comentariosOcultos = new Map(JSON.parse(comentariosOcultosStorage).map(e => [e, true]));


    const store= writable(data);
    var globalStore = {
        subscribe: store.subscribe,
        set(value) {
            localStorage.setItem('comentariosOcultos', JSON.stringify(Array.from(value.comentariosOcultos.keys())));
            js_cookie.set('categoriasActivas', value.categoriasActivas, { expires: 696969 });
            store.set(value);
        },
        update (config){
            js_cookie.set('categoriasActivas', config.categoriasActivas, { expires: 696969 });
            store.update(config);
        }
    };

    class MediaType
    {
        static Imagen = 0
        static Video = 1
        static Youtube = 2
    }

    /* src\components\Media.svelte generated by Svelte v3.29.0 */

    const { console: console_1 } = globals;
    const file$2 = "src\\components\\Media.svelte";

    // (30:4) {#if !abierto}
    function create_if_block_7(ctx) {
    	let div;
    	let button;
    	let current;

    	button = new ye({
    			props: {
    				class: "cerrar",
    				icon: true,
    				$$slots: { default: [create_default_slot_4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button.$on("click", /*click_handler*/ ctx[7]);

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(button.$$.fragment);
    			attr_dev(div, "class", "ocultar svelte-10iiddm");
    			add_location(div, file$2, 30, 8, 686);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(button, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button_changes = {};

    			if (dirty & /*$$scope, oculto*/ 2056) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(button);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_7.name,
    		type: "if",
    		source: "(30:4) {#if !abierto}",
    		ctx
    	});

    	return block;
    }

    // (32:12) <Button on:click={() => oculto = !oculto} class="cerrar" icon>
    function create_default_slot_4(ctx) {
    	let i;
    	let i_class_value;

    	const block = {
    		c: function create() {
    			i = element("i");
    			attr_dev(i, "class", i_class_value = "fe fe-eye" + (!/*oculto*/ ctx[3] ? "-off" : ""));
    			add_location(i, file$2, 32, 16, 801);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, i, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*oculto*/ 8 && i_class_value !== (i_class_value = "fe fe-eye" + (!/*oculto*/ ctx[3] ? "-off" : ""))) {
    				attr_dev(i, "class", i_class_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(i);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4.name,
    		type: "slot",
    		source: "(32:12) <Button on:click={() => oculto = !oculto} class=\\\"cerrar\\\" icon>",
    		ctx
    	});

    	return block;
    }

    // (62:50) 
    function create_if_block_5(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let t0;
    	let a;
    	let t1;
    	let ripple;
    	let a_href_value;
    	let current;
    	const if_block_creators = [create_if_block_6, create_else_block_2];
    	const if_blocks = [];

    	function select_block_type_3(ctx, dirty) {
    		if (/*abierto*/ ctx[0]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_3(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	ripple = new he({ $$inline: true });

    	const block = {
    		c: function create() {
    			if_block.c();
    			t0 = space();
    			a = element("a");
    			t1 = text("Abrir en Yeutube \r\n                    ");
    			create_component(ripple.$$.fragment);
    			attr_dev(a, "class", "medialink svelte-10iiddm");
    			attr_dev(a, "target", "_blanck");
    			attr_dev(a, "href", a_href_value = "https://www.youtube.com/watch/" + /*media*/ ctx[1].id);
    			add_location(a, file$2, 76, 16, 2812);
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, a, anchor);
    			append_dev(a, t1);
    			mount_component(ripple, a, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_3(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				}

    				transition_in(if_block, 1);
    				if_block.m(t0.parentNode, t0);
    			}

    			if (!current || dirty & /*media*/ 2 && a_href_value !== (a_href_value = "https://www.youtube.com/watch/" + /*media*/ ctx[1].id)) {
    				attr_dev(a, "href", a_href_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			transition_in(ripple.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			transition_out(ripple.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(a);
    			destroy_component(ripple);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5.name,
    		type: "if",
    		source: "(62:50) ",
    		ctx
    	});

    	return block;
    }

    // (49:48) 
    function create_if_block_3(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block_4, create_else_block_1];
    	const if_blocks = [];

    	function select_block_type_2(ctx, dirty) {
    		if (/*abierto*/ ctx[0]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_2(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_2(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3.name,
    		type: "if",
    		source: "(49:48) ",
    		ctx
    	});

    	return block;
    }

    // (39:46) 
    function create_if_block_1(ctx) {
    	let if_block_anchor;

    	function select_block_type_1(ctx, dirty) {
    		if (/*media*/ ctx[1].esGif) return create_if_block_2;
    		return create_else_block;
    	}

    	let current_block_type = select_block_type_1(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1.name,
    		type: "if",
    		source: "(39:46) ",
    		ctx
    	});

    	return block;
    }

    // (37:4) {#if oculto}
    function create_if_block$1(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			set_style(div, "height", "64px");
    			add_location(div, file$2, 37, 8, 924);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$1.name,
    		type: "if",
    		source: "(37:4) {#if oculto}",
    		ctx
    	});

    	return block;
    }

    // (71:16) {:else}
    function create_else_block_2(ctx) {
    	let img;
    	let img_src_value;
    	let t;
    	let button;
    	let current;
    	let mounted;
    	let dispose;

    	button = new ye({
    			props: {
    				color: "red",
    				class: "play",
    				icon: true,
    				$$slots: { default: [create_default_slot_3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button.$on("click", /*abrirVideo*/ ctx[6]);

    	const block = {
    		c: function create() {
    			img = element("img");
    			t = space();
    			create_component(button.$$.fragment);
    			if (img.src !== (img_src_value = /*vistaPrevia*/ ctx[5])) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", "");
    			attr_dev(img, "srcset", "");
    			attr_dev(img, "class", "svelte-10iiddm");
    			add_location(img, file$2, 71, 16, 2511);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, img, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(button, target, anchor);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(img, "click", /*abrirVideo*/ ctx[6], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (!current || dirty & /*vistaPrevia*/ 32 && img.src !== (img_src_value = /*vistaPrevia*/ ctx[5])) {
    				attr_dev(img, "src", img_src_value);
    			}

    			const button_changes = {};

    			if (dirty & /*$$scope*/ 2048) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(img);
    			if (detaching) detach_dev(t);
    			destroy_component(button, detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_2.name,
    		type: "else",
    		source: "(71:16) {:else}",
    		ctx
    	});

    	return block;
    }

    // (64:12) {#if abierto}
    function create_if_block_6(ctx) {
    	let div;
    	let iframe;
    	let iframe_src_value;
    	let t;
    	let button;
    	let current;

    	button = new ye({
    			props: {
    				class: "cerrar",
    				icon: true,
    				$$slots: { default: [create_default_slot_2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button.$on("click", /*click_handler_2*/ ctx[10]);

    	const block = {
    		c: function create() {
    			div = element("div");
    			iframe = element("iframe");
    			t = space();
    			create_component(button.$$.fragment);
    			attr_dev(iframe, "title", "youtube");
    			iframe.allowFullscreen = true;
    			if (iframe.src !== (iframe_src_value = "https://www.youtube.com/embed/" + /*media*/ ctx[1].id + "?autoplay=1")) attr_dev(iframe, "src", iframe_src_value);
    			attr_dev(iframe, "class", "svelte-10iiddm");
    			add_location(iframe, file$2, 65, 20, 2184);
    			attr_dev(div, "class", "youtube-container svelte-10iiddm");
    			add_location(div, file$2, 64, 16, 2131);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, iframe);
    			insert_dev(target, t, anchor);
    			mount_component(button, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (!current || dirty & /*media*/ 2 && iframe.src !== (iframe_src_value = "https://www.youtube.com/embed/" + /*media*/ ctx[1].id + "?autoplay=1")) {
    				attr_dev(iframe, "src", iframe_src_value);
    			}

    			const button_changes = {};

    			if (dirty & /*$$scope*/ 2048) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (detaching) detach_dev(t);
    			destroy_component(button, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_6.name,
    		type: "if",
    		source: "(64:12) {#if abierto}",
    		ctx
    	});

    	return block;
    }

    // (73:16) <Button on:click={abrirVideo}  color="red" class="play" icon>
    function create_default_slot_3(ctx) {
    	let i;

    	const block = {
    		c: function create() {
    			i = element("i");
    			attr_dev(i, "class", "fe fe-youtube");
    			set_style(i, "position", "relative");
    			set_style(i, "left", "1px");
    			add_location(i, file$2, 73, 20, 2676);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, i, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(i);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3.name,
    		type: "slot",
    		source: "(73:16) <Button on:click={abrirVideo}  color=\\\"red\\\" class=\\\"play\\\" icon>",
    		ctx
    	});

    	return block;
    }

    // (68:16) <Button on:click={() => abierto = false} class="cerrar" icon>
    function create_default_slot_2(ctx) {
    	let i;

    	const block = {
    		c: function create() {
    			i = element("i");
    			attr_dev(i, "class", "fe fe-x");
    			add_location(i, file$2, 68, 20, 2417);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, i, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(i);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2.name,
    		type: "slot",
    		source: "(68:16) <Button on:click={() => abierto = false} class=\\\"cerrar\\\" icon>",
    		ctx
    	});

    	return block;
    }

    // (56:16) {:else}
    function create_else_block_1(ctx) {
    	let img;
    	let img_src_value;
    	let t;
    	let button;
    	let current;
    	let mounted;
    	let dispose;

    	button = new ye({
    			props: {
    				color: "red",
    				class: "play",
    				icon: true,
    				$$slots: { default: [create_default_slot_1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button.$on("click", /*abrirVideo*/ ctx[6]);

    	const block = {
    		c: function create() {
    			img = element("img");
    			t = space();
    			create_component(button.$$.fragment);
    			if (img.src !== (img_src_value = /*vistaPrevia*/ ctx[5])) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", "");
    			attr_dev(img, "srcset", "");
    			attr_dev(img, "class", "svelte-10iiddm");
    			add_location(img, file$2, 56, 16, 1748);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, img, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(button, target, anchor);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(img, "click", /*abrirVideo*/ ctx[6], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (!current || dirty & /*vistaPrevia*/ 32 && img.src !== (img_src_value = /*vistaPrevia*/ ctx[5])) {
    				attr_dev(img, "src", img_src_value);
    			}

    			const button_changes = {};

    			if (dirty & /*$$scope*/ 2048) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(img);
    			if (detaching) detach_dev(t);
    			destroy_component(button, detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1.name,
    		type: "else",
    		source: "(56:16) {:else}",
    		ctx
    	});

    	return block;
    }

    // (51:12) {#if abierto}
    function create_if_block_4(ctx) {
    	let video;
    	let video_src_value;
    	let t;
    	let button;
    	let current;

    	button = new ye({
    			props: {
    				class: "cerrar",
    				icon: true,
    				$$slots: { default: [create_default_slot] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button.$on("click", /*click_handler_1*/ ctx[9]);

    	const block = {
    		c: function create() {
    			video = element("video");
    			t = space();
    			create_component(button.$$.fragment);
    			video.muted = true;
    			video.loop = true;
    			video.controls = true;
    			if (video.src !== (video_src_value = "/Media/" + /*media*/ ctx[1].url)) attr_dev(video, "src", video_src_value);
    			set_style(video, "margin-bottom", "16px");
    			attr_dev(video, "class", "svelte-10iiddm");
    			add_location(video, file$2, 51, 16, 1447);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, video, anchor);
    			/*video_binding*/ ctx[8](video);
    			insert_dev(target, t, anchor);
    			mount_component(button, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (!current || dirty & /*media*/ 2 && video.src !== (video_src_value = "/Media/" + /*media*/ ctx[1].url)) {
    				attr_dev(video, "src", video_src_value);
    			}

    			const button_changes = {};

    			if (dirty & /*$$scope*/ 2048) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(video);
    			/*video_binding*/ ctx[8](null);
    			if (detaching) detach_dev(t);
    			destroy_component(button, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4.name,
    		type: "if",
    		source: "(51:12) {#if abierto}",
    		ctx
    	});

    	return block;
    }

    // (58:16) <Button on:click={abrirVideo}  color="red" class="play" icon>
    function create_default_slot_1(ctx) {
    	let i;

    	const block = {
    		c: function create() {
    			i = element("i");
    			attr_dev(i, "class", "fe fe-play");
    			set_style(i, "position", "relative");
    			set_style(i, "left", "2px");
    			add_location(i, file$2, 58, 20, 1913);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, i, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(i);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1.name,
    		type: "slot",
    		source: "(58:16) <Button on:click={abrirVideo}  color=\\\"red\\\" class=\\\"play\\\" icon>",
    		ctx
    	});

    	return block;
    }

    // (53:16) <Button on:click={() => abierto = false} class="cerrar" icon>
    function create_default_slot(ctx) {
    	let i;

    	const block = {
    		c: function create() {
    			i = element("i");
    			attr_dev(i, "class", "fe fe-x");
    			add_location(i, file$2, 53, 20, 1654);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, i, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(i);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot.name,
    		type: "slot",
    		source: "(53:16) <Button on:click={() => abierto = false} class=\\\"cerrar\\\" icon>",
    		ctx
    	});

    	return block;
    }

    // (44:8) {:else}
    function create_else_block(ctx) {
    	let a;
    	let img;
    	let img_src_value;
    	let a_href_value;

    	const block = {
    		c: function create() {
    			a = element("a");
    			img = element("img");
    			if (img.src !== (img_src_value = /*vistaPrevia*/ ctx[5])) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", "");
    			attr_dev(img, "srcset", "");
    			attr_dev(img, "class", "svelte-10iiddm");
    			add_location(img, file$2, 45, 16, 1267);
    			attr_dev(a, "href", a_href_value = "/Media/" + /*media*/ ctx[1].url);
    			attr_dev(a, "target", "_blank");
    			attr_dev(a, "class", "svelte-10iiddm");
    			add_location(a, file$2, 44, 12, 1204);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);
    			append_dev(a, img);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*vistaPrevia*/ 32 && img.src !== (img_src_value = /*vistaPrevia*/ ctx[5])) {
    				attr_dev(img, "src", img_src_value);
    			}

    			if (dirty & /*media*/ 2 && a_href_value !== (a_href_value = "/Media/" + /*media*/ ctx[1].url)) {
    				attr_dev(a, "href", a_href_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block.name,
    		type: "else",
    		source: "(44:8) {:else}",
    		ctx
    	});

    	return block;
    }

    // (40:8) {#if media.esGif}
    function create_if_block_2(ctx) {
    	let a;
    	let img;
    	let img_src_value;
    	let a_href_value;

    	const block = {
    		c: function create() {
    			a = element("a");
    			img = element("img");
    			if (img.src !== (img_src_value = "/Media/" + /*media*/ ctx[1].url)) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", "");
    			attr_dev(img, "srcset", "");
    			attr_dev(img, "class", "svelte-10iiddm");
    			add_location(img, file$2, 41, 16, 1108);
    			attr_dev(a, "href", a_href_value = "/Media/" + /*media*/ ctx[1].url);
    			attr_dev(a, "target", "_blank");
    			attr_dev(a, "class", "svelte-10iiddm");
    			add_location(a, file$2, 40, 12, 1045);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);
    			append_dev(a, img);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*media*/ 2 && img.src !== (img_src_value = "/Media/" + /*media*/ ctx[1].url)) {
    				attr_dev(img, "src", img_src_value);
    			}

    			if (dirty & /*media*/ 2 && a_href_value !== (a_href_value = "/Media/" + /*media*/ ctx[1].url)) {
    				attr_dev(a, "href", a_href_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2.name,
    		type: "if",
    		source: "(40:8) {#if media.esGif}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$2(ctx) {
    	let div;
    	let t;
    	let current_block_type_index;
    	let if_block1;
    	let current;
    	let if_block0 = !/*abierto*/ ctx[0] && create_if_block_7(ctx);
    	const if_block_creators = [create_if_block$1, create_if_block_1, create_if_block_3, create_if_block_5];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*oculto*/ ctx[3]) return 0;
    		if (/*media*/ ctx[1].tipo == MediaType.Imagen) return 1;
    		if (/*media*/ ctx[1].tipo == MediaType.Video) return 2;
    		if (/*media*/ ctx[1].tipo == MediaType.Youtube) return 3;
    		return -1;
    	}

    	if (~(current_block_type_index = select_block_type(ctx))) {
    		if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block0) if_block0.c();
    			t = space();
    			if (if_block1) if_block1.c();
    			attr_dev(div, "class", "media svelte-10iiddm");
    			toggle_class(div, "abierto", /*abierto*/ ctx[0]);
    			toggle_class(div, "modoCuadrado", /*modoCuadrado*/ ctx[2]);
    			toggle_class(div, "youtube", /*media*/ ctx[1].tipo == MediaType.Youtube);
    			add_location(div, file$2, 25, 0, 540);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block0) if_block0.m(div, null);
    			append_dev(div, t);

    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (!/*abierto*/ ctx[0]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty & /*abierto*/ 1) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_7(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(div, t);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if (~current_block_type_index) {
    					if_blocks[current_block_type_index].p(ctx, dirty);
    				}
    			} else {
    				if (if_block1) {
    					group_outros();

    					transition_out(if_blocks[previous_block_index], 1, 1, () => {
    						if_blocks[previous_block_index] = null;
    					});

    					check_outros();
    				}

    				if (~current_block_type_index) {
    					if_block1 = if_blocks[current_block_type_index];

    					if (!if_block1) {
    						if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    						if_block1.c();
    					}

    					transition_in(if_block1, 1);
    					if_block1.m(div, null);
    				} else {
    					if_block1 = null;
    				}
    			}

    			if (dirty & /*abierto*/ 1) {
    				toggle_class(div, "abierto", /*abierto*/ ctx[0]);
    			}

    			if (dirty & /*modoCuadrado*/ 4) {
    				toggle_class(div, "modoCuadrado", /*modoCuadrado*/ ctx[2]);
    			}

    			if (dirty & /*media, MediaType*/ 2) {
    				toggle_class(div, "youtube", /*media*/ ctx[1].tipo == MediaType.Youtube);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block0) if_block0.d();

    			if (~current_block_type_index) {
    				if_blocks[current_block_type_index].d();
    			}
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$2.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$2($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Media", slots, []);
    	let { media } = $$props;
    	let { modoCuadrado = false } = $$props;
    	let { abierto = false } = $$props;
    	let oculto = false;
    	let vid;

    	function abrirVideo() {
    		$$invalidate(0, abierto = true);
    		console.log(vid);

    		setTimeout(
    			async () => {
    				vid.play();
    			},
    			1
    		);
    	}

    	const writable_props = ["media", "modoCuadrado", "abierto"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1.warn(`<Media> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => $$invalidate(3, oculto = !oculto);

    	function video_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			vid = $$value;
    			$$invalidate(4, vid);
    		});
    	}

    	const click_handler_1 = () => $$invalidate(0, abierto = false);
    	const click_handler_2 = () => $$invalidate(0, abierto = false);

    	$$self.$$set = $$props => {
    		if ("media" in $$props) $$invalidate(1, media = $$props.media);
    		if ("modoCuadrado" in $$props) $$invalidate(2, modoCuadrado = $$props.modoCuadrado);
    		if ("abierto" in $$props) $$invalidate(0, abierto = $$props.abierto);
    	};

    	$$self.$capture_state = () => ({
    		MediaType,
    		onMount,
    		Icon: Me,
    		Button: ye,
    		Ripple: he,
    		media,
    		modoCuadrado,
    		abierto,
    		oculto,
    		vid,
    		abrirVideo,
    		vistaPrevia
    	});

    	$$self.$inject_state = $$props => {
    		if ("media" in $$props) $$invalidate(1, media = $$props.media);
    		if ("modoCuadrado" in $$props) $$invalidate(2, modoCuadrado = $$props.modoCuadrado);
    		if ("abierto" in $$props) $$invalidate(0, abierto = $$props.abierto);
    		if ("oculto" in $$props) $$invalidate(3, oculto = $$props.oculto);
    		if ("vid" in $$props) $$invalidate(4, vid = $$props.vid);
    		if ("vistaPrevia" in $$props) $$invalidate(5, vistaPrevia = $$props.vistaPrevia);
    	};

    	let vistaPrevia;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*modoCuadrado, media*/ 6) {
    			 $$invalidate(5, vistaPrevia = modoCuadrado
    			? media.vistaPreviaCuadrado
    			: media.vistaPrevia);
    		}
    	};

    	return [
    		abierto,
    		media,
    		modoCuadrado,
    		oculto,
    		vid,
    		vistaPrevia,
    		abrirVideo,
    		click_handler,
    		video_binding,
    		click_handler_1,
    		click_handler_2
    	];
    }

    class Media extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$2, create_fragment$2, safe_not_equal, { media: 1, modoCuadrado: 2, abierto: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Media",
    			options,
    			id: create_fragment$2.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*media*/ ctx[1] === undefined && !("media" in props)) {
    			console_1.warn("<Media> was created without expected prop 'media'");
    		}
    	}

    	get media() {
    		throw new Error("<Media>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set media(value) {
    		throw new Error("<Media>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get modoCuadrado() {
    		throw new Error("<Media>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set modoCuadrado(value) {
    		throw new Error("<Media>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get abierto() {
    		throw new Error("<Media>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set abierto(value) {
    		throw new Error("<Media>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\components\ErrorValidacion.svelte generated by Svelte v3.29.0 */

    const { Object: Object_1 } = globals;
    const file$3 = "src\\components\\ErrorValidacion.svelte";

    function get_each_context_3(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[4] = list[i];
    	return child_ctx;
    }

    function get_each_context_2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[1] = list[i];
    	return child_ctx;
    }

    function get_each_context_1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[4] = list[i];
    	return child_ctx;
    }

    function get_each_context(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[1] = list[i];
    	return child_ctx;
    }

    // (18:16) 
    function create_if_block_1$1(ctx) {
    	let div;
    	let h3;
    	let t1;
    	let each_value_2 = Object.keys(/*error*/ ctx[0]);
    	validate_each_argument(each_value_2);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_2.length; i += 1) {
    		each_blocks[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			h3 = element("h3");
    			h3.textContent = "Ay no se!";
    			t1 = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			add_location(h3, file$3, 19, 4, 456);
    			attr_dev(div, "class", "error-validacion");
    			add_location(div, file$3, 18, 0, 420);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, h3);
    			append_dev(div, t1);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div, null);
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*error, Object*/ 1) {
    				each_value_2 = Object.keys(/*error*/ ctx[0]);
    				validate_each_argument(each_value_2);
    				let i;

    				for (i = 0; i < each_value_2.length; i += 1) {
    					const child_ctx = get_each_context_2(ctx, each_value_2, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_2(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_2.length;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$1.name,
    		type: "if",
    		source: "(18:16) ",
    		ctx
    	});

    	return block;
    }

    // (6:0) {#if error && error.errors}
    function create_if_block$2(ctx) {
    	let div;
    	let h3;
    	let t1;
    	let each_value = Object.keys(/*error*/ ctx[0].errors);
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			h3 = element("h3");
    			h3.textContent = "Ay no se!";
    			t1 = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			add_location(h3, file$3, 7, 4, 119);
    			attr_dev(div, "class", "error-validacion");
    			add_location(div, file$3, 6, 0, 83);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, h3);
    			append_dev(div, t1);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div, null);
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*error, Object*/ 1) {
    				each_value = Object.keys(/*error*/ ctx[0].errors);
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$2.name,
    		type: "if",
    		source: "(6:0) {#if error && error.errors}",
    		ctx
    	});

    	return block;
    }

    // (24:16) {#each error[key] as e}
    function create_each_block_3(ctx) {
    	let t_value = /*e*/ ctx[4] + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*error*/ 1 && t_value !== (t_value = /*e*/ ctx[4] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_3.name,
    		type: "each",
    		source: "(24:16) {#each error[key] as e}",
    		ctx
    	});

    	return block;
    }

    // (21:4) {#each Object.keys(error) as key}
    function create_each_block_2(ctx) {
    	let div;
    	let strong;
    	let t0_value = /*key*/ ctx[1] + "";
    	let t0;
    	let t1;
    	let t2;
    	let t3;
    	let each_value_3 = /*error*/ ctx[0][/*key*/ ctx[1]];
    	validate_each_argument(each_value_3);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_3.length; i += 1) {
    		each_blocks[i] = create_each_block_3(get_each_context_3(ctx, each_value_3, i));
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			strong = element("strong");
    			t0 = text(t0_value);
    			t1 = text(":");
    			t2 = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t3 = space();
    			add_location(strong, file$3, 22, 16, 559);
    			attr_dev(div, "class", "");
    			add_location(div, file$3, 21, 12, 527);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, strong);
    			append_dev(strong, t0);
    			append_dev(strong, t1);
    			append_dev(div, t2);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div, null);
    			}

    			append_dev(div, t3);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*error*/ 1 && t0_value !== (t0_value = /*key*/ ctx[1] + "")) set_data_dev(t0, t0_value);

    			if (dirty & /*error, Object*/ 1) {
    				each_value_3 = /*error*/ ctx[0][/*key*/ ctx[1]];
    				validate_each_argument(each_value_3);
    				let i;

    				for (i = 0; i < each_value_3.length; i += 1) {
    					const child_ctx = get_each_context_3(ctx, each_value_3, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_3(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div, t3);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_3.length;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_2.name,
    		type: "each",
    		source: "(21:4) {#each Object.keys(error) as key}",
    		ctx
    	});

    	return block;
    }

    // (12:16) {#each error.errors[key] as e}
    function create_each_block_1(ctx) {
    	let t_value = /*e*/ ctx[4] + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*error*/ 1 && t_value !== (t_value = /*e*/ ctx[4] + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1.name,
    		type: "each",
    		source: "(12:16) {#each error.errors[key] as e}",
    		ctx
    	});

    	return block;
    }

    // (9:4) {#each Object.keys(error.errors) as key}
    function create_each_block(ctx) {
    	let div;
    	let strong;
    	let t0_value = /*key*/ ctx[1] + "";
    	let t0;
    	let t1;
    	let t2;
    	let t3;
    	let each_value_1 = /*error*/ ctx[0].errors[/*key*/ ctx[1]];
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			strong = element("strong");
    			t0 = text(t0_value);
    			t1 = text(":");
    			t2 = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t3 = space();
    			add_location(strong, file$3, 10, 16, 229);
    			attr_dev(div, "class", "");
    			add_location(div, file$3, 9, 12, 197);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, strong);
    			append_dev(strong, t0);
    			append_dev(strong, t1);
    			append_dev(div, t2);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div, null);
    			}

    			append_dev(div, t3);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*error*/ 1 && t0_value !== (t0_value = /*key*/ ctx[1] + "")) set_data_dev(t0, t0_value);

    			if (dirty & /*error, Object*/ 1) {
    				each_value_1 = /*error*/ ctx[0].errors[/*key*/ ctx[1]];
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_1(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div, t3);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_1.length;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block.name,
    		type: "each",
    		source: "(9:4) {#each Object.keys(error.errors) as key}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$3(ctx) {
    	let if_block_anchor;

    	function select_block_type(ctx, dirty) {
    		if (/*error*/ ctx[0] && /*error*/ ctx[0].errors) return create_if_block$2;
    		if (/*error*/ ctx[0]) return create_if_block_1$1;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type && current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, [dirty]) {
    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if (if_block) if_block.d(1);
    				if_block = current_block_type && current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (if_block) {
    				if_block.d(detaching);
    			}

    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$3.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$3($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("ErrorValidacion", slots, []);
    	let { error = null } = $$props;
    	const writable_props = ["error"];

    	Object_1.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ErrorValidacion> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("error" in $$props) $$invalidate(0, error = $$props.error);
    	};

    	$$self.$capture_state = () => ({ error });

    	$$self.$inject_state = $$props => {
    		if ("error" in $$props) $$invalidate(0, error = $$props.error);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [error];
    }

    class ErrorValidacion extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$3, create_fragment$3, safe_not_equal, { error: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ErrorValidacion",
    			options,
    			id: create_fragment$3.name
    		});
    	}

    	get error() {
    		throw new Error("<ErrorValidacion>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set error(value) {
    		throw new Error("<ErrorValidacion>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\components\Dialogo.svelte generated by Svelte v3.29.0 */

    const { console: console_1$1 } = globals;
    const file$4 = "src\\components\\Dialogo.svelte";
    const get_body_slot_changes = dirty => ({});
    const get_body_slot_context = ctx => ({});
    const get_activador_slot_changes$1 = dirty => ({});
    const get_activador_slot_context$1 = ctx => ({});

    // (41:8) <Button >
    function create_default_slot_3$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text(/*textoActivador*/ ctx[2]);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*textoActivador*/ 4) set_data_dev(t, /*textoActivador*/ ctx[2]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$1.name,
    		type: "slot",
    		source: "(41:8) <Button >",
    		ctx
    	});

    	return block;
    }

    // (40:28)           
    function fallback_block_1(ctx) {
    	let button;
    	let current;

    	button = new ye({
    			props: {
    				$$slots: { default: [create_default_slot_3$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(button.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(button, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button_changes = {};

    			if (dirty & /*$$scope, textoActivador*/ 8196) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(button, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block_1.name,
    		type: "fallback",
    		source: "(40:28)           ",
    		ctx
    	});

    	return block;
    }

    // (46:8) <div slot="title">
    function create_title_slot(ctx) {
    	let div;
    	let t;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text(/*titulo*/ ctx[1]);
    			attr_dev(div, "slot", "title");
    			add_location(div, file$4, 45, 8, 1121);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*titulo*/ 2) set_data_dev(t, /*titulo*/ ctx[1]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_title_slot.name,
    		type: "slot",
    		source: "(46:8) <div slot=\\\"title\\\">",
    		ctx
    	});

    	return block;
    }

    // (49:8) {#if exito}
    function create_if_block$3(ctx) {
    	let p;
    	let t_value = /*respuesta*/ ctx[4].mensaje + "";
    	let t;

    	const block = {
    		c: function create() {
    			p = element("p");
    			t = text(t_value);
    			attr_dev(p, "class", "exito svelte-1eg803u");
    			add_location(p, file$4, 49, 12, 1238);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, p, anchor);
    			append_dev(p, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*respuesta*/ 16 && t_value !== (t_value = /*respuesta*/ ctx[4].mensaje + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(p);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$3.name,
    		type: "if",
    		source: "(49:8) {#if exito}",
    		ctx
    	});

    	return block;
    }

    // (58:12) <Button color="primary" on:click={()=> visible = false}>
    function create_default_slot_2$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Cancelar");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$1.name,
    		type: "slot",
    		source: "(58:12) <Button color=\\\"primary\\\" on:click={()=> visible = false}>",
    		ctx
    	});

    	return block;
    }

    // (59:12) <Button color="primary" on:click={ejecutarAccion}>
    function create_default_slot_1$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Aceptar");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$1.name,
    		type: "slot",
    		source: "(59:12) <Button color=\\\"primary\\\" on:click={ejecutarAccion}>",
    		ctx
    	});

    	return block;
    }

    // (57:8) <div slot="actions" class="actions center">
    function create_actions_slot(ctx) {
    	let div;
    	let button0;
    	let t;
    	let button1;
    	let current;

    	button0 = new ye({
    			props: {
    				color: "primary",
    				$$slots: { default: [create_default_slot_2$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button0.$on("click", /*click_handler_1*/ ctx[11]);

    	button1 = new ye({
    			props: {
    				color: "primary",
    				$$slots: { default: [create_default_slot_1$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button1.$on("click", /*ejecutarAccion*/ ctx[6]);

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(button0.$$.fragment);
    			t = space();
    			create_component(button1.$$.fragment);
    			attr_dev(div, "slot", "actions");
    			attr_dev(div, "class", "actions center");
    			add_location(div, file$4, 56, 8, 1374);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(button0, div, null);
    			append_dev(div, t);
    			mount_component(button1, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button0_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				button0_changes.$$scope = { dirty, ctx };
    			}

    			button0.$set(button0_changes);
    			const button1_changes = {};

    			if (dirty & /*$$scope*/ 8192) {
    				button1_changes.$$scope = { dirty, ctx };
    			}

    			button1.$set(button1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button0.$$.fragment, local);
    			transition_in(button1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button0.$$.fragment, local);
    			transition_out(button1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(button0);
    			destroy_component(button1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_actions_slot.name,
    		type: "slot",
    		source: "(57:8) <div slot=\\\"actions\\\" class=\\\"actions center\\\">",
    		ctx
    	});

    	return block;
    }

    // (45:4) <Dialog width="320" bind:visible={visible}>
    function create_default_slot$1(ctx) {
    	let t0;
    	let errorvalidacion;
    	let updating_error;
    	let t1;
    	let t2;
    	let t3;
    	let current;

    	function errorvalidacion_error_binding(value) {
    		/*errorvalidacion_error_binding*/ ctx[10].call(null, value);
    	}

    	let errorvalidacion_props = {};

    	if (/*error*/ ctx[5] !== void 0) {
    		errorvalidacion_props.error = /*error*/ ctx[5];
    	}

    	errorvalidacion = new ErrorValidacion({
    			props: errorvalidacion_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(errorvalidacion, "error", errorvalidacion_error_binding));
    	let if_block = /*exito*/ ctx[3] && create_if_block$3(ctx);
    	const body_slot_template = /*#slots*/ ctx[8].body;
    	const body_slot = create_slot(body_slot_template, ctx, /*$$scope*/ ctx[13], get_body_slot_context);

    	const block = {
    		c: function create() {
    			t0 = space();
    			create_component(errorvalidacion.$$.fragment);
    			t1 = space();
    			if (if_block) if_block.c();
    			t2 = space();
    			if (body_slot) body_slot.c();
    			t3 = space();
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			mount_component(errorvalidacion, target, anchor);
    			insert_dev(target, t1, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, t2, anchor);

    			if (body_slot) {
    				body_slot.m(target, anchor);
    			}

    			insert_dev(target, t3, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const errorvalidacion_changes = {};

    			if (!updating_error && dirty & /*error*/ 32) {
    				updating_error = true;
    				errorvalidacion_changes.error = /*error*/ ctx[5];
    				add_flush_callback(() => updating_error = false);
    			}

    			errorvalidacion.$set(errorvalidacion_changes);

    			if (/*exito*/ ctx[3]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$3(ctx);
    					if_block.c();
    					if_block.m(t2.parentNode, t2);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			if (body_slot) {
    				if (body_slot.p && dirty & /*$$scope*/ 8192) {
    					update_slot(body_slot, body_slot_template, ctx, /*$$scope*/ ctx[13], dirty, get_body_slot_changes, get_body_slot_context);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(errorvalidacion.$$.fragment, local);
    			transition_in(body_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(errorvalidacion.$$.fragment, local);
    			transition_out(body_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			destroy_component(errorvalidacion, detaching);
    			if (detaching) detach_dev(t1);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(t2);
    			if (body_slot) body_slot.d(detaching);
    			if (detaching) detach_dev(t3);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$1.name,
    		type: "slot",
    		source: "(45:4) <Dialog width=\\\"320\\\" bind:visible={visible}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$4(ctx) {
    	let span;
    	let t;
    	let dialog;
    	let updating_visible;
    	let current;
    	let mounted;
    	let dispose;
    	const activador_slot_template = /*#slots*/ ctx[8].activador;
    	const activador_slot = create_slot(activador_slot_template, ctx, /*$$scope*/ ctx[13], get_activador_slot_context$1);
    	const activador_slot_or_fallback = activador_slot || fallback_block_1(ctx);

    	function dialog_visible_binding(value) {
    		/*dialog_visible_binding*/ ctx[12].call(null, value);
    	}

    	let dialog_props = {
    		width: "320",
    		$$slots: {
    			default: [create_default_slot$1],
    			actions: [create_actions_slot],
    			title: [create_title_slot]
    		},
    		$$scope: { ctx }
    	};

    	if (/*visible*/ ctx[0] !== void 0) {
    		dialog_props.visible = /*visible*/ ctx[0];
    	}

    	dialog = new pn({ props: dialog_props, $$inline: true });
    	binding_callbacks.push(() => bind(dialog, "visible", dialog_visible_binding));

    	const block = {
    		c: function create() {
    			span = element("span");
    			if (activador_slot_or_fallback) activador_slot_or_fallback.c();
    			t = space();
    			create_component(dialog.$$.fragment);
    			add_location(span, file$4, 38, 0, 926);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);

    			if (activador_slot_or_fallback) {
    				activador_slot_or_fallback.m(span, null);
    			}

    			insert_dev(target, t, anchor);
    			mount_component(dialog, target, anchor);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(span, "click", /*click_handler*/ ctx[9], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (activador_slot) {
    				if (activador_slot.p && dirty & /*$$scope*/ 8192) {
    					update_slot(activador_slot, activador_slot_template, ctx, /*$$scope*/ ctx[13], dirty, get_activador_slot_changes$1, get_activador_slot_context$1);
    				}
    			} else {
    				if (activador_slot_or_fallback && activador_slot_or_fallback.p && dirty & /*textoActivador*/ 4) {
    					activador_slot_or_fallback.p(ctx, dirty);
    				}
    			}

    			const dialog_changes = {};

    			if (dirty & /*$$scope, visible, respuesta, exito, error, titulo*/ 8251) {
    				dialog_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_visible && dirty & /*visible*/ 1) {
    				updating_visible = true;
    				dialog_changes.visible = /*visible*/ ctx[0];
    				add_flush_callback(() => updating_visible = false);
    			}

    			dialog.$set(dialog_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(activador_slot_or_fallback, local);
    			transition_in(dialog.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(activador_slot_or_fallback, local);
    			transition_out(dialog.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			if (activador_slot_or_fallback) activador_slot_or_fallback.d(detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(dialog, detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$4.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$4($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Dialogo", slots, ['activador','body']);
    	let { titulo = "Accion" } = $$props;
    	let { accion = () => console.log("Accionado") } = $$props;
    	let { visible = false } = $$props;
    	let { textoActivador = "Accion" } = $$props;
    	let exito = false;
    	let respuesta = null;

    	async function ejecutarAccion() {
    		try {
    			$$invalidate(5, error = null);
    			$$invalidate(4, respuesta = (await accion()).data);
    			$$invalidate(3, exito = true);
    			setTimeout(() => $$invalidate(0, visible = false), 1000);
    		} catch(e) {
    			$$invalidate(3, exito = false);
    			$$invalidate(5, error = e.response.data);
    		}
    	}

    	let error = null;

    	onDestroy(() => {
    		$$invalidate(4, respuesta = null);
    		$$invalidate(5, error = null);
    	});

    	const writable_props = ["titulo", "accion", "visible", "textoActivador"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$1.warn(`<Dialogo> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => $$invalidate(0, visible = true);

    	function errorvalidacion_error_binding(value) {
    		error = value;
    		($$invalidate(5, error), $$invalidate(0, visible));
    	}

    	const click_handler_1 = () => $$invalidate(0, visible = false);

    	function dialog_visible_binding(value) {
    		visible = value;
    		$$invalidate(0, visible);
    	}

    	$$self.$$set = $$props => {
    		if ("titulo" in $$props) $$invalidate(1, titulo = $$props.titulo);
    		if ("accion" in $$props) $$invalidate(7, accion = $$props.accion);
    		if ("visible" in $$props) $$invalidate(0, visible = $$props.visible);
    		if ("textoActivador" in $$props) $$invalidate(2, textoActivador = $$props.textoActivador);
    		if ("$$scope" in $$props) $$invalidate(13, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		ErrorValidacion,
    		Dialog: pn,
    		Button: ye,
    		onDestroy,
    		titulo,
    		accion,
    		visible,
    		textoActivador,
    		exito,
    		respuesta,
    		ejecutarAccion,
    		error
    	});

    	$$self.$inject_state = $$props => {
    		if ("titulo" in $$props) $$invalidate(1, titulo = $$props.titulo);
    		if ("accion" in $$props) $$invalidate(7, accion = $$props.accion);
    		if ("visible" in $$props) $$invalidate(0, visible = $$props.visible);
    		if ("textoActivador" in $$props) $$invalidate(2, textoActivador = $$props.textoActivador);
    		if ("exito" in $$props) $$invalidate(3, exito = $$props.exito);
    		if ("respuesta" in $$props) $$invalidate(4, respuesta = $$props.respuesta);
    		if ("error" in $$props) $$invalidate(5, error = $$props.error);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*visible*/ 1) {
    			 if (visible == false) {
    				$$invalidate(4, respuesta = null);
    				$$invalidate(5, error = null);
    				$$invalidate(3, exito = false);
    			}
    		}
    	};

    	return [
    		visible,
    		titulo,
    		textoActivador,
    		exito,
    		respuesta,
    		error,
    		ejecutarAccion,
    		accion,
    		slots,
    		click_handler,
    		errorvalidacion_error_binding,
    		click_handler_1,
    		dialog_visible_binding,
    		$$scope
    	];
    }

    class Dialogo extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$4, create_fragment$4, safe_not_equal, {
    			titulo: 1,
    			accion: 7,
    			visible: 0,
    			textoActivador: 2
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Dialogo",
    			options,
    			id: create_fragment$4.name
    		});
    	}

    	get titulo() {
    		throw new Error("<Dialogo>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set titulo(value) {
    		throw new Error("<Dialogo>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get accion() {
    		throw new Error("<Dialogo>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set accion(value) {
    		throw new Error("<Dialogo>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get visible() {
    		throw new Error("<Dialogo>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set visible(value) {
    		throw new Error("<Dialogo>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get textoActivador() {
    		throw new Error("<Dialogo>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set textoActivador(value) {
    		throw new Error("<Dialogo>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    var bind$1 = function bind(fn, thisArg) {
      return function wrap() {
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        return fn.apply(thisArg, args);
      };
    };

    /*global toString:true*/

    // utils is a library of generic helper functions non-specific to axios

    var toString = Object.prototype.toString;

    /**
     * Determine if a value is an Array
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is an Array, otherwise false
     */
    function isArray(val) {
      return toString.call(val) === '[object Array]';
    }

    /**
     * Determine if a value is undefined
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if the value is undefined, otherwise false
     */
    function isUndefined(val) {
      return typeof val === 'undefined';
    }

    /**
     * Determine if a value is a Buffer
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a Buffer, otherwise false
     */
    function isBuffer(val) {
      return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)
        && typeof val.constructor.isBuffer === 'function' && val.constructor.isBuffer(val);
    }

    /**
     * Determine if a value is an ArrayBuffer
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is an ArrayBuffer, otherwise false
     */
    function isArrayBuffer(val) {
      return toString.call(val) === '[object ArrayBuffer]';
    }

    /**
     * Determine if a value is a FormData
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is an FormData, otherwise false
     */
    function isFormData(val) {
      return (typeof FormData !== 'undefined') && (val instanceof FormData);
    }

    /**
     * Determine if a value is a view on an ArrayBuffer
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
     */
    function isArrayBufferView(val) {
      var result;
      if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
        result = ArrayBuffer.isView(val);
      } else {
        result = (val) && (val.buffer) && (val.buffer instanceof ArrayBuffer);
      }
      return result;
    }

    /**
     * Determine if a value is a String
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a String, otherwise false
     */
    function isString(val) {
      return typeof val === 'string';
    }

    /**
     * Determine if a value is a Number
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a Number, otherwise false
     */
    function isNumber(val) {
      return typeof val === 'number';
    }

    /**
     * Determine if a value is an Object
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is an Object, otherwise false
     */
    function isObject(val) {
      return val !== null && typeof val === 'object';
    }

    /**
     * Determine if a value is a plain Object
     *
     * @param {Object} val The value to test
     * @return {boolean} True if value is a plain Object, otherwise false
     */
    function isPlainObject(val) {
      if (toString.call(val) !== '[object Object]') {
        return false;
      }

      var prototype = Object.getPrototypeOf(val);
      return prototype === null || prototype === Object.prototype;
    }

    /**
     * Determine if a value is a Date
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a Date, otherwise false
     */
    function isDate(val) {
      return toString.call(val) === '[object Date]';
    }

    /**
     * Determine if a value is a File
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a File, otherwise false
     */
    function isFile(val) {
      return toString.call(val) === '[object File]';
    }

    /**
     * Determine if a value is a Blob
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a Blob, otherwise false
     */
    function isBlob(val) {
      return toString.call(val) === '[object Blob]';
    }

    /**
     * Determine if a value is a Function
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a Function, otherwise false
     */
    function isFunction(val) {
      return toString.call(val) === '[object Function]';
    }

    /**
     * Determine if a value is a Stream
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a Stream, otherwise false
     */
    function isStream(val) {
      return isObject(val) && isFunction(val.pipe);
    }

    /**
     * Determine if a value is a URLSearchParams object
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a URLSearchParams object, otherwise false
     */
    function isURLSearchParams(val) {
      return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;
    }

    /**
     * Trim excess whitespace off the beginning and end of a string
     *
     * @param {String} str The String to trim
     * @returns {String} The String freed of excess whitespace
     */
    function trim(str) {
      return str.replace(/^\s*/, '').replace(/\s*$/, '');
    }

    /**
     * Determine if we're running in a standard browser environment
     *
     * This allows axios to run in a web worker, and react-native.
     * Both environments support XMLHttpRequest, but not fully standard globals.
     *
     * web workers:
     *  typeof window -> undefined
     *  typeof document -> undefined
     *
     * react-native:
     *  navigator.product -> 'ReactNative'
     * nativescript
     *  navigator.product -> 'NativeScript' or 'NS'
     */
    function isStandardBrowserEnv() {
      if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' ||
                                               navigator.product === 'NativeScript' ||
                                               navigator.product === 'NS')) {
        return false;
      }
      return (
        typeof window !== 'undefined' &&
        typeof document !== 'undefined'
      );
    }

    /**
     * Iterate over an Array or an Object invoking a function for each item.
     *
     * If `obj` is an Array callback will be called passing
     * the value, index, and complete array for each item.
     *
     * If 'obj' is an Object callback will be called passing
     * the value, key, and complete object for each property.
     *
     * @param {Object|Array} obj The object to iterate
     * @param {Function} fn The callback to invoke for each item
     */
    function forEach(obj, fn) {
      // Don't bother if no value provided
      if (obj === null || typeof obj === 'undefined') {
        return;
      }

      // Force an array if not already something iterable
      if (typeof obj !== 'object') {
        /*eslint no-param-reassign:0*/
        obj = [obj];
      }

      if (isArray(obj)) {
        // Iterate over array values
        for (var i = 0, l = obj.length; i < l; i++) {
          fn.call(null, obj[i], i, obj);
        }
      } else {
        // Iterate over object keys
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) {
            fn.call(null, obj[key], key, obj);
          }
        }
      }
    }

    /**
     * Accepts varargs expecting each argument to be an object, then
     * immutably merges the properties of each object and returns result.
     *
     * When multiple objects contain the same key the later object in
     * the arguments list will take precedence.
     *
     * Example:
     *
     * ```js
     * var result = merge({foo: 123}, {foo: 456});
     * console.log(result.foo); // outputs 456
     * ```
     *
     * @param {Object} obj1 Object to merge
     * @returns {Object} Result of all merge properties
     */
    function merge(/* obj1, obj2, obj3, ... */) {
      var result = {};
      function assignValue(val, key) {
        if (isPlainObject(result[key]) && isPlainObject(val)) {
          result[key] = merge(result[key], val);
        } else if (isPlainObject(val)) {
          result[key] = merge({}, val);
        } else if (isArray(val)) {
          result[key] = val.slice();
        } else {
          result[key] = val;
        }
      }

      for (var i = 0, l = arguments.length; i < l; i++) {
        forEach(arguments[i], assignValue);
      }
      return result;
    }

    /**
     * Extends object a by mutably adding to it the properties of object b.
     *
     * @param {Object} a The object to be extended
     * @param {Object} b The object to copy properties from
     * @param {Object} thisArg The object to bind function to
     * @return {Object} The resulting value of object a
     */
    function extend(a, b, thisArg) {
      forEach(b, function assignValue(val, key) {
        if (thisArg && typeof val === 'function') {
          a[key] = bind$1(val, thisArg);
        } else {
          a[key] = val;
        }
      });
      return a;
    }

    /**
     * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
     *
     * @param {string} content with BOM
     * @return {string} content value without BOM
     */
    function stripBOM(content) {
      if (content.charCodeAt(0) === 0xFEFF) {
        content = content.slice(1);
      }
      return content;
    }

    var utils = {
      isArray: isArray,
      isArrayBuffer: isArrayBuffer,
      isBuffer: isBuffer,
      isFormData: isFormData,
      isArrayBufferView: isArrayBufferView,
      isString: isString,
      isNumber: isNumber,
      isObject: isObject,
      isPlainObject: isPlainObject,
      isUndefined: isUndefined,
      isDate: isDate,
      isFile: isFile,
      isBlob: isBlob,
      isFunction: isFunction,
      isStream: isStream,
      isURLSearchParams: isURLSearchParams,
      isStandardBrowserEnv: isStandardBrowserEnv,
      forEach: forEach,
      merge: merge,
      extend: extend,
      trim: trim,
      stripBOM: stripBOM
    };

    function encode(val) {
      return encodeURIComponent(val).
        replace(/%3A/gi, ':').
        replace(/%24/g, '$').
        replace(/%2C/gi, ',').
        replace(/%20/g, '+').
        replace(/%5B/gi, '[').
        replace(/%5D/gi, ']');
    }

    /**
     * Build a URL by appending params to the end
     *
     * @param {string} url The base of the url (e.g., http://www.google.com)
     * @param {object} [params] The params to be appended
     * @returns {string} The formatted url
     */
    var buildURL = function buildURL(url, params, paramsSerializer) {
      /*eslint no-param-reassign:0*/
      if (!params) {
        return url;
      }

      var serializedParams;
      if (paramsSerializer) {
        serializedParams = paramsSerializer(params);
      } else if (utils.isURLSearchParams(params)) {
        serializedParams = params.toString();
      } else {
        var parts = [];

        utils.forEach(params, function serialize(val, key) {
          if (val === null || typeof val === 'undefined') {
            return;
          }

          if (utils.isArray(val)) {
            key = key + '[]';
          } else {
            val = [val];
          }

          utils.forEach(val, function parseValue(v) {
            if (utils.isDate(v)) {
              v = v.toISOString();
            } else if (utils.isObject(v)) {
              v = JSON.stringify(v);
            }
            parts.push(encode(key) + '=' + encode(v));
          });
        });

        serializedParams = parts.join('&');
      }

      if (serializedParams) {
        var hashmarkIndex = url.indexOf('#');
        if (hashmarkIndex !== -1) {
          url = url.slice(0, hashmarkIndex);
        }

        url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
      }

      return url;
    };

    function InterceptorManager() {
      this.handlers = [];
    }

    /**
     * Add a new interceptor to the stack
     *
     * @param {Function} fulfilled The function to handle `then` for a `Promise`
     * @param {Function} rejected The function to handle `reject` for a `Promise`
     *
     * @return {Number} An ID used to remove interceptor later
     */
    InterceptorManager.prototype.use = function use(fulfilled, rejected) {
      this.handlers.push({
        fulfilled: fulfilled,
        rejected: rejected
      });
      return this.handlers.length - 1;
    };

    /**
     * Remove an interceptor from the stack
     *
     * @param {Number} id The ID that was returned by `use`
     */
    InterceptorManager.prototype.eject = function eject(id) {
      if (this.handlers[id]) {
        this.handlers[id] = null;
      }
    };

    /**
     * Iterate over all the registered interceptors
     *
     * This method is particularly useful for skipping over any
     * interceptors that may have become `null` calling `eject`.
     *
     * @param {Function} fn The function to call for each interceptor
     */
    InterceptorManager.prototype.forEach = function forEach(fn) {
      utils.forEach(this.handlers, function forEachHandler(h) {
        if (h !== null) {
          fn(h);
        }
      });
    };

    var InterceptorManager_1 = InterceptorManager;

    /**
     * Transform the data for a request or a response
     *
     * @param {Object|String} data The data to be transformed
     * @param {Array} headers The headers for the request or response
     * @param {Array|Function} fns A single function or Array of functions
     * @returns {*} The resulting transformed data
     */
    var transformData = function transformData(data, headers, fns) {
      /*eslint no-param-reassign:0*/
      utils.forEach(fns, function transform(fn) {
        data = fn(data, headers);
      });

      return data;
    };

    var isCancel = function isCancel(value) {
      return !!(value && value.__CANCEL__);
    };

    var normalizeHeaderName = function normalizeHeaderName(headers, normalizedName) {
      utils.forEach(headers, function processHeader(value, name) {
        if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
          headers[normalizedName] = value;
          delete headers[name];
        }
      });
    };

    /**
     * Update an Error with the specified config, error code, and response.
     *
     * @param {Error} error The error to update.
     * @param {Object} config The config.
     * @param {string} [code] The error code (for example, 'ECONNABORTED').
     * @param {Object} [request] The request.
     * @param {Object} [response] The response.
     * @returns {Error} The error.
     */
    var enhanceError = function enhanceError(error, config, code, request, response) {
      error.config = config;
      if (code) {
        error.code = code;
      }

      error.request = request;
      error.response = response;
      error.isAxiosError = true;

      error.toJSON = function toJSON() {
        return {
          // Standard
          message: this.message,
          name: this.name,
          // Microsoft
          description: this.description,
          number: this.number,
          // Mozilla
          fileName: this.fileName,
          lineNumber: this.lineNumber,
          columnNumber: this.columnNumber,
          stack: this.stack,
          // Axios
          config: this.config,
          code: this.code
        };
      };
      return error;
    };

    /**
     * Create an Error with the specified message, config, error code, request and response.
     *
     * @param {string} message The error message.
     * @param {Object} config The config.
     * @param {string} [code] The error code (for example, 'ECONNABORTED').
     * @param {Object} [request] The request.
     * @param {Object} [response] The response.
     * @returns {Error} The created error.
     */
    var createError = function createError(message, config, code, request, response) {
      var error = new Error(message);
      return enhanceError(error, config, code, request, response);
    };

    /**
     * Resolve or reject a Promise based on response status.
     *
     * @param {Function} resolve A function that resolves the promise.
     * @param {Function} reject A function that rejects the promise.
     * @param {object} response The response.
     */
    var settle = function settle(resolve, reject, response) {
      var validateStatus = response.config.validateStatus;
      if (!response.status || !validateStatus || validateStatus(response.status)) {
        resolve(response);
      } else {
        reject(createError(
          'Request failed with status code ' + response.status,
          response.config,
          null,
          response.request,
          response
        ));
      }
    };

    var cookies = (
      utils.isStandardBrowserEnv() ?

      // Standard browser envs support document.cookie
        (function standardBrowserEnv() {
          return {
            write: function write(name, value, expires, path, domain, secure) {
              var cookie = [];
              cookie.push(name + '=' + encodeURIComponent(value));

              if (utils.isNumber(expires)) {
                cookie.push('expires=' + new Date(expires).toGMTString());
              }

              if (utils.isString(path)) {
                cookie.push('path=' + path);
              }

              if (utils.isString(domain)) {
                cookie.push('domain=' + domain);
              }

              if (secure === true) {
                cookie.push('secure');
              }

              document.cookie = cookie.join('; ');
            },

            read: function read(name) {
              var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
              return (match ? decodeURIComponent(match[3]) : null);
            },

            remove: function remove(name) {
              this.write(name, '', Date.now() - 86400000);
            }
          };
        })() :

      // Non standard browser env (web workers, react-native) lack needed support.
        (function nonStandardBrowserEnv() {
          return {
            write: function write() {},
            read: function read() { return null; },
            remove: function remove() {}
          };
        })()
    );

    /**
     * Determines whether the specified URL is absolute
     *
     * @param {string} url The URL to test
     * @returns {boolean} True if the specified URL is absolute, otherwise false
     */
    var isAbsoluteURL = function isAbsoluteURL(url) {
      // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
      // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
      // by any combination of letters, digits, plus, period, or hyphen.
      return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
    };

    /**
     * Creates a new URL by combining the specified URLs
     *
     * @param {string} baseURL The base URL
     * @param {string} relativeURL The relative URL
     * @returns {string} The combined URL
     */
    var combineURLs = function combineURLs(baseURL, relativeURL) {
      return relativeURL
        ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '')
        : baseURL;
    };

    /**
     * Creates a new URL by combining the baseURL with the requestedURL,
     * only when the requestedURL is not already an absolute URL.
     * If the requestURL is absolute, this function returns the requestedURL untouched.
     *
     * @param {string} baseURL The base URL
     * @param {string} requestedURL Absolute or relative URL to combine
     * @returns {string} The combined full path
     */
    var buildFullPath = function buildFullPath(baseURL, requestedURL) {
      if (baseURL && !isAbsoluteURL(requestedURL)) {
        return combineURLs(baseURL, requestedURL);
      }
      return requestedURL;
    };

    // Headers whose duplicates are ignored by node
    // c.f. https://nodejs.org/api/http.html#http_message_headers
    var ignoreDuplicateOf = [
      'age', 'authorization', 'content-length', 'content-type', 'etag',
      'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',
      'last-modified', 'location', 'max-forwards', 'proxy-authorization',
      'referer', 'retry-after', 'user-agent'
    ];

    /**
     * Parse headers into an object
     *
     * ```
     * Date: Wed, 27 Aug 2014 08:58:49 GMT
     * Content-Type: application/json
     * Connection: keep-alive
     * Transfer-Encoding: chunked
     * ```
     *
     * @param {String} headers Headers needing to be parsed
     * @returns {Object} Headers parsed into an object
     */
    var parseHeaders = function parseHeaders(headers) {
      var parsed = {};
      var key;
      var val;
      var i;

      if (!headers) { return parsed; }

      utils.forEach(headers.split('\n'), function parser(line) {
        i = line.indexOf(':');
        key = utils.trim(line.substr(0, i)).toLowerCase();
        val = utils.trim(line.substr(i + 1));

        if (key) {
          if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
            return;
          }
          if (key === 'set-cookie') {
            parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
          } else {
            parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
          }
        }
      });

      return parsed;
    };

    var isURLSameOrigin = (
      utils.isStandardBrowserEnv() ?

      // Standard browser envs have full support of the APIs needed to test
      // whether the request URL is of the same origin as current location.
        (function standardBrowserEnv() {
          var msie = /(msie|trident)/i.test(navigator.userAgent);
          var urlParsingNode = document.createElement('a');
          var originURL;

          /**
        * Parse a URL to discover it's components
        *
        * @param {String} url The URL to be parsed
        * @returns {Object}
        */
          function resolveURL(url) {
            var href = url;

            if (msie) {
            // IE needs attribute set twice to normalize properties
              urlParsingNode.setAttribute('href', href);
              href = urlParsingNode.href;
            }

            urlParsingNode.setAttribute('href', href);

            // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
            return {
              href: urlParsingNode.href,
              protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
              host: urlParsingNode.host,
              search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
              hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
              hostname: urlParsingNode.hostname,
              port: urlParsingNode.port,
              pathname: (urlParsingNode.pathname.charAt(0) === '/') ?
                urlParsingNode.pathname :
                '/' + urlParsingNode.pathname
            };
          }

          originURL = resolveURL(window.location.href);

          /**
        * Determine if a URL shares the same origin as the current location
        *
        * @param {String} requestURL The URL to test
        * @returns {boolean} True if URL shares the same origin, otherwise false
        */
          return function isURLSameOrigin(requestURL) {
            var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;
            return (parsed.protocol === originURL.protocol &&
                parsed.host === originURL.host);
          };
        })() :

      // Non standard browser envs (web workers, react-native) lack needed support.
        (function nonStandardBrowserEnv() {
          return function isURLSameOrigin() {
            return true;
          };
        })()
    );

    var xhr = function xhrAdapter(config) {
      return new Promise(function dispatchXhrRequest(resolve, reject) {
        var requestData = config.data;
        var requestHeaders = config.headers;

        if (utils.isFormData(requestData)) {
          delete requestHeaders['Content-Type']; // Let the browser set it
        }

        if (
          (utils.isBlob(requestData) || utils.isFile(requestData)) &&
          requestData.type
        ) {
          delete requestHeaders['Content-Type']; // Let the browser set it
        }

        var request = new XMLHttpRequest();

        // HTTP basic authentication
        if (config.auth) {
          var username = config.auth.username || '';
          var password = unescape(encodeURIComponent(config.auth.password)) || '';
          requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
        }

        var fullPath = buildFullPath(config.baseURL, config.url);
        request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);

        // Set the request timeout in MS
        request.timeout = config.timeout;

        // Listen for ready state
        request.onreadystatechange = function handleLoad() {
          if (!request || request.readyState !== 4) {
            return;
          }

          // The request errored out and we didn't get a response, this will be
          // handled by onerror instead
          // With one exception: request that using file: protocol, most browsers
          // will return status as 0 even though it's a successful request
          if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
            return;
          }

          // Prepare the response
          var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
          var responseData = !config.responseType || config.responseType === 'text' ? request.responseText : request.response;
          var response = {
            data: responseData,
            status: request.status,
            statusText: request.statusText,
            headers: responseHeaders,
            config: config,
            request: request
          };

          settle(resolve, reject, response);

          // Clean up request
          request = null;
        };

        // Handle browser request cancellation (as opposed to a manual cancellation)
        request.onabort = function handleAbort() {
          if (!request) {
            return;
          }

          reject(createError('Request aborted', config, 'ECONNABORTED', request));

          // Clean up request
          request = null;
        };

        // Handle low level network errors
        request.onerror = function handleError() {
          // Real errors are hidden from us by the browser
          // onerror should only fire if it's a network error
          reject(createError('Network Error', config, null, request));

          // Clean up request
          request = null;
        };

        // Handle timeout
        request.ontimeout = function handleTimeout() {
          var timeoutErrorMessage = 'timeout of ' + config.timeout + 'ms exceeded';
          if (config.timeoutErrorMessage) {
            timeoutErrorMessage = config.timeoutErrorMessage;
          }
          reject(createError(timeoutErrorMessage, config, 'ECONNABORTED',
            request));

          // Clean up request
          request = null;
        };

        // Add xsrf header
        // This is only done if running in a standard browser environment.
        // Specifically not if we're in a web worker, or react-native.
        if (utils.isStandardBrowserEnv()) {
          // Add xsrf header
          var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ?
            cookies.read(config.xsrfCookieName) :
            undefined;

          if (xsrfValue) {
            requestHeaders[config.xsrfHeaderName] = xsrfValue;
          }
        }

        // Add headers to the request
        if ('setRequestHeader' in request) {
          utils.forEach(requestHeaders, function setRequestHeader(val, key) {
            if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
              // Remove Content-Type if data is undefined
              delete requestHeaders[key];
            } else {
              // Otherwise add header to the request
              request.setRequestHeader(key, val);
            }
          });
        }

        // Add withCredentials to request if needed
        if (!utils.isUndefined(config.withCredentials)) {
          request.withCredentials = !!config.withCredentials;
        }

        // Add responseType to request if needed
        if (config.responseType) {
          try {
            request.responseType = config.responseType;
          } catch (e) {
            // Expected DOMException thrown by browsers not compatible XMLHttpRequest Level 2.
            // But, this can be suppressed for 'json' type as it can be parsed by default 'transformResponse' function.
            if (config.responseType !== 'json') {
              throw e;
            }
          }
        }

        // Handle progress if needed
        if (typeof config.onDownloadProgress === 'function') {
          request.addEventListener('progress', config.onDownloadProgress);
        }

        // Not all browsers support upload events
        if (typeof config.onUploadProgress === 'function' && request.upload) {
          request.upload.addEventListener('progress', config.onUploadProgress);
        }

        if (config.cancelToken) {
          // Handle cancellation
          config.cancelToken.promise.then(function onCanceled(cancel) {
            if (!request) {
              return;
            }

            request.abort();
            reject(cancel);
            // Clean up request
            request = null;
          });
        }

        if (!requestData) {
          requestData = null;
        }

        // Send the request
        request.send(requestData);
      });
    };

    var DEFAULT_CONTENT_TYPE = {
      'Content-Type': 'application/x-www-form-urlencoded'
    };

    function setContentTypeIfUnset(headers, value) {
      if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
        headers['Content-Type'] = value;
      }
    }

    function getDefaultAdapter() {
      var adapter;
      if (typeof XMLHttpRequest !== 'undefined') {
        // For browsers use XHR adapter
        adapter = xhr;
      } else if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {
        // For node use HTTP adapter
        adapter = xhr;
      }
      return adapter;
    }

    var defaults = {
      adapter: getDefaultAdapter(),

      transformRequest: [function transformRequest(data, headers) {
        normalizeHeaderName(headers, 'Accept');
        normalizeHeaderName(headers, 'Content-Type');
        if (utils.isFormData(data) ||
          utils.isArrayBuffer(data) ||
          utils.isBuffer(data) ||
          utils.isStream(data) ||
          utils.isFile(data) ||
          utils.isBlob(data)
        ) {
          return data;
        }
        if (utils.isArrayBufferView(data)) {
          return data.buffer;
        }
        if (utils.isURLSearchParams(data)) {
          setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
          return data.toString();
        }
        if (utils.isObject(data)) {
          setContentTypeIfUnset(headers, 'application/json;charset=utf-8');
          return JSON.stringify(data);
        }
        return data;
      }],

      transformResponse: [function transformResponse(data) {
        /*eslint no-param-reassign:0*/
        if (typeof data === 'string') {
          try {
            data = JSON.parse(data);
          } catch (e) { /* Ignore */ }
        }
        return data;
      }],

      /**
       * A timeout in milliseconds to abort a request. If set to 0 (default) a
       * timeout is not created.
       */
      timeout: 0,

      xsrfCookieName: 'XSRF-TOKEN',
      xsrfHeaderName: 'X-XSRF-TOKEN',

      maxContentLength: -1,
      maxBodyLength: -1,

      validateStatus: function validateStatus(status) {
        return status >= 200 && status < 300;
      }
    };

    defaults.headers = {
      common: {
        'Accept': 'application/json, text/plain, */*'
      }
    };

    utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
      defaults.headers[method] = {};
    });

    utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
      defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
    });

    var defaults_1 = defaults;

    /**
     * Throws a `Cancel` if cancellation has been requested.
     */
    function throwIfCancellationRequested(config) {
      if (config.cancelToken) {
        config.cancelToken.throwIfRequested();
      }
    }

    /**
     * Dispatch a request to the server using the configured adapter.
     *
     * @param {object} config The config that is to be used for the request
     * @returns {Promise} The Promise to be fulfilled
     */
    var dispatchRequest = function dispatchRequest(config) {
      throwIfCancellationRequested(config);

      // Ensure headers exist
      config.headers = config.headers || {};

      // Transform request data
      config.data = transformData(
        config.data,
        config.headers,
        config.transformRequest
      );

      // Flatten headers
      config.headers = utils.merge(
        config.headers.common || {},
        config.headers[config.method] || {},
        config.headers
      );

      utils.forEach(
        ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
        function cleanHeaderConfig(method) {
          delete config.headers[method];
        }
      );

      var adapter = config.adapter || defaults_1.adapter;

      return adapter(config).then(function onAdapterResolution(response) {
        throwIfCancellationRequested(config);

        // Transform response data
        response.data = transformData(
          response.data,
          response.headers,
          config.transformResponse
        );

        return response;
      }, function onAdapterRejection(reason) {
        if (!isCancel(reason)) {
          throwIfCancellationRequested(config);

          // Transform response data
          if (reason && reason.response) {
            reason.response.data = transformData(
              reason.response.data,
              reason.response.headers,
              config.transformResponse
            );
          }
        }

        return Promise.reject(reason);
      });
    };

    /**
     * Config-specific merge-function which creates a new config-object
     * by merging two configuration objects together.
     *
     * @param {Object} config1
     * @param {Object} config2
     * @returns {Object} New object resulting from merging config2 to config1
     */
    var mergeConfig = function mergeConfig(config1, config2) {
      // eslint-disable-next-line no-param-reassign
      config2 = config2 || {};
      var config = {};

      var valueFromConfig2Keys = ['url', 'method', 'data'];
      var mergeDeepPropertiesKeys = ['headers', 'auth', 'proxy', 'params'];
      var defaultToConfig2Keys = [
        'baseURL', 'transformRequest', 'transformResponse', 'paramsSerializer',
        'timeout', 'timeoutMessage', 'withCredentials', 'adapter', 'responseType', 'xsrfCookieName',
        'xsrfHeaderName', 'onUploadProgress', 'onDownloadProgress', 'decompress',
        'maxContentLength', 'maxBodyLength', 'maxRedirects', 'transport', 'httpAgent',
        'httpsAgent', 'cancelToken', 'socketPath', 'responseEncoding'
      ];
      var directMergeKeys = ['validateStatus'];

      function getMergedValue(target, source) {
        if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
          return utils.merge(target, source);
        } else if (utils.isPlainObject(source)) {
          return utils.merge({}, source);
        } else if (utils.isArray(source)) {
          return source.slice();
        }
        return source;
      }

      function mergeDeepProperties(prop) {
        if (!utils.isUndefined(config2[prop])) {
          config[prop] = getMergedValue(config1[prop], config2[prop]);
        } else if (!utils.isUndefined(config1[prop])) {
          config[prop] = getMergedValue(undefined, config1[prop]);
        }
      }

      utils.forEach(valueFromConfig2Keys, function valueFromConfig2(prop) {
        if (!utils.isUndefined(config2[prop])) {
          config[prop] = getMergedValue(undefined, config2[prop]);
        }
      });

      utils.forEach(mergeDeepPropertiesKeys, mergeDeepProperties);

      utils.forEach(defaultToConfig2Keys, function defaultToConfig2(prop) {
        if (!utils.isUndefined(config2[prop])) {
          config[prop] = getMergedValue(undefined, config2[prop]);
        } else if (!utils.isUndefined(config1[prop])) {
          config[prop] = getMergedValue(undefined, config1[prop]);
        }
      });

      utils.forEach(directMergeKeys, function merge(prop) {
        if (prop in config2) {
          config[prop] = getMergedValue(config1[prop], config2[prop]);
        } else if (prop in config1) {
          config[prop] = getMergedValue(undefined, config1[prop]);
        }
      });

      var axiosKeys = valueFromConfig2Keys
        .concat(mergeDeepPropertiesKeys)
        .concat(defaultToConfig2Keys)
        .concat(directMergeKeys);

      var otherKeys = Object
        .keys(config1)
        .concat(Object.keys(config2))
        .filter(function filterAxiosKeys(key) {
          return axiosKeys.indexOf(key) === -1;
        });

      utils.forEach(otherKeys, mergeDeepProperties);

      return config;
    };

    /**
     * Create a new instance of Axios
     *
     * @param {Object} instanceConfig The default config for the instance
     */
    function Axios(instanceConfig) {
      this.defaults = instanceConfig;
      this.interceptors = {
        request: new InterceptorManager_1(),
        response: new InterceptorManager_1()
      };
    }

    /**
     * Dispatch a request
     *
     * @param {Object} config The config specific for this request (merged with this.defaults)
     */
    Axios.prototype.request = function request(config) {
      /*eslint no-param-reassign:0*/
      // Allow for axios('example/url'[, config]) a la fetch API
      if (typeof config === 'string') {
        config = arguments[1] || {};
        config.url = arguments[0];
      } else {
        config = config || {};
      }

      config = mergeConfig(this.defaults, config);

      // Set config.method
      if (config.method) {
        config.method = config.method.toLowerCase();
      } else if (this.defaults.method) {
        config.method = this.defaults.method.toLowerCase();
      } else {
        config.method = 'get';
      }

      // Hook up interceptors middleware
      var chain = [dispatchRequest, undefined];
      var promise = Promise.resolve(config);

      this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
        chain.unshift(interceptor.fulfilled, interceptor.rejected);
      });

      this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
        chain.push(interceptor.fulfilled, interceptor.rejected);
      });

      while (chain.length) {
        promise = promise.then(chain.shift(), chain.shift());
      }

      return promise;
    };

    Axios.prototype.getUri = function getUri(config) {
      config = mergeConfig(this.defaults, config);
      return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\?/, '');
    };

    // Provide aliases for supported request methods
    utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
      /*eslint func-names:0*/
      Axios.prototype[method] = function(url, config) {
        return this.request(mergeConfig(config || {}, {
          method: method,
          url: url
        }));
      };
    });

    utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
      /*eslint func-names:0*/
      Axios.prototype[method] = function(url, data, config) {
        return this.request(mergeConfig(config || {}, {
          method: method,
          url: url,
          data: data
        }));
      };
    });

    var Axios_1 = Axios;

    /**
     * A `Cancel` is an object that is thrown when an operation is canceled.
     *
     * @class
     * @param {string=} message The message.
     */
    function Cancel(message) {
      this.message = message;
    }

    Cancel.prototype.toString = function toString() {
      return 'Cancel' + (this.message ? ': ' + this.message : '');
    };

    Cancel.prototype.__CANCEL__ = true;

    var Cancel_1 = Cancel;

    /**
     * A `CancelToken` is an object that can be used to request cancellation of an operation.
     *
     * @class
     * @param {Function} executor The executor function.
     */
    function CancelToken(executor) {
      if (typeof executor !== 'function') {
        throw new TypeError('executor must be a function.');
      }

      var resolvePromise;
      this.promise = new Promise(function promiseExecutor(resolve) {
        resolvePromise = resolve;
      });

      var token = this;
      executor(function cancel(message) {
        if (token.reason) {
          // Cancellation has already been requested
          return;
        }

        token.reason = new Cancel_1(message);
        resolvePromise(token.reason);
      });
    }

    /**
     * Throws a `Cancel` if cancellation has been requested.
     */
    CancelToken.prototype.throwIfRequested = function throwIfRequested() {
      if (this.reason) {
        throw this.reason;
      }
    };

    /**
     * Returns an object that contains a new `CancelToken` and a function that, when called,
     * cancels the `CancelToken`.
     */
    CancelToken.source = function source() {
      var cancel;
      var token = new CancelToken(function executor(c) {
        cancel = c;
      });
      return {
        token: token,
        cancel: cancel
      };
    };

    var CancelToken_1 = CancelToken;

    /**
     * Syntactic sugar for invoking a function and expanding an array for arguments.
     *
     * Common use case would be to use `Function.prototype.apply`.
     *
     *  ```js
     *  function f(x, y, z) {}
     *  var args = [1, 2, 3];
     *  f.apply(null, args);
     *  ```
     *
     * With `spread` this example can be re-written.
     *
     *  ```js
     *  spread(function(x, y, z) {})([1, 2, 3]);
     *  ```
     *
     * @param {Function} callback
     * @returns {Function}
     */
    var spread = function spread(callback) {
      return function wrap(arr) {
        return callback.apply(null, arr);
      };
    };

    /**
     * Create an instance of Axios
     *
     * @param {Object} defaultConfig The default config for the instance
     * @return {Axios} A new instance of Axios
     */
    function createInstance(defaultConfig) {
      var context = new Axios_1(defaultConfig);
      var instance = bind$1(Axios_1.prototype.request, context);

      // Copy axios.prototype to instance
      utils.extend(instance, Axios_1.prototype, context);

      // Copy context to instance
      utils.extend(instance, context);

      return instance;
    }

    // Create the default instance to be exported
    var axios = createInstance(defaults_1);

    // Expose Axios class to allow class inheritance
    axios.Axios = Axios_1;

    // Factory for creating new instances
    axios.create = function create(instanceConfig) {
      return createInstance(mergeConfig(axios.defaults, instanceConfig));
    };

    // Expose Cancel & CancelToken
    axios.Cancel = Cancel_1;
    axios.CancelToken = CancelToken_1;
    axios.isCancel = isCancel;

    // Expose all/spread
    axios.all = function all(promises) {
      return Promise.all(promises);
    };
    axios.spread = spread;

    var axios_1 = axios;

    // Allow use of default import syntax in TypeScript
    var _default = axios;
    axios_1.default = _default;

    var axios$1 = axios_1;

    axios$1.maxRedirects = 0;

    axios$1.interceptors.response.use(function (response) {
        // Any status code that lie within the range of 2xx cause this function to trigger
        // Do something with response data
        if(response && response.data && response.data.redirect){ //??quitado
            window.location.href = response.data.redirect;
            throw new Error("Redirigido")
        }
        // if(response?.data?.redirect || false){ //??quitado
        //     window.location.href = response.data.redirect
        //     throw new Error("Redirigido")
        // }
        if(response.request.responseURL && response.request.responseURL.indexOf("/Domad") != -1) {
            window.location = response.request.responseURL;
        }
        if(response.data.redirect) window.location = response.data.redirect;
        return response
      }, function (error) {
          
            // if(error?.response?.data.redirect){
            if(error.response && error.response.data && error.response.data.redirect){
                console.log(JSON.stringify(error.response));
                window.location = error.response.data.redirect;
                return Promise.resolve();
            }
            return Promise.reject(error);
      });

      axios$1.interceptors.request.use(function (config) {
        // Do something before request is sent
        config.headers["RequestVerificationToken"] = window.token;
        return config;
      }, function (error) {
        // Do something with request error
        return Promise.reject(error);
      });

    class RChanClient {
        // Acciones
        static crearHilo(titulo, categoria, contenido, archivo, link="", captcha="", encuesta=[], mostrarNombre=false, mostrarRango=false) {
            let form = new FormData();
            form.append("Titulo", titulo);
            form.append("CategoriaId", categoria);
            form.append("Contenido", contenido);
            form.append("Archivo", archivo);
            form.append("Link", link);
            form.append("captcha", captcha);
            form.append("encuesta", JSON.stringify(encuesta));
            if(mostrarNombre || mostrarRango) {
                form.append('mostrarNombre', mostrarNombre);
                form.append('mostrarRango', mostrarRango);
            }
            return axios$1.post("/api/Hilo/Crear", form)
        }

        static crearComentario(hiloId, contenido, archivo = null, link="", captcha="", mostrarNombre=false, mostrarRango=false) {
            let form = new FormData();
            form.append('hiloId', hiloId);
            form.append('contenido', contenido);
            form.append('archivo', archivo);
            form.append("Link", link);
            form.append('captcha', captcha);
            if(mostrarNombre || mostrarRango) {
                form.append('mostrarNombre', mostrarNombre);
                form.append('mostrarRango', mostrarRango);
            }
            return axios$1.post('/api/Comentario/Crear', form)
        }

        static registrase(nick, contraseña, captcha, codigoDeInvitacion="") {
            return axios$1.post('/api/Usuario/Registro', {
                nick,
                contraseña,
                captcha,
                codigo: codigoDeInvitacion,
            })
        }

        static restaurarSesion(token) {
            return axios$1.post('/api/Usuario/RestaurarSesion', {
                token
            })
        }
        static inicio(captcha, codigoDeInvitacion="") {
            return axios$1.post('/api/Usuario/Inicio', {
                captcha,
                codigo: codigoDeInvitacion,
            })
        }

        static logearse(nick, contraseña) {
            return axios$1.post('/api/Usuario/Login', {
                nick,
                contraseña
            })
        }
        static deslogearse() {
            return axios$1.post('/logout')
        }
        static agregar(accion, id) {
            return axios$1.post('/api/Hilo/Agregar', {
                accion, // favoritos | seguidos | ocultos
                hiloId: id
            })
        }
        static limpiarNotificaciones() {
            return axios$1.post("/api/Notificacion/Limpiar")
        }

        static añadirRol(nick, role) {
            return axios$1.post("/api/Administracion/AñadirRol", {
                username: nick,
                role
            })
        }

        static removerRol(nick, role) {
            return axios$1.post("/api/Administracion/RemoverRol", {
                username: nick,
                role
            })
        }

        static añadirSticky(hiloId, global, importancia) {
            return axios$1.post("/api/Moderacion/AñadirSticky", {
                hiloId,
                global,
                importancia: Number(importancia),
            })
        }
        static borrarHilos(ids, borrarMedia = false) {
            return axios$1.post("/api/Moderacion/BorrarHilo", {
                ids,
                borrarMedia
            })
        }
        static cambiarCategoria(hiloId, categoriaId) {
            return axios$1.post("/api/Moderacion/CambiarCategoria", {
                hiloId,
                categoriaId,
            })
        }

        static ActualizarConfiguracion(config) {
            return axios$1.post("/api/Administracion/ActualizarConfiguracion", config)
        }

        static Denunciar(tipo, hiloId, motivo, aclaracion, comentarioId) {
            return axios$1.post("/api/Hilo/Denunciar", {
                tipo,
                hiloId,
                motivo,
                aclaracion,
                comentarioId
            })
        }
        static banear(motivo, aclaracion, duracion, usuarioId, hiloId="", comentarioId="", eliminarElemento=true, eliminarAdjunto=false, desaparecer=false) {
            return axios$1.post("/api/Moderacion/Banear", {
                motivo,
                aclaracion,
                duracion,
                eliminarElemento,
                eliminarAdjunto,
                hiloId,
                comentarioId,
                desaparecer,
            })
        }

        static cargarMasHilos(ultimoBump, categorias){
            return axios$1.get('api/Hilo/CargarMas', {
                params:{
                    ultimoBump,
                    categorias: categorias.join(",")
                }
            })
        }
        //Paginas
        static index(){
            return axios$1.get("/")
        }
        static hilo(id){
            return axios$1.get(`/Hilo/${id}`)
        }
        static favoritos(id){
            return axios$1.get(`/Hilo/Favoritos`)
        }

        //Denuncias
        static rechazarDenuncia(denunciaId)
        {
            return axios$1.post(`/api/Moderacion/RechazarDenuncia/${denunciaId}`)
        }

        static eliminarComentarios(ids, borrarMedia = false)
        {
            return axios$1.post(`/api/Moderacion/EliminarComentarios`, {
                ids,
                borrarMedia
            })
        }

        static removerBan(id)
        {
            return axios$1.post(`/api/Moderacion/RemoverBan/${id}`)
        }
        
        static restaurarRoz(id)
        {
            return axios$1.post(`/api/Moderacion/RestaurarHilo/${id}`)
        }
        static restaurarComentario(id)
        {
            return axios$1.post(`/api/Moderacion/RestaurarComentario/${id}`)
        }
        static generarNuevoLinkDeInvitacion()
        {
            return axios$1.post(`/api/Administracion/GenerarNuevoLinkDeInvitacion`)
        }
        static eliminarMedias(ids)
        {
            return axios$1.post(`/api/Moderacion/EliminarMedia`, ids)
        }
        static eliminarMedia(mediaId, eliminarElementos=true)
        {
            return axios$1.post(`/api/Moderacion/EliminarMedia`, {
                mediaId,
                eliminarElementos,
            })
        }
        static limpiarRozesViejos()
        {
            return axios$1.post(`/api/Administracion/LimpiarRozesViejos`)
        }

        static buscar(cadenaDeBusqueda) {
            return axios$1.post(`/api/Hilo/Buscar?busqueda=${cadenaDeBusqueda}`)
        }
        static votarEncuesta(hiloId, opcion) {
            return axios$1.post(`/api/Hilo/VotarEncuesta`, {hiloId, opcion})
        }

    }

    class Enum {
        static aString(rango) 
        {
            let keys = Object.keys(this);
            let string = "";
            keys.forEach(k => {
                if(this[k] == rango) string = k;
            });
            return  string
        }
    }
    class HiloEstado {
        static normal = 0
        static archivado = 1
        static eliminado = 2
    }
    class ComentarioEstado {
        static normal = 0
        static eliminado = 1
    }

    class MotivoDenuncia  extends Enum
    {
        static CategoriaIncorrecta = 0
        static Spam = 1
        static Doxxeo = 2
        static CoentenidoIlegal = 3
        static Gore = 4
        static MaltratoAnimal = 5
    }

    class EstadoDenuncia
    {
        static Aceptada = 0
        static Rechazada = 1
        static NoRevisada = 2
    }

    class CreacionRango 
    {
        static Anon = 0
        static Janitor = 1
        static Mod = 2
        static Admin = 3

        static aString(rango) 
        {
            let keys = Object.keys(CreacionRango);
            let string = "";
            keys.forEach(k => {
                if(CreacionRango[k] == rango) string = k;
            });
            return  string
        }
    }
    class TipoAccion 
    {
        static ComentarioBorrado = 0
        static HiloBorrado = 1
        static CategoriaCambiada = 2
        static DenunciaRechazada = 3
        static UsuarioBaneado = 4
        static UsuarioDesbaneado = 5
        static ComentarioRestaurado = 6
        static HiloRestaurado = 7

        static aString(rango) 
        {
            let keys = Object.keys(TipoAccion);
            let string = "";
            keys.forEach(k => {
                if(TipoAccion[k] == rango) string = k;
            });
            return  string
        }
    }

    /* src\components\Dialogos\DialogoReporte.svelte generated by Svelte v3.29.0 */

    const { Object: Object_1$1 } = globals;
    const file$5 = "src\\components\\Dialogos\\DialogoReporte.svelte";

    function get_each_context$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[13] = list[i];
    	child_ctx[15] = i;
    	return child_ctx;
    }

    const get_default_slot_changes = dirty => ({});
    const get_default_slot_context = ctx => ({ slot: "activador" });

    // (23:4) <slot slot="activador">        </slot>      <div slot="body">          <p>Reportar el {tipoString}
    function create_activador_slot(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[7].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[12], get_default_slot_context);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 4096) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[12], dirty, get_default_slot_changes, get_default_slot_context);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_activador_slot.name,
    		type: "slot",
    		source: "(23:4) <slot slot=\\\"activador\\\">        </slot>      <div slot=\\\"body\\\">          <p>Reportar el {tipoString}",
    		ctx
    	});

    	return block;
    }

    // (33:12) {#each Object.keys(MotivoDenuncia) as k, i}
    function create_each_block$1(ctx) {
    	let option;
    	let t_value = /*k*/ ctx[13] + "";
    	let t;
    	let option_value_value;

    	const block = {
    		c: function create() {
    			option = element("option");
    			t = text(t_value);
    			option.__value = option_value_value = MotivoDenuncia[/*k*/ ctx[13]];
    			option.value = option.__value;
    			add_location(option, file$5, 33, 16, 1191);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, option, anchor);
    			append_dev(option, t);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(option);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$1.name,
    		type: "each",
    		source: "(33:12) {#each Object.keys(MotivoDenuncia) as k, i}",
    		ctx
    	});

    	return block;
    }

    // (26:4) <div slot="body">
    function create_body_slot(ctx) {
    	let div;
    	let p;
    	let t0;
    	let t1;
    	let t2;

    	let t3_value = (/*tipoString*/ ctx[6] == "hilo"
    	? /*hiloId*/ ctx[2]
    	: /*comentarioId*/ ctx[1]) + "";

    	let t3;
    	let t4;
    	let select;
    	let option;
    	let t6;
    	let textarea;
    	let mounted;
    	let dispose;
    	let each_value = Object.keys(MotivoDenuncia);
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			p = element("p");
    			t0 = text("Reportar el ");
    			t1 = text(/*tipoString*/ ctx[6]);
    			t2 = space();
    			t3 = text(t3_value);
    			t4 = space();
    			select = element("select");
    			option = element("option");
    			option.textContent = "Motivo";

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t6 = space();
    			textarea = element("textarea");
    			add_location(p, file$5, 26, 8, 760);
    			option.__value = "-1";
    			option.value = option.__value;
    			option.selected = "selected";
    			option.disabled = "disabled";
    			add_location(option, file$5, 28, 12, 906);
    			attr_dev(select, "name", "motivo");
    			if (/*motivo*/ ctx[3] === void 0) add_render_callback(() => /*select_change_handler*/ ctx[8].call(select));
    			add_location(select, file$5, 27, 8, 848);
    			attr_dev(textarea, "placeholder", "Aclaracion");
    			add_location(textarea, file$5, 37, 8, 1289);
    			attr_dev(div, "slot", "body");
    			add_location(div, file$5, 25, 4, 733);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, p);
    			append_dev(p, t0);
    			append_dev(p, t1);
    			append_dev(p, t2);
    			append_dev(p, t3);
    			append_dev(div, t4);
    			append_dev(div, select);
    			append_dev(select, option);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(select, null);
    			}

    			select_option(select, /*motivo*/ ctx[3]);
    			append_dev(div, t6);
    			append_dev(div, textarea);
    			set_input_value(textarea, /*aclaracion*/ ctx[4]);

    			if (!mounted) {
    				dispose = [
    					listen_dev(select, "change", /*select_change_handler*/ ctx[8]),
    					listen_dev(textarea, "input", /*textarea_input_handler*/ ctx[9])
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*tipoString*/ 64) set_data_dev(t1, /*tipoString*/ ctx[6]);

    			if (dirty & /*tipoString, hiloId, comentarioId*/ 70 && t3_value !== (t3_value = (/*tipoString*/ ctx[6] == "hilo"
    			? /*hiloId*/ ctx[2]
    			: /*comentarioId*/ ctx[1]) + "")) set_data_dev(t3, t3_value);

    			if (dirty & /*MotivoDenuncia, Object*/ 0) {
    				each_value = Object.keys(MotivoDenuncia);
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$1(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$1(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(select, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*motivo, MotivoDenuncia, Object*/ 8) {
    				select_option(select, /*motivo*/ ctx[3]);
    			}

    			if (dirty & /*aclaracion*/ 16) {
    				set_input_value(textarea, /*aclaracion*/ ctx[4]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_body_slot.name,
    		type: "slot",
    		source: "(26:4) <div slot=\\\"body\\\">",
    		ctx
    	});

    	return block;
    }

    // (18:0) <Dialogo       bind:visible={visible}       textoActivador="Reportar {tipoString}"       titulo="Reportar {tipoString}"      accion={() => RChanClient.Denunciar(tipo, hiloId, motivo, aclaracion, comentarioId)}>
    function create_default_slot$2(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = space();
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$2.name,
    		type: "slot",
    		source: "(18:0) <Dialogo       bind:visible={visible}       textoActivador=\\\"Reportar {tipoString}\\\"       titulo=\\\"Reportar {tipoString}\\\"      accion={() => RChanClient.Denunciar(tipo, hiloId, motivo, aclaracion, comentarioId)}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$5(ctx) {
    	let dialogo;
    	let updating_visible;
    	let current;

    	function dialogo_visible_binding(value) {
    		/*dialogo_visible_binding*/ ctx[11].call(null, value);
    	}

    	let dialogo_props = {
    		textoActivador: "Reportar " + /*tipoString*/ ctx[6],
    		titulo: "Reportar " + /*tipoString*/ ctx[6],
    		accion: /*func*/ ctx[10],
    		$$slots: {
    			default: [create_default_slot$2],
    			body: [create_body_slot],
    			activador: [create_activador_slot]
    		},
    		$$scope: { ctx }
    	};

    	if (/*visible*/ ctx[0] !== void 0) {
    		dialogo_props.visible = /*visible*/ ctx[0];
    	}

    	dialogo = new Dialogo({ props: dialogo_props, $$inline: true });
    	binding_callbacks.push(() => bind(dialogo, "visible", dialogo_visible_binding));

    	const block = {
    		c: function create() {
    			create_component(dialogo.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(dialogo, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const dialogo_changes = {};
    			if (dirty & /*tipoString*/ 64) dialogo_changes.textoActivador = "Reportar " + /*tipoString*/ ctx[6];
    			if (dirty & /*tipoString*/ 64) dialogo_changes.titulo = "Reportar " + /*tipoString*/ ctx[6];
    			if (dirty & /*tipo, hiloId, motivo, aclaracion, comentarioId*/ 62) dialogo_changes.accion = /*func*/ ctx[10];

    			if (dirty & /*$$scope, aclaracion, motivo, tipoString, hiloId, comentarioId*/ 4190) {
    				dialogo_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_visible && dirty & /*visible*/ 1) {
    				updating_visible = true;
    				dialogo_changes.visible = /*visible*/ ctx[0];
    				add_flush_callback(() => updating_visible = false);
    			}

    			dialogo.$set(dialogo_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dialogo.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dialogo.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dialogo, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$5.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$5($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("DialogoReporte", slots, ['default']);
    	let { comentarioId = "" } = $$props;
    	let { hiloId = "" } = $$props;
    	let motivo = -1;
    	let aclaracion = "";
    	let { visible = false } = $$props;
    	const writable_props = ["comentarioId", "hiloId", "visible"];

    	Object_1$1.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<DialogoReporte> was created with unknown prop '${key}'`);
    	});

    	function select_change_handler() {
    		motivo = select_value(this);
    		$$invalidate(3, motivo);
    	}

    	function textarea_input_handler() {
    		aclaracion = this.value;
    		$$invalidate(4, aclaracion);
    	}

    	const func = () => RChanClient.Denunciar(tipo, hiloId, motivo, aclaracion, comentarioId);

    	function dialogo_visible_binding(value) {
    		visible = value;
    		$$invalidate(0, visible);
    	}

    	$$self.$$set = $$props => {
    		if ("comentarioId" in $$props) $$invalidate(1, comentarioId = $$props.comentarioId);
    		if ("hiloId" in $$props) $$invalidate(2, hiloId = $$props.hiloId);
    		if ("visible" in $$props) $$invalidate(0, visible = $$props.visible);
    		if ("$$scope" in $$props) $$invalidate(12, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		Dialogo,
    		globalStore,
    		RChanClient,
    		MotivoDenuncia,
    		comentarioId,
    		hiloId,
    		motivo,
    		aclaracion,
    		visible,
    		tipo,
    		tipoString
    	});

    	$$self.$inject_state = $$props => {
    		if ("comentarioId" in $$props) $$invalidate(1, comentarioId = $$props.comentarioId);
    		if ("hiloId" in $$props) $$invalidate(2, hiloId = $$props.hiloId);
    		if ("motivo" in $$props) $$invalidate(3, motivo = $$props.motivo);
    		if ("aclaracion" in $$props) $$invalidate(4, aclaracion = $$props.aclaracion);
    		if ("visible" in $$props) $$invalidate(0, visible = $$props.visible);
    		if ("tipo" in $$props) $$invalidate(5, tipo = $$props.tipo);
    		if ("tipoString" in $$props) $$invalidate(6, tipoString = $$props.tipoString);
    	};

    	let tipo;
    	let tipoString;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*comentarioId*/ 2) {
    			 $$invalidate(5, tipo = comentarioId == "" || !comentarioId ? 0 : 1);
    		}

    		if ($$self.$$.dirty & /*tipo*/ 32) {
    			 $$invalidate(6, tipoString = tipo == 0 ? "hilo" : "comentario");
    		}
    	};

    	return [
    		visible,
    		comentarioId,
    		hiloId,
    		motivo,
    		aclaracion,
    		tipo,
    		tipoString,
    		slots,
    		select_change_handler,
    		textarea_input_handler,
    		func,
    		dialogo_visible_binding,
    		$$scope
    	];
    }

    class DialogoReporte extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$5, create_fragment$5, safe_not_equal, { comentarioId: 1, hiloId: 2, visible: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "DialogoReporte",
    			options,
    			id: create_fragment$5.name
    		});
    	}

    	get comentarioId() {
    		throw new Error("<DialogoReporte>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set comentarioId(value) {
    		throw new Error("<DialogoReporte>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get hiloId() {
    		throw new Error("<DialogoReporte>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set hiloId(value) {
    		throw new Error("<DialogoReporte>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get visible() {
    		throw new Error("<DialogoReporte>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set visible(value) {
    		throw new Error("<DialogoReporte>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\components\Dialogos\DialogoBan.svelte generated by Svelte v3.29.0 */

    const { Object: Object_1$2 } = globals;
    const file$6 = "src\\components\\Dialogos\\DialogoBan.svelte";

    function get_each_context$2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[21] = list[i];
    	child_ctx[23] = i;
    	return child_ctx;
    }

    const get_default_slot_changes$1 = dirty => ({});
    const get_default_slot_context$1 = ctx => ({ slot: "activador" });

    // (32:4) <slot slot="activador">        </slot>      <div slot="body">          <div class="">              {#if hiloId}
    function create_activador_slot$1(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[11].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[19], get_default_slot_context$1);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 524288) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[19], dirty, get_default_slot_changes$1, get_default_slot_context$1);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_activador_slot$1.name,
    		type: "slot",
    		source: "(32:4) <slot slot=\\\"activador\\\">        </slot>      <div slot=\\\"body\\\">          <div class=\\\"\\\">              {#if hiloId}",
    		ctx
    	});

    	return block;
    }

    // (37:12) {#if hiloId}
    function create_if_block_2$1(ctx) {
    	let t0;
    	let t1;
    	let t2;
    	let t3;
    	let t4;
    	let t5;

    	const block = {
    		c: function create() {
    			t0 = text("Banear al usuario ");
    			t1 = text(/*usuarioId*/ ctx[3]);
    			t2 = text(" \r\n                por ");
    			t3 = text(/*hiloId*/ ctx[1]);
    			t4 = text("#");
    			t5 = text(/*comentarioId*/ ctx[2]);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, t4, anchor);
    			insert_dev(target, t5, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*usuarioId*/ 8) set_data_dev(t1, /*usuarioId*/ ctx[3]);
    			if (dirty & /*hiloId*/ 2) set_data_dev(t3, /*hiloId*/ ctx[1]);
    			if (dirty & /*comentarioId*/ 4) set_data_dev(t5, /*comentarioId*/ ctx[2]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(t4);
    			if (detaching) detach_dev(t5);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$1.name,
    		type: "if",
    		source: "(37:12) {#if hiloId}",
    		ctx
    	});

    	return block;
    }

    // (44:12) {#each Object.keys(MotivoDenuncia) as k, i}
    function create_each_block$2(ctx) {
    	let option;
    	let t_value = /*k*/ ctx[21] + "";
    	let t;
    	let option_value_value;

    	const block = {
    		c: function create() {
    			option = element("option");
    			t = text(t_value);
    			option.__value = option_value_value = MotivoDenuncia[/*k*/ ctx[21]];
    			option.value = option.__value;
    			add_location(option, file$6, 44, 16, 1289);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, option, anchor);
    			append_dev(option, t);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(option);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$2.name,
    		type: "each",
    		source: "(44:12) {#each Object.keys(MotivoDenuncia) as k, i}",
    		ctx
    	});

    	return block;
    }

    // (64:8) {#if comentarioId || hiloId}
    function create_if_block_1$2(ctx) {
    	let checkbox0;
    	let updating_checked;
    	let t;
    	let checkbox1;
    	let updating_checked_1;
    	let current;

    	function checkbox0_checked_binding(value) {
    		/*checkbox0_checked_binding*/ ctx[15].call(null, value);
    	}

    	let checkbox0_props = {
    		style: "padding: 0 8px",
    		right: true,
    		$$slots: { default: [create_default_slot_3$2] },
    		$$scope: { ctx }
    	};

    	if (/*eliminarElemento*/ ctx[7] !== void 0) {
    		checkbox0_props.checked = /*eliminarElemento*/ ctx[7];
    	}

    	checkbox0 = new Ne({ props: checkbox0_props, $$inline: true });
    	binding_callbacks.push(() => bind(checkbox0, "checked", checkbox0_checked_binding));

    	function checkbox1_checked_binding(value) {
    		/*checkbox1_checked_binding*/ ctx[16].call(null, value);
    	}

    	let checkbox1_props = {
    		style: "padding: 0 8px",
    		title: "Borra la imagen del servidor, usar en caso de cp",
    		right: true,
    		$$slots: { default: [create_default_slot_2$2] },
    		$$scope: { ctx }
    	};

    	if (/*eliminarAdjunto*/ ctx[8] !== void 0) {
    		checkbox1_props.checked = /*eliminarAdjunto*/ ctx[8];
    	}

    	checkbox1 = new Ne({ props: checkbox1_props, $$inline: true });
    	binding_callbacks.push(() => bind(checkbox1, "checked", checkbox1_checked_binding));

    	const block = {
    		c: function create() {
    			create_component(checkbox0.$$.fragment);
    			t = space();
    			create_component(checkbox1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(checkbox0, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(checkbox1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const checkbox0_changes = {};

    			if (dirty & /*$$scope*/ 524288) {
    				checkbox0_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_checked && dirty & /*eliminarElemento*/ 128) {
    				updating_checked = true;
    				checkbox0_changes.checked = /*eliminarElemento*/ ctx[7];
    				add_flush_callback(() => updating_checked = false);
    			}

    			checkbox0.$set(checkbox0_changes);
    			const checkbox1_changes = {};

    			if (dirty & /*$$scope*/ 524288) {
    				checkbox1_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_checked_1 && dirty & /*eliminarAdjunto*/ 256) {
    				updating_checked_1 = true;
    				checkbox1_changes.checked = /*eliminarAdjunto*/ ctx[8];
    				add_flush_callback(() => updating_checked_1 = false);
    			}

    			checkbox1.$set(checkbox1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(checkbox0.$$.fragment, local);
    			transition_in(checkbox1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(checkbox0.$$.fragment, local);
    			transition_out(checkbox1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(checkbox0, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(checkbox1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$2.name,
    		type: "if",
    		source: "(64:8) {#if comentarioId || hiloId}",
    		ctx
    	});

    	return block;
    }

    // (65:12) <Checkbox style="padding: 0 8px" bind:checked={eliminarElemento} right>
    function create_default_slot_3$2(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Eliminar elemento(hilo/comentario)");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$2.name,
    		type: "slot",
    		source: "(65:12) <Checkbox style=\\\"padding: 0 8px\\\" bind:checked={eliminarElemento} right>",
    		ctx
    	});

    	return block;
    }

    // (66:12) <Checkbox style="padding: 0 8px" title="Borra la imagen del servidor, usar en caso de cp" bind:checked={eliminarAdjunto} right>
    function create_default_slot_2$2(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Eliminar adjunto(imagen/video)");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$2.name,
    		type: "slot",
    		source: "(66:12) <Checkbox style=\\\"padding: 0 8px\\\" title=\\\"Borra la imagen del servidor, usar en caso de cp\\\" bind:checked={eliminarAdjunto} right>",
    		ctx
    	});

    	return block;
    }

    // (68:8) {#if duracion > 5000 }
    function create_if_block$4(ctx) {
    	let checkbox;
    	let updating_checked;
    	let current;

    	function checkbox_checked_binding(value) {
    		/*checkbox_checked_binding*/ ctx[17].call(null, value);
    	}

    	let checkbox_props = {
    		style: "padding: 0 8px",
    		title: "Borra todos los rozes y comentarios del usuario",
    		right: true,
    		$$slots: { default: [create_default_slot_1$2] },
    		$$scope: { ctx }
    	};

    	if (/*desaparecer*/ ctx[9] !== void 0) {
    		checkbox_props.checked = /*desaparecer*/ ctx[9];
    	}

    	checkbox = new Ne({ props: checkbox_props, $$inline: true });
    	binding_callbacks.push(() => bind(checkbox, "checked", checkbox_checked_binding));

    	const block = {
    		c: function create() {
    			create_component(checkbox.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(checkbox, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const checkbox_changes = {};

    			if (dirty & /*$$scope*/ 524288) {
    				checkbox_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_checked && dirty & /*desaparecer*/ 512) {
    				updating_checked = true;
    				checkbox_changes.checked = /*desaparecer*/ ctx[9];
    				add_flush_callback(() => updating_checked = false);
    			}

    			checkbox.$set(checkbox_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(checkbox.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(checkbox.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(checkbox, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$4.name,
    		type: "if",
    		source: "(68:8) {#if duracion > 5000 }",
    		ctx
    	});

    	return block;
    }

    // (69:12) <Checkbox                   style="padding: 0 8px"                   title="Borra todos los rozes y comentarios del usuario"                   bind:checked={desaparecer} right>
    function create_default_slot_1$2(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Desaparecer");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$2.name,
    		type: "slot",
    		source: "(69:12) <Checkbox                   style=\\\"padding: 0 8px\\\"                   title=\\\"Borra todos los rozes y comentarios del usuario\\\"                   bind:checked={desaparecer} right>",
    		ctx
    	});

    	return block;
    }

    // (35:4) <div slot="body">
    function create_body_slot$1(ctx) {
    	let div0;
    	let div1;
    	let t0;
    	let select0;
    	let option0;
    	let t2;
    	let textarea;
    	let t3;
    	let select1;
    	let option1;
    	let option2;
    	let option3;
    	let option4;
    	let option5;
    	let option6;
    	let option7;
    	let option8;
    	let option9;
    	let t13;
    	let t14;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block0 = /*hiloId*/ ctx[1] && create_if_block_2$1(ctx);
    	let each_value = Object.keys(MotivoDenuncia);
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$2(get_each_context$2(ctx, each_value, i));
    	}

    	let if_block1 = (/*comentarioId*/ ctx[2] || /*hiloId*/ ctx[1]) && create_if_block_1$2(ctx);
    	let if_block2 = /*duracion*/ ctx[5] > 5000 && create_if_block$4(ctx);

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			div1 = element("div");
    			if (if_block0) if_block0.c();
    			t0 = space();
    			select0 = element("select");
    			option0 = element("option");
    			option0.textContent = "Motivo";

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t2 = space();
    			textarea = element("textarea");
    			t3 = space();
    			select1 = element("select");
    			option1 = element("option");
    			option1.textContent = "Duracion";
    			option2 = element("option");
    			option2.textContent = "0 min (Advertencia)";
    			option3 = element("option");
    			option3.textContent = "5 min";
    			option4 = element("option");
    			option4.textContent = "30 min";
    			option5 = element("option");
    			option5.textContent = "1 hora";
    			option6 = element("option");
    			option6.textContent = "1 dia";
    			option7 = element("option");
    			option7.textContent = "1 semana";
    			option8 = element("option");
    			option8.textContent = "1 mes";
    			option9 = element("option");
    			option9.textContent = "Permanente";
    			t13 = space();
    			if (if_block1) if_block1.c();
    			t14 = space();
    			if (if_block2) if_block2.c();
    			attr_dev(div1, "class", "");
    			add_location(div1, file$6, 35, 8, 904);
    			option0.__value = "-1";
    			option0.value = option0.__value;
    			option0.selected = "selected";
    			option0.disabled = "disabled";
    			add_location(option0, file$6, 42, 12, 1140);
    			attr_dev(select0, "name", "motivo");
    			if (/*motivo*/ ctx[4] === void 0) add_render_callback(() => /*select0_change_handler*/ ctx[12].call(select0));
    			add_location(select0, file$6, 41, 8, 1082);
    			attr_dev(textarea, "placeholder", "Aclaracion, mensaje");
    			add_location(textarea, file$6, 48, 8, 1395);
    			option1.__value = "-1";
    			option1.value = option1.__value;
    			option1.selected = "selected";
    			option1.disabled = "disabled";
    			add_location(option1, file$6, 51, 12, 1556);
    			option2.__value = "0";
    			option2.value = option2.__value;
    			add_location(option2, file$6, 52, 12, 1646);
    			option3.__value = "5";
    			option3.value = option3.__value;
    			add_location(option3, file$6, 53, 12, 1706);
    			option4.__value = "30";
    			option4.value = option4.__value;
    			add_location(option4, file$6, 54, 12, 1752);
    			option5.__value = "60";
    			option5.value = option5.__value;
    			add_location(option5, file$6, 55, 12, 1800);
    			option6.__value = "1440";
    			option6.value = option6.__value;
    			add_location(option6, file$6, 56, 12, 1848);
    			option7.__value = "10080";
    			option7.value = option7.__value;
    			add_location(option7, file$6, 57, 12, 1897);
    			option8.__value = "40320";
    			option8.value = option8.__value;
    			add_location(option8, file$6, 58, 12, 1950);
    			option9.__value = "99999999";
    			option9.value = option9.__value;
    			add_location(option9, file$6, 59, 12, 2000);
    			attr_dev(select1, "name", "duracion");
    			if (/*duracion*/ ctx[5] === void 0) add_render_callback(() => /*select1_change_handler*/ ctx[14].call(select1));
    			add_location(select1, file$6, 50, 8, 1494);
    			attr_dev(div0, "slot", "body");
    			add_location(div0, file$6, 34, 4, 877);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			append_dev(div0, div1);
    			if (if_block0) if_block0.m(div1, null);
    			append_dev(div0, t0);
    			append_dev(div0, select0);
    			append_dev(select0, option0);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(select0, null);
    			}

    			select_option(select0, /*motivo*/ ctx[4]);
    			append_dev(div0, t2);
    			append_dev(div0, textarea);
    			set_input_value(textarea, /*aclaracion*/ ctx[6]);
    			append_dev(div0, t3);
    			append_dev(div0, select1);
    			append_dev(select1, option1);
    			append_dev(select1, option2);
    			append_dev(select1, option3);
    			append_dev(select1, option4);
    			append_dev(select1, option5);
    			append_dev(select1, option6);
    			append_dev(select1, option7);
    			append_dev(select1, option8);
    			append_dev(select1, option9);
    			select_option(select1, /*duracion*/ ctx[5]);
    			append_dev(div0, t13);
    			if (if_block1) if_block1.m(div0, null);
    			append_dev(div0, t14);
    			if (if_block2) if_block2.m(div0, null);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(select0, "change", /*select0_change_handler*/ ctx[12]),
    					listen_dev(textarea, "input", /*textarea_input_handler*/ ctx[13]),
    					listen_dev(select1, "change", /*select1_change_handler*/ ctx[14])
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (/*hiloId*/ ctx[1]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_2$1(ctx);
    					if_block0.c();
    					if_block0.m(div1, null);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (dirty & /*MotivoDenuncia, Object*/ 0) {
    				each_value = Object.keys(MotivoDenuncia);
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$2(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$2(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(select0, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*motivo, MotivoDenuncia, Object*/ 16) {
    				select_option(select0, /*motivo*/ ctx[4]);
    			}

    			if (dirty & /*aclaracion*/ 64) {
    				set_input_value(textarea, /*aclaracion*/ ctx[6]);
    			}

    			if (dirty & /*duracion*/ 32) {
    				select_option(select1, /*duracion*/ ctx[5]);
    			}

    			if (/*comentarioId*/ ctx[2] || /*hiloId*/ ctx[1]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty & /*comentarioId, hiloId*/ 6) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_1$2(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div0, t14);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (/*duracion*/ ctx[5] > 5000) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);

    					if (dirty & /*duracion*/ 32) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block$4(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(div0, null);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block1);
    			transition_in(if_block2);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block1);
    			transition_out(if_block2);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			if (if_block0) if_block0.d();
    			destroy_each(each_blocks, detaching);
    			if (if_block1) if_block1.d();
    			if (if_block2) if_block2.d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_body_slot$1.name,
    		type: "slot",
    		source: "(35:4) <div slot=\\\"body\\\">",
    		ctx
    	});

    	return block;
    }

    // (27:0) <Dialogo       bind:visible={visible}       textoActivador="Banear"       titulo="Banear"      accion={banear}>
    function create_default_slot$3(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = space();
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$3.name,
    		type: "slot",
    		source: "(27:0) <Dialogo       bind:visible={visible}       textoActivador=\\\"Banear\\\"       titulo=\\\"Banear\\\"      accion={banear}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$6(ctx) {
    	let dialogo;
    	let updating_visible;
    	let current;

    	function dialogo_visible_binding(value) {
    		/*dialogo_visible_binding*/ ctx[18].call(null, value);
    	}

    	let dialogo_props = {
    		textoActivador: "Banear",
    		titulo: "Banear",
    		accion: /*banear*/ ctx[10],
    		$$slots: {
    			default: [create_default_slot$3],
    			body: [create_body_slot$1],
    			activador: [create_activador_slot$1]
    		},
    		$$scope: { ctx }
    	};

    	if (/*visible*/ ctx[0] !== void 0) {
    		dialogo_props.visible = /*visible*/ ctx[0];
    	}

    	dialogo = new Dialogo({ props: dialogo_props, $$inline: true });
    	binding_callbacks.push(() => bind(dialogo, "visible", dialogo_visible_binding));

    	const block = {
    		c: function create() {
    			create_component(dialogo.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(dialogo, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const dialogo_changes = {};

    			if (dirty & /*$$scope, desaparecer, duracion, eliminarAdjunto, eliminarElemento, comentarioId, hiloId, aclaracion, motivo, usuarioId*/ 525310) {
    				dialogo_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_visible && dirty & /*visible*/ 1) {
    				updating_visible = true;
    				dialogo_changes.visible = /*visible*/ ctx[0];
    				add_flush_callback(() => updating_visible = false);
    			}

    			dialogo.$set(dialogo_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dialogo.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dialogo.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dialogo, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$6.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$6($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("DialogoBan", slots, ['default']);
    	let motivo;
    	let duracion;
    	let aclaracion;
    	let eliminarElemento = true;
    	let eliminarAdjunto = false;
    	let desaparecer = false;
    	let { hiloId } = $$props;
    	let { comentarioId } = $$props;
    	let { usuarioId } = $$props;
    	let { visible = false } = $$props;

    	function banear() {
    		return RChanClient.banear(motivo, aclaracion, duracion, usuarioId, hiloId, comentarioId, eliminarElemento, eliminarAdjunto, desaparecer);
    	}

    	const writable_props = ["hiloId", "comentarioId", "usuarioId", "visible"];

    	Object_1$2.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<DialogoBan> was created with unknown prop '${key}'`);
    	});

    	function select0_change_handler() {
    		motivo = select_value(this);
    		$$invalidate(4, motivo);
    	}

    	function textarea_input_handler() {
    		aclaracion = this.value;
    		$$invalidate(6, aclaracion);
    	}

    	function select1_change_handler() {
    		duracion = select_value(this);
    		$$invalidate(5, duracion);
    	}

    	function checkbox0_checked_binding(value) {
    		eliminarElemento = value;
    		$$invalidate(7, eliminarElemento);
    	}

    	function checkbox1_checked_binding(value) {
    		eliminarAdjunto = value;
    		$$invalidate(8, eliminarAdjunto);
    	}

    	function checkbox_checked_binding(value) {
    		desaparecer = value;
    		$$invalidate(9, desaparecer);
    	}

    	function dialogo_visible_binding(value) {
    		visible = value;
    		$$invalidate(0, visible);
    	}

    	$$self.$$set = $$props => {
    		if ("hiloId" in $$props) $$invalidate(1, hiloId = $$props.hiloId);
    		if ("comentarioId" in $$props) $$invalidate(2, comentarioId = $$props.comentarioId);
    		if ("usuarioId" in $$props) $$invalidate(3, usuarioId = $$props.usuarioId);
    		if ("visible" in $$props) $$invalidate(0, visible = $$props.visible);
    		if ("$$scope" in $$props) $$invalidate(19, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		RChanClient,
    		MotivoDenuncia,
    		Dialogo,
    		Checkbox: Ne,
    		motivo,
    		duracion,
    		aclaracion,
    		eliminarElemento,
    		eliminarAdjunto,
    		desaparecer,
    		hiloId,
    		comentarioId,
    		usuarioId,
    		visible,
    		banear,
    		tipo
    	});

    	$$self.$inject_state = $$props => {
    		if ("motivo" in $$props) $$invalidate(4, motivo = $$props.motivo);
    		if ("duracion" in $$props) $$invalidate(5, duracion = $$props.duracion);
    		if ("aclaracion" in $$props) $$invalidate(6, aclaracion = $$props.aclaracion);
    		if ("eliminarElemento" in $$props) $$invalidate(7, eliminarElemento = $$props.eliminarElemento);
    		if ("eliminarAdjunto" in $$props) $$invalidate(8, eliminarAdjunto = $$props.eliminarAdjunto);
    		if ("desaparecer" in $$props) $$invalidate(9, desaparecer = $$props.desaparecer);
    		if ("hiloId" in $$props) $$invalidate(1, hiloId = $$props.hiloId);
    		if ("comentarioId" in $$props) $$invalidate(2, comentarioId = $$props.comentarioId);
    		if ("usuarioId" in $$props) $$invalidate(3, usuarioId = $$props.usuarioId);
    		if ("visible" in $$props) $$invalidate(0, visible = $$props.visible);
    		if ("tipo" in $$props) tipo = $$props.tipo;
    	};

    	let tipo;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*comentarioId*/ 4) {
    			 tipo = comentarioId == "" || !comentarioId ? 0 : 1;
    		}
    	};

    	return [
    		visible,
    		hiloId,
    		comentarioId,
    		usuarioId,
    		motivo,
    		duracion,
    		aclaracion,
    		eliminarElemento,
    		eliminarAdjunto,
    		desaparecer,
    		banear,
    		slots,
    		select0_change_handler,
    		textarea_input_handler,
    		select1_change_handler,
    		checkbox0_checked_binding,
    		checkbox1_checked_binding,
    		checkbox_checked_binding,
    		dialogo_visible_binding,
    		$$scope
    	];
    }

    class DialogoBan extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$6, create_fragment$6, safe_not_equal, {
    			hiloId: 1,
    			comentarioId: 2,
    			usuarioId: 3,
    			visible: 0
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "DialogoBan",
    			options,
    			id: create_fragment$6.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*hiloId*/ ctx[1] === undefined && !("hiloId" in props)) {
    			console.warn("<DialogoBan> was created without expected prop 'hiloId'");
    		}

    		if (/*comentarioId*/ ctx[2] === undefined && !("comentarioId" in props)) {
    			console.warn("<DialogoBan> was created without expected prop 'comentarioId'");
    		}

    		if (/*usuarioId*/ ctx[3] === undefined && !("usuarioId" in props)) {
    			console.warn("<DialogoBan> was created without expected prop 'usuarioId'");
    		}
    	}

    	get hiloId() {
    		throw new Error("<DialogoBan>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set hiloId(value) {
    		throw new Error("<DialogoBan>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get comentarioId() {
    		throw new Error("<DialogoBan>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set comentarioId(value) {
    		throw new Error("<DialogoBan>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get usuarioId() {
    		throw new Error("<DialogoBan>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set usuarioId(value) {
    		throw new Error("<DialogoBan>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get visible() {
    		throw new Error("<DialogoBan>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set visible(value) {
    		throw new Error("<DialogoBan>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\components\Dialogos\Dialogos.svelte generated by Svelte v3.29.0 */
    const file$7 = "src\\components\\Dialogos\\Dialogos.svelte";

    function get_each_context$3(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[11] = list[i];
    	return child_ctx;
    }

    // (102:0) {#if $dialogosStore.dialogoAbierto == "sticky"}
    function create_if_block$5(ctx) {
    	let h1;

    	const block = {
    		c: function create() {
    			h1 = element("h1");
    			h1.textContent = "sticky";
    			add_location(h1, file$7, 102, 4, 3204);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h1, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$5.name,
    		type: "if",
    		source: "(102:0) {#if $dialogosStore.dialogoAbierto == \\\"sticky\\\"}",
    		ctx
    	});

    	return block;
    }

    // (114:4) <span slot="activador">
    function create_activador_slot_5(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			attr_dev(span, "slot", "activador");
    			add_location(span, file$7, 113, 4, 3633);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_activador_slot_5.name,
    		type: "slot",
    		source: "(114:4) <span slot=\\\"activador\\\">",
    		ctx
    	});

    	return block;
    }

    // (117:8) <Checkbox bind:checked={$dialogosStore.eliminarMedia} right>
    function create_default_slot_8(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Eliminar Archivos");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_8.name,
    		type: "slot",
    		source: "(117:8) <Checkbox bind:checked={$dialogosStore.eliminarMedia} right>",
    		ctx
    	});

    	return block;
    }

    // (115:4) <div slot="body">
    function create_body_slot_5(ctx) {
    	let div;
    	let t;
    	let checkbox;
    	let updating_checked;
    	let current;

    	function checkbox_checked_binding(value) {
    		/*checkbox_checked_binding*/ ctx[1].call(null, value);
    	}

    	let checkbox_props = {
    		right: true,
    		$$slots: { default: [create_default_slot_8] },
    		$$scope: { ctx }
    	};

    	if (/*$dialogosStore*/ ctx[0].eliminarMedia !== void 0) {
    		checkbox_props.checked = /*$dialogosStore*/ ctx[0].eliminarMedia;
    	}

    	checkbox = new Ne({ props: checkbox_props, $$inline: true });
    	binding_callbacks.push(() => bind(checkbox, "checked", checkbox_checked_binding));

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = text("¿Estas seguro de que queres domar el roz?\r\n        ");
    			create_component(checkbox.$$.fragment);
    			attr_dev(div, "slot", "body");
    			add_location(div, file$7, 114, 4, 3669);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t);
    			mount_component(checkbox, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const checkbox_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				checkbox_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_checked && dirty & /*$dialogosStore*/ 1) {
    				updating_checked = true;
    				checkbox_changes.checked = /*$dialogosStore*/ ctx[0].eliminarMedia;
    				add_flush_callback(() => updating_checked = false);
    			}

    			checkbox.$set(checkbox_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(checkbox.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(checkbox.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(checkbox);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_body_slot_5.name,
    		type: "slot",
    		source: "(115:4) <div slot=\\\"body\\\">",
    		ctx
    	});

    	return block;
    }

    // (109:0) <Dialogo visible={$dialogosStore.dialogoAbierto == "eliminarHilo"}       textoActivador="Eliminar"       titulo="Eliminar roz"       accion = {() => RChanClient.borrarHilos([$dialogosStore.hiloId], $dialogosStore.eliminarMedia)}      >
    function create_default_slot_7(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = space();
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_7.name,
    		type: "slot",
    		source: "(109:0) <Dialogo visible={$dialogosStore.dialogoAbierto == \\\"eliminarHilo\\\"}       textoActivador=\\\"Eliminar\\\"       titulo=\\\"Eliminar roz\\\"       accion = {() => RChanClient.borrarHilos([$dialogosStore.hiloId], $dialogosStore.eliminarMedia)}      >",
    		ctx
    	});

    	return block;
    }

    // (126:4) <span slot="activador">
    function create_activador_slot_4(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			attr_dev(span, "slot", "activador");
    			add_location(span, file$7, 125, 4, 4079);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_activador_slot_4.name,
    		type: "slot",
    		source: "(126:4) <span slot=\\\"activador\\\">",
    		ctx
    	});

    	return block;
    }

    // (127:4) <div slot="body">
    function create_body_slot_4(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			div.textContent = "¿Estas seguro de que queres restaurar el roz?";
    			attr_dev(div, "slot", "body");
    			add_location(div, file$7, 126, 4, 4115);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_body_slot_4.name,
    		type: "slot",
    		source: "(127:4) <div slot=\\\"body\\\">",
    		ctx
    	});

    	return block;
    }

    // (121:0) <Dialogo visible={$dialogosStore.dialogoAbierto == "restaurarHilo"}       textoActivador="Restaurar"       titulo="Restaurar el roz"       accion = {() => RChanClient.restaurarRoz($dialogosStore.hiloId)}      >
    function create_default_slot_6(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = space();
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_6.name,
    		type: "slot",
    		source: "(121:0) <Dialogo visible={$dialogosStore.dialogoAbierto == \\\"restaurarHilo\\\"}       textoActivador=\\\"Restaurar\\\"       titulo=\\\"Restaurar el roz\\\"       accion = {() => RChanClient.restaurarRoz($dialogosStore.hiloId)}      >",
    		ctx
    	});

    	return block;
    }

    // (136:4) <span slot="activador">
    function create_activador_slot_3(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			attr_dev(span, "slot", "activador");
    			add_location(span, file$7, 135, 4, 4478);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_activador_slot_3.name,
    		type: "slot",
    		source: "(136:4) <span slot=\\\"activador\\\">",
    		ctx
    	});

    	return block;
    }

    // (137:4) <div slot="body">
    function create_body_slot_3(ctx) {
    	let div;
    	let t0;
    	let t1_value = /*$dialogosStore*/ ctx[0].comentarioId + "";
    	let t1;
    	let t2;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text("¿Estas seguro de que queres restaurar el comentario ");
    			t1 = text(t1_value);
    			t2 = text("?");
    			attr_dev(div, "slot", "body");
    			add_location(div, file$7, 136, 4, 4514);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);
    			append_dev(div, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$dialogosStore*/ 1 && t1_value !== (t1_value = /*$dialogosStore*/ ctx[0].comentarioId + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_body_slot_3.name,
    		type: "slot",
    		source: "(137:4) <div slot=\\\"body\\\">",
    		ctx
    	});

    	return block;
    }

    // (131:0) <Dialogo visible={$dialogosStore.dialogoAbierto == "restaurarComentario"}       textoActivador="Restaurar"       titulo="Restaurar el comentario"       accion = {() => RChanClient.restaurarComentario($dialogosStore.hiloId, $dialogosStore.comentarioId)}      >
    function create_default_slot_5(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = space();
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5.name,
    		type: "slot",
    		source: "(131:0) <Dialogo visible={$dialogosStore.dialogoAbierto == \\\"restaurarComentario\\\"}       textoActivador=\\\"Restaurar\\\"       titulo=\\\"Restaurar el comentario\\\"       accion = {() => RChanClient.restaurarComentario($dialogosStore.hiloId, $dialogosStore.comentarioId)}      >",
    		ctx
    	});

    	return block;
    }

    // (147:4) <span slot="activador">
    function create_activador_slot_2(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			attr_dev(span, "slot", "activador");
    			add_location(span, file$7, 146, 4, 4920);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_activador_slot_2.name,
    		type: "slot",
    		source: "(147:4) <span slot=\\\"activador\\\">",
    		ctx
    	});

    	return block;
    }

    // (150:8) <Checkbox bind:checked={$dialogosStore.eliminarMedia} right>
    function create_default_slot_4$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Eliminar Archivos");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$1.name,
    		type: "slot",
    		source: "(150:8) <Checkbox bind:checked={$dialogosStore.eliminarMedia} right>",
    		ctx
    	});

    	return block;
    }

    // (148:4) <div slot="body">
    function create_body_slot_2(ctx) {
    	let div;
    	let t0;
    	let t1_value = /*$dialogosStore*/ ctx[0].comentariosIds + "";
    	let t1;
    	let t2;
    	let checkbox;
    	let updating_checked;
    	let current;

    	function checkbox_checked_binding_1(value) {
    		/*checkbox_checked_binding_1*/ ctx[5].call(null, value);
    	}

    	let checkbox_props = {
    		right: true,
    		$$slots: { default: [create_default_slot_4$1] },
    		$$scope: { ctx }
    	};

    	if (/*$dialogosStore*/ ctx[0].eliminarMedia !== void 0) {
    		checkbox_props.checked = /*$dialogosStore*/ ctx[0].eliminarMedia;
    	}

    	checkbox = new Ne({ props: checkbox_props, $$inline: true });
    	binding_callbacks.push(() => bind(checkbox, "checked", checkbox_checked_binding_1));

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text("¿Estas seguro de que queres borrar los comentarios ");
    			t1 = text(t1_value);
    			t2 = space();
    			create_component(checkbox.$$.fragment);
    			attr_dev(div, "slot", "body");
    			add_location(div, file$7, 147, 4, 4956);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);
    			append_dev(div, t2);
    			mount_component(checkbox, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty & /*$dialogosStore*/ 1) && t1_value !== (t1_value = /*$dialogosStore*/ ctx[0].comentariosIds + "")) set_data_dev(t1, t1_value);
    			const checkbox_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				checkbox_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_checked && dirty & /*$dialogosStore*/ 1) {
    				updating_checked = true;
    				checkbox_changes.checked = /*$dialogosStore*/ ctx[0].eliminarMedia;
    				add_flush_callback(() => updating_checked = false);
    			}

    			checkbox.$set(checkbox_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(checkbox.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(checkbox.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(checkbox);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_body_slot_2.name,
    		type: "slot",
    		source: "(148:4) <div slot=\\\"body\\\">",
    		ctx
    	});

    	return block;
    }

    // (142:0) <Dialogo visible={$dialogosStore.dialogoAbierto == "eliminarComentarios"}       textoActivador="Eliminar"       titulo="Eliminar comentario"       accion = {() => RChanClient.eliminarComentarios($dialogosStore.comentariosIds, $dialogosStore.eliminarMedia)}      >
    function create_default_slot_3$3(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = space();
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$3.name,
    		type: "slot",
    		source: "(142:0) <Dialogo visible={$dialogosStore.dialogoAbierto == \\\"eliminarComentarios\\\"}       textoActivador=\\\"Eliminar\\\"       titulo=\\\"Eliminar comentario\\\"       accion = {() => RChanClient.eliminarComentarios($dialogosStore.comentariosIds, $dialogosStore.eliminarMedia)}      >",
    		ctx
    	});

    	return block;
    }

    // (164:4) <span slot="activador">
    function create_activador_slot_1(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			attr_dev(span, "slot", "activador");
    			add_location(span, file$7, 163, 4, 5617);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_activador_slot_1.name,
    		type: "slot",
    		source: "(164:4) <span slot=\\\"activador\\\">",
    		ctx
    	});

    	return block;
    }

    // (166:8) <Checkbox bind:checked={$dialogosStore.mediaEliminarDependientes} right>
    function create_default_slot_2$3(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Eliminar todos los elementos con este archivo?");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$3.name,
    		type: "slot",
    		source: "(166:8) <Checkbox bind:checked={$dialogosStore.mediaEliminarDependientes} right>",
    		ctx
    	});

    	return block;
    }

    // (165:4) <div slot="body">
    function create_body_slot_1(ctx) {
    	let div;
    	let checkbox;
    	let updating_checked;
    	let current;

    	function checkbox_checked_binding_2(value) {
    		/*checkbox_checked_binding_2*/ ctx[7].call(null, value);
    	}

    	let checkbox_props = {
    		right: true,
    		$$slots: { default: [create_default_slot_2$3] },
    		$$scope: { ctx }
    	};

    	if (/*$dialogosStore*/ ctx[0].mediaEliminarDependientes !== void 0) {
    		checkbox_props.checked = /*$dialogosStore*/ ctx[0].mediaEliminarDependientes;
    	}

    	checkbox = new Ne({ props: checkbox_props, $$inline: true });
    	binding_callbacks.push(() => bind(checkbox, "checked", checkbox_checked_binding_2));

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(checkbox.$$.fragment);
    			attr_dev(div, "slot", "body");
    			add_location(div, file$7, 164, 4, 5653);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(checkbox, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const checkbox_changes = {};

    			if (dirty & /*$$scope*/ 16384) {
    				checkbox_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_checked && dirty & /*$dialogosStore*/ 1) {
    				updating_checked = true;
    				checkbox_changes.checked = /*$dialogosStore*/ ctx[0].mediaEliminarDependientes;
    				add_flush_callback(() => updating_checked = false);
    			}

    			checkbox.$set(checkbox_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(checkbox.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(checkbox.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(checkbox);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_body_slot_1.name,
    		type: "slot",
    		source: "(165:4) <div slot=\\\"body\\\">",
    		ctx
    	});

    	return block;
    }

    // (159:0) <Dialogo visible={$dialogosStore.dialogoAbierto == "eliminarMedia"}       textoActivador="Eliminar"       titulo="Eliminar la imagen/video"       accion = {() => RChanClient.eliminarMedia($dialogosStore.mediaId)}      >
    function create_default_slot_1$3(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = space();
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$3.name,
    		type: "slot",
    		source: "(159:0) <Dialogo visible={$dialogosStore.dialogoAbierto == \\\"eliminarMedia\\\"}       textoActivador=\\\"Eliminar\\\"       titulo=\\\"Eliminar la imagen/video\\\"       accion = {() => RChanClient.eliminarMedia($dialogosStore.mediaId)}      >",
    		ctx
    	});

    	return block;
    }

    // (174:4) <span slot="activador">
    function create_activador_slot$2(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			attr_dev(span, "slot", "activador");
    			add_location(span, file$7, 173, 4, 6056);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_activador_slot$2.name,
    		type: "slot",
    		source: "(174:4) <span slot=\\\"activador\\\">",
    		ctx
    	});

    	return block;
    }

    // (179:12) {#each config.categorias as c}
    function create_each_block$3(ctx) {
    	let option;
    	let t_value = /*c*/ ctx[11].nombre + "";
    	let t;
    	let option_value_value;

    	const block = {
    		c: function create() {
    			option = element("option");
    			t = text(t_value);
    			option.__value = option_value_value = /*c*/ ctx[11].id;
    			option.value = option.__value;
    			add_location(option, file$7, 179, 12, 6390);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, option, anchor);
    			append_dev(option, t);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(option);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$3.name,
    		type: "each",
    		source: "(179:12) {#each config.categorias as c}",
    		ctx
    	});

    	return block;
    }

    // (175:4) <div slot="body">
    function create_body_slot$2(ctx) {
    	let div;
    	let span;
    	let t0;
    	let select;
    	let option;
    	let mounted;
    	let dispose;
    	let each_value = config.categorias;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$3(get_each_context$3(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			span = element("span");
    			t0 = space();
    			select = element("select");
    			option = element("option");
    			option.textContent = "Categoría";

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(span, "asp-validation-for", "CategoriaId");
    			add_location(span, file$7, 175, 8, 6119);
    			option.__value = "-1";
    			option.value = option.__value;
    			option.selected = "selected";
    			option.disabled = "disabled";
    			add_location(option, file$7, 177, 12, 6255);
    			attr_dev(select, "name", "categoria");
    			if (/*$dialogosStore*/ ctx[0].categoriaId === void 0) add_render_callback(() => /*select_change_handler*/ ctx[9].call(select));
    			add_location(select, file$7, 176, 8, 6175);
    			attr_dev(div, "slot", "body");
    			add_location(div, file$7, 174, 4, 6092);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, span);
    			append_dev(div, t0);
    			append_dev(div, select);
    			append_dev(select, option);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(select, null);
    			}

    			select_option(select, /*$dialogosStore*/ ctx[0].categoriaId);

    			if (!mounted) {
    				dispose = listen_dev(select, "change", /*select_change_handler*/ ctx[9]);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*config*/ 0) {
    				each_value = config.categorias;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$3(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$3(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(select, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*$dialogosStore, config*/ 1) {
    				select_option(select, /*$dialogosStore*/ ctx[0].categoriaId);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_body_slot$2.name,
    		type: "slot",
    		source: "(175:4) <div slot=\\\"body\\\">",
    		ctx
    	});

    	return block;
    }

    // (170:0) <Dialogo       visible={$dialogosStore.dialogoAbierto == "cambiarCategoria"}       titulo="Cambiar categoria"       accion = {() => RChanClient.cambiarCategoria($dialogosStore.hiloId, $dialogosStore.categoriaId)}>
    function create_default_slot$4(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = space();
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$4.name,
    		type: "slot",
    		source: "(170:0) <Dialogo       visible={$dialogosStore.dialogoAbierto == \\\"cambiarCategoria\\\"}       titulo=\\\"Cambiar categoria\\\"       accion = {() => RChanClient.cambiarCategoria($dialogosStore.hiloId, $dialogosStore.categoriaId)}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$7(ctx) {
    	let t0;
    	let dialogoreporte;
    	let t1;
    	let dialogo0;
    	let t2;
    	let dialogo1;
    	let t3;
    	let dialogo2;
    	let t4;
    	let dialogo3;
    	let t5;
    	let dialogoban;
    	let t6;
    	let dialogo4;
    	let t7;
    	let dialogo5;
    	let current;
    	let if_block = /*$dialogosStore*/ ctx[0].dialogoAbierto == "sticky" && create_if_block$5(ctx);

    	dialogoreporte = new DialogoReporte({
    			props: {
    				visible: /*$dialogosStore*/ ctx[0].dialogoAbierto == "reporte",
    				hiloId: /*$dialogosStore*/ ctx[0].hiloId,
    				comentarioId: /*$dialogosStore*/ ctx[0].comentarioId
    			},
    			$$inline: true
    		});

    	dialogo0 = new Dialogo({
    			props: {
    				visible: /*$dialogosStore*/ ctx[0].dialogoAbierto == "eliminarHilo",
    				textoActivador: "Eliminar",
    				titulo: "Eliminar roz",
    				accion: /*func*/ ctx[2],
    				$$slots: {
    					default: [create_default_slot_7],
    					body: [create_body_slot_5],
    					activador: [create_activador_slot_5]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dialogo1 = new Dialogo({
    			props: {
    				visible: /*$dialogosStore*/ ctx[0].dialogoAbierto == "restaurarHilo",
    				textoActivador: "Restaurar",
    				titulo: "Restaurar el roz",
    				accion: /*func_1*/ ctx[3],
    				$$slots: {
    					default: [create_default_slot_6],
    					body: [create_body_slot_4],
    					activador: [create_activador_slot_4]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dialogo2 = new Dialogo({
    			props: {
    				visible: /*$dialogosStore*/ ctx[0].dialogoAbierto == "restaurarComentario",
    				textoActivador: "Restaurar",
    				titulo: "Restaurar el comentario",
    				accion: /*func_2*/ ctx[4],
    				$$slots: {
    					default: [create_default_slot_5],
    					body: [create_body_slot_3],
    					activador: [create_activador_slot_3]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dialogo3 = new Dialogo({
    			props: {
    				visible: /*$dialogosStore*/ ctx[0].dialogoAbierto == "eliminarComentarios",
    				textoActivador: "Eliminar",
    				titulo: "Eliminar comentario",
    				accion: /*func_3*/ ctx[6],
    				$$slots: {
    					default: [create_default_slot_3$3],
    					body: [create_body_slot_2],
    					activador: [create_activador_slot_2]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dialogoban = new DialogoBan({
    			props: {
    				visible: /*$dialogosStore*/ ctx[0].dialogoAbierto == "ban",
    				hiloId: /*$dialogosStore*/ ctx[0].hiloId,
    				usuarioId: /*$dialogosStore*/ ctx[0].usuarioId,
    				comentarioId: /*$dialogosStore*/ ctx[0].comentarioId
    			},
    			$$inline: true
    		});

    	dialogo4 = new Dialogo({
    			props: {
    				visible: /*$dialogosStore*/ ctx[0].dialogoAbierto == "eliminarMedia",
    				textoActivador: "Eliminar",
    				titulo: "Eliminar la imagen/video",
    				accion: /*func_4*/ ctx[8],
    				$$slots: {
    					default: [create_default_slot_1$3],
    					body: [create_body_slot_1],
    					activador: [create_activador_slot_1]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	dialogo5 = new Dialogo({
    			props: {
    				visible: /*$dialogosStore*/ ctx[0].dialogoAbierto == "cambiarCategoria",
    				titulo: "Cambiar categoria",
    				accion: /*func_5*/ ctx[10],
    				$$slots: {
    					default: [create_default_slot$4],
    					body: [create_body_slot$2],
    					activador: [create_activador_slot$2]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			t0 = space();
    			create_component(dialogoreporte.$$.fragment);
    			t1 = space();
    			create_component(dialogo0.$$.fragment);
    			t2 = space();
    			create_component(dialogo1.$$.fragment);
    			t3 = space();
    			create_component(dialogo2.$$.fragment);
    			t4 = space();
    			create_component(dialogo3.$$.fragment);
    			t5 = space();
    			create_component(dialogoban.$$.fragment);
    			t6 = space();
    			create_component(dialogo4.$$.fragment);
    			t7 = space();
    			create_component(dialogo5.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(dialogoreporte, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(dialogo0, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(dialogo1, target, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(dialogo2, target, anchor);
    			insert_dev(target, t4, anchor);
    			mount_component(dialogo3, target, anchor);
    			insert_dev(target, t5, anchor);
    			mount_component(dialogoban, target, anchor);
    			insert_dev(target, t6, anchor);
    			mount_component(dialogo4, target, anchor);
    			insert_dev(target, t7, anchor);
    			mount_component(dialogo5, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*$dialogosStore*/ ctx[0].dialogoAbierto == "sticky") {
    				if (if_block) ; else {
    					if_block = create_if_block$5(ctx);
    					if_block.c();
    					if_block.m(t0.parentNode, t0);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			const dialogoreporte_changes = {};
    			if (dirty & /*$dialogosStore*/ 1) dialogoreporte_changes.visible = /*$dialogosStore*/ ctx[0].dialogoAbierto == "reporte";
    			if (dirty & /*$dialogosStore*/ 1) dialogoreporte_changes.hiloId = /*$dialogosStore*/ ctx[0].hiloId;
    			if (dirty & /*$dialogosStore*/ 1) dialogoreporte_changes.comentarioId = /*$dialogosStore*/ ctx[0].comentarioId;
    			dialogoreporte.$set(dialogoreporte_changes);
    			const dialogo0_changes = {};
    			if (dirty & /*$dialogosStore*/ 1) dialogo0_changes.visible = /*$dialogosStore*/ ctx[0].dialogoAbierto == "eliminarHilo";
    			if (dirty & /*$dialogosStore*/ 1) dialogo0_changes.accion = /*func*/ ctx[2];

    			if (dirty & /*$$scope, $dialogosStore*/ 16385) {
    				dialogo0_changes.$$scope = { dirty, ctx };
    			}

    			dialogo0.$set(dialogo0_changes);
    			const dialogo1_changes = {};
    			if (dirty & /*$dialogosStore*/ 1) dialogo1_changes.visible = /*$dialogosStore*/ ctx[0].dialogoAbierto == "restaurarHilo";
    			if (dirty & /*$dialogosStore*/ 1) dialogo1_changes.accion = /*func_1*/ ctx[3];

    			if (dirty & /*$$scope*/ 16384) {
    				dialogo1_changes.$$scope = { dirty, ctx };
    			}

    			dialogo1.$set(dialogo1_changes);
    			const dialogo2_changes = {};
    			if (dirty & /*$dialogosStore*/ 1) dialogo2_changes.visible = /*$dialogosStore*/ ctx[0].dialogoAbierto == "restaurarComentario";
    			if (dirty & /*$dialogosStore*/ 1) dialogo2_changes.accion = /*func_2*/ ctx[4];

    			if (dirty & /*$$scope, $dialogosStore*/ 16385) {
    				dialogo2_changes.$$scope = { dirty, ctx };
    			}

    			dialogo2.$set(dialogo2_changes);
    			const dialogo3_changes = {};
    			if (dirty & /*$dialogosStore*/ 1) dialogo3_changes.visible = /*$dialogosStore*/ ctx[0].dialogoAbierto == "eliminarComentarios";
    			if (dirty & /*$dialogosStore*/ 1) dialogo3_changes.accion = /*func_3*/ ctx[6];

    			if (dirty & /*$$scope, $dialogosStore*/ 16385) {
    				dialogo3_changes.$$scope = { dirty, ctx };
    			}

    			dialogo3.$set(dialogo3_changes);
    			const dialogoban_changes = {};
    			if (dirty & /*$dialogosStore*/ 1) dialogoban_changes.visible = /*$dialogosStore*/ ctx[0].dialogoAbierto == "ban";
    			if (dirty & /*$dialogosStore*/ 1) dialogoban_changes.hiloId = /*$dialogosStore*/ ctx[0].hiloId;
    			if (dirty & /*$dialogosStore*/ 1) dialogoban_changes.usuarioId = /*$dialogosStore*/ ctx[0].usuarioId;
    			if (dirty & /*$dialogosStore*/ 1) dialogoban_changes.comentarioId = /*$dialogosStore*/ ctx[0].comentarioId;
    			dialogoban.$set(dialogoban_changes);
    			const dialogo4_changes = {};
    			if (dirty & /*$dialogosStore*/ 1) dialogo4_changes.visible = /*$dialogosStore*/ ctx[0].dialogoAbierto == "eliminarMedia";
    			if (dirty & /*$dialogosStore*/ 1) dialogo4_changes.accion = /*func_4*/ ctx[8];

    			if (dirty & /*$$scope, $dialogosStore*/ 16385) {
    				dialogo4_changes.$$scope = { dirty, ctx };
    			}

    			dialogo4.$set(dialogo4_changes);
    			const dialogo5_changes = {};
    			if (dirty & /*$dialogosStore*/ 1) dialogo5_changes.visible = /*$dialogosStore*/ ctx[0].dialogoAbierto == "cambiarCategoria";
    			if (dirty & /*$dialogosStore*/ 1) dialogo5_changes.accion = /*func_5*/ ctx[10];

    			if (dirty & /*$$scope, $dialogosStore*/ 16385) {
    				dialogo5_changes.$$scope = { dirty, ctx };
    			}

    			dialogo5.$set(dialogo5_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dialogoreporte.$$.fragment, local);
    			transition_in(dialogo0.$$.fragment, local);
    			transition_in(dialogo1.$$.fragment, local);
    			transition_in(dialogo2.$$.fragment, local);
    			transition_in(dialogo3.$$.fragment, local);
    			transition_in(dialogoban.$$.fragment, local);
    			transition_in(dialogo4.$$.fragment, local);
    			transition_in(dialogo5.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dialogoreporte.$$.fragment, local);
    			transition_out(dialogo0.$$.fragment, local);
    			transition_out(dialogo1.$$.fragment, local);
    			transition_out(dialogo2.$$.fragment, local);
    			transition_out(dialogo3.$$.fragment, local);
    			transition_out(dialogoban.$$.fragment, local);
    			transition_out(dialogo4.$$.fragment, local);
    			transition_out(dialogo5.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(dialogoreporte, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(dialogo0, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(dialogo1, detaching);
    			if (detaching) detach_dev(t3);
    			destroy_component(dialogo2, detaching);
    			if (detaching) detach_dev(t4);
    			destroy_component(dialogo3, detaching);
    			if (detaching) detach_dev(t5);
    			destroy_component(dialogoban, detaching);
    			if (detaching) detach_dev(t6);
    			destroy_component(dialogo4, detaching);
    			if (detaching) detach_dev(t7);
    			destroy_component(dialogo5, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$7.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const dialogosStore = writable({
    	dialogoAbierto: "ninguno",
    	hiloId: "",
    	comentarioId: "",
    	comentariosIds: [],
    	usuarioId: "",
    	mediaId: "",
    	categoriaId: "-1",
    	eliminarMedia: false,
    	mediaEliminarDependientes: true
    });

    function abrirReporte(hiloId, comentarioId = null) {
    	dialogosStore.update(s => {
    		s.dialogoAbierto = "reporte";
    		s.hiloId = hiloId;
    		s.comentarioId = comentarioId;
    		return s;
    	});
    }

    function abrirEliminarhilo(hiloId, comentarioId = null) {
    	dialogosStore.update(s => {
    		s.dialogoAbierto = "eliminarHilo";
    		s.hiloId = hiloId;
    		s.comentarioId = comentarioId;
    		return s;
    	});
    }

    function abrirRestaurarHilo(hiloId, comentarioId = null) {
    	dialogosStore.update(s => {
    		s.dialogoAbierto = "restaurarHilo";
    		s.hiloId = hiloId;
    		return s;
    	});
    }

    function abrirRestaurarComentario(hiloId, comentarioId = null) {
    	dialogosStore.update(s => {
    		s.dialogoAbierto = "restaurarComentario";
    		s.hiloId = hiloId;
    		s.comentarioId = comentarioId;
    		return s;
    	});
    }

    function abrirEliminarComentarios(ids) {
    	dialogosStore.update(s => {
    		s.dialogoAbierto = "eliminarComentarios";
    		s.comentariosIds = ids;
    		return s;
    	});
    }

    function abrirBan(hiloId, comentarioId = null, usuarioId = null) {
    	dialogosStore.update(s => {
    		s.dialogoAbierto = "ban";
    		s.hiloId = hiloId;
    		s.comentarioId = comentarioId;
    		s.usuarioId = usuarioId;
    		return s;
    	});
    }

    function abrirEliminarMedia(mediaId) {
    	dialogosStore.update(s => {
    		s.dialogoAbierto = "eliminarMedia";
    		s.mediaId = mediaId;
    		return s;
    	});
    }

    function abrirCambiarCategoria(hiloId) {
    	dialogosStore.update(s => {
    		s.dialogoAbierto = "cambiarCategoria";
    		s.hiloId = hiloId;
    		return s;
    	});
    }

    const abrir = {
    	//  sticky : abrirDialogo("sticky"),
    	ban: abrirBan,
    	reporte: abrirReporte,
    	eliminarHilo: abrirEliminarhilo,
    	eliminarComentarios: abrirEliminarComentarios,
    	restaurarHilo: abrirRestaurarHilo,
    	restaurarComentario: abrirRestaurarComentario,
    	eliminarMedia: abrirEliminarMedia,
    	cambiarCategoria: abrirCambiarCategoria
    }; //  categoria : abrirDialogo("categoria"),
    //  eliminar : abrirDialogo("eliminar"),

    function instance$7($$self, $$props, $$invalidate) {
    	let $dialogosStore;
    	validate_store(dialogosStore, "dialogosStore");
    	component_subscribe($$self, dialogosStore, $$value => $$invalidate(0, $dialogosStore = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Dialogos", slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Dialogos> was created with unknown prop '${key}'`);
    	});

    	function checkbox_checked_binding(value) {
    		$dialogosStore.eliminarMedia = value;
    		dialogosStore.set($dialogosStore);
    	}

    	const func = () => RChanClient.borrarHilos([$dialogosStore.hiloId], $dialogosStore.eliminarMedia);
    	const func_1 = () => RChanClient.restaurarRoz($dialogosStore.hiloId);
    	const func_2 = () => RChanClient.restaurarComentario($dialogosStore.hiloId, $dialogosStore.comentarioId);

    	function checkbox_checked_binding_1(value) {
    		$dialogosStore.eliminarMedia = value;
    		dialogosStore.set($dialogosStore);
    	}

    	const func_3 = () => RChanClient.eliminarComentarios($dialogosStore.comentariosIds, $dialogosStore.eliminarMedia);

    	function checkbox_checked_binding_2(value) {
    		$dialogosStore.mediaEliminarDependientes = value;
    		dialogosStore.set($dialogosStore);
    	}

    	const func_4 = () => RChanClient.eliminarMedia($dialogosStore.mediaId);

    	function select_change_handler() {
    		$dialogosStore.categoriaId = select_value(this);
    		dialogosStore.set($dialogosStore);
    	}

    	const func_5 = () => RChanClient.cambiarCategoria($dialogosStore.hiloId, $dialogosStore.categoriaId);

    	$$self.$capture_state = () => ({
    		writable,
    		RChanClient,
    		Dialogo,
    		DialogoBan,
    		DialogoReporte,
    		Checkbox: Ne,
    		config,
    		dialogosStore,
    		abrirReporte,
    		abrirEliminarhilo,
    		abrirRestaurarHilo,
    		abrirRestaurarComentario,
    		abrirEliminarComentarios,
    		abrirBan,
    		abrirEliminarMedia,
    		abrirCambiarCategoria,
    		abrir,
    		$dialogosStore
    	});

    	return [
    		$dialogosStore,
    		checkbox_checked_binding,
    		func,
    		func_1,
    		func_2,
    		checkbox_checked_binding_1,
    		func_3,
    		checkbox_checked_binding_2,
    		func_4,
    		select_change_handler,
    		func_5
    	];
    }

    class Dialogos extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$7, create_fragment$7, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Dialogos",
    			options,
    			id: create_fragment$7.name
    		});
    	}
    }

    let  selectorStore = writable({
        activado: true,
        seleccionados: new Set()
    });
    selectorStore.selecionar =  function selecionar (id) {
        selectorStore.update(v => {
            if(v.seleccionados.has(id)) {
                v.seleccionados.delete(id);
            } else {
                v.seleccionados.add(id);
            }
            v.seleccionados = v.seleccionados;
            return v
        });
    };

    /* src\components\Comentarios\Comentario.svelte generated by Svelte v3.29.0 */
    const file$8 = "src\\components\\Comentarios\\Comentario.svelte";

    function get_each_context$4(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[38] = list[i];
    	return child_ctx;
    }

    // (109:8) {#each comentario.respuestas as r }
    function create_each_block$4(ctx) {
    	let a;
    	let t0;
    	let t1_value = /*r*/ ctx[38] + "";
    	let t1;
    	let t2_value = (/*esOp*/ ctx[19](/*r*/ ctx[38]) ? "(OP)" : "") + "";
    	let t2;
    	let t3;
    	let a_href_value;
    	let a_r_id_value;
    	let mounted;
    	let dispose;

    	function mouseover_handler(...args) {
    		return /*mouseover_handler*/ ctx[22](/*r*/ ctx[38], ...args);
    	}

    	const block = {
    		c: function create() {
    			a = element("a");
    			t0 = text(">>");
    			t1 = text(t1_value);
    			t2 = text(t2_value);
    			t3 = space();
    			attr_dev(a, "href", a_href_value = "#" + /*r*/ ctx[38]);
    			attr_dev(a, "class", "restag");
    			attr_dev(a, "r-id", a_r_id_value = /*r*/ ctx[38]);
    			add_location(a, file$8, 109, 8, 3723);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);
    			append_dev(a, t0);
    			append_dev(a, t1);
    			append_dev(a, t2);
    			append_dev(a, t3);

    			if (!mounted) {
    				dispose = [
    					listen_dev(a, "mouseover", mouseover_handler, false, false, false),
    					listen_dev(a, "mouseleave", /*ocultarRespuesta*/ ctx[15], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if (dirty[0] & /*comentario*/ 1 && t1_value !== (t1_value = /*r*/ ctx[38] + "")) set_data_dev(t1, t1_value);
    			if (dirty[0] & /*comentario*/ 1 && t2_value !== (t2_value = (/*esOp*/ ctx[19](/*r*/ ctx[38]) ? "(OP)" : "") + "")) set_data_dev(t2, t2_value);

    			if (dirty[0] & /*comentario*/ 1 && a_href_value !== (a_href_value = "#" + /*r*/ ctx[38])) {
    				attr_dev(a, "href", a_href_value);
    			}

    			if (dirty[0] & /*comentario*/ 1 && a_r_id_value !== (a_r_id_value = /*r*/ ctx[38])) {
    				attr_dev(a, "r-id", a_r_id_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$4.name,
    		type: "each",
    		source: "(109:8) {#each comentario.respuestas as r }",
    		ctx
    	});

    	return block;
    }

    // (124:8) {:else}
    function create_else_block_1$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("ANON");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$1.name,
    		type: "else",
    		source: "(124:8) {:else}",
    		ctx
    	});

    	return block;
    }

    // (122:35) 
    function create_if_block_10(ctx) {
    	let t_value = CreacionRango.aString(/*comentario*/ ctx[0].rango).toUpperCase() + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*comentario*/ 1 && t_value !== (t_value = CreacionRango.aString(/*comentario*/ ctx[0].rango).toUpperCase() + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_10.name,
    		type: "if",
    		source: "(122:35) ",
    		ctx
    	});

    	return block;
    }

    // (120:8) {#if comentario.dados!= undefined && comentario.dados != -1}
    function create_if_block_9(ctx) {
    	let t_value = /*comentario*/ ctx[0].dados + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*comentario*/ 1 && t_value !== (t_value = /*comentario*/ ctx[0].dados + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_9.name,
    		type: "if",
    		source: "(120:8) {#if comentario.dados!= undefined && comentario.dados != -1}",
    		ctx
    	});

    	return block;
    }

    // (129:8) {#if comentario.esOp}
    function create_if_block_8(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "OP";
    			attr_dev(span, "class", "nick tag tag-op svelte-19kf1id");
    			add_location(span, file$8, 128, 30, 4472);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_8.name,
    		type: "if",
    		source: "(129:8) {#if comentario.esOp}",
    		ctx
    	});

    	return block;
    }

    // (135:8) {#if comentario.idUnico}
    function create_if_block_7$1(ctx) {
    	let span;
    	let t0_value = /*comentario*/ ctx[0].idUnico + "";
    	let t0;
    	let t1;
    	let ripple;
    	let span_style_value;
    	let current;
    	let mounted;
    	let dispose;

    	ripple = new he({
    			props: { color: "var(--color5)" },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			span = element("span");
    			t0 = text(t0_value);
    			t1 = space();
    			create_component(ripple.$$.fragment);
    			attr_dev(span, "class", "tag ns cpt idunico svelte-19kf1id");
    			attr_dev(span, "style", span_style_value = `background:${/*idUnicoColor*/ ctx[20]()};`);
    			add_location(span, file$8, 135, 12, 4759);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t0);
    			append_dev(span, t1);
    			mount_component(ripple, span, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(span, "click", /*click_handler_1*/ ctx[24], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[0] & /*comentario*/ 1) && t0_value !== (t0_value = /*comentario*/ ctx[0].idUnico + "")) set_data_dev(t0, t0_value);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(ripple.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(ripple.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			destroy_component(ripple);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_7$1.name,
    		type: "if",
    		source: "(135:8) {#if comentario.idUnico}",
    		ctx
    	});

    	return block;
    }

    // (142:8) {#if comentario.usuarioId}
    function create_if_block_6$1(ctx) {
    	let a;
    	let span;
    	let t_value = /*comentario*/ ctx[0].usuarioId.split("-")[0] + "";
    	let t;
    	let a_href_value;

    	const block = {
    		c: function create() {
    			a = element("a");
    			span = element("span");
    			t = text(t_value);
    			attr_dev(span, "class", "nick svelte-19kf1id");
    			add_location(span, file$8, 143, 12, 5203);
    			attr_dev(a, "href", a_href_value = "/Moderacion/HistorialDeUsuario/" + /*comentario*/ ctx[0].usuarioId);
    			set_style(a, "color", "var(--color6)", 1);
    			add_location(a, file$8, 142, 8, 5086);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);
    			append_dev(a, span);
    			append_dev(span, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*comentario*/ 1 && t_value !== (t_value = /*comentario*/ ctx[0].usuarioId.split("-")[0] + "")) set_data_dev(t, t_value);

    			if (dirty[0] & /*comentario*/ 1 && a_href_value !== (a_href_value = "/Moderacion/HistorialDeUsuario/" + /*comentario*/ ctx[0].usuarioId)) {
    				attr_dev(a, "href", a_href_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_6$1.name,
    		type: "if",
    		source: "(142:8) {#if comentario.usuarioId}",
    		ctx
    	});

    	return block;
    }

    // (153:16) <span slot="activador" on:click={() => mostrarMenu = true} class="">
    function create_activador_slot$3(ctx) {
    	let span;
    	let i;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			span = element("span");
    			i = element("i");
    			attr_dev(i, "class", "fe fe-more-vertical relative");
    			add_location(i, file$8, 152, 84, 5638);
    			attr_dev(span, "slot", "activador");
    			attr_dev(span, "class", " svelte-19kf1id");
    			add_location(span, file$8, 152, 16, 5570);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, i);

    			if (!mounted) {
    				dispose = listen_dev(span, "click", /*click_handler_3*/ ctx[26], false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_activador_slot$3.name,
    		type: "slot",
    		source: "(153:16) <span slot=\\\"activador\\\" on:click={() => mostrarMenu = true} class=\\\"\\\">",
    		ctx
    	});

    	return block;
    }

    // (156:16) {#if $globalStore.usuario.esAuxiliar}
    function create_if_block_3$1(ctx) {
    	let hr;
    	let t0;
    	let t1;
    	let menuitem;
    	let t2;
    	let current_block_type_index;
    	let if_block1;
    	let if_block1_anchor;
    	let current;
    	let if_block0 = /*comentario*/ ctx[0].hiloId && create_if_block_5$1(ctx);

    	menuitem = new jn({
    			props: {
    				$$slots: { default: [create_default_slot_3$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	menuitem.$on("click", /*click_handler_6*/ ctx[29]);
    	const if_block_creators = [create_if_block_4$1, create_else_block$1];
    	const if_blocks = [];

    	function select_block_type_1(ctx, dirty) {
    		if (/*comentario*/ ctx[0].estado == ComentarioEstado.normal) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_1(ctx);
    	if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			hr = element("hr");
    			t0 = space();
    			if (if_block0) if_block0.c();
    			t1 = space();
    			create_component(menuitem.$$.fragment);
    			t2 = space();
    			if_block1.c();
    			if_block1_anchor = empty();
    			add_location(hr, file$8, 156, 20, 5959);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, hr, anchor);
    			insert_dev(target, t0, anchor);
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(menuitem, target, anchor);
    			insert_dev(target, t2, anchor);
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*comentario*/ ctx[0].hiloId) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty[0] & /*comentario*/ 1) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_5$1(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(t1.parentNode, t1);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			const menuitem_changes = {};

    			if (dirty[1] & /*$$scope*/ 1024) {
    				menuitem_changes.$$scope = { dirty, ctx };
    			}

    			menuitem.$set(menuitem_changes);
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_1(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block1 = if_blocks[current_block_type_index];

    				if (!if_block1) {
    					if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block1.c();
    				}

    				transition_in(if_block1, 1);
    				if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(menuitem.$$.fragment, local);
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(menuitem.$$.fragment, local);
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(hr);
    			if (detaching) detach_dev(t0);
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(menuitem, detaching);
    			if (detaching) detach_dev(t2);
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$1.name,
    		type: "if",
    		source: "(156:16) {#if $globalStore.usuario.esAuxiliar}",
    		ctx
    	});

    	return block;
    }

    // (158:20) {#if comentario.hiloId}
    function create_if_block_5$1(ctx) {
    	let a;
    	let menuitem;
    	let a_href_value;
    	let current;

    	menuitem = new jn({
    			props: {
    				$$slots: { default: [create_default_slot_4$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			a = element("a");
    			create_component(menuitem.$$.fragment);
    			attr_dev(a, "href", a_href_value = "/Hilo/" + /*comentario*/ ctx[0].hiloId + "#" + /*comentario*/ ctx[0].id);
    			set_style(a, "color", "white", 1);
    			add_location(a, file$8, 158, 24, 6034);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);
    			mount_component(menuitem, a, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const menuitem_changes = {};

    			if (dirty[1] & /*$$scope*/ 1024) {
    				menuitem_changes.$$scope = { dirty, ctx };
    			}

    			menuitem.$set(menuitem_changes);

    			if (!current || dirty[0] & /*comentario*/ 1 && a_href_value !== (a_href_value = "/Hilo/" + /*comentario*/ ctx[0].hiloId + "#" + /*comentario*/ ctx[0].id)) {
    				attr_dev(a, "href", a_href_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(menuitem.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(menuitem.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    			destroy_component(menuitem);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5$1.name,
    		type: "if",
    		source: "(158:20) {#if comentario.hiloId}",
    		ctx
    	});

    	return block;
    }

    // (160:28) <Menuitem>
    function create_default_slot_4$2(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Ir");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$2.name,
    		type: "slot",
    		source: "(160:28) <Menuitem>",
    		ctx
    	});

    	return block;
    }

    // (163:20) <Menuitem on:click={() => abrir.ban(hilo.id || comentario.hiloId, comentario.id)} >
    function create_default_slot_3$4(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Banear");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$4.name,
    		type: "slot",
    		source: "(163:20) <Menuitem on:click={() => abrir.ban(hilo.id || comentario.hiloId, comentario.id)} >",
    		ctx
    	});

    	return block;
    }

    // (166:20) {:else}
    function create_else_block$1(ctx) {
    	let menuitem;
    	let current;

    	menuitem = new jn({
    			props: {
    				$$slots: { default: [create_default_slot_2$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	menuitem.$on("click", /*click_handler_8*/ ctx[31]);

    	const block = {
    		c: function create() {
    			create_component(menuitem.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(menuitem, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const menuitem_changes = {};

    			if (dirty[1] & /*$$scope*/ 1024) {
    				menuitem_changes.$$scope = { dirty, ctx };
    			}

    			menuitem.$set(menuitem_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(menuitem.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(menuitem.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(menuitem, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$1.name,
    		type: "else",
    		source: "(166:20) {:else}",
    		ctx
    	});

    	return block;
    }

    // (164:20) {#if comentario.estado == ComentarioEstado.normal}
    function create_if_block_4$1(ctx) {
    	let menuitem;
    	let current;

    	menuitem = new jn({
    			props: {
    				$$slots: { default: [create_default_slot_1$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	menuitem.$on("click", /*click_handler_7*/ ctx[30]);

    	const block = {
    		c: function create() {
    			create_component(menuitem.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(menuitem, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const menuitem_changes = {};

    			if (dirty[1] & /*$$scope*/ 1024) {
    				menuitem_changes.$$scope = { dirty, ctx };
    			}

    			menuitem.$set(menuitem_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(menuitem.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(menuitem.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(menuitem, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$1.name,
    		type: "if",
    		source: "(164:20) {#if comentario.estado == ComentarioEstado.normal}",
    		ctx
    	});

    	return block;
    }

    // (167:24) <Menuitem on:click={() => abrir.restaurarComentario(comentario.id)} >
    function create_default_slot_2$4(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Restaurar");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$4.name,
    		type: "slot",
    		source: "(167:24) <Menuitem on:click={() => abrir.restaurarComentario(comentario.id)} >",
    		ctx
    	});

    	return block;
    }

    // (165:20) <Menuitem on:click={() => abrir.eliminarComentarios([comentario.id])}>
    function create_default_slot_1$4(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Eliminar");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$4.name,
    		type: "slot",
    		source: "(165:20) <Menuitem on:click={() => abrir.eliminarComentarios([comentario.id])}>",
    		ctx
    	});

    	return block;
    }

    // (152:12) <Menu>
    function create_default_slot$5(ctx) {
    	let t0;
    	let li0;
    	let t1_value = (/*visible*/ ctx[8] ? "Ocultar" : "Mostrar") + "";
    	let t1;
    	let t2;
    	let li1;
    	let t4;
    	let if_block_anchor;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block = /*$globalStore*/ ctx[10].usuario.esAuxiliar && create_if_block_3$1(ctx);

    	const block = {
    		c: function create() {
    			t0 = space();
    			li0 = element("li");
    			t1 = text(t1_value);
    			t2 = space();
    			li1 = element("li");
    			li1.textContent = "Reportar";
    			t4 = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    			add_location(li0, file$8, 153, 16, 5707);
    			add_location(li1, file$8, 154, 16, 5789);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, li0, anchor);
    			append_dev(li0, t1);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, li1, anchor);
    			insert_dev(target, t4, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(li0, "click", /*click_handler_4*/ ctx[27], false, false, false),
    					listen_dev(li1, "click", /*click_handler_5*/ ctx[28], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[0] & /*visible*/ 256) && t1_value !== (t1_value = (/*visible*/ ctx[8] ? "Ocultar" : "Mostrar") + "")) set_data_dev(t1, t1_value);

    			if (/*$globalStore*/ ctx[10].usuario.esAuxiliar) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty[0] & /*$globalStore*/ 1024) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_3$1(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(li0);
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(li1);
    			if (detaching) detach_dev(t4);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$5.name,
    		type: "slot",
    		source: "(152:12) <Menu>",
    		ctx
    	});

    	return block;
    }

    // (176:4) {#if visible}
    function create_if_block_1$3(ctx) {
    	let div;
    	let t;
    	let span;
    	let raw_value = /*comentario*/ ctx[0].contenido + "";
    	let current;
    	let if_block = /*comentario*/ ctx[0].media && create_if_block_2$2(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block) if_block.c();
    			t = space();
    			span = element("span");
    			attr_dev(span, "class", "texto svelte-19kf1id");
    			add_location(span, file$8, 182, 12, 7068);
    			attr_dev(div, "class", "contenido svelte-19kf1id");
    			toggle_class(div, "mediaExpandido", /*mediaExpandido*/ ctx[7]);
    			add_location(div, file$8, 176, 8, 6847);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block) if_block.m(div, null);
    			append_dev(div, t);
    			append_dev(div, span);
    			span.innerHTML = raw_value;
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*comentario*/ ctx[0].media) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty[0] & /*comentario*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_2$2(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(div, t);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}

    			if ((!current || dirty[0] & /*comentario*/ 1) && raw_value !== (raw_value = /*comentario*/ ctx[0].contenido + "")) span.innerHTML = raw_value;
    			if (dirty[0] & /*mediaExpandido*/ 128) {
    				toggle_class(div, "mediaExpandido", /*mediaExpandido*/ ctx[7]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block) if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$3.name,
    		type: "if",
    		source: "(176:4) {#if visible}",
    		ctx
    	});

    	return block;
    }

    // (180:12) {#if comentario.media}
    function create_if_block_2$2(ctx) {
    	let media;
    	let updating_abierto;
    	let current;

    	function media_abierto_binding(value) {
    		/*media_abierto_binding*/ ctx[32].call(null, value);
    	}

    	let media_props = { media: /*comentario*/ ctx[0].media };

    	if (/*mediaExpandido*/ ctx[7] !== void 0) {
    		media_props.abierto = /*mediaExpandido*/ ctx[7];
    	}

    	media = new Media({ props: media_props, $$inline: true });
    	binding_callbacks.push(() => bind(media, "abierto", media_abierto_binding));

    	const block = {
    		c: function create() {
    			create_component(media.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(media, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const media_changes = {};
    			if (dirty[0] & /*comentario*/ 1) media_changes.media = /*comentario*/ ctx[0].media;

    			if (!updating_abierto && dirty[0] & /*mediaExpandido*/ 128) {
    				updating_abierto = true;
    				media_changes.abierto = /*mediaExpandido*/ ctx[7];
    				add_flush_callback(() => updating_abierto = false);
    			}

    			media.$set(media_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(media.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(media.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(media, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$2.name,
    		type: "if",
    		source: "(180:12) {#if comentario.media}",
    		ctx
    	});

    	return block;
    }

    // (188:4) {#if mostrandoRespuesta}
    function create_if_block$6(ctx) {
    	let div;
    	let comentario_1;
    	let div_transition;
    	let current;

    	comentario_1 = new Comentario({
    			props: {
    				comentario: /*respuestaMostrada*/ ctx[6],
    				esRespuesta: true
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(comentario_1.$$.fragment);
    			attr_dev(div, "class", "comentario-flotante");
    			add_location(div, file$8, 188, 8, 7222);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(comentario_1, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const comentario_1_changes = {};
    			if (dirty[0] & /*respuestaMostrada*/ 64) comentario_1_changes.comentario = /*respuestaMostrada*/ ctx[6];
    			comentario_1.$set(comentario_1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(comentario_1.$$.fragment, local);

    			if (local) {
    				add_render_callback(() => {
    					if (!div_transition) div_transition = create_bidirectional_transition(div, fly, { x: -50, duration: 150 }, true);
    					div_transition.run(1);
    				});
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(comentario_1.$$.fragment, local);

    			if (local) {
    				if (!div_transition) div_transition = create_bidirectional_transition(div, fly, { x: -50, duration: 150 }, false);
    				div_transition.run(0);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(comentario_1);
    			if (detaching && div_transition) div_transition.end();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$6.name,
    		type: "if",
    		source: "(188:4) {#if mostrandoRespuesta}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$8(ctx) {
    	let div5;
    	let div0;
    	let t0;
    	let div1;
    	let div1_class_value;
    	let t1;
    	let div3;
    	let t2;
    	let span0;
    	let t3_value = (/*comentario*/ ctx[0].nombre || "Gordo") + "";
    	let t3;
    	let t4;
    	let t5;
    	let t6;
    	let span1;
    	let t7_value = /*comentario*/ ctx[0].id + "";
    	let t7;
    	let t8;
    	let span2;
    	let tiempo;
    	let t9;
    	let div2;
    	let menu;
    	let t10;
    	let div4;
    	let t11;
    	let t12;
    	let div5_class_value;
    	let div5_r_id_value;
    	let div5_id_value;
    	let current;
    	let mounted;
    	let dispose;
    	let each_value = /*comentario*/ ctx[0].respuestas;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$4(get_each_context$4(ctx, each_value, i));
    	}

    	function select_block_type(ctx, dirty) {
    		if (/*comentario*/ ctx[0].dados != undefined && /*comentario*/ ctx[0].dados != -1) return create_if_block_9;
    		if (/*comentario*/ ctx[0].rango) return create_if_block_10;
    		return create_else_block_1$1;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block0 = current_block_type(ctx);
    	let if_block1 = /*comentario*/ ctx[0].esOp && create_if_block_8(ctx);
    	let if_block2 = /*comentario*/ ctx[0].idUnico && create_if_block_7$1(ctx);
    	let if_block3 = /*comentario*/ ctx[0].usuarioId && create_if_block_6$1(ctx);

    	tiempo = new Tiempo({
    			props: { date: /*comentario*/ ctx[0].creacion },
    			$$inline: true
    		});

    	menu = new Menu_1({
    			props: {
    				$$slots: {
    					default: [create_default_slot$5],
    					activador: [create_activador_slot$3]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	let if_block4 = /*visible*/ ctx[8] && create_if_block_1$3(ctx);
    	let if_block5 = /*mostrandoRespuesta*/ ctx[5] && create_if_block$6(ctx);

    	const block = {
    		c: function create() {
    			div5 = element("div");
    			div0 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t0 = space();
    			div1 = element("div");
    			if_block0.c();
    			t1 = space();
    			div3 = element("div");
    			if (if_block1) if_block1.c();
    			t2 = space();
    			span0 = element("span");
    			t3 = text(t3_value);
    			t4 = space();
    			if (if_block2) if_block2.c();
    			t5 = space();
    			if (if_block3) if_block3.c();
    			t6 = space();
    			span1 = element("span");
    			t7 = text(t7_value);
    			t8 = space();
    			span2 = element("span");
    			create_component(tiempo.$$.fragment);
    			t9 = space();
    			div2 = element("div");
    			create_component(menu.$$.fragment);
    			t10 = space();
    			div4 = element("div");
    			t11 = space();
    			if (if_block4) if_block4.c();
    			t12 = space();
    			if (if_block5) if_block5.c();
    			attr_dev(div0, "class", "respuestas svelte-19kf1id");
    			add_location(div0, file$8, 107, 4, 3643);
    			attr_dev(div1, "class", div1_class_value = "color color-" + /*comentario*/ ctx[0].color + " ns" + " svelte-19kf1id");
    			toggle_class(div1, "dado", /*comentario*/ ctx[0].dados != undefined && /*comentario*/ ctx[0].dados != -1);
    			add_location(div1, file$8, 115, 4, 3951);
    			attr_dev(span0, "class", "nick nombre cptr svelte-19kf1id");
    			toggle_class(span0, "nombreResaltado", /*comentario*/ ctx[0].nombre);
    			add_location(span0, file$8, 129, 8, 4526);
    			attr_dev(span1, "class", "id tag ns svelte-19kf1id");
    			add_location(span1, file$8, 147, 8, 5356);
    			attr_dev(span2, "class", "tiempo svelte-19kf1id");
    			add_location(span2, file$8, 148, 8, 5451);
    			add_location(div2, file$8, 150, 8, 5527);
    			attr_dev(div3, "class", "header svelte-19kf1id");
    			add_location(div3, file$8, 127, 4, 4420);
    			attr_dev(div4, "class", "respuestas svelte-19kf1id");
    			add_location(div4, file$8, 173, 4, 6782);
    			attr_dev(div5, "class", div5_class_value = "comentario " + (/*windowsWidh*/ ctx[12] <= 400 ? "comentario-movil" : "") + " svelte-19kf1id");
    			attr_dev(div5, "r-id", div5_r_id_value = /*comentario*/ ctx[0].id);
    			attr_dev(div5, "id", div5_id_value = "" + (/*comentario*/ ctx[0].id + (/*esRespuesta*/ ctx[3] ? "-res" : "")));
    			toggle_class(div5, "resaltado", /*comentario*/ ctx[0].resaltado || /*resaltado*/ ctx[2] || /*$selectorStore*/ ctx[11].seleccionados.has(/*comentario*/ ctx[0].id));
    			toggle_class(div5, "eliminado", /*comentario*/ ctx[0].estado == ComentarioEstado.eliminado);
    			toggle_class(div5, "comentarioMod", /*comentario*/ ctx[0].rango > CreacionRango.Anon);
    			add_location(div5, file$8, 101, 0, 3228);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div5, anchor);
    			append_dev(div5, div0);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div0, null);
    			}

    			append_dev(div5, t0);
    			append_dev(div5, div1);
    			if_block0.m(div1, null);
    			append_dev(div5, t1);
    			append_dev(div5, div3);
    			if (if_block1) if_block1.m(div3, null);
    			append_dev(div3, t2);
    			append_dev(div3, span0);
    			append_dev(span0, t3);
    			append_dev(div3, t4);
    			if (if_block2) if_block2.m(div3, null);
    			append_dev(div3, t5);
    			if (if_block3) if_block3.m(div3, null);
    			append_dev(div3, t6);
    			append_dev(div3, span1);
    			append_dev(span1, t7);
    			append_dev(div3, t8);
    			append_dev(div3, span2);
    			mount_component(tiempo, span2, null);
    			append_dev(div3, t9);
    			append_dev(div3, div2);
    			mount_component(menu, div2, null);
    			append_dev(div5, t10);
    			append_dev(div5, div4);
    			append_dev(div5, t11);
    			if (if_block4) if_block4.m(div5, null);
    			append_dev(div5, t12);
    			if (if_block5) if_block5.m(div5, null);
    			/*div5_binding*/ ctx[33](div5);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(div1, "click", /*click_handler*/ ctx[23], false, false, false),
    					listen_dev(span0, "click", /*seleccionar*/ ctx[17], false, false, false),
    					listen_dev(span1, "click", /*click_handler_2*/ ctx[25], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*comentario, mostrarRespuesta, ocultarRespuesta, esOp*/ 573441) {
    				each_value = /*comentario*/ ctx[0].respuestas;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$4(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$4(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div0, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block0) {
    				if_block0.p(ctx, dirty);
    			} else {
    				if_block0.d(1);
    				if_block0 = current_block_type(ctx);

    				if (if_block0) {
    					if_block0.c();
    					if_block0.m(div1, null);
    				}
    			}

    			if (!current || dirty[0] & /*comentario*/ 1 && div1_class_value !== (div1_class_value = "color color-" + /*comentario*/ ctx[0].color + " ns" + " svelte-19kf1id")) {
    				attr_dev(div1, "class", div1_class_value);
    			}

    			if (dirty[0] & /*comentario, comentario*/ 1) {
    				toggle_class(div1, "dado", /*comentario*/ ctx[0].dados != undefined && /*comentario*/ ctx[0].dados != -1);
    			}

    			if (/*comentario*/ ctx[0].esOp) {
    				if (if_block1) ; else {
    					if_block1 = create_if_block_8(ctx);
    					if_block1.c();
    					if_block1.m(div3, t2);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if ((!current || dirty[0] & /*comentario*/ 1) && t3_value !== (t3_value = (/*comentario*/ ctx[0].nombre || "Gordo") + "")) set_data_dev(t3, t3_value);

    			if (dirty[0] & /*comentario*/ 1) {
    				toggle_class(span0, "nombreResaltado", /*comentario*/ ctx[0].nombre);
    			}

    			if (/*comentario*/ ctx[0].idUnico) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);

    					if (dirty[0] & /*comentario*/ 1) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block_7$1(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(div3, t5);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}

    			if (/*comentario*/ ctx[0].usuarioId) {
    				if (if_block3) {
    					if_block3.p(ctx, dirty);
    				} else {
    					if_block3 = create_if_block_6$1(ctx);
    					if_block3.c();
    					if_block3.m(div3, t6);
    				}
    			} else if (if_block3) {
    				if_block3.d(1);
    				if_block3 = null;
    			}

    			if ((!current || dirty[0] & /*comentario*/ 1) && t7_value !== (t7_value = /*comentario*/ ctx[0].id + "")) set_data_dev(t7, t7_value);
    			const tiempo_changes = {};
    			if (dirty[0] & /*comentario*/ 1) tiempo_changes.date = /*comentario*/ ctx[0].creacion;
    			tiempo.$set(tiempo_changes);
    			const menu_changes = {};

    			if (dirty[0] & /*comentario, hilo, $globalStore, visible, mostrarMenu*/ 1795 | dirty[1] & /*$$scope*/ 1024) {
    				menu_changes.$$scope = { dirty, ctx };
    			}

    			menu.$set(menu_changes);

    			if (/*visible*/ ctx[8]) {
    				if (if_block4) {
    					if_block4.p(ctx, dirty);

    					if (dirty[0] & /*visible*/ 256) {
    						transition_in(if_block4, 1);
    					}
    				} else {
    					if_block4 = create_if_block_1$3(ctx);
    					if_block4.c();
    					transition_in(if_block4, 1);
    					if_block4.m(div5, t12);
    				}
    			} else if (if_block4) {
    				group_outros();

    				transition_out(if_block4, 1, 1, () => {
    					if_block4 = null;
    				});

    				check_outros();
    			}

    			if (/*mostrandoRespuesta*/ ctx[5]) {
    				if (if_block5) {
    					if_block5.p(ctx, dirty);

    					if (dirty[0] & /*mostrandoRespuesta*/ 32) {
    						transition_in(if_block5, 1);
    					}
    				} else {
    					if_block5 = create_if_block$6(ctx);
    					if_block5.c();
    					transition_in(if_block5, 1);
    					if_block5.m(div5, null);
    				}
    			} else if (if_block5) {
    				group_outros();

    				transition_out(if_block5, 1, 1, () => {
    					if_block5 = null;
    				});

    				check_outros();
    			}

    			if (!current || dirty[0] & /*comentario*/ 1 && div5_r_id_value !== (div5_r_id_value = /*comentario*/ ctx[0].id)) {
    				attr_dev(div5, "r-id", div5_r_id_value);
    			}

    			if (!current || dirty[0] & /*comentario, esRespuesta*/ 9 && div5_id_value !== (div5_id_value = "" + (/*comentario*/ ctx[0].id + (/*esRespuesta*/ ctx[3] ? "-res" : "")))) {
    				attr_dev(div5, "id", div5_id_value);
    			}

    			if (dirty[0] & /*comentario, resaltado, $selectorStore*/ 2053) {
    				toggle_class(div5, "resaltado", /*comentario*/ ctx[0].resaltado || /*resaltado*/ ctx[2] || /*$selectorStore*/ ctx[11].seleccionados.has(/*comentario*/ ctx[0].id));
    			}

    			if (dirty[0] & /*comentario*/ 1) {
    				toggle_class(div5, "eliminado", /*comentario*/ ctx[0].estado == ComentarioEstado.eliminado);
    			}

    			if (dirty[0] & /*comentario*/ 1) {
    				toggle_class(div5, "comentarioMod", /*comentario*/ ctx[0].rango > CreacionRango.Anon);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block2);
    			transition_in(tiempo.$$.fragment, local);
    			transition_in(menu.$$.fragment, local);
    			transition_in(if_block4);
    			transition_in(if_block5);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block2);
    			transition_out(tiempo.$$.fragment, local);
    			transition_out(menu.$$.fragment, local);
    			transition_out(if_block4);
    			transition_out(if_block5);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div5);
    			destroy_each(each_blocks, detaching);
    			if_block0.d();
    			if (if_block1) if_block1.d();
    			if (if_block2) if_block2.d();
    			if (if_block3) if_block3.d();
    			destroy_component(tiempo);
    			destroy_component(menu);
    			if (if_block4) if_block4.d();
    			if (if_block5) if_block5.d();
    			/*div5_binding*/ ctx[33](null);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$8.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$8($$self, $$props, $$invalidate) {
    	let $globalStore;
    	let $comentarioStore;
    	let $selectorStore;
    	validate_store(globalStore, "globalStore");
    	component_subscribe($$self, globalStore, $$value => $$invalidate(10, $globalStore = $$value));
    	validate_store(comentarioStore, "comentarioStore");
    	component_subscribe($$self, comentarioStore, $$value => $$invalidate(34, $comentarioStore = $$value));
    	validate_store(selectorStore, "selectorStore");
    	component_subscribe($$self, selectorStore, $$value => $$invalidate(11, $selectorStore = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Comentario", slots, []);
    	let { comentario } = $$props;
    	let { hilo = { id: null } } = $$props;
    	let { comentariosDic = {} } = $$props;
    	let { resaltado = false } = $$props;
    	let { esRespuesta = false } = $$props;
    	comentario.estado = comentario.estado || ComentarioEstado.normal;
    	let el;
    	let respuestas;
    	let mostrandoRespuesta = false;
    	let respuestaMostrada;
    	let mediaExpandido = false;
    	let windowsWidh = window.screen.width;
    	let visible = !$globalStore.comentariosOcultos.has(comentario.id);
    	let dispatch = createEventDispatcher();
    	let mostrarMenu = false;

    	onMount(() => {
    		let respuestas = el.querySelectorAll(".restag");

    		respuestas.forEach(r => {
    			r.addEventListener("mouseover", () => mostrarRespuesta(r.getAttribute("r-id").trim()));
    			r.addEventListener("mouseleave", ocultarRespuesta);
    			r.addEventListener("click", () => resaltarCliqueado(r.getAttribute("r-id").trim()));
    		});
    	});

    	function mostrarRespuesta(id) {
    		if (!comentariosDic[id]) return;
    		$$invalidate(5, mostrandoRespuesta = true);
    		$$invalidate(6, respuestaMostrada = comentariosDic[id]);
    	}

    	function resaltarCliqueado(id) {
    		dispatch("tagClickeado", id);
    	}

    	function ocultarRespuesta() {
    		$$invalidate(5, mostrandoRespuesta = false);
    	}

    	function toggle() {
    		if (visible) {
    			$globalStore.comentariosOcultos.set(comentario.id, true);
    		} else {
    			$globalStore.comentariosOcultos.delete(comentario.id);
    		}

    		globalStore.set($globalStore);
    		$$invalidate(8, visible = !visible);
    	}

    	function seleccionar() {
    		if (!$globalStore.usuario.esMod) return;
    		selectorStore.selecionar(comentario.id);
    	}

    	let mostrarReporte = true;
    	if (!Array.isArray(comentario.respuestas)) comentario.respuestas = [];

    	function tagear(id) {
    		if (!$comentarioStore.includes(`>>${comentario.id}\n`)) set_store_value(comentarioStore, $comentarioStore += `>>${comentario.id}\n`, $comentarioStore);
    	}

    	function esOp(comentarioId) {
    		let comentario = comentariosDic[comentarioId] || { esOp: false }; //??quitado
    		return comentario.esOp;
    	}

    	function idUnicoColor() {
    		let coloresPosibles = [
    			"#7bd800",
    			"#00d87e",
    			"#006ad8",
    			"#3500d8",
    			"#8500d8",
    			"#d80096",
    			"#737679",
    			"#5d130b",
    			"#ec64e2",
    			"#ff5722"
    		];

    		let n = comentario.idUnico.charCodeAt(0) + comentario.idUnico.charCodeAt(1) + comentario.idUnico.charCodeAt(2);
    		return coloresPosibles[n % coloresPosibles.length - 1];
    	}

    	const writable_props = ["comentario", "hilo", "comentariosDic", "resaltado", "esRespuesta"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Comentario> was created with unknown prop '${key}'`);
    	});

    	const mouseover_handler = r => mostrarRespuesta(r);
    	const click_handler = () => dispatch("colorClick", comentario);
    	const click_handler_1 = () => dispatch("idUnicoClickeado", comentario.idUnico);
    	const click_handler_2 = () => tagear(comentario.id);
    	const click_handler_3 = () => $$invalidate(9, mostrarMenu = true);
    	const click_handler_4 = () => toggle();
    	const click_handler_5 = () => abrir.reporte(hilo.id || comentario.hiloId, comentario.id);
    	const click_handler_6 = () => abrir.ban(hilo.id || comentario.hiloId, comentario.id);
    	const click_handler_7 = () => abrir.eliminarComentarios([comentario.id]);
    	const click_handler_8 = () => abrir.restaurarComentario(comentario.id);

    	function media_abierto_binding(value) {
    		mediaExpandido = value;
    		$$invalidate(7, mediaExpandido);
    	}

    	function div5_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			el = $$value;
    			$$invalidate(4, el);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ("comentario" in $$props) $$invalidate(0, comentario = $$props.comentario);
    		if ("hilo" in $$props) $$invalidate(1, hilo = $$props.hilo);
    		if ("comentariosDic" in $$props) $$invalidate(21, comentariosDic = $$props.comentariosDic);
    		if ("resaltado" in $$props) $$invalidate(2, resaltado = $$props.resaltado);
    		if ("esRespuesta" in $$props) $$invalidate(3, esRespuesta = $$props.esRespuesta);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		createEventDispatcher,
    		Menuitem: jn,
    		Button: ye,
    		Icon: Me,
    		Ripple: he,
    		Menu: Menu_1,
    		comentarioStore,
    		fly,
    		Tiempo,
    		globalStore,
    		Media,
    		abrir,
    		ComentarioEstado,
    		CreacionRango,
    		selectorStore,
    		comentario,
    		hilo,
    		comentariosDic,
    		resaltado,
    		esRespuesta,
    		el,
    		respuestas,
    		mostrandoRespuesta,
    		respuestaMostrada,
    		mediaExpandido,
    		windowsWidh,
    		visible,
    		dispatch,
    		mostrarMenu,
    		mostrarRespuesta,
    		resaltarCliqueado,
    		ocultarRespuesta,
    		toggle,
    		seleccionar,
    		mostrarReporte,
    		tagear,
    		esOp,
    		idUnicoColor,
    		$globalStore,
    		$comentarioStore,
    		$selectorStore
    	});

    	$$self.$inject_state = $$props => {
    		if ("comentario" in $$props) $$invalidate(0, comentario = $$props.comentario);
    		if ("hilo" in $$props) $$invalidate(1, hilo = $$props.hilo);
    		if ("comentariosDic" in $$props) $$invalidate(21, comentariosDic = $$props.comentariosDic);
    		if ("resaltado" in $$props) $$invalidate(2, resaltado = $$props.resaltado);
    		if ("esRespuesta" in $$props) $$invalidate(3, esRespuesta = $$props.esRespuesta);
    		if ("el" in $$props) $$invalidate(4, el = $$props.el);
    		if ("respuestas" in $$props) respuestas = $$props.respuestas;
    		if ("mostrandoRespuesta" in $$props) $$invalidate(5, mostrandoRespuesta = $$props.mostrandoRespuesta);
    		if ("respuestaMostrada" in $$props) $$invalidate(6, respuestaMostrada = $$props.respuestaMostrada);
    		if ("mediaExpandido" in $$props) $$invalidate(7, mediaExpandido = $$props.mediaExpandido);
    		if ("windowsWidh" in $$props) $$invalidate(12, windowsWidh = $$props.windowsWidh);
    		if ("visible" in $$props) $$invalidate(8, visible = $$props.visible);
    		if ("dispatch" in $$props) $$invalidate(13, dispatch = $$props.dispatch);
    		if ("mostrarMenu" in $$props) $$invalidate(9, mostrarMenu = $$props.mostrarMenu);
    		if ("mostrarReporte" in $$props) mostrarReporte = $$props.mostrarReporte;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		comentario,
    		hilo,
    		resaltado,
    		esRespuesta,
    		el,
    		mostrandoRespuesta,
    		respuestaMostrada,
    		mediaExpandido,
    		visible,
    		mostrarMenu,
    		$globalStore,
    		$selectorStore,
    		windowsWidh,
    		dispatch,
    		mostrarRespuesta,
    		ocultarRespuesta,
    		toggle,
    		seleccionar,
    		tagear,
    		esOp,
    		idUnicoColor,
    		comentariosDic,
    		mouseover_handler,
    		click_handler,
    		click_handler_1,
    		click_handler_2,
    		click_handler_3,
    		click_handler_4,
    		click_handler_5,
    		click_handler_6,
    		click_handler_7,
    		click_handler_8,
    		media_abierto_binding,
    		div5_binding
    	];
    }

    class Comentario extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(
    			this,
    			options,
    			instance$8,
    			create_fragment$8,
    			safe_not_equal,
    			{
    				comentario: 0,
    				hilo: 1,
    				comentariosDic: 21,
    				resaltado: 2,
    				esRespuesta: 3
    			},
    			[-1, -1]
    		);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Comentario",
    			options,
    			id: create_fragment$8.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*comentario*/ ctx[0] === undefined && !("comentario" in props)) {
    			console.warn("<Comentario> was created without expected prop 'comentario'");
    		}
    	}

    	get comentario() {
    		throw new Error("<Comentario>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set comentario(value) {
    		throw new Error("<Comentario>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get hilo() {
    		throw new Error("<Comentario>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set hilo(value) {
    		throw new Error("<Comentario>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get comentariosDic() {
    		throw new Error("<Comentario>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set comentariosDic(value) {
    		throw new Error("<Comentario>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get resaltado() {
    		throw new Error("<Comentario>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set resaltado(value) {
    		throw new Error("<Comentario>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get esRespuesta() {
    		throw new Error("<Comentario>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set esRespuesta(value) {
    		throw new Error("<Comentario>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\components\MediaInput.svelte generated by Svelte v3.29.0 */

    const { console: console_1$2 } = globals;
    const file$9 = "src\\components\\MediaInput.svelte";

    // (107:4) {#if mediaType == MediaType.Video && media.archivo}
    function create_if_block_3$2(ctx) {
    	let video;
    	let video_src_value;

    	const block = {
    		c: function create() {
    			video = element("video");
    			if (video.src !== (video_src_value = /*archivoBlob*/ ctx[2])) attr_dev(video, "src", video_src_value);
    			attr_dev(video, "class", "svelte-1c7ojhi");
    			add_location(video, file$9, 107, 8, 3151);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, video, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*archivoBlob*/ 4 && video.src !== (video_src_value = /*archivoBlob*/ ctx[2])) {
    				attr_dev(video, "src", video_src_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(video);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$2.name,
    		type: "if",
    		source: "(107:4) {#if mediaType == MediaType.Video && media.archivo}",
    		ctx
    	});

    	return block;
    }

    // (111:4) {#if estado=="importarLink"}
    function create_if_block_2$3(ctx) {
    	let div;
    	let input_1;
    	let t0;
    	let button0;
    	let t1;
    	let button1;
    	let current;
    	let mounted;
    	let dispose;

    	button0 = new ye({
    			props: {
    				outlined: true,
    				shaped: true,
    				$$slots: { default: [create_default_slot_5$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button0.$on("click", /*importarVideo*/ ctx[9]);

    	button1 = new ye({
    			props: {
    				outlined: true,
    				shaped: true,
    				$$slots: { default: [create_default_slot_4$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button1.$on("click", /*click_handler*/ ctx[14]);

    	const block = {
    		c: function create() {
    			div = element("div");
    			input_1 = element("input");
    			t0 = space();
    			create_component(button0.$$.fragment);
    			t1 = space();
    			create_component(button1.$$.fragment);
    			attr_dev(input_1, "type", "text");
    			attr_dev(input_1, "placeholder", "Ingrese link de iutube");
    			add_location(input_1, file$9, 112, 8, 3273);
    			attr_dev(div, "class", "link-input svelte-1c7ojhi");
    			add_location(div, file$9, 111, 4, 3239);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, input_1);
    			set_input_value(input_1, /*inputLink*/ ctx[6]);
    			append_dev(div, t0);
    			mount_component(button0, div, null);
    			append_dev(div, t1);
    			mount_component(button1, div, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(input_1, "input", /*input_1_input_handler*/ ctx[13]);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*inputLink*/ 64 && input_1.value !== /*inputLink*/ ctx[6]) {
    				set_input_value(input_1, /*inputLink*/ ctx[6]);
    			}

    			const button0_changes = {};

    			if (dirty & /*$$scope*/ 1048576) {
    				button0_changes.$$scope = { dirty, ctx };
    			}

    			button0.$set(button0_changes);
    			const button1_changes = {};

    			if (dirty & /*$$scope*/ 1048576) {
    				button1_changes.$$scope = { dirty, ctx };
    			}

    			button1.$set(button1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button0.$$.fragment, local);
    			transition_in(button1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button0.$$.fragment, local);
    			transition_out(button1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(button0);
    			destroy_component(button1);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$3.name,
    		type: "if",
    		source: "(111:4) {#if estado==\\\"importarLink\\\"}",
    		ctx
    	});

    	return block;
    }

    // (114:12) <Button  outlined shaped={true} on:click={importarVideo}>
    function create_default_slot_5$1(ctx) {
    	let icon;

    	const block = {
    		c: function create() {
    			icon = element("icon");
    			icon.textContent = "OK";
    			add_location(icon, file$9, 114, 20, 3446);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, icon, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(icon);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5$1.name,
    		type: "slot",
    		source: "(114:12) <Button  outlined shaped={true} on:click={importarVideo}>",
    		ctx
    	});

    	return block;
    }

    // (117:12) <Button  outlined shaped={true} on:click={() => estado = "vacio" }>
    function create_default_slot_4$3(ctx) {
    	let icon;

    	const block = {
    		c: function create() {
    			icon = element("icon");
    			icon.textContent = "x";
    			add_location(icon, file$9, 117, 20, 3588);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, icon, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(icon);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$3.name,
    		type: "slot",
    		source: "(117:12) <Button  outlined shaped={true} on:click={() => estado = \\\"vacio\\\" }>",
    		ctx
    	});

    	return block;
    }

    // (122:4) {#if !media.archivo && estado=="vacio"}
    function create_if_block_1$4(ctx) {
    	let span;
    	let t;
    	let buttongroup;
    	let current;

    	buttongroup = new $e({
    			props: {
    				$$slots: { default: [create_default_slot_1$5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = text("Agrega un archivo:\r\n            ");
    			create_component(buttongroup.$$.fragment);
    			attr_dev(span, "class", "opciones svelte-1c7ojhi");
    			add_location(span, file$9, 122, 8, 3703);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);
    			mount_component(buttongroup, span, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const buttongroup_changes = {};

    			if (dirty & /*$$scope, estado, input*/ 1048712) {
    				buttongroup_changes.$$scope = { dirty, ctx };
    			}

    			buttongroup.$set(buttongroup_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(buttongroup.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(buttongroup.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			destroy_component(buttongroup);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$4.name,
    		type: "if",
    		source: "(122:4) {#if !media.archivo && estado==\\\"vacio\\\"}",
    		ctx
    	});

    	return block;
    }

    // (126:16) <Button on:click={() => input.click()} icon outlined shaped={true} on:click={() => true}>
    function create_default_slot_3$5(ctx) {
    	let icon;

    	const block = {
    		c: function create() {
    			icon = element("icon");
    			attr_dev(icon, "class", "fe fe-upload");
    			add_location(icon, file$9, 126, 21, 3916);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, icon, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(icon);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$5.name,
    		type: "slot",
    		source: "(126:16) <Button on:click={() => input.click()} icon outlined shaped={true} on:click={() => true}>",
    		ctx
    	});

    	return block;
    }

    // (129:16) <Button  icon outlined shaped={true} on:click={() => estado="importarLink"}>
    function create_default_slot_2$5(ctx) {
    	let icon;

    	const block = {
    		c: function create() {
    			icon = element("icon");
    			attr_dev(icon, "class", "fe fe-youtube");
    			add_location(icon, file$9, 129, 21, 4095);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, icon, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(icon);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$5.name,
    		type: "slot",
    		source: "(129:16) <Button  icon outlined shaped={true} on:click={() => estado=\\\"importarLink\\\"}>",
    		ctx
    	});

    	return block;
    }

    // (125:12) <ButtonGroup>
    function create_default_slot_1$5(ctx) {
    	let button0;
    	let t;
    	let button1;
    	let current;

    	button0 = new ye({
    			props: {
    				icon: true,
    				outlined: true,
    				shaped: true,
    				$$slots: { default: [create_default_slot_3$5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button0.$on("click", /*click_handler_1*/ ctx[15]);
    	button0.$on("click", click_handler_2);

    	button1 = new ye({
    			props: {
    				icon: true,
    				outlined: true,
    				shaped: true,
    				$$slots: { default: [create_default_slot_2$5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button1.$on("click", /*click_handler_3*/ ctx[16]);

    	const block = {
    		c: function create() {
    			create_component(button0.$$.fragment);
    			t = space();
    			create_component(button1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(button0, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(button1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button0_changes = {};

    			if (dirty & /*$$scope*/ 1048576) {
    				button0_changes.$$scope = { dirty, ctx };
    			}

    			button0.$set(button0_changes);
    			const button1_changes = {};

    			if (dirty & /*$$scope*/ 1048576) {
    				button1_changes.$$scope = { dirty, ctx };
    			}

    			button1.$set(button1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button0.$$.fragment, local);
    			transition_in(button1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button0.$$.fragment, local);
    			transition_out(button1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(button0, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(button1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$5.name,
    		type: "slot",
    		source: "(125:12) <ButtonGroup>",
    		ctx
    	});

    	return block;
    }

    // (135:4) {#if media.archivo || media.link}
    function create_if_block$7(ctx) {
    	let button;
    	let current;

    	button = new ye({
    			props: {
    				class: "cancelar",
    				icon: true,
    				outlined: true,
    				shaped: true,
    				$$slots: { default: [create_default_slot$6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button.$on("click", /*removerArchivo*/ ctx[10]);
    	button.$on("click", click_handler_4);

    	const block = {
    		c: function create() {
    			create_component(button.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(button, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button_changes = {};

    			if (dirty & /*$$scope*/ 1048576) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(button, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$7.name,
    		type: "if",
    		source: "(135:4) {#if media.archivo || media.link}",
    		ctx
    	});

    	return block;
    }

    // (136:8) <Button class="cancelar" on:click={removerArchivo} icon outlined shaped={true} on:click={() => true}>
    function create_default_slot$6(ctx) {
    	let icon;

    	const block = {
    		c: function create() {
    			icon = element("icon");
    			attr_dev(icon, "class", "fe fe-x");
    			add_location(icon, file$9, 136, 12, 4382);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, icon, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(icon);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$6.name,
    		type: "slot",
    		source: "(136:8) <Button class=\\\"cancelar\\\" on:click={removerArchivo} icon outlined shaped={true} on:click={() => true}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$9(ctx) {
    	let input_1;
    	let t0;
    	let div;
    	let t1;
    	let t2;
    	let t3;
    	let div_style_value;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block0 = /*mediaType*/ ctx[4] == MediaType.Video && /*media*/ ctx[0].archivo && create_if_block_3$2(ctx);
    	let if_block1 = /*estado*/ ctx[7] == "importarLink" && create_if_block_2$3(ctx);
    	let if_block2 = !/*media*/ ctx[0].archivo && /*estado*/ ctx[7] == "vacio" && create_if_block_1$4(ctx);
    	let if_block3 = (/*media*/ ctx[0].archivo || /*media*/ ctx[0].link) && create_if_block$7(ctx);

    	const block = {
    		c: function create() {
    			input_1 = element("input");
    			t0 = space();
    			div = element("div");
    			if (if_block0) if_block0.c();
    			t1 = space();
    			if (if_block1) if_block1.c();
    			t2 = space();
    			if (if_block2) if_block2.c();
    			t3 = space();
    			if (if_block3) if_block3.c();
    			attr_dev(input_1, "name", "archivo");
    			attr_dev(input_1, "type", "file");
    			attr_dev(input_1, "id", "hilo-input");
    			set_style(input_1, "position", "absolute");
    			set_style(input_1, "top", "-1000px");
    			add_location(input_1, file$9, 92, 0, 2648);
    			attr_dev(div, "class", "video-preview media-input svelte-1c7ojhi");

    			attr_dev(div, "style", div_style_value = "" + (((/*media*/ ctx[0].archivo || /*media*/ ctx[0].link) && /*mediaType*/ ctx[4] != MediaType.Video
    			? `background:url(${/*archivoBlob*/ ctx[2] || /*media*/ ctx[0]})`
    			: "background:url(/imagenes/rose2.jpg)") + ";overflow:hidden;"));

    			toggle_class(div, "compacto", /*compacto*/ ctx[1]);
    			add_location(div, file$9, 101, 0, 2826);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, input_1, anchor);
    			/*input_1_binding*/ ctx[12](input_1);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div, anchor);
    			if (if_block0) if_block0.m(div, null);
    			append_dev(div, t1);
    			if (if_block1) if_block1.m(div, null);
    			append_dev(div, t2);
    			if (if_block2) if_block2.m(div, null);
    			append_dev(div, t3);
    			if (if_block3) if_block3.m(div, null);
    			/*div_binding*/ ctx[17](div);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(input_1, "change", /*actualizarArchivo*/ ctx[8], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*mediaType*/ ctx[4] == MediaType.Video && /*media*/ ctx[0].archivo) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_3$2(ctx);
    					if_block0.c();
    					if_block0.m(div, t1);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (/*estado*/ ctx[7] == "importarLink") {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty & /*estado*/ 128) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_2$3(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div, t2);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (!/*media*/ ctx[0].archivo && /*estado*/ ctx[7] == "vacio") {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);

    					if (dirty & /*media, estado*/ 129) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block_1$4(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(div, t3);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}

    			if (/*media*/ ctx[0].archivo || /*media*/ ctx[0].link) {
    				if (if_block3) {
    					if_block3.p(ctx, dirty);

    					if (dirty & /*media*/ 1) {
    						transition_in(if_block3, 1);
    					}
    				} else {
    					if_block3 = create_if_block$7(ctx);
    					if_block3.c();
    					transition_in(if_block3, 1);
    					if_block3.m(div, null);
    				}
    			} else if (if_block3) {
    				group_outros();

    				transition_out(if_block3, 1, 1, () => {
    					if_block3 = null;
    				});

    				check_outros();
    			}

    			if (!current || dirty & /*media, mediaType, archivoBlob*/ 21 && div_style_value !== (div_style_value = "" + (((/*media*/ ctx[0].archivo || /*media*/ ctx[0].link) && /*mediaType*/ ctx[4] != MediaType.Video
    			? `background:url(${/*archivoBlob*/ ctx[2] || /*media*/ ctx[0]})`
    			: "background:url(/imagenes/rose2.jpg)") + ";overflow:hidden;"))) {
    				attr_dev(div, "style", div_style_value);
    			}

    			if (dirty & /*compacto*/ 2) {
    				toggle_class(div, "compacto", /*compacto*/ ctx[1]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block1);
    			transition_in(if_block2);
    			transition_in(if_block3);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block1);
    			transition_out(if_block2);
    			transition_out(if_block3);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(input_1);
    			/*input_1_binding*/ ctx[12](null);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (if_block2) if_block2.d();
    			if (if_block3) if_block3.d();
    			/*div_binding*/ ctx[17](null);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$9.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const youtubeRegex = /(?:youtube\.com\/\S*(?:(?:\/e(?:mbed))?\/|watch\?(?:\S*?&?v\=))|youtu\.be\/)([a-zA-Z0-9_-]{6,11})/;

    async function getBlobFromInput(input) {
    	return new Promise((resolve, reject) => {
    			if (!(input.files && input.files[0])) return null;
    			let blob;
    			let reader = new FileReader();

    			reader.onload = function (e) {
    				blob = e.target.result;
    				resolve(blob);
    			};

    			reader.readAsDataURL(input.files[0]);
    		});
    }

    const click_handler_2 = () => true;
    const click_handler_4 = () => true;

    function instance$9($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("MediaInput", slots, []);
    	let { compacto = false } = $$props;
    	let { media = { archivo: null, link: "" } } = $$props;
    	let { videoUrl = null } = $$props;
    	let vistaPreviaYoutube = "";
    	let menuLink = false;
    	let archivoBlob = null;
    	let input = null;
    	let mediaType = MediaType.Imagen;
    	let el;
    	let inputLink = "";
    	let estado = "vacio"; // importarLink | cargado

    	async function actualizarArchivo() {
    		if (input.files && input.files[0]) {
    			$$invalidate(2, archivoBlob = await getBlobFromInput(input));
    			$$invalidate(0, media.archivo = input.files[0], media);

    			if (input.files[0].type.indexOf("image") != -1) {
    				$$invalidate(4, mediaType = MediaType.Imagen);
    			} else if (input.files[0].type.indexOf("video") != -1) {
    				$$invalidate(4, mediaType = MediaType.Video);
    			}
    		}
    	}

    	async function importarVideo() {
    		let id = inputLink.match(youtubeRegex);
    		console.log(id);

    		if (!id) {
    			$$invalidate(6, inputLink = "Link invalido");
    			return;
    		}

    		$$invalidate(4, mediaType = MediaType.Youtube);
    		vistaPreviaYoutube = `https://img.youtube.com/vi/${id[1]}/hqdefault.jpg`;
    		$$invalidate(11, videoUrl = inputLink);
    		$$invalidate(2, archivoBlob = `https://img.youtube.com/vi/${id[1]}/hqdefault.jpg`);
    		$$invalidate(0, media.link = videoUrl, media);
    		$$invalidate(7, estado = "cargado");
    	}

    	function removerArchivo() {
    		$$invalidate(0, media.archivo = null, media);
    		$$invalidate(0, media.link = "", media);
    		$$invalidate(2, archivoBlob = null);
    		$$invalidate(3, input.value = "", input);
    		$$invalidate(6, inputLink = "");
    		$$invalidate(4, mediaType = MediaType.Imagen);
    		$$invalidate(7, estado = "vacio");
    	}

    	onDestroy(() => {
    		$$invalidate(0, media.archivo = null, media);
    		$$invalidate(2, archivoBlob = null);
    	});

    	onMount(() => {
    		window.addEventListener("paste", e => {
    			console.log(e.clipboardData.files);
    			$$invalidate(3, input.files = e.clipboardData.files, input);
    			actualizarArchivo();
    		});
    	});

    	const writable_props = ["compacto", "media", "videoUrl"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$2.warn(`<MediaInput> was created with unknown prop '${key}'`);
    	});

    	function input_1_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			input = $$value;
    			$$invalidate(3, input);
    		});
    	}

    	function input_1_input_handler() {
    		inputLink = this.value;
    		$$invalidate(6, inputLink);
    	}

    	const click_handler = () => $$invalidate(7, estado = "vacio");
    	const click_handler_1 = () => input.click();
    	const click_handler_3 = () => $$invalidate(7, estado = "importarLink");

    	function div_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			el = $$value;
    			$$invalidate(5, el);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ("compacto" in $$props) $$invalidate(1, compacto = $$props.compacto);
    		if ("media" in $$props) $$invalidate(0, media = $$props.media);
    		if ("videoUrl" in $$props) $$invalidate(11, videoUrl = $$props.videoUrl);
    	};

    	$$self.$capture_state = () => ({
    		MediaType,
    		Button: ye,
    		ButtonGroup: $e,
    		Icon: Me,
    		onDestroy,
    		onMount,
    		compacto,
    		media,
    		videoUrl,
    		vistaPreviaYoutube,
    		menuLink,
    		archivoBlob,
    		input,
    		mediaType,
    		el,
    		inputLink,
    		estado,
    		youtubeRegex,
    		actualizarArchivo,
    		getBlobFromInput,
    		importarVideo,
    		removerArchivo
    	});

    	$$self.$inject_state = $$props => {
    		if ("compacto" in $$props) $$invalidate(1, compacto = $$props.compacto);
    		if ("media" in $$props) $$invalidate(0, media = $$props.media);
    		if ("videoUrl" in $$props) $$invalidate(11, videoUrl = $$props.videoUrl);
    		if ("vistaPreviaYoutube" in $$props) vistaPreviaYoutube = $$props.vistaPreviaYoutube;
    		if ("menuLink" in $$props) menuLink = $$props.menuLink;
    		if ("archivoBlob" in $$props) $$invalidate(2, archivoBlob = $$props.archivoBlob);
    		if ("input" in $$props) $$invalidate(3, input = $$props.input);
    		if ("mediaType" in $$props) $$invalidate(4, mediaType = $$props.mediaType);
    		if ("el" in $$props) $$invalidate(5, el = $$props.el);
    		if ("inputLink" in $$props) $$invalidate(6, inputLink = $$props.inputLink);
    		if ("estado" in $$props) $$invalidate(7, estado = $$props.estado);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		media,
    		compacto,
    		archivoBlob,
    		input,
    		mediaType,
    		el,
    		inputLink,
    		estado,
    		actualizarArchivo,
    		importarVideo,
    		removerArchivo,
    		videoUrl,
    		input_1_binding,
    		input_1_input_handler,
    		click_handler,
    		click_handler_1,
    		click_handler_3,
    		div_binding
    	];
    }

    class MediaInput extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$9, create_fragment$9, safe_not_equal, { compacto: 1, media: 0, videoUrl: 11 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "MediaInput",
    			options,
    			id: create_fragment$9.name
    		});
    	}

    	get compacto() {
    		throw new Error("<MediaInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set compacto(value) {
    		throw new Error("<MediaInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get media() {
    		throw new Error("<MediaInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set media(value) {
    		throw new Error("<MediaInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get videoUrl() {
    		throw new Error("<MediaInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set videoUrl(value) {
    		throw new Error("<MediaInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\components\Spinner.svelte generated by Svelte v3.29.0 */

    const file$a = "src\\components\\Spinner.svelte";

    // (9:4) {:else}
    function create_else_block$2(ctx) {
    	let current;
    	const default_slot_template = /*#slots*/ ctx[2].default;
    	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[1], null);

    	const block = {
    		c: function create() {
    			if (default_slot) default_slot.c();
    		},
    		m: function mount(target, anchor) {
    			if (default_slot) {
    				default_slot.m(target, anchor);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (default_slot) {
    				if (default_slot.p && dirty & /*$$scope*/ 2) {
    					update_slot(default_slot, default_slot_template, ctx, /*$$scope*/ ctx[1], dirty, null, null);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(default_slot, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(default_slot, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (default_slot) default_slot.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$2.name,
    		type: "else",
    		source: "(9:4) {:else}",
    		ctx
    	});

    	return block;
    }

    // (5:0) {#if cargando}
    function create_if_block$8(ctx) {
    	let div;
    	let span;

    	const block = {
    		c: function create() {
    			div = element("div");
    			span = element("span");
    			span.textContent = "R";
    			attr_dev(span, "class", "svelte-1qbtk51");
    			add_location(span, file$a, 6, 8, 106);
    			attr_dev(div, "class", "loader svelte-1qbtk51");
    			add_location(div, file$a, 5, 4, 76);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, span);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$8.name,
    		type: "if",
    		source: "(5:0) {#if cargando}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$a(ctx) {
    	let current_block_type_index;
    	let if_block;
    	let if_block_anchor;
    	let current;
    	const if_block_creators = [create_if_block$8, create_else_block$2];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*cargando*/ ctx[0]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_blocks[current_block_type_index].m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				}

    				transition_in(if_block, 1);
    				if_block.m(if_block_anchor.parentNode, if_block_anchor);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if_blocks[current_block_type_index].d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$a.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$a($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Spinner", slots, ['default']);
    	let { cargando = false } = $$props;
    	const writable_props = ["cargando"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Spinner> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("cargando" in $$props) $$invalidate(0, cargando = $$props.cargando);
    		if ("$$scope" in $$props) $$invalidate(1, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({ cargando });

    	$$self.$inject_state = $$props => {
    		if ("cargando" in $$props) $$invalidate(0, cargando = $$props.cargando);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [cargando, $$scope, slots];
    }

    class Spinner extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$a, create_fragment$a, safe_not_equal, { cargando: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Spinner",
    			options,
    			id: create_fragment$a.name
    		});
    	}

    	get cargando() {
    		throw new Error("<Spinner>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set cargando(value) {
    		throw new Error("<Spinner>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\components\Comentarios\Formulario.svelte generated by Svelte v3.29.0 */
    const file$b = "src\\components\\Comentarios\\Formulario.svelte";

    // (71:8) {#if $globalStore.usuario.esMod}
    function create_if_block$9(ctx) {
    	let div;
    	let checkbox0;
    	let updating_checked;
    	let t;
    	let checkbox1;
    	let updating_checked_1;
    	let current;

    	function checkbox0_checked_binding(value) {
    		/*checkbox0_checked_binding*/ ctx[14].call(null, value);
    	}

    	let checkbox0_props = {
    		right: true,
    		$$slots: { default: [create_default_slot_3$6] },
    		$$scope: { ctx }
    	};

    	if (/*mostrarRango*/ ctx[2] !== void 0) {
    		checkbox0_props.checked = /*mostrarRango*/ ctx[2];
    	}

    	checkbox0 = new Ne({ props: checkbox0_props, $$inline: true });
    	binding_callbacks.push(() => bind(checkbox0, "checked", checkbox0_checked_binding));

    	function checkbox1_checked_binding(value) {
    		/*checkbox1_checked_binding*/ ctx[15].call(null, value);
    	}

    	let checkbox1_props = {
    		right: true,
    		$$slots: { default: [create_default_slot_2$6] },
    		$$scope: { ctx }
    	};

    	if (/*mostrarNombre*/ ctx[3] !== void 0) {
    		checkbox1_props.checked = /*mostrarNombre*/ ctx[3];
    	}

    	checkbox1 = new Ne({ props: checkbox1_props, $$inline: true });
    	binding_callbacks.push(() => bind(checkbox1, "checked", checkbox1_checked_binding));

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(checkbox0.$$.fragment);
    			t = space();
    			create_component(checkbox1.$$.fragment);
    			set_style(div, "flex-direction", "row");
    			set_style(div, "display", "flex");
    			add_location(div, file$b, 71, 12, 2200);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(checkbox0, div, null);
    			append_dev(div, t);
    			mount_component(checkbox1, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const checkbox0_changes = {};

    			if (dirty & /*$$scope*/ 65536) {
    				checkbox0_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_checked && dirty & /*mostrarRango*/ 4) {
    				updating_checked = true;
    				checkbox0_changes.checked = /*mostrarRango*/ ctx[2];
    				add_flush_callback(() => updating_checked = false);
    			}

    			checkbox0.$set(checkbox0_changes);
    			const checkbox1_changes = {};

    			if (dirty & /*$$scope*/ 65536) {
    				checkbox1_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_checked_1 && dirty & /*mostrarNombre*/ 8) {
    				updating_checked_1 = true;
    				checkbox1_changes.checked = /*mostrarNombre*/ ctx[3];
    				add_flush_callback(() => updating_checked_1 = false);
    			}

    			checkbox1.$set(checkbox1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(checkbox0.$$.fragment, local);
    			transition_in(checkbox1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(checkbox0.$$.fragment, local);
    			transition_out(checkbox1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(checkbox0);
    			destroy_component(checkbox1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$9.name,
    		type: "if",
    		source: "(71:8) {#if $globalStore.usuario.esMod}",
    		ctx
    	});

    	return block;
    }

    // (73:16) <Checkbox bind:checked={mostrarRango} right>
    function create_default_slot_3$6(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Lucesitas");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$6.name,
    		type: "slot",
    		source: "(73:16) <Checkbox bind:checked={mostrarRango} right>",
    		ctx
    	});

    	return block;
    }

    // (74:16) <Checkbox bind:checked={mostrarNombre} right>
    function create_default_slot_2$6(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Nombre");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$6.name,
    		type: "slot",
    		source: "(74:16) <Checkbox bind:checked={mostrarNombre} right>",
    		ctx
    	});

    	return block;
    }

    // (78:12) <Spinner {cargando}>
    function create_default_slot_1$6(ctx) {
    	let t_value = (/*espera*/ ctx[4] == 0 ? "Responder" : /*espera*/ ctx[4]) + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*espera*/ 16 && t_value !== (t_value = (/*espera*/ ctx[4] == 0 ? "Responder" : /*espera*/ ctx[4]) + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$6.name,
    		type: "slot",
    		source: "(78:12) <Spinner {cargando}>",
    		ctx
    	});

    	return block;
    }

    // (77:8) <Button  disabled={cargando} color="primary"  class="mra" on:click={crearComentario}>
    function create_default_slot$7(ctx) {
    	let spinner;
    	let current;

    	spinner = new Spinner({
    			props: {
    				cargando: /*cargando*/ ctx[0],
    				$$slots: { default: [create_default_slot_1$6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(spinner.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(spinner, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const spinner_changes = {};
    			if (dirty & /*cargando*/ 1) spinner_changes.cargando = /*cargando*/ ctx[0];

    			if (dirty & /*$$scope, espera*/ 65552) {
    				spinner_changes.$$scope = { dirty, ctx };
    			}

    			spinner.$set(spinner_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(spinner.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(spinner.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(spinner, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$7.name,
    		type: "slot",
    		source: "(77:8) <Button  disabled={cargando} color=\\\"primary\\\"  class=\\\"mra\\\" on:click={crearComentario}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$b(ctx) {
    	let form;
    	let errorvalidacion;
    	let t0;
    	let mediainput;
    	let updating_media;
    	let t1;
    	let textarea;
    	let t2;
    	let div;
    	let t3;
    	let button;
    	let current;
    	let mounted;
    	let dispose;

    	errorvalidacion = new ErrorValidacion({
    			props: { error: /*error*/ ctx[5] },
    			$$inline: true
    		});

    	function mediainput_media_binding(value) {
    		/*mediainput_media_binding*/ ctx[12].call(null, value);
    	}

    	let mediainput_props = { compacto: true };

    	if (/*media*/ ctx[1] !== void 0) {
    		mediainput_props.media = /*media*/ ctx[1];
    	}

    	mediainput = new MediaInput({ props: mediainput_props, $$inline: true });
    	binding_callbacks.push(() => bind(mediainput, "media", mediainput_media_binding));
    	let if_block = /*$globalStore*/ ctx[7].usuario.esMod && create_if_block$9(ctx);

    	button = new ye({
    			props: {
    				disabled: /*cargando*/ ctx[0],
    				color: "primary",
    				class: "mra",
    				$$slots: { default: [create_default_slot$7] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button.$on("click", /*crearComentario*/ ctx[8]);

    	const block = {
    		c: function create() {
    			form = element("form");
    			create_component(errorvalidacion.$$.fragment);
    			t0 = space();
    			create_component(mediainput.$$.fragment);
    			t1 = space();
    			textarea = element("textarea");
    			t2 = space();
    			div = element("div");
    			if (if_block) if_block.c();
    			t3 = space();
    			create_component(button.$$.fragment);
    			attr_dev(textarea, "cols", "30");
    			attr_dev(textarea, "rows", "10");
    			attr_dev(textarea, "placeholder", "Que dificil discutir con pibes...");
    			add_location(textarea, file$b, 63, 4, 1936);
    			attr_dev(div, "class", "acciones svelte-llyggc");
    			add_location(div, file$b, 69, 4, 2122);
    			attr_dev(form, "id", "form-comentario");
    			attr_dev(form, "class", "form-comentario panel svelte-llyggc");
    			add_location(form, file$b, 59, 0, 1745);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, form, anchor);
    			mount_component(errorvalidacion, form, null);
    			append_dev(form, t0);
    			mount_component(mediainput, form, null);
    			append_dev(form, t1);
    			append_dev(form, textarea);
    			set_input_value(textarea, /*$comentarioStore*/ ctx[6]);
    			append_dev(form, t2);
    			append_dev(form, div);
    			if (if_block) if_block.m(div, null);
    			append_dev(div, t3);
    			mount_component(button, div, null);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(textarea, "focus", /*onFocus*/ ctx[9], false, false, false),
    					listen_dev(textarea, "input", /*textarea_input_handler*/ ctx[13]),
    					listen_dev(form, "submit", prevent_default(/*submit_handler*/ ctx[11]), false, true, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			const errorvalidacion_changes = {};
    			if (dirty & /*error*/ 32) errorvalidacion_changes.error = /*error*/ ctx[5];
    			errorvalidacion.$set(errorvalidacion_changes);
    			const mediainput_changes = {};

    			if (!updating_media && dirty & /*media*/ 2) {
    				updating_media = true;
    				mediainput_changes.media = /*media*/ ctx[1];
    				add_flush_callback(() => updating_media = false);
    			}

    			mediainput.$set(mediainput_changes);

    			if (dirty & /*$comentarioStore*/ 64) {
    				set_input_value(textarea, /*$comentarioStore*/ ctx[6]);
    			}

    			if (/*$globalStore*/ ctx[7].usuario.esMod) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*$globalStore*/ 128) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$9(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(div, t3);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}

    			const button_changes = {};
    			if (dirty & /*cargando*/ 1) button_changes.disabled = /*cargando*/ ctx[0];

    			if (dirty & /*$$scope, cargando, espera*/ 65553) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(errorvalidacion.$$.fragment, local);
    			transition_in(mediainput.$$.fragment, local);
    			transition_in(if_block);
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(errorvalidacion.$$.fragment, local);
    			transition_out(mediainput.$$.fragment, local);
    			transition_out(if_block);
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(form);
    			destroy_component(errorvalidacion);
    			destroy_component(mediainput);
    			if (if_block) if_block.d();
    			destroy_component(button);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$b.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$b($$self, $$props, $$invalidate) {
    	let $comentarioStore;
    	let $globalStore;
    	validate_store(comentarioStore, "comentarioStore");
    	component_subscribe($$self, comentarioStore, $$value => $$invalidate(6, $comentarioStore = $$value));
    	validate_store(globalStore, "globalStore");
    	component_subscribe($$self, globalStore, $$value => $$invalidate(7, $globalStore = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Formulario", slots, []);
    	let { hilo } = $$props;
    	let cargando = false;
    	let media;
    	let mostrarRango = false;
    	let mostrarNombre = false;
    	let espera = 0;
    	let error = null;

    	async function crearComentario() {
    		if (espera != 0 || cargando) return;

    		try {
    			$$invalidate(0, cargando = true);

    			if (!$globalStore.usuario.esMod) {
    				await RChanClient.crearComentario(hilo.id, $comentarioStore, media.archivo, media.link);
    			} else {
    				await RChanClient.crearComentario(hilo.id, $comentarioStore, media.archivo, media.link, "", mostrarNombre, mostrarRango);
    			}

    			if (!$globalStore.usuario.esMod) {
    				$$invalidate(4, espera = config.general.tiempoEntreComentarios);
    			}
    		} catch(e) {
    			$$invalidate(5, error = e.response.data);
    			$$invalidate(0, cargando = false);
    			return;
    		}

    		$$invalidate(0, cargando = false);
    		set_store_value(comentarioStore, $comentarioStore = "", $comentarioStore);
    		$$invalidate(1, media.archivo = null, media);
    		$$invalidate(5, error = null);
    	}

    	function onFocus() {
    		$$invalidate(5, error = null);

    		if (!$globalStore.usuario.estaAutenticado) {
    			window.location = "/Inicio";
    		}
    	}

    	const writable_props = ["hilo"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Formulario> was created with unknown prop '${key}'`);
    	});

    	function submit_handler(event) {
    		bubble($$self, event);
    	}

    	function mediainput_media_binding(value) {
    		media = value;
    		$$invalidate(1, media);
    	}

    	function textarea_input_handler() {
    		$comentarioStore = this.value;
    		comentarioStore.set($comentarioStore);
    	}

    	function checkbox0_checked_binding(value) {
    		mostrarRango = value;
    		$$invalidate(2, mostrarRango);
    	}

    	function checkbox1_checked_binding(value) {
    		mostrarNombre = value;
    		$$invalidate(3, mostrarNombre);
    	}

    	$$self.$$set = $$props => {
    		if ("hilo" in $$props) $$invalidate(10, hilo = $$props.hilo);
    	};

    	$$self.$capture_state = () => ({
    		fade,
    		blur,
    		fly,
    		Button: ye,
    		Checkbox: Ne,
    		comentarioStore,
    		RChanClient,
    		ErrorValidacion,
    		MediaInput,
    		Spinner,
    		config,
    		globalStore,
    		hilo,
    		cargando,
    		media,
    		mostrarRango,
    		mostrarNombre,
    		espera,
    		error,
    		crearComentario,
    		onFocus,
    		$comentarioStore,
    		$globalStore
    	});

    	$$self.$inject_state = $$props => {
    		if ("hilo" in $$props) $$invalidate(10, hilo = $$props.hilo);
    		if ("cargando" in $$props) $$invalidate(0, cargando = $$props.cargando);
    		if ("media" in $$props) $$invalidate(1, media = $$props.media);
    		if ("mostrarRango" in $$props) $$invalidate(2, mostrarRango = $$props.mostrarRango);
    		if ("mostrarNombre" in $$props) $$invalidate(3, mostrarNombre = $$props.mostrarNombre);
    		if ("espera" in $$props) $$invalidate(4, espera = $$props.espera);
    		if ("error" in $$props) $$invalidate(5, error = $$props.error);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*espera*/ 16) {
    			 if (espera != 0) {
    				setTimeout(() => $$invalidate(4, espera--, espera), 1000);
    			}
    		}
    	};

    	return [
    		cargando,
    		media,
    		mostrarRango,
    		mostrarNombre,
    		espera,
    		error,
    		$comentarioStore,
    		$globalStore,
    		crearComentario,
    		onFocus,
    		hilo,
    		submit_handler,
    		mediainput_media_binding,
    		textarea_input_handler,
    		checkbox0_checked_binding,
    		checkbox1_checked_binding
    	];
    }

    class Formulario extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$b, create_fragment$b, safe_not_equal, { hilo: 10 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Formulario",
    			options,
    			id: create_fragment$b.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*hilo*/ ctx[10] === undefined && !("hilo" in props)) {
    			console.warn("<Formulario> was created without expected prop 'hilo'");
    		}
    	}

    	get hilo() {
    		throw new Error("<Formulario>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set hilo(value) {
    		throw new Error("<Formulario>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    // Copyright (c) .NET Foundation. All rights reserved.
    // Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.
    var __extends = (undefined && undefined.__extends) || (function () {
        var extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    /** Error thrown when an HTTP request fails. */
    var HttpError = /** @class */ (function (_super) {
        __extends(HttpError, _super);
        /** Constructs a new instance of {@link @microsoft/signalr.HttpError}.
         *
         * @param {string} errorMessage A descriptive error message.
         * @param {number} statusCode The HTTP status code represented by this error.
         */
        function HttpError(errorMessage, statusCode) {
            var _newTarget = this.constructor;
            var _this = this;
            var trueProto = _newTarget.prototype;
            _this = _super.call(this, errorMessage) || this;
            _this.statusCode = statusCode;
            // Workaround issue in Typescript compiler
            // https://github.com/Microsoft/TypeScript/issues/13965#issuecomment-278570200
            _this.__proto__ = trueProto;
            return _this;
        }
        return HttpError;
    }(Error));
    /** Error thrown when a timeout elapses. */
    var TimeoutError = /** @class */ (function (_super) {
        __extends(TimeoutError, _super);
        /** Constructs a new instance of {@link @microsoft/signalr.TimeoutError}.
         *
         * @param {string} errorMessage A descriptive error message.
         */
        function TimeoutError(errorMessage) {
            var _newTarget = this.constructor;
            if (errorMessage === void 0) { errorMessage = "A timeout occurred."; }
            var _this = this;
            var trueProto = _newTarget.prototype;
            _this = _super.call(this, errorMessage) || this;
            // Workaround issue in Typescript compiler
            // https://github.com/Microsoft/TypeScript/issues/13965#issuecomment-278570200
            _this.__proto__ = trueProto;
            return _this;
        }
        return TimeoutError;
    }(Error));
    /** Error thrown when an action is aborted. */
    var AbortError = /** @class */ (function (_super) {
        __extends(AbortError, _super);
        /** Constructs a new instance of {@link AbortError}.
         *
         * @param {string} errorMessage A descriptive error message.
         */
        function AbortError(errorMessage) {
            var _newTarget = this.constructor;
            if (errorMessage === void 0) { errorMessage = "An abort occurred."; }
            var _this = this;
            var trueProto = _newTarget.prototype;
            _this = _super.call(this, errorMessage) || this;
            // Workaround issue in Typescript compiler
            // https://github.com/Microsoft/TypeScript/issues/13965#issuecomment-278570200
            _this.__proto__ = trueProto;
            return _this;
        }
        return AbortError;
    }(Error));

    // Copyright (c) .NET Foundation. All rights reserved.
    // Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.
    var __assign = (undefined && undefined.__assign) || Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    /** Represents an HTTP response. */
    var HttpResponse = /** @class */ (function () {
        function HttpResponse(statusCode, statusText, content) {
            this.statusCode = statusCode;
            this.statusText = statusText;
            this.content = content;
        }
        return HttpResponse;
    }());
    /** Abstraction over an HTTP client.
     *
     * This class provides an abstraction over an HTTP client so that a different implementation can be provided on different platforms.
     */
    var HttpClient = /** @class */ (function () {
        function HttpClient() {
        }
        HttpClient.prototype.get = function (url, options) {
            return this.send(__assign({}, options, { method: "GET", url: url }));
        };
        HttpClient.prototype.post = function (url, options) {
            return this.send(__assign({}, options, { method: "POST", url: url }));
        };
        HttpClient.prototype.delete = function (url, options) {
            return this.send(__assign({}, options, { method: "DELETE", url: url }));
        };
        /** Gets all cookies that apply to the specified URL.
         *
         * @param url The URL that the cookies are valid for.
         * @returns {string} A string containing all the key-value cookie pairs for the specified URL.
         */
        // @ts-ignore
        HttpClient.prototype.getCookieString = function (url) {
            return "";
        };
        return HttpClient;
    }());

    // Copyright (c) .NET Foundation. All rights reserved.
    // Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.
    // These values are designed to match the ASP.NET Log Levels since that's the pattern we're emulating here.
    /** Indicates the severity of a log message.
     *
     * Log Levels are ordered in increasing severity. So `Debug` is more severe than `Trace`, etc.
     */
    var LogLevel;
    (function (LogLevel) {
        /** Log level for very low severity diagnostic messages. */
        LogLevel[LogLevel["Trace"] = 0] = "Trace";
        /** Log level for low severity diagnostic messages. */
        LogLevel[LogLevel["Debug"] = 1] = "Debug";
        /** Log level for informational diagnostic messages. */
        LogLevel[LogLevel["Information"] = 2] = "Information";
        /** Log level for diagnostic messages that indicate a non-fatal problem. */
        LogLevel[LogLevel["Warning"] = 3] = "Warning";
        /** Log level for diagnostic messages that indicate a failure in the current operation. */
        LogLevel[LogLevel["Error"] = 4] = "Error";
        /** Log level for diagnostic messages that indicate a failure that will terminate the entire application. */
        LogLevel[LogLevel["Critical"] = 5] = "Critical";
        /** The highest possible log level. Used when configuring logging to indicate that no log messages should be emitted. */
        LogLevel[LogLevel["None"] = 6] = "None";
    })(LogLevel || (LogLevel = {}));

    // Copyright (c) .NET Foundation. All rights reserved.
    // Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.
    /** A logger that does nothing when log messages are sent to it. */
    var NullLogger = /** @class */ (function () {
        function NullLogger() {
        }
        /** @inheritDoc */
        // tslint:disable-next-line
        NullLogger.prototype.log = function (_logLevel, _message) {
        };
        /** The singleton instance of the {@link @microsoft/signalr.NullLogger}. */
        NullLogger.instance = new NullLogger();
        return NullLogger;
    }());

    // Copyright (c) .NET Foundation. All rights reserved.
    // Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.
    var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };
    var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    };
    /** @private */
    var Arg = /** @class */ (function () {
        function Arg() {
        }
        Arg.isRequired = function (val, name) {
            if (val === null || val === undefined) {
                throw new Error("The '" + name + "' argument is required.");
            }
        };
        Arg.isIn = function (val, values, name) {
            // TypeScript enums have keys for **both** the name and the value of each enum member on the type itself.
            if (!(val in values)) {
                throw new Error("Unknown " + name + " value: " + val + ".");
            }
        };
        return Arg;
    }());
    /** @private */
    var Platform = /** @class */ (function () {
        function Platform() {
        }
        Object.defineProperty(Platform, "isBrowser", {
            get: function () {
                return typeof window === "object";
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Platform, "isWebWorker", {
            get: function () {
                return typeof self === "object" && "importScripts" in self;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(Platform, "isNode", {
            get: function () {
                return !this.isBrowser && !this.isWebWorker;
            },
            enumerable: true,
            configurable: true
        });
        return Platform;
    }());
    /** @private */
    function getDataDetail(data, includeContent) {
        var detail = "";
        if (isArrayBuffer$1(data)) {
            detail = "Binary data of length " + data.byteLength;
            if (includeContent) {
                detail += ". Content: '" + formatArrayBuffer(data) + "'";
            }
        }
        else if (typeof data === "string") {
            detail = "String data of length " + data.length;
            if (includeContent) {
                detail += ". Content: '" + data + "'";
            }
        }
        return detail;
    }
    /** @private */
    function formatArrayBuffer(data) {
        var view = new Uint8Array(data);
        // Uint8Array.map only supports returning another Uint8Array?
        var str = "";
        view.forEach(function (num) {
            var pad = num < 16 ? "0" : "";
            str += "0x" + pad + num.toString(16) + " ";
        });
        // Trim of trailing space.
        return str.substr(0, str.length - 1);
    }
    // Also in signalr-protocol-msgpack/Utils.ts
    /** @private */
    function isArrayBuffer$1(val) {
        return val && typeof ArrayBuffer !== "undefined" &&
            (val instanceof ArrayBuffer ||
                // Sometimes we get an ArrayBuffer that doesn't satisfy instanceof
                (val.constructor && val.constructor.name === "ArrayBuffer"));
    }
    /** @private */
    function sendMessage(logger, transportName, httpClient, url, accessTokenFactory, content, logMessageContent) {
        return __awaiter(this, void 0, void 0, function () {
            var _a, headers, token, responseType, response;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (!accessTokenFactory) return [3 /*break*/, 2];
                        return [4 /*yield*/, accessTokenFactory()];
                    case 1:
                        token = _b.sent();
                        if (token) {
                            headers = (_a = {},
                                _a["Authorization"] = "Bearer " + token,
                                _a);
                        }
                        _b.label = 2;
                    case 2:
                        logger.log(LogLevel.Trace, "(" + transportName + " transport) sending data. " + getDataDetail(content, logMessageContent) + ".");
                        responseType = isArrayBuffer$1(content) ? "arraybuffer" : "text";
                        return [4 /*yield*/, httpClient.post(url, {
                                content: content,
                                headers: headers,
                                responseType: responseType,
                            })];
                    case 3:
                        response = _b.sent();
                        logger.log(LogLevel.Trace, "(" + transportName + " transport) request complete. Response status: " + response.statusCode + ".");
                        return [2 /*return*/];
                }
            });
        });
    }
    /** @private */
    function createLogger(logger) {
        if (logger === undefined) {
            return new ConsoleLogger(LogLevel.Information);
        }
        if (logger === null) {
            return NullLogger.instance;
        }
        if (logger.log) {
            return logger;
        }
        return new ConsoleLogger(logger);
    }
    /** @private */
    var SubjectSubscription = /** @class */ (function () {
        function SubjectSubscription(subject, observer) {
            this.subject = subject;
            this.observer = observer;
        }
        SubjectSubscription.prototype.dispose = function () {
            var index = this.subject.observers.indexOf(this.observer);
            if (index > -1) {
                this.subject.observers.splice(index, 1);
            }
            if (this.subject.observers.length === 0 && this.subject.cancelCallback) {
                this.subject.cancelCallback().catch(function (_) { });
            }
        };
        return SubjectSubscription;
    }());
    /** @private */
    var ConsoleLogger = /** @class */ (function () {
        function ConsoleLogger(minimumLogLevel) {
            this.minimumLogLevel = minimumLogLevel;
            this.outputConsole = console;
        }
        ConsoleLogger.prototype.log = function (logLevel, message) {
            if (logLevel >= this.minimumLogLevel) {
                switch (logLevel) {
                    case LogLevel.Critical:
                    case LogLevel.Error:
                        this.outputConsole.error("[" + new Date().toISOString() + "] " + LogLevel[logLevel] + ": " + message);
                        break;
                    case LogLevel.Warning:
                        this.outputConsole.warn("[" + new Date().toISOString() + "] " + LogLevel[logLevel] + ": " + message);
                        break;
                    case LogLevel.Information:
                        this.outputConsole.info("[" + new Date().toISOString() + "] " + LogLevel[logLevel] + ": " + message);
                        break;
                    default:
                        // console.debug only goes to attached debuggers in Node, so we use console.log for Trace and Debug
                        this.outputConsole.log("[" + new Date().toISOString() + "] " + LogLevel[logLevel] + ": " + message);
                        break;
                }
            }
        };
        return ConsoleLogger;
    }());

    // Copyright (c) .NET Foundation. All rights reserved.
    // Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.
    var __extends$1 = (undefined && undefined.__extends) || (function () {
        var extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var __assign$1 = (undefined && undefined.__assign) || Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    var requestModule;
    if (typeof XMLHttpRequest === "undefined") {
        // In order to ignore the dynamic require in webpack builds we need to do this magic
        // @ts-ignore: TS doesn't know about these names
        var requireFunc = typeof __webpack_require__ === "function" ? __non_webpack_require__ : require;
        requestModule = requireFunc("request");
    }
    /** @private */
    var NodeHttpClient = /** @class */ (function (_super) {
        __extends$1(NodeHttpClient, _super);
        function NodeHttpClient(logger) {
            var _this = _super.call(this) || this;
            if (typeof requestModule === "undefined") {
                throw new Error("The 'request' module could not be loaded.");
            }
            _this.logger = logger;
            _this.cookieJar = requestModule.jar();
            _this.request = requestModule.defaults({ jar: _this.cookieJar });
            return _this;
        }
        NodeHttpClient.prototype.send = function (httpRequest) {
            var _this = this;
            // Check that abort was not signaled before calling send
            if (httpRequest.abortSignal) {
                if (httpRequest.abortSignal.aborted) {
                    return Promise.reject(new AbortError());
                }
            }
            return new Promise(function (resolve, reject) {
                var requestBody;
                if (isArrayBuffer$1(httpRequest.content)) {
                    requestBody = Buffer.from(httpRequest.content);
                }
                else {
                    requestBody = httpRequest.content || "";
                }
                var currentRequest = _this.request(httpRequest.url, {
                    body: requestBody,
                    // If binary is expected 'null' should be used, otherwise for text 'utf8'
                    encoding: httpRequest.responseType === "arraybuffer" ? null : "utf8",
                    headers: __assign$1({ 
                        // Tell auth middleware to 401 instead of redirecting
                        "X-Requested-With": "XMLHttpRequest" }, httpRequest.headers),
                    method: httpRequest.method,
                    timeout: httpRequest.timeout,
                }, function (error, response, body) {
                    if (httpRequest.abortSignal) {
                        httpRequest.abortSignal.onabort = null;
                    }
                    if (error) {
                        if (error.code === "ETIMEDOUT") {
                            _this.logger.log(LogLevel.Warning, "Timeout from HTTP request.");
                            reject(new TimeoutError());
                        }
                        _this.logger.log(LogLevel.Warning, "Error from HTTP request. " + error);
                        reject(error);
                        return;
                    }
                    if (response.statusCode >= 200 && response.statusCode < 300) {
                        resolve(new HttpResponse(response.statusCode, response.statusMessage || "", body));
                    }
                    else {
                        reject(new HttpError(response.statusMessage || "", response.statusCode || 0));
                    }
                });
                if (httpRequest.abortSignal) {
                    httpRequest.abortSignal.onabort = function () {
                        currentRequest.abort();
                        reject(new AbortError());
                    };
                }
            });
        };
        NodeHttpClient.prototype.getCookieString = function (url) {
            return this.cookieJar.getCookieString(url);
        };
        return NodeHttpClient;
    }(HttpClient));

    // Copyright (c) .NET Foundation. All rights reserved.
    // Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.
    var __extends$2 = (undefined && undefined.__extends) || (function () {
        var extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var XhrHttpClient = /** @class */ (function (_super) {
        __extends$2(XhrHttpClient, _super);
        function XhrHttpClient(logger) {
            var _this = _super.call(this) || this;
            _this.logger = logger;
            return _this;
        }
        /** @inheritDoc */
        XhrHttpClient.prototype.send = function (request) {
            var _this = this;
            // Check that abort was not signaled before calling send
            if (request.abortSignal && request.abortSignal.aborted) {
                return Promise.reject(new AbortError());
            }
            if (!request.method) {
                return Promise.reject(new Error("No method defined."));
            }
            if (!request.url) {
                return Promise.reject(new Error("No url defined."));
            }
            return new Promise(function (resolve, reject) {
                var xhr = new XMLHttpRequest();
                xhr.open(request.method, request.url, true);
                xhr.withCredentials = true;
                xhr.setRequestHeader("X-Requested-With", "XMLHttpRequest");
                // Explicitly setting the Content-Type header for React Native on Android platform.
                xhr.setRequestHeader("Content-Type", "text/plain;charset=UTF-8");
                var headers = request.headers;
                if (headers) {
                    Object.keys(headers)
                        .forEach(function (header) {
                        xhr.setRequestHeader(header, headers[header]);
                    });
                }
                if (request.responseType) {
                    xhr.responseType = request.responseType;
                }
                if (request.abortSignal) {
                    request.abortSignal.onabort = function () {
                        xhr.abort();
                        reject(new AbortError());
                    };
                }
                if (request.timeout) {
                    xhr.timeout = request.timeout;
                }
                xhr.onload = function () {
                    if (request.abortSignal) {
                        request.abortSignal.onabort = null;
                    }
                    if (xhr.status >= 200 && xhr.status < 300) {
                        resolve(new HttpResponse(xhr.status, xhr.statusText, xhr.response || xhr.responseText));
                    }
                    else {
                        reject(new HttpError(xhr.statusText, xhr.status));
                    }
                };
                xhr.onerror = function () {
                    _this.logger.log(LogLevel.Warning, "Error from HTTP request. " + xhr.status + ": " + xhr.statusText + ".");
                    reject(new HttpError(xhr.statusText, xhr.status));
                };
                xhr.ontimeout = function () {
                    _this.logger.log(LogLevel.Warning, "Timeout from HTTP request.");
                    reject(new TimeoutError());
                };
                xhr.send(request.content || "");
            });
        };
        return XhrHttpClient;
    }(HttpClient));

    // Copyright (c) .NET Foundation. All rights reserved.
    // Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.
    var __extends$3 = (undefined && undefined.__extends) || (function () {
        var extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    /** Default implementation of {@link @microsoft/signalr.HttpClient}. */
    var DefaultHttpClient = /** @class */ (function (_super) {
        __extends$3(DefaultHttpClient, _super);
        /** Creates a new instance of the {@link @microsoft/signalr.DefaultHttpClient}, using the provided {@link @microsoft/signalr.ILogger} to log messages. */
        function DefaultHttpClient(logger) {
            var _this = _super.call(this) || this;
            if (typeof XMLHttpRequest !== "undefined") {
                _this.httpClient = new XhrHttpClient(logger);
            }
            else {
                _this.httpClient = new NodeHttpClient(logger);
            }
            return _this;
        }
        /** @inheritDoc */
        DefaultHttpClient.prototype.send = function (request) {
            // Check that abort was not signaled before calling send
            if (request.abortSignal && request.abortSignal.aborted) {
                return Promise.reject(new AbortError());
            }
            if (!request.method) {
                return Promise.reject(new Error("No method defined."));
            }
            if (!request.url) {
                return Promise.reject(new Error("No url defined."));
            }
            return this.httpClient.send(request);
        };
        DefaultHttpClient.prototype.getCookieString = function (url) {
            return this.httpClient.getCookieString(url);
        };
        return DefaultHttpClient;
    }(HttpClient));

    // Copyright (c) .NET Foundation. All rights reserved.
    // Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.
    // Not exported from index
    /** @private */
    var TextMessageFormat = /** @class */ (function () {
        function TextMessageFormat() {
        }
        TextMessageFormat.write = function (output) {
            return "" + output + TextMessageFormat.RecordSeparator;
        };
        TextMessageFormat.parse = function (input) {
            if (input[input.length - 1] !== TextMessageFormat.RecordSeparator) {
                throw new Error("Message is incomplete.");
            }
            var messages = input.split(TextMessageFormat.RecordSeparator);
            messages.pop();
            return messages;
        };
        TextMessageFormat.RecordSeparatorCode = 0x1e;
        TextMessageFormat.RecordSeparator = String.fromCharCode(TextMessageFormat.RecordSeparatorCode);
        return TextMessageFormat;
    }());

    // Copyright (c) .NET Foundation. All rights reserved.
    /** @private */
    var HandshakeProtocol = /** @class */ (function () {
        function HandshakeProtocol() {
        }
        // Handshake request is always JSON
        HandshakeProtocol.prototype.writeHandshakeRequest = function (handshakeRequest) {
            return TextMessageFormat.write(JSON.stringify(handshakeRequest));
        };
        HandshakeProtocol.prototype.parseHandshakeResponse = function (data) {
            var responseMessage;
            var messageData;
            var remainingData;
            if (isArrayBuffer$1(data) || (typeof Buffer !== "undefined" && data instanceof Buffer)) {
                // Format is binary but still need to read JSON text from handshake response
                var binaryData = new Uint8Array(data);
                var separatorIndex = binaryData.indexOf(TextMessageFormat.RecordSeparatorCode);
                if (separatorIndex === -1) {
                    throw new Error("Message is incomplete.");
                }
                // content before separator is handshake response
                // optional content after is additional messages
                var responseLength = separatorIndex + 1;
                messageData = String.fromCharCode.apply(null, binaryData.slice(0, responseLength));
                remainingData = (binaryData.byteLength > responseLength) ? binaryData.slice(responseLength).buffer : null;
            }
            else {
                var textData = data;
                var separatorIndex = textData.indexOf(TextMessageFormat.RecordSeparator);
                if (separatorIndex === -1) {
                    throw new Error("Message is incomplete.");
                }
                // content before separator is handshake response
                // optional content after is additional messages
                var responseLength = separatorIndex + 1;
                messageData = textData.substring(0, responseLength);
                remainingData = (textData.length > responseLength) ? textData.substring(responseLength) : null;
            }
            // At this point we should have just the single handshake message
            var messages = TextMessageFormat.parse(messageData);
            var response = JSON.parse(messages[0]);
            if (response.type) {
                throw new Error("Expected a handshake response from the server.");
            }
            responseMessage = response;
            // multiple messages could have arrived with handshake
            // return additional data to be parsed as usual, or null if all parsed
            return [remainingData, responseMessage];
        };
        return HandshakeProtocol;
    }());

    // Copyright (c) .NET Foundation. All rights reserved.
    // Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.
    /** Defines the type of a Hub Message. */
    var MessageType;
    (function (MessageType) {
        /** Indicates the message is an Invocation message and implements the {@link @microsoft/signalr.InvocationMessage} interface. */
        MessageType[MessageType["Invocation"] = 1] = "Invocation";
        /** Indicates the message is a StreamItem message and implements the {@link @microsoft/signalr.StreamItemMessage} interface. */
        MessageType[MessageType["StreamItem"] = 2] = "StreamItem";
        /** Indicates the message is a Completion message and implements the {@link @microsoft/signalr.CompletionMessage} interface. */
        MessageType[MessageType["Completion"] = 3] = "Completion";
        /** Indicates the message is a Stream Invocation message and implements the {@link @microsoft/signalr.StreamInvocationMessage} interface. */
        MessageType[MessageType["StreamInvocation"] = 4] = "StreamInvocation";
        /** Indicates the message is a Cancel Invocation message and implements the {@link @microsoft/signalr.CancelInvocationMessage} interface. */
        MessageType[MessageType["CancelInvocation"] = 5] = "CancelInvocation";
        /** Indicates the message is a Ping message and implements the {@link @microsoft/signalr.PingMessage} interface. */
        MessageType[MessageType["Ping"] = 6] = "Ping";
        /** Indicates the message is a Close message and implements the {@link @microsoft/signalr.CloseMessage} interface. */
        MessageType[MessageType["Close"] = 7] = "Close";
    })(MessageType || (MessageType = {}));

    // Copyright (c) .NET Foundation. All rights reserved.
    /** Stream implementation to stream items to the server. */
    var Subject = /** @class */ (function () {
        function Subject() {
            this.observers = [];
        }
        Subject.prototype.next = function (item) {
            for (var _i = 0, _a = this.observers; _i < _a.length; _i++) {
                var observer = _a[_i];
                observer.next(item);
            }
        };
        Subject.prototype.error = function (err) {
            for (var _i = 0, _a = this.observers; _i < _a.length; _i++) {
                var observer = _a[_i];
                if (observer.error) {
                    observer.error(err);
                }
            }
        };
        Subject.prototype.complete = function () {
            for (var _i = 0, _a = this.observers; _i < _a.length; _i++) {
                var observer = _a[_i];
                if (observer.complete) {
                    observer.complete();
                }
            }
        };
        Subject.prototype.subscribe = function (observer) {
            this.observers.push(observer);
            return new SubjectSubscription(this, observer);
        };
        return Subject;
    }());

    // Copyright (c) .NET Foundation. All rights reserved.
    // Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.
    var __awaiter$1 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };
    var __generator$1 = (undefined && undefined.__generator) || function (thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    };
    var DEFAULT_TIMEOUT_IN_MS = 30 * 1000;
    var DEFAULT_PING_INTERVAL_IN_MS = 15 * 1000;
    /** Describes the current state of the {@link HubConnection} to the server. */
    var HubConnectionState;
    (function (HubConnectionState) {
        /** The hub connection is disconnected. */
        HubConnectionState["Disconnected"] = "Disconnected";
        /** The hub connection is connecting. */
        HubConnectionState["Connecting"] = "Connecting";
        /** The hub connection is connected. */
        HubConnectionState["Connected"] = "Connected";
        /** The hub connection is disconnecting. */
        HubConnectionState["Disconnecting"] = "Disconnecting";
        /** The hub connection is reconnecting. */
        HubConnectionState["Reconnecting"] = "Reconnecting";
    })(HubConnectionState || (HubConnectionState = {}));
    /** Represents a connection to a SignalR Hub. */
    var HubConnection = /** @class */ (function () {
        function HubConnection(connection, logger, protocol, reconnectPolicy) {
            var _this = this;
            Arg.isRequired(connection, "connection");
            Arg.isRequired(logger, "logger");
            Arg.isRequired(protocol, "protocol");
            this.serverTimeoutInMilliseconds = DEFAULT_TIMEOUT_IN_MS;
            this.keepAliveIntervalInMilliseconds = DEFAULT_PING_INTERVAL_IN_MS;
            this.logger = logger;
            this.protocol = protocol;
            this.connection = connection;
            this.reconnectPolicy = reconnectPolicy;
            this.handshakeProtocol = new HandshakeProtocol();
            this.connection.onreceive = function (data) { return _this.processIncomingData(data); };
            this.connection.onclose = function (error) { return _this.connectionClosed(error); };
            this.callbacks = {};
            this.methods = {};
            this.closedCallbacks = [];
            this.reconnectingCallbacks = [];
            this.reconnectedCallbacks = [];
            this.invocationId = 0;
            this.receivedHandshakeResponse = false;
            this.connectionState = HubConnectionState.Disconnected;
            this.connectionStarted = false;
            this.cachedPingMessage = this.protocol.writeMessage({ type: MessageType.Ping });
        }
        /** @internal */
        // Using a public static factory method means we can have a private constructor and an _internal_
        // create method that can be used by HubConnectionBuilder. An "internal" constructor would just
        // be stripped away and the '.d.ts' file would have no constructor, which is interpreted as a
        // public parameter-less constructor.
        HubConnection.create = function (connection, logger, protocol, reconnectPolicy) {
            return new HubConnection(connection, logger, protocol, reconnectPolicy);
        };
        Object.defineProperty(HubConnection.prototype, "state", {
            /** Indicates the state of the {@link HubConnection} to the server. */
            get: function () {
                return this.connectionState;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HubConnection.prototype, "connectionId", {
            /** Represents the connection id of the {@link HubConnection} on the server. The connection id will be null when the connection is either
             *  in the disconnected state or if the negotiation step was skipped.
             */
            get: function () {
                return this.connection ? (this.connection.connectionId || null) : null;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(HubConnection.prototype, "baseUrl", {
            /** Indicates the url of the {@link HubConnection} to the server. */
            get: function () {
                return this.connection.baseUrl || "";
            },
            /**
             * Sets a new url for the HubConnection. Note that the url can only be changed when the connection is in either the Disconnected or
             * Reconnecting states.
             * @param {string} url The url to connect to.
             */
            set: function (url) {
                if (this.connectionState !== HubConnectionState.Disconnected && this.connectionState !== HubConnectionState.Reconnecting) {
                    throw new Error("The HubConnection must be in the Disconnected or Reconnecting state to change the url.");
                }
                if (!url) {
                    throw new Error("The HubConnection url must be a valid url.");
                }
                this.connection.baseUrl = url;
            },
            enumerable: true,
            configurable: true
        });
        /** Starts the connection.
         *
         * @returns {Promise<void>} A Promise that resolves when the connection has been successfully established, or rejects with an error.
         */
        HubConnection.prototype.start = function () {
            this.startPromise = this.startWithStateTransitions();
            return this.startPromise;
        };
        HubConnection.prototype.startWithStateTransitions = function () {
            return __awaiter$1(this, void 0, void 0, function () {
                var e_1;
                return __generator$1(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (this.connectionState !== HubConnectionState.Disconnected) {
                                return [2 /*return*/, Promise.reject(new Error("Cannot start a HubConnection that is not in the 'Disconnected' state."))];
                            }
                            this.connectionState = HubConnectionState.Connecting;
                            this.logger.log(LogLevel.Debug, "Starting HubConnection.");
                            _a.label = 1;
                        case 1:
                            _a.trys.push([1, 3, , 4]);
                            return [4 /*yield*/, this.startInternal()];
                        case 2:
                            _a.sent();
                            this.connectionState = HubConnectionState.Connected;
                            this.connectionStarted = true;
                            this.logger.log(LogLevel.Debug, "HubConnection connected successfully.");
                            return [3 /*break*/, 4];
                        case 3:
                            e_1 = _a.sent();
                            this.connectionState = HubConnectionState.Disconnected;
                            this.logger.log(LogLevel.Debug, "HubConnection failed to start successfully because of error '" + e_1 + "'.");
                            return [2 /*return*/, Promise.reject(e_1)];
                        case 4: return [2 /*return*/];
                    }
                });
            });
        };
        HubConnection.prototype.startInternal = function () {
            return __awaiter$1(this, void 0, void 0, function () {
                var handshakePromise, handshakeRequest, e_2;
                var _this = this;
                return __generator$1(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            this.stopDuringStartError = undefined;
                            this.receivedHandshakeResponse = false;
                            handshakePromise = new Promise(function (resolve, reject) {
                                _this.handshakeResolver = resolve;
                                _this.handshakeRejecter = reject;
                            });
                            return [4 /*yield*/, this.connection.start(this.protocol.transferFormat)];
                        case 1:
                            _a.sent();
                            _a.label = 2;
                        case 2:
                            _a.trys.push([2, 5, , 7]);
                            handshakeRequest = {
                                protocol: this.protocol.name,
                                version: this.protocol.version,
                            };
                            this.logger.log(LogLevel.Debug, "Sending handshake request.");
                            return [4 /*yield*/, this.sendMessage(this.handshakeProtocol.writeHandshakeRequest(handshakeRequest))];
                        case 3:
                            _a.sent();
                            this.logger.log(LogLevel.Information, "Using HubProtocol '" + this.protocol.name + "'.");
                            // defensively cleanup timeout in case we receive a message from the server before we finish start
                            this.cleanupTimeout();
                            this.resetTimeoutPeriod();
                            this.resetKeepAliveInterval();
                            return [4 /*yield*/, handshakePromise];
                        case 4:
                            _a.sent();
                            // It's important to check the stopDuringStartError instead of just relying on the handshakePromise
                            // being rejected on close, because this continuation can run after both the handshake completed successfully
                            // and the connection was closed.
                            if (this.stopDuringStartError) {
                                // It's important to throw instead of returning a rejected promise, because we don't want to allow any state
                                // transitions to occur between now and the calling code observing the exceptions. Returning a rejected promise
                                // will cause the calling continuation to get scheduled to run later.
                                throw this.stopDuringStartError;
                            }
                            return [3 /*break*/, 7];
                        case 5:
                            e_2 = _a.sent();
                            this.logger.log(LogLevel.Debug, "Hub handshake failed with error '" + e_2 + "' during start(). Stopping HubConnection.");
                            this.cleanupTimeout();
                            this.cleanupPingTimer();
                            // HttpConnection.stop() should not complete until after the onclose callback is invoked.
                            // This will transition the HubConnection to the disconnected state before HttpConnection.stop() completes.
                            return [4 /*yield*/, this.connection.stop(e_2)];
                        case 6:
                            // HttpConnection.stop() should not complete until after the onclose callback is invoked.
                            // This will transition the HubConnection to the disconnected state before HttpConnection.stop() completes.
                            _a.sent();
                            throw e_2;
                        case 7: return [2 /*return*/];
                    }
                });
            });
        };
        /** Stops the connection.
         *
         * @returns {Promise<void>} A Promise that resolves when the connection has been successfully terminated, or rejects with an error.
         */
        HubConnection.prototype.stop = function () {
            return __awaiter$1(this, void 0, void 0, function () {
                var startPromise, e_3;
                return __generator$1(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            startPromise = this.startPromise;
                            this.stopPromise = this.stopInternal();
                            return [4 /*yield*/, this.stopPromise];
                        case 1:
                            _a.sent();
                            _a.label = 2;
                        case 2:
                            _a.trys.push([2, 4, , 5]);
                            // Awaiting undefined continues immediately
                            return [4 /*yield*/, startPromise];
                        case 3:
                            // Awaiting undefined continues immediately
                            _a.sent();
                            return [3 /*break*/, 5];
                        case 4:
                            e_3 = _a.sent();
                            return [3 /*break*/, 5];
                        case 5: return [2 /*return*/];
                    }
                });
            });
        };
        HubConnection.prototype.stopInternal = function (error) {
            if (this.connectionState === HubConnectionState.Disconnected) {
                this.logger.log(LogLevel.Debug, "Call to HubConnection.stop(" + error + ") ignored because it is already in the disconnected state.");
                return Promise.resolve();
            }
            if (this.connectionState === HubConnectionState.Disconnecting) {
                this.logger.log(LogLevel.Debug, "Call to HttpConnection.stop(" + error + ") ignored because the connection is already in the disconnecting state.");
                return this.stopPromise;
            }
            this.connectionState = HubConnectionState.Disconnecting;
            this.logger.log(LogLevel.Debug, "Stopping HubConnection.");
            if (this.reconnectDelayHandle) {
                // We're in a reconnect delay which means the underlying connection is currently already stopped.
                // Just clear the handle to stop the reconnect loop (which no one is waiting on thankfully) and
                // fire the onclose callbacks.
                this.logger.log(LogLevel.Debug, "Connection stopped during reconnect delay. Done reconnecting.");
                clearTimeout(this.reconnectDelayHandle);
                this.reconnectDelayHandle = undefined;
                this.completeClose();
                return Promise.resolve();
            }
            this.cleanupTimeout();
            this.cleanupPingTimer();
            this.stopDuringStartError = error || new Error("The connection was stopped before the hub handshake could complete.");
            // HttpConnection.stop() should not complete until after either HttpConnection.start() fails
            // or the onclose callback is invoked. The onclose callback will transition the HubConnection
            // to the disconnected state if need be before HttpConnection.stop() completes.
            return this.connection.stop(error);
        };
        /** Invokes a streaming hub method on the server using the specified name and arguments.
         *
         * @typeparam T The type of the items returned by the server.
         * @param {string} methodName The name of the server method to invoke.
         * @param {any[]} args The arguments used to invoke the server method.
         * @returns {IStreamResult<T>} An object that yields results from the server as they are received.
         */
        HubConnection.prototype.stream = function (methodName) {
            var _this = this;
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            var _a = this.replaceStreamingParams(args), streams = _a[0], streamIds = _a[1];
            var invocationDescriptor = this.createStreamInvocation(methodName, args, streamIds);
            var promiseQueue;
            var subject = new Subject();
            subject.cancelCallback = function () {
                var cancelInvocation = _this.createCancelInvocation(invocationDescriptor.invocationId);
                delete _this.callbacks[invocationDescriptor.invocationId];
                return promiseQueue.then(function () {
                    return _this.sendWithProtocol(cancelInvocation);
                });
            };
            this.callbacks[invocationDescriptor.invocationId] = function (invocationEvent, error) {
                if (error) {
                    subject.error(error);
                    return;
                }
                else if (invocationEvent) {
                    // invocationEvent will not be null when an error is not passed to the callback
                    if (invocationEvent.type === MessageType.Completion) {
                        if (invocationEvent.error) {
                            subject.error(new Error(invocationEvent.error));
                        }
                        else {
                            subject.complete();
                        }
                    }
                    else {
                        subject.next((invocationEvent.item));
                    }
                }
            };
            promiseQueue = this.sendWithProtocol(invocationDescriptor)
                .catch(function (e) {
                subject.error(e);
                delete _this.callbacks[invocationDescriptor.invocationId];
            });
            this.launchStreams(streams, promiseQueue);
            return subject;
        };
        HubConnection.prototype.sendMessage = function (message) {
            this.resetKeepAliveInterval();
            return this.connection.send(message);
        };
        /**
         * Sends a js object to the server.
         * @param message The js object to serialize and send.
         */
        HubConnection.prototype.sendWithProtocol = function (message) {
            return this.sendMessage(this.protocol.writeMessage(message));
        };
        /** Invokes a hub method on the server using the specified name and arguments. Does not wait for a response from the receiver.
         *
         * The Promise returned by this method resolves when the client has sent the invocation to the server. The server may still
         * be processing the invocation.
         *
         * @param {string} methodName The name of the server method to invoke.
         * @param {any[]} args The arguments used to invoke the server method.
         * @returns {Promise<void>} A Promise that resolves when the invocation has been successfully sent, or rejects with an error.
         */
        HubConnection.prototype.send = function (methodName) {
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            var _a = this.replaceStreamingParams(args), streams = _a[0], streamIds = _a[1];
            var sendPromise = this.sendWithProtocol(this.createInvocation(methodName, args, true, streamIds));
            this.launchStreams(streams, sendPromise);
            return sendPromise;
        };
        /** Invokes a hub method on the server using the specified name and arguments.
         *
         * The Promise returned by this method resolves when the server indicates it has finished invoking the method. When the promise
         * resolves, the server has finished invoking the method. If the server method returns a result, it is produced as the result of
         * resolving the Promise.
         *
         * @typeparam T The expected return type.
         * @param {string} methodName The name of the server method to invoke.
         * @param {any[]} args The arguments used to invoke the server method.
         * @returns {Promise<T>} A Promise that resolves with the result of the server method (if any), or rejects with an error.
         */
        HubConnection.prototype.invoke = function (methodName) {
            var _this = this;
            var args = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                args[_i - 1] = arguments[_i];
            }
            var _a = this.replaceStreamingParams(args), streams = _a[0], streamIds = _a[1];
            var invocationDescriptor = this.createInvocation(methodName, args, false, streamIds);
            var p = new Promise(function (resolve, reject) {
                // invocationId will always have a value for a non-blocking invocation
                _this.callbacks[invocationDescriptor.invocationId] = function (invocationEvent, error) {
                    if (error) {
                        reject(error);
                        return;
                    }
                    else if (invocationEvent) {
                        // invocationEvent will not be null when an error is not passed to the callback
                        if (invocationEvent.type === MessageType.Completion) {
                            if (invocationEvent.error) {
                                reject(new Error(invocationEvent.error));
                            }
                            else {
                                resolve(invocationEvent.result);
                            }
                        }
                        else {
                            reject(new Error("Unexpected message type: " + invocationEvent.type));
                        }
                    }
                };
                var promiseQueue = _this.sendWithProtocol(invocationDescriptor)
                    .catch(function (e) {
                    reject(e);
                    // invocationId will always have a value for a non-blocking invocation
                    delete _this.callbacks[invocationDescriptor.invocationId];
                });
                _this.launchStreams(streams, promiseQueue);
            });
            return p;
        };
        /** Registers a handler that will be invoked when the hub method with the specified method name is invoked.
         *
         * @param {string} methodName The name of the hub method to define.
         * @param {Function} newMethod The handler that will be raised when the hub method is invoked.
         */
        HubConnection.prototype.on = function (methodName, newMethod) {
            if (!methodName || !newMethod) {
                return;
            }
            methodName = methodName.toLowerCase();
            if (!this.methods[methodName]) {
                this.methods[methodName] = [];
            }
            // Preventing adding the same handler multiple times.
            if (this.methods[methodName].indexOf(newMethod) !== -1) {
                return;
            }
            this.methods[methodName].push(newMethod);
        };
        HubConnection.prototype.off = function (methodName, method) {
            if (!methodName) {
                return;
            }
            methodName = methodName.toLowerCase();
            var handlers = this.methods[methodName];
            if (!handlers) {
                return;
            }
            if (method) {
                var removeIdx = handlers.indexOf(method);
                if (removeIdx !== -1) {
                    handlers.splice(removeIdx, 1);
                    if (handlers.length === 0) {
                        delete this.methods[methodName];
                    }
                }
            }
            else {
                delete this.methods[methodName];
            }
        };
        /** Registers a handler that will be invoked when the connection is closed.
         *
         * @param {Function} callback The handler that will be invoked when the connection is closed. Optionally receives a single argument containing the error that caused the connection to close (if any).
         */
        HubConnection.prototype.onclose = function (callback) {
            if (callback) {
                this.closedCallbacks.push(callback);
            }
        };
        /** Registers a handler that will be invoked when the connection starts reconnecting.
         *
         * @param {Function} callback The handler that will be invoked when the connection starts reconnecting. Optionally receives a single argument containing the error that caused the connection to start reconnecting (if any).
         */
        HubConnection.prototype.onreconnecting = function (callback) {
            if (callback) {
                this.reconnectingCallbacks.push(callback);
            }
        };
        /** Registers a handler that will be invoked when the connection successfully reconnects.
         *
         * @param {Function} callback The handler that will be invoked when the connection successfully reconnects.
         */
        HubConnection.prototype.onreconnected = function (callback) {
            if (callback) {
                this.reconnectedCallbacks.push(callback);
            }
        };
        HubConnection.prototype.processIncomingData = function (data) {
            this.cleanupTimeout();
            if (!this.receivedHandshakeResponse) {
                data = this.processHandshakeResponse(data);
                this.receivedHandshakeResponse = true;
            }
            // Data may have all been read when processing handshake response
            if (data) {
                // Parse the messages
                var messages = this.protocol.parseMessages(data, this.logger);
                for (var _i = 0, messages_1 = messages; _i < messages_1.length; _i++) {
                    var message = messages_1[_i];
                    switch (message.type) {
                        case MessageType.Invocation:
                            this.invokeClientMethod(message);
                            break;
                        case MessageType.StreamItem:
                        case MessageType.Completion:
                            var callback = this.callbacks[message.invocationId];
                            if (callback) {
                                if (message.type === MessageType.Completion) {
                                    delete this.callbacks[message.invocationId];
                                }
                                callback(message);
                            }
                            break;
                        case MessageType.Ping:
                            // Don't care about pings
                            break;
                        case MessageType.Close:
                            this.logger.log(LogLevel.Information, "Close message received from server.");
                            var error = message.error ? new Error("Server returned an error on close: " + message.error) : undefined;
                            if (message.allowReconnect === true) {
                                // It feels wrong not to await connection.stop() here, but processIncomingData is called as part of an onreceive callback which is not async,
                                // this is already the behavior for serverTimeout(), and HttpConnection.Stop() should catch and log all possible exceptions.
                                // tslint:disable-next-line:no-floating-promises
                                this.connection.stop(error);
                            }
                            else {
                                // We cannot await stopInternal() here, but subsequent calls to stop() will await this if stopInternal() is still ongoing.
                                this.stopPromise = this.stopInternal(error);
                            }
                            break;
                        default:
                            this.logger.log(LogLevel.Warning, "Invalid message type: " + message.type + ".");
                            break;
                    }
                }
            }
            this.resetTimeoutPeriod();
        };
        HubConnection.prototype.processHandshakeResponse = function (data) {
            var _a;
            var responseMessage;
            var remainingData;
            try {
                _a = this.handshakeProtocol.parseHandshakeResponse(data), remainingData = _a[0], responseMessage = _a[1];
            }
            catch (e) {
                var message = "Error parsing handshake response: " + e;
                this.logger.log(LogLevel.Error, message);
                var error = new Error(message);
                this.handshakeRejecter(error);
                throw error;
            }
            if (responseMessage.error) {
                var message = "Server returned handshake error: " + responseMessage.error;
                this.logger.log(LogLevel.Error, message);
                var error = new Error(message);
                this.handshakeRejecter(error);
                throw error;
            }
            else {
                this.logger.log(LogLevel.Debug, "Server handshake complete.");
            }
            this.handshakeResolver();
            return remainingData;
        };
        HubConnection.prototype.resetKeepAliveInterval = function () {
            var _this = this;
            this.cleanupPingTimer();
            this.pingServerHandle = setTimeout(function () { return __awaiter$1(_this, void 0, void 0, function () {
                var _a;
                return __generator$1(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            if (!(this.connectionState === HubConnectionState.Connected)) return [3 /*break*/, 4];
                            _b.label = 1;
                        case 1:
                            _b.trys.push([1, 3, , 4]);
                            return [4 /*yield*/, this.sendMessage(this.cachedPingMessage)];
                        case 2:
                            _b.sent();
                            return [3 /*break*/, 4];
                        case 3:
                            _a = _b.sent();
                            // We don't care about the error. It should be seen elsewhere in the client.
                            // The connection is probably in a bad or closed state now, cleanup the timer so it stops triggering
                            this.cleanupPingTimer();
                            return [3 /*break*/, 4];
                        case 4: return [2 /*return*/];
                    }
                });
            }); }, this.keepAliveIntervalInMilliseconds);
        };
        HubConnection.prototype.resetTimeoutPeriod = function () {
            var _this = this;
            if (!this.connection.features || !this.connection.features.inherentKeepAlive) {
                // Set the timeout timer
                this.timeoutHandle = setTimeout(function () { return _this.serverTimeout(); }, this.serverTimeoutInMilliseconds);
            }
        };
        HubConnection.prototype.serverTimeout = function () {
            // The server hasn't talked to us in a while. It doesn't like us anymore ... :(
            // Terminate the connection, but we don't need to wait on the promise. This could trigger reconnecting.
            // tslint:disable-next-line:no-floating-promises
            this.connection.stop(new Error("Server timeout elapsed without receiving a message from the server."));
        };
        HubConnection.prototype.invokeClientMethod = function (invocationMessage) {
            var _this = this;
            var methods = this.methods[invocationMessage.target.toLowerCase()];
            if (methods) {
                try {
                    methods.forEach(function (m) { return m.apply(_this, invocationMessage.arguments); });
                }
                catch (e) {
                    this.logger.log(LogLevel.Error, "A callback for the method " + invocationMessage.target.toLowerCase() + " threw error '" + e + "'.");
                }
                if (invocationMessage.invocationId) {
                    // This is not supported in v1. So we return an error to avoid blocking the server waiting for the response.
                    var message = "Server requested a response, which is not supported in this version of the client.";
                    this.logger.log(LogLevel.Error, message);
                    // We don't want to wait on the stop itself.
                    this.stopPromise = this.stopInternal(new Error(message));
                }
            }
            else {
                this.logger.log(LogLevel.Warning, "No client method with the name '" + invocationMessage.target + "' found.");
            }
        };
        HubConnection.prototype.connectionClosed = function (error) {
            this.logger.log(LogLevel.Debug, "HubConnection.connectionClosed(" + error + ") called while in state " + this.connectionState + ".");
            // Triggering this.handshakeRejecter is insufficient because it could already be resolved without the continuation having run yet.
            this.stopDuringStartError = this.stopDuringStartError || error || new Error("The underlying connection was closed before the hub handshake could complete.");
            // If the handshake is in progress, start will be waiting for the handshake promise, so we complete it.
            // If it has already completed, this should just noop.
            if (this.handshakeResolver) {
                this.handshakeResolver();
            }
            this.cancelCallbacksWithError(error || new Error("Invocation canceled due to the underlying connection being closed."));
            this.cleanupTimeout();
            this.cleanupPingTimer();
            if (this.connectionState === HubConnectionState.Disconnecting) {
                this.completeClose(error);
            }
            else if (this.connectionState === HubConnectionState.Connected && this.reconnectPolicy) {
                // tslint:disable-next-line:no-floating-promises
                this.reconnect(error);
            }
            else if (this.connectionState === HubConnectionState.Connected) {
                this.completeClose(error);
            }
            // If none of the above if conditions were true were called the HubConnection must be in either:
            // 1. The Connecting state in which case the handshakeResolver will complete it and stopDuringStartError will fail it.
            // 2. The Reconnecting state in which case the handshakeResolver will complete it and stopDuringStartError will fail the current reconnect attempt
            //    and potentially continue the reconnect() loop.
            // 3. The Disconnected state in which case we're already done.
        };
        HubConnection.prototype.completeClose = function (error) {
            var _this = this;
            if (this.connectionStarted) {
                this.connectionState = HubConnectionState.Disconnected;
                this.connectionStarted = false;
                try {
                    this.closedCallbacks.forEach(function (c) { return c.apply(_this, [error]); });
                }
                catch (e) {
                    this.logger.log(LogLevel.Error, "An onclose callback called with error '" + error + "' threw error '" + e + "'.");
                }
            }
        };
        HubConnection.prototype.reconnect = function (error) {
            return __awaiter$1(this, void 0, void 0, function () {
                var reconnectStartTime, previousReconnectAttempts, retryError, nextRetryDelay, e_4;
                var _this = this;
                return __generator$1(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            reconnectStartTime = Date.now();
                            previousReconnectAttempts = 0;
                            retryError = error !== undefined ? error : new Error("Attempting to reconnect due to a unknown error.");
                            nextRetryDelay = this.getNextRetryDelay(previousReconnectAttempts++, 0, retryError);
                            if (nextRetryDelay === null) {
                                this.logger.log(LogLevel.Debug, "Connection not reconnecting because the IRetryPolicy returned null on the first reconnect attempt.");
                                this.completeClose(error);
                                return [2 /*return*/];
                            }
                            this.connectionState = HubConnectionState.Reconnecting;
                            if (error) {
                                this.logger.log(LogLevel.Information, "Connection reconnecting because of error '" + error + "'.");
                            }
                            else {
                                this.logger.log(LogLevel.Information, "Connection reconnecting.");
                            }
                            if (this.onreconnecting) {
                                try {
                                    this.reconnectingCallbacks.forEach(function (c) { return c.apply(_this, [error]); });
                                }
                                catch (e) {
                                    this.logger.log(LogLevel.Error, "An onreconnecting callback called with error '" + error + "' threw error '" + e + "'.");
                                }
                                // Exit early if an onreconnecting callback called connection.stop().
                                if (this.connectionState !== HubConnectionState.Reconnecting) {
                                    this.logger.log(LogLevel.Debug, "Connection left the reconnecting state in onreconnecting callback. Done reconnecting.");
                                    return [2 /*return*/];
                                }
                            }
                            _a.label = 1;
                        case 1:
                            if (!(nextRetryDelay !== null)) return [3 /*break*/, 7];
                            this.logger.log(LogLevel.Information, "Reconnect attempt number " + previousReconnectAttempts + " will start in " + nextRetryDelay + " ms.");
                            return [4 /*yield*/, new Promise(function (resolve) {
                                    _this.reconnectDelayHandle = setTimeout(resolve, nextRetryDelay);
                                })];
                        case 2:
                            _a.sent();
                            this.reconnectDelayHandle = undefined;
                            if (this.connectionState !== HubConnectionState.Reconnecting) {
                                this.logger.log(LogLevel.Debug, "Connection left the reconnecting state during reconnect delay. Done reconnecting.");
                                return [2 /*return*/];
                            }
                            _a.label = 3;
                        case 3:
                            _a.trys.push([3, 5, , 6]);
                            return [4 /*yield*/, this.startInternal()];
                        case 4:
                            _a.sent();
                            this.connectionState = HubConnectionState.Connected;
                            this.logger.log(LogLevel.Information, "HubConnection reconnected successfully.");
                            if (this.onreconnected) {
                                try {
                                    this.reconnectedCallbacks.forEach(function (c) { return c.apply(_this, [_this.connection.connectionId]); });
                                }
                                catch (e) {
                                    this.logger.log(LogLevel.Error, "An onreconnected callback called with connectionId '" + this.connection.connectionId + "; threw error '" + e + "'.");
                                }
                            }
                            return [2 /*return*/];
                        case 5:
                            e_4 = _a.sent();
                            this.logger.log(LogLevel.Information, "Reconnect attempt failed because of error '" + e_4 + "'.");
                            if (this.connectionState !== HubConnectionState.Reconnecting) {
                                this.logger.log(LogLevel.Debug, "Connection left the reconnecting state during reconnect attempt. Done reconnecting.");
                                return [2 /*return*/];
                            }
                            retryError = e_4 instanceof Error ? e_4 : new Error(e_4.toString());
                            nextRetryDelay = this.getNextRetryDelay(previousReconnectAttempts++, Date.now() - reconnectStartTime, retryError);
                            return [3 /*break*/, 6];
                        case 6: return [3 /*break*/, 1];
                        case 7:
                            this.logger.log(LogLevel.Information, "Reconnect retries have been exhausted after " + (Date.now() - reconnectStartTime) + " ms and " + previousReconnectAttempts + " failed attempts. Connection disconnecting.");
                            this.completeClose();
                            return [2 /*return*/];
                    }
                });
            });
        };
        HubConnection.prototype.getNextRetryDelay = function (previousRetryCount, elapsedMilliseconds, retryReason) {
            try {
                return this.reconnectPolicy.nextRetryDelayInMilliseconds({
                    elapsedMilliseconds: elapsedMilliseconds,
                    previousRetryCount: previousRetryCount,
                    retryReason: retryReason,
                });
            }
            catch (e) {
                this.logger.log(LogLevel.Error, "IRetryPolicy.nextRetryDelayInMilliseconds(" + previousRetryCount + ", " + elapsedMilliseconds + ") threw error '" + e + "'.");
                return null;
            }
        };
        HubConnection.prototype.cancelCallbacksWithError = function (error) {
            var callbacks = this.callbacks;
            this.callbacks = {};
            Object.keys(callbacks)
                .forEach(function (key) {
                var callback = callbacks[key];
                callback(null, error);
            });
        };
        HubConnection.prototype.cleanupPingTimer = function () {
            if (this.pingServerHandle) {
                clearTimeout(this.pingServerHandle);
            }
        };
        HubConnection.prototype.cleanupTimeout = function () {
            if (this.timeoutHandle) {
                clearTimeout(this.timeoutHandle);
            }
        };
        HubConnection.prototype.createInvocation = function (methodName, args, nonblocking, streamIds) {
            if (nonblocking) {
                return {
                    arguments: args,
                    streamIds: streamIds,
                    target: methodName,
                    type: MessageType.Invocation,
                };
            }
            else {
                var invocationId = this.invocationId;
                this.invocationId++;
                return {
                    arguments: args,
                    invocationId: invocationId.toString(),
                    streamIds: streamIds,
                    target: methodName,
                    type: MessageType.Invocation,
                };
            }
        };
        HubConnection.prototype.launchStreams = function (streams, promiseQueue) {
            var _this = this;
            if (streams.length === 0) {
                return;
            }
            // Synchronize stream data so they arrive in-order on the server
            if (!promiseQueue) {
                promiseQueue = Promise.resolve();
            }
            var _loop_1 = function (streamId) {
                streams[streamId].subscribe({
                    complete: function () {
                        promiseQueue = promiseQueue.then(function () { return _this.sendWithProtocol(_this.createCompletionMessage(streamId)); });
                    },
                    error: function (err) {
                        var message;
                        if (err instanceof Error) {
                            message = err.message;
                        }
                        else if (err && err.toString) {
                            message = err.toString();
                        }
                        else {
                            message = "Unknown error";
                        }
                        promiseQueue = promiseQueue.then(function () { return _this.sendWithProtocol(_this.createCompletionMessage(streamId, message)); });
                    },
                    next: function (item) {
                        promiseQueue = promiseQueue.then(function () { return _this.sendWithProtocol(_this.createStreamItemMessage(streamId, item)); });
                    },
                });
            };
            // We want to iterate over the keys, since the keys are the stream ids
            // tslint:disable-next-line:forin
            for (var streamId in streams) {
                _loop_1(streamId);
            }
        };
        HubConnection.prototype.replaceStreamingParams = function (args) {
            var streams = [];
            var streamIds = [];
            for (var i = 0; i < args.length; i++) {
                var argument = args[i];
                if (this.isObservable(argument)) {
                    var streamId = this.invocationId;
                    this.invocationId++;
                    // Store the stream for later use
                    streams[streamId] = argument;
                    streamIds.push(streamId.toString());
                    // remove stream from args
                    args.splice(i, 1);
                }
            }
            return [streams, streamIds];
        };
        HubConnection.prototype.isObservable = function (arg) {
            // This allows other stream implementations to just work (like rxjs)
            return arg && arg.subscribe && typeof arg.subscribe === "function";
        };
        HubConnection.prototype.createStreamInvocation = function (methodName, args, streamIds) {
            var invocationId = this.invocationId;
            this.invocationId++;
            return {
                arguments: args,
                invocationId: invocationId.toString(),
                streamIds: streamIds,
                target: methodName,
                type: MessageType.StreamInvocation,
            };
        };
        HubConnection.prototype.createCancelInvocation = function (id) {
            return {
                invocationId: id,
                type: MessageType.CancelInvocation,
            };
        };
        HubConnection.prototype.createStreamItemMessage = function (id, item) {
            return {
                invocationId: id,
                item: item,
                type: MessageType.StreamItem,
            };
        };
        HubConnection.prototype.createCompletionMessage = function (id, error, result) {
            if (error) {
                return {
                    error: error,
                    invocationId: id,
                    type: MessageType.Completion,
                };
            }
            return {
                invocationId: id,
                result: result,
                type: MessageType.Completion,
            };
        };
        return HubConnection;
    }());

    // Copyright (c) .NET Foundation. All rights reserved.
    // Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.
    // 0, 2, 10, 30 second delays before reconnect attempts.
    var DEFAULT_RETRY_DELAYS_IN_MILLISECONDS = [0, 2000, 10000, 30000, null];
    /** @private */
    var DefaultReconnectPolicy = /** @class */ (function () {
        function DefaultReconnectPolicy(retryDelays) {
            this.retryDelays = retryDelays !== undefined ? retryDelays.concat([null]) : DEFAULT_RETRY_DELAYS_IN_MILLISECONDS;
        }
        DefaultReconnectPolicy.prototype.nextRetryDelayInMilliseconds = function (retryContext) {
            return this.retryDelays[retryContext.previousRetryCount];
        };
        return DefaultReconnectPolicy;
    }());

    // Copyright (c) .NET Foundation. All rights reserved.
    // Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.
    // This will be treated as a bit flag in the future, so we keep it using power-of-two values.
    /** Specifies a specific HTTP transport type. */
    var HttpTransportType;
    (function (HttpTransportType) {
        /** Specifies no transport preference. */
        HttpTransportType[HttpTransportType["None"] = 0] = "None";
        /** Specifies the WebSockets transport. */
        HttpTransportType[HttpTransportType["WebSockets"] = 1] = "WebSockets";
        /** Specifies the Server-Sent Events transport. */
        HttpTransportType[HttpTransportType["ServerSentEvents"] = 2] = "ServerSentEvents";
        /** Specifies the Long Polling transport. */
        HttpTransportType[HttpTransportType["LongPolling"] = 4] = "LongPolling";
    })(HttpTransportType || (HttpTransportType = {}));
    /** Specifies the transfer format for a connection. */
    var TransferFormat;
    (function (TransferFormat) {
        /** Specifies that only text data will be transmitted over the connection. */
        TransferFormat[TransferFormat["Text"] = 1] = "Text";
        /** Specifies that binary data will be transmitted over the connection. */
        TransferFormat[TransferFormat["Binary"] = 2] = "Binary";
    })(TransferFormat || (TransferFormat = {}));

    // Copyright (c) .NET Foundation. All rights reserved.
    // Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.
    // Rough polyfill of https://developer.mozilla.org/en-US/docs/Web/API/AbortController
    // We don't actually ever use the API being polyfilled, we always use the polyfill because
    // it's a very new API right now.
    // Not exported from index.
    /** @private */
    var AbortController = /** @class */ (function () {
        function AbortController() {
            this.isAborted = false;
            this.onabort = null;
        }
        AbortController.prototype.abort = function () {
            if (!this.isAborted) {
                this.isAborted = true;
                if (this.onabort) {
                    this.onabort();
                }
            }
        };
        Object.defineProperty(AbortController.prototype, "signal", {
            get: function () {
                return this;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(AbortController.prototype, "aborted", {
            get: function () {
                return this.isAborted;
            },
            enumerable: true,
            configurable: true
        });
        return AbortController;
    }());

    // Copyright (c) .NET Foundation. All rights reserved.
    // Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.
    var __awaiter$2 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };
    var __generator$2 = (undefined && undefined.__generator) || function (thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    };
    // Not exported from 'index', this type is internal.
    /** @private */
    var LongPollingTransport = /** @class */ (function () {
        function LongPollingTransport(httpClient, accessTokenFactory, logger, logMessageContent) {
            this.httpClient = httpClient;
            this.accessTokenFactory = accessTokenFactory;
            this.logger = logger;
            this.pollAbort = new AbortController();
            this.logMessageContent = logMessageContent;
            this.running = false;
            this.onreceive = null;
            this.onclose = null;
        }
        Object.defineProperty(LongPollingTransport.prototype, "pollAborted", {
            // This is an internal type, not exported from 'index' so this is really just internal.
            get: function () {
                return this.pollAbort.aborted;
            },
            enumerable: true,
            configurable: true
        });
        LongPollingTransport.prototype.connect = function (url, transferFormat) {
            return __awaiter$2(this, void 0, void 0, function () {
                var pollOptions, token, pollUrl, response;
                return __generator$2(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            Arg.isRequired(url, "url");
                            Arg.isRequired(transferFormat, "transferFormat");
                            Arg.isIn(transferFormat, TransferFormat, "transferFormat");
                            this.url = url;
                            this.logger.log(LogLevel.Trace, "(LongPolling transport) Connecting.");
                            // Allow binary format on Node and Browsers that support binary content (indicated by the presence of responseType property)
                            if (transferFormat === TransferFormat.Binary &&
                                (typeof XMLHttpRequest !== "undefined" && typeof new XMLHttpRequest().responseType !== "string")) {
                                throw new Error("Binary protocols over XmlHttpRequest not implementing advanced features are not supported.");
                            }
                            pollOptions = {
                                abortSignal: this.pollAbort.signal,
                                headers: {},
                                timeout: 100000,
                            };
                            if (transferFormat === TransferFormat.Binary) {
                                pollOptions.responseType = "arraybuffer";
                            }
                            return [4 /*yield*/, this.getAccessToken()];
                        case 1:
                            token = _a.sent();
                            this.updateHeaderToken(pollOptions, token);
                            pollUrl = url + "&_=" + Date.now();
                            this.logger.log(LogLevel.Trace, "(LongPolling transport) polling: " + pollUrl + ".");
                            return [4 /*yield*/, this.httpClient.get(pollUrl, pollOptions)];
                        case 2:
                            response = _a.sent();
                            if (response.statusCode !== 200) {
                                this.logger.log(LogLevel.Error, "(LongPolling transport) Unexpected response code: " + response.statusCode + ".");
                                // Mark running as false so that the poll immediately ends and runs the close logic
                                this.closeError = new HttpError(response.statusText || "", response.statusCode);
                                this.running = false;
                            }
                            else {
                                this.running = true;
                            }
                            this.receiving = this.poll(this.url, pollOptions);
                            return [2 /*return*/];
                    }
                });
            });
        };
        LongPollingTransport.prototype.getAccessToken = function () {
            return __awaiter$2(this, void 0, void 0, function () {
                return __generator$2(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (!this.accessTokenFactory) return [3 /*break*/, 2];
                            return [4 /*yield*/, this.accessTokenFactory()];
                        case 1: return [2 /*return*/, _a.sent()];
                        case 2: return [2 /*return*/, null];
                    }
                });
            });
        };
        LongPollingTransport.prototype.updateHeaderToken = function (request, token) {
            if (!request.headers) {
                request.headers = {};
            }
            if (token) {
                // tslint:disable-next-line:no-string-literal
                request.headers["Authorization"] = "Bearer " + token;
                return;
            }
            // tslint:disable-next-line:no-string-literal
            if (request.headers["Authorization"]) {
                // tslint:disable-next-line:no-string-literal
                delete request.headers["Authorization"];
            }
        };
        LongPollingTransport.prototype.poll = function (url, pollOptions) {
            return __awaiter$2(this, void 0, void 0, function () {
                var token, pollUrl, response, e_1;
                return __generator$2(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            _a.trys.push([0, , 8, 9]);
                            _a.label = 1;
                        case 1:
                            if (!this.running) return [3 /*break*/, 7];
                            return [4 /*yield*/, this.getAccessToken()];
                        case 2:
                            token = _a.sent();
                            this.updateHeaderToken(pollOptions, token);
                            _a.label = 3;
                        case 3:
                            _a.trys.push([3, 5, , 6]);
                            pollUrl = url + "&_=" + Date.now();
                            this.logger.log(LogLevel.Trace, "(LongPolling transport) polling: " + pollUrl + ".");
                            return [4 /*yield*/, this.httpClient.get(pollUrl, pollOptions)];
                        case 4:
                            response = _a.sent();
                            if (response.statusCode === 204) {
                                this.logger.log(LogLevel.Information, "(LongPolling transport) Poll terminated by server.");
                                this.running = false;
                            }
                            else if (response.statusCode !== 200) {
                                this.logger.log(LogLevel.Error, "(LongPolling transport) Unexpected response code: " + response.statusCode + ".");
                                // Unexpected status code
                                this.closeError = new HttpError(response.statusText || "", response.statusCode);
                                this.running = false;
                            }
                            else {
                                // Process the response
                                if (response.content) {
                                    this.logger.log(LogLevel.Trace, "(LongPolling transport) data received. " + getDataDetail(response.content, this.logMessageContent) + ".");
                                    if (this.onreceive) {
                                        this.onreceive(response.content);
                                    }
                                }
                                else {
                                    // This is another way timeout manifest.
                                    this.logger.log(LogLevel.Trace, "(LongPolling transport) Poll timed out, reissuing.");
                                }
                            }
                            return [3 /*break*/, 6];
                        case 5:
                            e_1 = _a.sent();
                            if (!this.running) {
                                // Log but disregard errors that occur after stopping
                                this.logger.log(LogLevel.Trace, "(LongPolling transport) Poll errored after shutdown: " + e_1.message);
                            }
                            else {
                                if (e_1 instanceof TimeoutError) {
                                    // Ignore timeouts and reissue the poll.
                                    this.logger.log(LogLevel.Trace, "(LongPolling transport) Poll timed out, reissuing.");
                                }
                                else {
                                    // Close the connection with the error as the result.
                                    this.closeError = e_1;
                                    this.running = false;
                                }
                            }
                            return [3 /*break*/, 6];
                        case 6: return [3 /*break*/, 1];
                        case 7: return [3 /*break*/, 9];
                        case 8:
                            this.logger.log(LogLevel.Trace, "(LongPolling transport) Polling complete.");
                            // We will reach here with pollAborted==false when the server returned a response causing the transport to stop.
                            // If pollAborted==true then client initiated the stop and the stop method will raise the close event after DELETE is sent.
                            if (!this.pollAborted) {
                                this.raiseOnClose();
                            }
                            return [7 /*endfinally*/];
                        case 9: return [2 /*return*/];
                    }
                });
            });
        };
        LongPollingTransport.prototype.send = function (data) {
            return __awaiter$2(this, void 0, void 0, function () {
                return __generator$2(this, function (_a) {
                    if (!this.running) {
                        return [2 /*return*/, Promise.reject(new Error("Cannot send until the transport is connected"))];
                    }
                    return [2 /*return*/, sendMessage(this.logger, "LongPolling", this.httpClient, this.url, this.accessTokenFactory, data, this.logMessageContent)];
                });
            });
        };
        LongPollingTransport.prototype.stop = function () {
            return __awaiter$2(this, void 0, void 0, function () {
                var deleteOptions, token;
                return __generator$2(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            this.logger.log(LogLevel.Trace, "(LongPolling transport) Stopping polling.");
                            // Tell receiving loop to stop, abort any current request, and then wait for it to finish
                            this.running = false;
                            this.pollAbort.abort();
                            _a.label = 1;
                        case 1:
                            _a.trys.push([1, , 5, 6]);
                            return [4 /*yield*/, this.receiving];
                        case 2:
                            _a.sent();
                            // Send DELETE to clean up long polling on the server
                            this.logger.log(LogLevel.Trace, "(LongPolling transport) sending DELETE request to " + this.url + ".");
                            deleteOptions = {
                                headers: {},
                            };
                            return [4 /*yield*/, this.getAccessToken()];
                        case 3:
                            token = _a.sent();
                            this.updateHeaderToken(deleteOptions, token);
                            return [4 /*yield*/, this.httpClient.delete(this.url, deleteOptions)];
                        case 4:
                            _a.sent();
                            this.logger.log(LogLevel.Trace, "(LongPolling transport) DELETE request sent.");
                            return [3 /*break*/, 6];
                        case 5:
                            this.logger.log(LogLevel.Trace, "(LongPolling transport) Stop finished.");
                            // Raise close event here instead of in polling
                            // It needs to happen after the DELETE request is sent
                            this.raiseOnClose();
                            return [7 /*endfinally*/];
                        case 6: return [2 /*return*/];
                    }
                });
            });
        };
        LongPollingTransport.prototype.raiseOnClose = function () {
            if (this.onclose) {
                var logMessage = "(LongPolling transport) Firing onclose event.";
                if (this.closeError) {
                    logMessage += " Error: " + this.closeError;
                }
                this.logger.log(LogLevel.Trace, logMessage);
                this.onclose(this.closeError);
            }
        };
        return LongPollingTransport;
    }());

    // Copyright (c) .NET Foundation. All rights reserved.
    // Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.
    var __awaiter$3 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };
    var __generator$3 = (undefined && undefined.__generator) || function (thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    };
    /** @private */
    var ServerSentEventsTransport = /** @class */ (function () {
        function ServerSentEventsTransport(httpClient, accessTokenFactory, logger, logMessageContent, eventSourceConstructor) {
            this.httpClient = httpClient;
            this.accessTokenFactory = accessTokenFactory;
            this.logger = logger;
            this.logMessageContent = logMessageContent;
            this.eventSourceConstructor = eventSourceConstructor;
            this.onreceive = null;
            this.onclose = null;
        }
        ServerSentEventsTransport.prototype.connect = function (url, transferFormat) {
            return __awaiter$3(this, void 0, void 0, function () {
                var token;
                var _this = this;
                return __generator$3(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            Arg.isRequired(url, "url");
                            Arg.isRequired(transferFormat, "transferFormat");
                            Arg.isIn(transferFormat, TransferFormat, "transferFormat");
                            this.logger.log(LogLevel.Trace, "(SSE transport) Connecting.");
                            // set url before accessTokenFactory because this.url is only for send and we set the auth header instead of the query string for send
                            this.url = url;
                            if (!this.accessTokenFactory) return [3 /*break*/, 2];
                            return [4 /*yield*/, this.accessTokenFactory()];
                        case 1:
                            token = _a.sent();
                            if (token) {
                                url += (url.indexOf("?") < 0 ? "?" : "&") + ("access_token=" + encodeURIComponent(token));
                            }
                            _a.label = 2;
                        case 2: return [2 /*return*/, new Promise(function (resolve, reject) {
                                var opened = false;
                                if (transferFormat !== TransferFormat.Text) {
                                    reject(new Error("The Server-Sent Events transport only supports the 'Text' transfer format"));
                                    return;
                                }
                                var eventSource;
                                if (Platform.isBrowser || Platform.isWebWorker) {
                                    eventSource = new _this.eventSourceConstructor(url, { withCredentials: true });
                                }
                                else {
                                    // Non-browser passes cookies via the dictionary
                                    var cookies = _this.httpClient.getCookieString(url);
                                    eventSource = new _this.eventSourceConstructor(url, { withCredentials: true, headers: { Cookie: cookies } });
                                }
                                try {
                                    eventSource.onmessage = function (e) {
                                        if (_this.onreceive) {
                                            try {
                                                _this.logger.log(LogLevel.Trace, "(SSE transport) data received. " + getDataDetail(e.data, _this.logMessageContent) + ".");
                                                _this.onreceive(e.data);
                                            }
                                            catch (error) {
                                                _this.close(error);
                                                return;
                                            }
                                        }
                                    };
                                    eventSource.onerror = function (e) {
                                        var error = new Error(e.data || "Error occurred");
                                        if (opened) {
                                            _this.close(error);
                                        }
                                        else {
                                            reject(error);
                                        }
                                    };
                                    eventSource.onopen = function () {
                                        _this.logger.log(LogLevel.Information, "SSE connected to " + _this.url);
                                        _this.eventSource = eventSource;
                                        opened = true;
                                        resolve();
                                    };
                                }
                                catch (e) {
                                    reject(e);
                                    return;
                                }
                            })];
                    }
                });
            });
        };
        ServerSentEventsTransport.prototype.send = function (data) {
            return __awaiter$3(this, void 0, void 0, function () {
                return __generator$3(this, function (_a) {
                    if (!this.eventSource) {
                        return [2 /*return*/, Promise.reject(new Error("Cannot send until the transport is connected"))];
                    }
                    return [2 /*return*/, sendMessage(this.logger, "SSE", this.httpClient, this.url, this.accessTokenFactory, data, this.logMessageContent)];
                });
            });
        };
        ServerSentEventsTransport.prototype.stop = function () {
            this.close();
            return Promise.resolve();
        };
        ServerSentEventsTransport.prototype.close = function (e) {
            if (this.eventSource) {
                this.eventSource.close();
                this.eventSource = undefined;
                if (this.onclose) {
                    this.onclose(e);
                }
            }
        };
        return ServerSentEventsTransport;
    }());

    // Copyright (c) .NET Foundation. All rights reserved.
    // Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.
    var __awaiter$4 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };
    var __generator$4 = (undefined && undefined.__generator) || function (thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    };
    /** @private */
    var WebSocketTransport = /** @class */ (function () {
        function WebSocketTransport(httpClient, accessTokenFactory, logger, logMessageContent, webSocketConstructor) {
            this.logger = logger;
            this.accessTokenFactory = accessTokenFactory;
            this.logMessageContent = logMessageContent;
            this.webSocketConstructor = webSocketConstructor;
            this.httpClient = httpClient;
            this.onreceive = null;
            this.onclose = null;
        }
        WebSocketTransport.prototype.connect = function (url, transferFormat) {
            return __awaiter$4(this, void 0, void 0, function () {
                var token;
                var _this = this;
                return __generator$4(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            Arg.isRequired(url, "url");
                            Arg.isRequired(transferFormat, "transferFormat");
                            Arg.isIn(transferFormat, TransferFormat, "transferFormat");
                            this.logger.log(LogLevel.Trace, "(WebSockets transport) Connecting.");
                            if (!this.accessTokenFactory) return [3 /*break*/, 2];
                            return [4 /*yield*/, this.accessTokenFactory()];
                        case 1:
                            token = _a.sent();
                            if (token) {
                                url += (url.indexOf("?") < 0 ? "?" : "&") + ("access_token=" + encodeURIComponent(token));
                            }
                            _a.label = 2;
                        case 2: return [2 /*return*/, new Promise(function (resolve, reject) {
                                url = url.replace(/^http/, "ws");
                                var webSocket;
                                var cookies = _this.httpClient.getCookieString(url);
                                var opened = false;
                                if (Platform.isNode && cookies) {
                                    // Only pass cookies when in non-browser environments
                                    webSocket = new _this.webSocketConstructor(url, undefined, {
                                        headers: {
                                            Cookie: "" + cookies,
                                        },
                                    });
                                }
                                if (!webSocket) {
                                    // Chrome is not happy with passing 'undefined' as protocol
                                    webSocket = new _this.webSocketConstructor(url);
                                }
                                if (transferFormat === TransferFormat.Binary) {
                                    webSocket.binaryType = "arraybuffer";
                                }
                                // tslint:disable-next-line:variable-name
                                webSocket.onopen = function (_event) {
                                    _this.logger.log(LogLevel.Information, "WebSocket connected to " + url + ".");
                                    _this.webSocket = webSocket;
                                    opened = true;
                                    resolve();
                                };
                                webSocket.onerror = function (event) {
                                    var error = null;
                                    // ErrorEvent is a browser only type we need to check if the type exists before using it
                                    if (typeof ErrorEvent !== "undefined" && event instanceof ErrorEvent) {
                                        error = event.error;
                                    }
                                    else {
                                        error = new Error("There was an error with the transport.");
                                    }
                                    reject(error);
                                };
                                webSocket.onmessage = function (message) {
                                    _this.logger.log(LogLevel.Trace, "(WebSockets transport) data received. " + getDataDetail(message.data, _this.logMessageContent) + ".");
                                    if (_this.onreceive) {
                                        _this.onreceive(message.data);
                                    }
                                };
                                webSocket.onclose = function (event) {
                                    // Don't call close handler if connection was never established
                                    // We'll reject the connect call instead
                                    if (opened) {
                                        _this.close(event);
                                    }
                                    else {
                                        var error = null;
                                        // ErrorEvent is a browser only type we need to check if the type exists before using it
                                        if (typeof ErrorEvent !== "undefined" && event instanceof ErrorEvent) {
                                            error = event.error;
                                        }
                                        else {
                                            error = new Error("There was an error with the transport.");
                                        }
                                        reject(error);
                                    }
                                };
                            })];
                    }
                });
            });
        };
        WebSocketTransport.prototype.send = function (data) {
            if (this.webSocket && this.webSocket.readyState === this.webSocketConstructor.OPEN) {
                this.logger.log(LogLevel.Trace, "(WebSockets transport) sending data. " + getDataDetail(data, this.logMessageContent) + ".");
                this.webSocket.send(data);
                return Promise.resolve();
            }
            return Promise.reject("WebSocket is not in the OPEN state");
        };
        WebSocketTransport.prototype.stop = function () {
            if (this.webSocket) {
                // Manually invoke onclose callback inline so we know the HttpConnection was closed properly before returning
                // This also solves an issue where websocket.onclose could take 18+ seconds to trigger during network disconnects
                this.close(undefined);
            }
            return Promise.resolve();
        };
        WebSocketTransport.prototype.close = function (event) {
            // webSocket will be null if the transport did not start successfully
            if (this.webSocket) {
                // Clear websocket handlers because we are considering the socket closed now
                this.webSocket.onclose = function () { };
                this.webSocket.onmessage = function () { };
                this.webSocket.onerror = function () { };
                this.webSocket.close();
                this.webSocket = undefined;
            }
            this.logger.log(LogLevel.Trace, "(WebSockets transport) socket closed.");
            if (this.onclose) {
                if (event && (event.wasClean === false || event.code !== 1000)) {
                    this.onclose(new Error("WebSocket closed with status code: " + event.code + " (" + event.reason + ")."));
                }
                else {
                    this.onclose();
                }
            }
        };
        return WebSocketTransport;
    }());

    // Copyright (c) .NET Foundation. All rights reserved.
    // Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.
    var __awaiter$5 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };
    var __generator$5 = (undefined && undefined.__generator) || function (thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    };
    var MAX_REDIRECTS = 100;
    var WebSocketModule = null;
    var EventSourceModule = null;
    if (Platform.isNode && typeof require !== "undefined") {
        // In order to ignore the dynamic require in webpack builds we need to do this magic
        // @ts-ignore: TS doesn't know about these names
        var requireFunc$1 = typeof __webpack_require__ === "function" ? __non_webpack_require__ : require;
        WebSocketModule = requireFunc$1("ws");
        EventSourceModule = requireFunc$1("eventsource");
    }
    /** @private */
    var HttpConnection = /** @class */ (function () {
        function HttpConnection(url, options) {
            if (options === void 0) { options = {}; }
            this.features = {};
            this.negotiateVersion = 1;
            Arg.isRequired(url, "url");
            this.logger = createLogger(options.logger);
            this.baseUrl = this.resolveUrl(url);
            options = options || {};
            options.logMessageContent = options.logMessageContent || false;
            if (!Platform.isNode && typeof WebSocket !== "undefined" && !options.WebSocket) {
                options.WebSocket = WebSocket;
            }
            else if (Platform.isNode && !options.WebSocket) {
                if (WebSocketModule) {
                    options.WebSocket = WebSocketModule;
                }
            }
            if (!Platform.isNode && typeof EventSource !== "undefined" && !options.EventSource) {
                options.EventSource = EventSource;
            }
            else if (Platform.isNode && !options.EventSource) {
                if (typeof EventSourceModule !== "undefined") {
                    options.EventSource = EventSourceModule;
                }
            }
            this.httpClient = options.httpClient || new DefaultHttpClient(this.logger);
            this.connectionState = "Disconnected" /* Disconnected */;
            this.connectionStarted = false;
            this.options = options;
            this.onreceive = null;
            this.onclose = null;
        }
        HttpConnection.prototype.start = function (transferFormat) {
            return __awaiter$5(this, void 0, void 0, function () {
                var message, message;
                return __generator$5(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            transferFormat = transferFormat || TransferFormat.Binary;
                            Arg.isIn(transferFormat, TransferFormat, "transferFormat");
                            this.logger.log(LogLevel.Debug, "Starting connection with transfer format '" + TransferFormat[transferFormat] + "'.");
                            if (this.connectionState !== "Disconnected" /* Disconnected */) {
                                return [2 /*return*/, Promise.reject(new Error("Cannot start an HttpConnection that is not in the 'Disconnected' state."))];
                            }
                            this.connectionState = "Connecting " /* Connecting */;
                            this.startInternalPromise = this.startInternal(transferFormat);
                            return [4 /*yield*/, this.startInternalPromise];
                        case 1:
                            _a.sent();
                            if (!(this.connectionState === "Disconnecting" /* Disconnecting */)) return [3 /*break*/, 3];
                            message = "Failed to start the HttpConnection before stop() was called.";
                            this.logger.log(LogLevel.Error, message);
                            // We cannot await stopPromise inside startInternal since stopInternal awaits the startInternalPromise.
                            return [4 /*yield*/, this.stopPromise];
                        case 2:
                            // We cannot await stopPromise inside startInternal since stopInternal awaits the startInternalPromise.
                            _a.sent();
                            return [2 /*return*/, Promise.reject(new Error(message))];
                        case 3:
                            if (this.connectionState !== "Connected" /* Connected */) {
                                message = "HttpConnection.startInternal completed gracefully but didn't enter the connection into the connected state!";
                                this.logger.log(LogLevel.Error, message);
                                return [2 /*return*/, Promise.reject(new Error(message))];
                            }
                            _a.label = 4;
                        case 4:
                            this.connectionStarted = true;
                            return [2 /*return*/];
                    }
                });
            });
        };
        HttpConnection.prototype.send = function (data) {
            if (this.connectionState !== "Connected" /* Connected */) {
                return Promise.reject(new Error("Cannot send data if the connection is not in the 'Connected' State."));
            }
            if (!this.sendQueue) {
                this.sendQueue = new TransportSendQueue(this.transport);
            }
            // Transport will not be null if state is connected
            return this.sendQueue.send(data);
        };
        HttpConnection.prototype.stop = function (error) {
            return __awaiter$5(this, void 0, void 0, function () {
                var _this = this;
                return __generator$5(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (this.connectionState === "Disconnected" /* Disconnected */) {
                                this.logger.log(LogLevel.Debug, "Call to HttpConnection.stop(" + error + ") ignored because the connection is already in the disconnected state.");
                                return [2 /*return*/, Promise.resolve()];
                            }
                            if (this.connectionState === "Disconnecting" /* Disconnecting */) {
                                this.logger.log(LogLevel.Debug, "Call to HttpConnection.stop(" + error + ") ignored because the connection is already in the disconnecting state.");
                                return [2 /*return*/, this.stopPromise];
                            }
                            this.connectionState = "Disconnecting" /* Disconnecting */;
                            this.stopPromise = new Promise(function (resolve) {
                                // Don't complete stop() until stopConnection() completes.
                                _this.stopPromiseResolver = resolve;
                            });
                            // stopInternal should never throw so just observe it.
                            return [4 /*yield*/, this.stopInternal(error)];
                        case 1:
                            // stopInternal should never throw so just observe it.
                            _a.sent();
                            return [4 /*yield*/, this.stopPromise];
                        case 2:
                            _a.sent();
                            return [2 /*return*/];
                    }
                });
            });
        };
        HttpConnection.prototype.stopInternal = function (error) {
            return __awaiter$5(this, void 0, void 0, function () {
                var e_1, e_2;
                return __generator$5(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // Set error as soon as possible otherwise there is a race between
                            // the transport closing and providing an error and the error from a close message
                            // We would prefer the close message error.
                            this.stopError = error;
                            _a.label = 1;
                        case 1:
                            _a.trys.push([1, 3, , 4]);
                            return [4 /*yield*/, this.startInternalPromise];
                        case 2:
                            _a.sent();
                            return [3 /*break*/, 4];
                        case 3:
                            e_1 = _a.sent();
                            return [3 /*break*/, 4];
                        case 4:
                            if (!this.transport) return [3 /*break*/, 9];
                            _a.label = 5;
                        case 5:
                            _a.trys.push([5, 7, , 8]);
                            return [4 /*yield*/, this.transport.stop()];
                        case 6:
                            _a.sent();
                            return [3 /*break*/, 8];
                        case 7:
                            e_2 = _a.sent();
                            this.logger.log(LogLevel.Error, "HttpConnection.transport.stop() threw error '" + e_2 + "'.");
                            this.stopConnection();
                            return [3 /*break*/, 8];
                        case 8:
                            this.transport = undefined;
                            return [3 /*break*/, 10];
                        case 9:
                            this.logger.log(LogLevel.Debug, "HttpConnection.transport is undefined in HttpConnection.stop() because start() failed.");
                            this.stopConnection();
                            _a.label = 10;
                        case 10: return [2 /*return*/];
                    }
                });
            });
        };
        HttpConnection.prototype.startInternal = function (transferFormat) {
            return __awaiter$5(this, void 0, void 0, function () {
                var url, negotiateResponse, redirects, _loop_1, this_1, e_3;
                return __generator$5(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            url = this.baseUrl;
                            this.accessTokenFactory = this.options.accessTokenFactory;
                            _a.label = 1;
                        case 1:
                            _a.trys.push([1, 12, , 13]);
                            if (!this.options.skipNegotiation) return [3 /*break*/, 5];
                            if (!(this.options.transport === HttpTransportType.WebSockets)) return [3 /*break*/, 3];
                            // No need to add a connection ID in this case
                            this.transport = this.constructTransport(HttpTransportType.WebSockets);
                            // We should just call connect directly in this case.
                            // No fallback or negotiate in this case.
                            return [4 /*yield*/, this.startTransport(url, transferFormat)];
                        case 2:
                            // We should just call connect directly in this case.
                            // No fallback or negotiate in this case.
                            _a.sent();
                            return [3 /*break*/, 4];
                        case 3: throw new Error("Negotiation can only be skipped when using the WebSocket transport directly.");
                        case 4: return [3 /*break*/, 11];
                        case 5:
                            negotiateResponse = null;
                            redirects = 0;
                            _loop_1 = function () {
                                var accessToken_1;
                                return __generator$5(this, function (_a) {
                                    switch (_a.label) {
                                        case 0: return [4 /*yield*/, this_1.getNegotiationResponse(url)];
                                        case 1:
                                            negotiateResponse = _a.sent();
                                            // the user tries to stop the connection when it is being started
                                            if (this_1.connectionState === "Disconnecting" /* Disconnecting */ || this_1.connectionState === "Disconnected" /* Disconnected */) {
                                                throw new Error("The connection was stopped during negotiation.");
                                            }
                                            if (negotiateResponse.error) {
                                                throw new Error(negotiateResponse.error);
                                            }
                                            if (negotiateResponse.ProtocolVersion) {
                                                throw new Error("Detected a connection attempt to an ASP.NET SignalR Server. This client only supports connecting to an ASP.NET Core SignalR Server. See https://aka.ms/signalr-core-differences for details.");
                                            }
                                            if (negotiateResponse.url) {
                                                url = negotiateResponse.url;
                                            }
                                            if (negotiateResponse.accessToken) {
                                                accessToken_1 = negotiateResponse.accessToken;
                                                this_1.accessTokenFactory = function () { return accessToken_1; };
                                            }
                                            redirects++;
                                            return [2 /*return*/];
                                    }
                                });
                            };
                            this_1 = this;
                            _a.label = 6;
                        case 6: return [5 /*yield**/, _loop_1()];
                        case 7:
                            _a.sent();
                            _a.label = 8;
                        case 8:
                            if (negotiateResponse.url && redirects < MAX_REDIRECTS) return [3 /*break*/, 6];
                            _a.label = 9;
                        case 9:
                            if (redirects === MAX_REDIRECTS && negotiateResponse.url) {
                                throw new Error("Negotiate redirection limit exceeded.");
                            }
                            return [4 /*yield*/, this.createTransport(url, this.options.transport, negotiateResponse, transferFormat)];
                        case 10:
                            _a.sent();
                            _a.label = 11;
                        case 11:
                            if (this.transport instanceof LongPollingTransport) {
                                this.features.inherentKeepAlive = true;
                            }
                            if (this.connectionState === "Connecting " /* Connecting */) {
                                // Ensure the connection transitions to the connected state prior to completing this.startInternalPromise.
                                // start() will handle the case when stop was called and startInternal exits still in the disconnecting state.
                                this.logger.log(LogLevel.Debug, "The HttpConnection connected successfully.");
                                this.connectionState = "Connected" /* Connected */;
                            }
                            return [3 /*break*/, 13];
                        case 12:
                            e_3 = _a.sent();
                            this.logger.log(LogLevel.Error, "Failed to start the connection: " + e_3);
                            this.connectionState = "Disconnected" /* Disconnected */;
                            this.transport = undefined;
                            return [2 /*return*/, Promise.reject(e_3)];
                        case 13: return [2 /*return*/];
                    }
                });
            });
        };
        HttpConnection.prototype.getNegotiationResponse = function (url) {
            return __awaiter$5(this, void 0, void 0, function () {
                var _a, headers, token, negotiateUrl, response, negotiateResponse, e_4;
                return __generator$5(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            if (!this.accessTokenFactory) return [3 /*break*/, 2];
                            return [4 /*yield*/, this.accessTokenFactory()];
                        case 1:
                            token = _b.sent();
                            if (token) {
                                headers = (_a = {},
                                    _a["Authorization"] = "Bearer " + token,
                                    _a);
                            }
                            _b.label = 2;
                        case 2:
                            negotiateUrl = this.resolveNegotiateUrl(url);
                            this.logger.log(LogLevel.Debug, "Sending negotiation request: " + negotiateUrl + ".");
                            _b.label = 3;
                        case 3:
                            _b.trys.push([3, 5, , 6]);
                            return [4 /*yield*/, this.httpClient.post(negotiateUrl, {
                                    content: "",
                                    headers: headers,
                                })];
                        case 4:
                            response = _b.sent();
                            if (response.statusCode !== 200) {
                                return [2 /*return*/, Promise.reject(new Error("Unexpected status code returned from negotiate " + response.statusCode))];
                            }
                            negotiateResponse = JSON.parse(response.content);
                            if (!negotiateResponse.negotiateVersion || negotiateResponse.negotiateVersion < 1) {
                                // Negotiate version 0 doesn't use connectionToken
                                // So we set it equal to connectionId so all our logic can use connectionToken without being aware of the negotiate version
                                negotiateResponse.connectionToken = negotiateResponse.connectionId;
                            }
                            return [2 /*return*/, negotiateResponse];
                        case 5:
                            e_4 = _b.sent();
                            this.logger.log(LogLevel.Error, "Failed to complete negotiation with the server: " + e_4);
                            return [2 /*return*/, Promise.reject(e_4)];
                        case 6: return [2 /*return*/];
                    }
                });
            });
        };
        HttpConnection.prototype.createConnectUrl = function (url, connectionToken) {
            if (!connectionToken) {
                return url;
            }
            return url + (url.indexOf("?") === -1 ? "?" : "&") + ("id=" + connectionToken);
        };
        HttpConnection.prototype.createTransport = function (url, requestedTransport, negotiateResponse, requestedTransferFormat) {
            return __awaiter$5(this, void 0, void 0, function () {
                var connectUrl, transportExceptions, transports, negotiate, _i, transports_1, endpoint, transportOrError, ex_1, ex_2, message;
                return __generator$5(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            connectUrl = this.createConnectUrl(url, negotiateResponse.connectionToken);
                            if (!this.isITransport(requestedTransport)) return [3 /*break*/, 2];
                            this.logger.log(LogLevel.Debug, "Connection was provided an instance of ITransport, using that directly.");
                            this.transport = requestedTransport;
                            return [4 /*yield*/, this.startTransport(connectUrl, requestedTransferFormat)];
                        case 1:
                            _a.sent();
                            this.connectionId = negotiateResponse.connectionId;
                            return [2 /*return*/];
                        case 2:
                            transportExceptions = [];
                            transports = negotiateResponse.availableTransports || [];
                            negotiate = negotiateResponse;
                            _i = 0, transports_1 = transports;
                            _a.label = 3;
                        case 3:
                            if (!(_i < transports_1.length)) return [3 /*break*/, 13];
                            endpoint = transports_1[_i];
                            transportOrError = this.resolveTransportOrError(endpoint, requestedTransport, requestedTransferFormat);
                            if (!(transportOrError instanceof Error)) return [3 /*break*/, 4];
                            // Store the error and continue, we don't want to cause a re-negotiate in these cases
                            transportExceptions.push(endpoint.transport + " failed: " + transportOrError);
                            return [3 /*break*/, 12];
                        case 4:
                            if (!this.isITransport(transportOrError)) return [3 /*break*/, 12];
                            this.transport = transportOrError;
                            if (!!negotiate) return [3 /*break*/, 9];
                            _a.label = 5;
                        case 5:
                            _a.trys.push([5, 7, , 8]);
                            return [4 /*yield*/, this.getNegotiationResponse(url)];
                        case 6:
                            negotiate = _a.sent();
                            return [3 /*break*/, 8];
                        case 7:
                            ex_1 = _a.sent();
                            return [2 /*return*/, Promise.reject(ex_1)];
                        case 8:
                            connectUrl = this.createConnectUrl(url, negotiate.connectionToken);
                            _a.label = 9;
                        case 9:
                            _a.trys.push([9, 11, , 12]);
                            return [4 /*yield*/, this.startTransport(connectUrl, requestedTransferFormat)];
                        case 10:
                            _a.sent();
                            this.connectionId = negotiate.connectionId;
                            return [2 /*return*/];
                        case 11:
                            ex_2 = _a.sent();
                            this.logger.log(LogLevel.Error, "Failed to start the transport '" + endpoint.transport + "': " + ex_2);
                            negotiate = undefined;
                            transportExceptions.push(endpoint.transport + " failed: " + ex_2);
                            if (this.connectionState !== "Connecting " /* Connecting */) {
                                message = "Failed to select transport before stop() was called.";
                                this.logger.log(LogLevel.Debug, message);
                                return [2 /*return*/, Promise.reject(new Error(message))];
                            }
                            return [3 /*break*/, 12];
                        case 12:
                            _i++;
                            return [3 /*break*/, 3];
                        case 13:
                            if (transportExceptions.length > 0) {
                                return [2 /*return*/, Promise.reject(new Error("Unable to connect to the server with any of the available transports. " + transportExceptions.join(" ")))];
                            }
                            return [2 /*return*/, Promise.reject(new Error("None of the transports supported by the client are supported by the server."))];
                    }
                });
            });
        };
        HttpConnection.prototype.constructTransport = function (transport) {
            switch (transport) {
                case HttpTransportType.WebSockets:
                    if (!this.options.WebSocket) {
                        throw new Error("'WebSocket' is not supported in your environment.");
                    }
                    return new WebSocketTransport(this.httpClient, this.accessTokenFactory, this.logger, this.options.logMessageContent || false, this.options.WebSocket);
                case HttpTransportType.ServerSentEvents:
                    if (!this.options.EventSource) {
                        throw new Error("'EventSource' is not supported in your environment.");
                    }
                    return new ServerSentEventsTransport(this.httpClient, this.accessTokenFactory, this.logger, this.options.logMessageContent || false, this.options.EventSource);
                case HttpTransportType.LongPolling:
                    return new LongPollingTransport(this.httpClient, this.accessTokenFactory, this.logger, this.options.logMessageContent || false);
                default:
                    throw new Error("Unknown transport: " + transport + ".");
            }
        };
        HttpConnection.prototype.startTransport = function (url, transferFormat) {
            var _this = this;
            this.transport.onreceive = this.onreceive;
            this.transport.onclose = function (e) { return _this.stopConnection(e); };
            return this.transport.connect(url, transferFormat);
        };
        HttpConnection.prototype.resolveTransportOrError = function (endpoint, requestedTransport, requestedTransferFormat) {
            var transport = HttpTransportType[endpoint.transport];
            if (transport === null || transport === undefined) {
                this.logger.log(LogLevel.Debug, "Skipping transport '" + endpoint.transport + "' because it is not supported by this client.");
                return new Error("Skipping transport '" + endpoint.transport + "' because it is not supported by this client.");
            }
            else {
                if (transportMatches(requestedTransport, transport)) {
                    var transferFormats = endpoint.transferFormats.map(function (s) { return TransferFormat[s]; });
                    if (transferFormats.indexOf(requestedTransferFormat) >= 0) {
                        if ((transport === HttpTransportType.WebSockets && !this.options.WebSocket) ||
                            (transport === HttpTransportType.ServerSentEvents && !this.options.EventSource)) {
                            this.logger.log(LogLevel.Debug, "Skipping transport '" + HttpTransportType[transport] + "' because it is not supported in your environment.'");
                            return new Error("'" + HttpTransportType[transport] + "' is not supported in your environment.");
                        }
                        else {
                            this.logger.log(LogLevel.Debug, "Selecting transport '" + HttpTransportType[transport] + "'.");
                            try {
                                return this.constructTransport(transport);
                            }
                            catch (ex) {
                                return ex;
                            }
                        }
                    }
                    else {
                        this.logger.log(LogLevel.Debug, "Skipping transport '" + HttpTransportType[transport] + "' because it does not support the requested transfer format '" + TransferFormat[requestedTransferFormat] + "'.");
                        return new Error("'" + HttpTransportType[transport] + "' does not support " + TransferFormat[requestedTransferFormat] + ".");
                    }
                }
                else {
                    this.logger.log(LogLevel.Debug, "Skipping transport '" + HttpTransportType[transport] + "' because it was disabled by the client.");
                    return new Error("'" + HttpTransportType[transport] + "' is disabled by the client.");
                }
            }
        };
        HttpConnection.prototype.isITransport = function (transport) {
            return transport && typeof (transport) === "object" && "connect" in transport;
        };
        HttpConnection.prototype.stopConnection = function (error) {
            var _this = this;
            this.logger.log(LogLevel.Debug, "HttpConnection.stopConnection(" + error + ") called while in state " + this.connectionState + ".");
            this.transport = undefined;
            // If we have a stopError, it takes precedence over the error from the transport
            error = this.stopError || error;
            this.stopError = undefined;
            if (this.connectionState === "Disconnected" /* Disconnected */) {
                this.logger.log(LogLevel.Debug, "Call to HttpConnection.stopConnection(" + error + ") was ignored because the connection is already in the disconnected state.");
                return;
            }
            if (this.connectionState === "Connecting " /* Connecting */) {
                this.logger.log(LogLevel.Warning, "Call to HttpConnection.stopConnection(" + error + ") was ignored because the connection hasn't yet left the in the connecting state.");
                return;
            }
            if (this.connectionState === "Disconnecting" /* Disconnecting */) {
                // A call to stop() induced this call to stopConnection and needs to be completed.
                // Any stop() awaiters will be scheduled to continue after the onclose callback fires.
                this.stopPromiseResolver();
            }
            if (error) {
                this.logger.log(LogLevel.Error, "Connection disconnected with error '" + error + "'.");
            }
            else {
                this.logger.log(LogLevel.Information, "Connection disconnected.");
            }
            if (this.sendQueue) {
                this.sendQueue.stop().catch(function (e) {
                    _this.logger.log(LogLevel.Error, "TransportSendQueue.stop() threw error '" + e + "'.");
                });
                this.sendQueue = undefined;
            }
            this.connectionId = undefined;
            this.connectionState = "Disconnected" /* Disconnected */;
            if (this.connectionStarted) {
                this.connectionStarted = false;
                try {
                    if (this.onclose) {
                        this.onclose(error);
                    }
                }
                catch (e) {
                    this.logger.log(LogLevel.Error, "HttpConnection.onclose(" + error + ") threw error '" + e + "'.");
                }
            }
        };
        HttpConnection.prototype.resolveUrl = function (url) {
            // startsWith is not supported in IE
            if (url.lastIndexOf("https://", 0) === 0 || url.lastIndexOf("http://", 0) === 0) {
                return url;
            }
            if (!Platform.isBrowser || !window.document) {
                throw new Error("Cannot resolve '" + url + "'.");
            }
            // Setting the url to the href propery of an anchor tag handles normalization
            // for us. There are 3 main cases.
            // 1. Relative path normalization e.g "b" -> "http://localhost:5000/a/b"
            // 2. Absolute path normalization e.g "/a/b" -> "http://localhost:5000/a/b"
            // 3. Networkpath reference normalization e.g "//localhost:5000/a/b" -> "http://localhost:5000/a/b"
            var aTag = window.document.createElement("a");
            aTag.href = url;
            this.logger.log(LogLevel.Information, "Normalizing '" + url + "' to '" + aTag.href + "'.");
            return aTag.href;
        };
        HttpConnection.prototype.resolveNegotiateUrl = function (url) {
            var index = url.indexOf("?");
            var negotiateUrl = url.substring(0, index === -1 ? url.length : index);
            if (negotiateUrl[negotiateUrl.length - 1] !== "/") {
                negotiateUrl += "/";
            }
            negotiateUrl += "negotiate";
            negotiateUrl += index === -1 ? "" : url.substring(index);
            if (negotiateUrl.indexOf("negotiateVersion") === -1) {
                negotiateUrl += index === -1 ? "?" : "&";
                negotiateUrl += "negotiateVersion=" + this.negotiateVersion;
            }
            return negotiateUrl;
        };
        return HttpConnection;
    }());
    function transportMatches(requestedTransport, actualTransport) {
        return !requestedTransport || ((actualTransport & requestedTransport) !== 0);
    }
    /** @private */
    var TransportSendQueue = /** @class */ (function () {
        function TransportSendQueue(transport) {
            this.transport = transport;
            this.buffer = [];
            this.executing = true;
            this.sendBufferedData = new PromiseSource();
            this.transportResult = new PromiseSource();
            this.sendLoopPromise = this.sendLoop();
        }
        TransportSendQueue.prototype.send = function (data) {
            this.bufferData(data);
            if (!this.transportResult) {
                this.transportResult = new PromiseSource();
            }
            return this.transportResult.promise;
        };
        TransportSendQueue.prototype.stop = function () {
            this.executing = false;
            this.sendBufferedData.resolve();
            return this.sendLoopPromise;
        };
        TransportSendQueue.prototype.bufferData = function (data) {
            if (this.buffer.length && typeof (this.buffer[0]) !== typeof (data)) {
                throw new Error("Expected data to be of type " + typeof (this.buffer) + " but was of type " + typeof (data));
            }
            this.buffer.push(data);
            this.sendBufferedData.resolve();
        };
        TransportSendQueue.prototype.sendLoop = function () {
            return __awaiter$5(this, void 0, void 0, function () {
                var transportResult, data, error_1;
                return __generator$5(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            return [4 /*yield*/, this.sendBufferedData.promise];
                        case 1:
                            _a.sent();
                            if (!this.executing) {
                                if (this.transportResult) {
                                    this.transportResult.reject("Connection stopped.");
                                }
                                return [3 /*break*/, 6];
                            }
                            this.sendBufferedData = new PromiseSource();
                            transportResult = this.transportResult;
                            this.transportResult = undefined;
                            data = typeof (this.buffer[0]) === "string" ?
                                this.buffer.join("") :
                                TransportSendQueue.concatBuffers(this.buffer);
                            this.buffer.length = 0;
                            _a.label = 2;
                        case 2:
                            _a.trys.push([2, 4, , 5]);
                            return [4 /*yield*/, this.transport.send(data)];
                        case 3:
                            _a.sent();
                            transportResult.resolve();
                            return [3 /*break*/, 5];
                        case 4:
                            error_1 = _a.sent();
                            transportResult.reject(error_1);
                            return [3 /*break*/, 5];
                        case 5: return [3 /*break*/, 0];
                        case 6: return [2 /*return*/];
                    }
                });
            });
        };
        TransportSendQueue.concatBuffers = function (arrayBuffers) {
            var totalLength = arrayBuffers.map(function (b) { return b.byteLength; }).reduce(function (a, b) { return a + b; });
            var result = new Uint8Array(totalLength);
            var offset = 0;
            for (var _i = 0, arrayBuffers_1 = arrayBuffers; _i < arrayBuffers_1.length; _i++) {
                var item = arrayBuffers_1[_i];
                result.set(new Uint8Array(item), offset);
                offset += item.byteLength;
            }
            return result;
        };
        return TransportSendQueue;
    }());
    var PromiseSource = /** @class */ (function () {
        function PromiseSource() {
            var _this = this;
            this.promise = new Promise(function (resolve, reject) {
                var _a;
                return _a = [resolve, reject], _this.resolver = _a[0], _this.rejecter = _a[1], _a;
            });
        }
        PromiseSource.prototype.resolve = function () {
            this.resolver();
        };
        PromiseSource.prototype.reject = function (reason) {
            this.rejecter(reason);
        };
        return PromiseSource;
    }());

    // Copyright (c) .NET Foundation. All rights reserved.
    var JSON_HUB_PROTOCOL_NAME = "json";
    /** Implements the JSON Hub Protocol. */
    var JsonHubProtocol = /** @class */ (function () {
        function JsonHubProtocol() {
            /** @inheritDoc */
            this.name = JSON_HUB_PROTOCOL_NAME;
            /** @inheritDoc */
            this.version = 1;
            /** @inheritDoc */
            this.transferFormat = TransferFormat.Text;
        }
        /** Creates an array of {@link @microsoft/signalr.HubMessage} objects from the specified serialized representation.
         *
         * @param {string} input A string containing the serialized representation.
         * @param {ILogger} logger A logger that will be used to log messages that occur during parsing.
         */
        JsonHubProtocol.prototype.parseMessages = function (input, logger) {
            // The interface does allow "ArrayBuffer" to be passed in, but this implementation does not. So let's throw a useful error.
            if (typeof input !== "string") {
                throw new Error("Invalid input for JSON hub protocol. Expected a string.");
            }
            if (!input) {
                return [];
            }
            if (logger === null) {
                logger = NullLogger.instance;
            }
            // Parse the messages
            var messages = TextMessageFormat.parse(input);
            var hubMessages = [];
            for (var _i = 0, messages_1 = messages; _i < messages_1.length; _i++) {
                var message = messages_1[_i];
                var parsedMessage = JSON.parse(message);
                if (typeof parsedMessage.type !== "number") {
                    throw new Error("Invalid payload.");
                }
                switch (parsedMessage.type) {
                    case MessageType.Invocation:
                        this.isInvocationMessage(parsedMessage);
                        break;
                    case MessageType.StreamItem:
                        this.isStreamItemMessage(parsedMessage);
                        break;
                    case MessageType.Completion:
                        this.isCompletionMessage(parsedMessage);
                        break;
                    case MessageType.Ping:
                        // Single value, no need to validate
                        break;
                    case MessageType.Close:
                        // All optional values, no need to validate
                        break;
                    default:
                        // Future protocol changes can add message types, old clients can ignore them
                        logger.log(LogLevel.Information, "Unknown message type '" + parsedMessage.type + "' ignored.");
                        continue;
                }
                hubMessages.push(parsedMessage);
            }
            return hubMessages;
        };
        /** Writes the specified {@link @microsoft/signalr.HubMessage} to a string and returns it.
         *
         * @param {HubMessage} message The message to write.
         * @returns {string} A string containing the serialized representation of the message.
         */
        JsonHubProtocol.prototype.writeMessage = function (message) {
            return TextMessageFormat.write(JSON.stringify(message));
        };
        JsonHubProtocol.prototype.isInvocationMessage = function (message) {
            this.assertNotEmptyString(message.target, "Invalid payload for Invocation message.");
            if (message.invocationId !== undefined) {
                this.assertNotEmptyString(message.invocationId, "Invalid payload for Invocation message.");
            }
        };
        JsonHubProtocol.prototype.isStreamItemMessage = function (message) {
            this.assertNotEmptyString(message.invocationId, "Invalid payload for StreamItem message.");
            if (message.item === undefined) {
                throw new Error("Invalid payload for StreamItem message.");
            }
        };
        JsonHubProtocol.prototype.isCompletionMessage = function (message) {
            if (message.result && message.error) {
                throw new Error("Invalid payload for Completion message.");
            }
            if (!message.result && message.error) {
                this.assertNotEmptyString(message.error, "Invalid payload for Completion message.");
            }
            this.assertNotEmptyString(message.invocationId, "Invalid payload for Completion message.");
        };
        JsonHubProtocol.prototype.assertNotEmptyString = function (value, errorMessage) {
            if (typeof value !== "string" || value === "") {
                throw new Error(errorMessage);
            }
        };
        return JsonHubProtocol;
    }());

    // Copyright (c) .NET Foundation. All rights reserved.
    // Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.
    var __assign$2 = (undefined && undefined.__assign) || Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    // tslint:disable:object-literal-sort-keys
    var LogLevelNameMapping = {
        trace: LogLevel.Trace,
        debug: LogLevel.Debug,
        info: LogLevel.Information,
        information: LogLevel.Information,
        warn: LogLevel.Warning,
        warning: LogLevel.Warning,
        error: LogLevel.Error,
        critical: LogLevel.Critical,
        none: LogLevel.None,
    };
    function parseLogLevel(name) {
        // Case-insensitive matching via lower-casing
        // Yes, I know case-folding is a complicated problem in Unicode, but we only support
        // the ASCII strings defined in LogLevelNameMapping anyway, so it's fine -anurse.
        var mapping = LogLevelNameMapping[name.toLowerCase()];
        if (typeof mapping !== "undefined") {
            return mapping;
        }
        else {
            throw new Error("Unknown log level: " + name);
        }
    }
    /** A builder for configuring {@link @microsoft/signalr.HubConnection} instances. */
    var HubConnectionBuilder = /** @class */ (function () {
        function HubConnectionBuilder() {
        }
        HubConnectionBuilder.prototype.configureLogging = function (logging) {
            Arg.isRequired(logging, "logging");
            if (isLogger(logging)) {
                this.logger = logging;
            }
            else if (typeof logging === "string") {
                var logLevel = parseLogLevel(logging);
                this.logger = new ConsoleLogger(logLevel);
            }
            else {
                this.logger = new ConsoleLogger(logging);
            }
            return this;
        };
        HubConnectionBuilder.prototype.withUrl = function (url, transportTypeOrOptions) {
            Arg.isRequired(url, "url");
            this.url = url;
            // Flow-typing knows where it's at. Since HttpTransportType is a number and IHttpConnectionOptions is guaranteed
            // to be an object, we know (as does TypeScript) this comparison is all we need to figure out which overload was called.
            if (typeof transportTypeOrOptions === "object") {
                this.httpConnectionOptions = __assign$2({}, this.httpConnectionOptions, transportTypeOrOptions);
            }
            else {
                this.httpConnectionOptions = __assign$2({}, this.httpConnectionOptions, { transport: transportTypeOrOptions });
            }
            return this;
        };
        /** Configures the {@link @microsoft/signalr.HubConnection} to use the specified Hub Protocol.
         *
         * @param {IHubProtocol} protocol The {@link @microsoft/signalr.IHubProtocol} implementation to use.
         */
        HubConnectionBuilder.prototype.withHubProtocol = function (protocol) {
            Arg.isRequired(protocol, "protocol");
            this.protocol = protocol;
            return this;
        };
        HubConnectionBuilder.prototype.withAutomaticReconnect = function (retryDelaysOrReconnectPolicy) {
            if (this.reconnectPolicy) {
                throw new Error("A reconnectPolicy has already been set.");
            }
            if (!retryDelaysOrReconnectPolicy) {
                this.reconnectPolicy = new DefaultReconnectPolicy();
            }
            else if (Array.isArray(retryDelaysOrReconnectPolicy)) {
                this.reconnectPolicy = new DefaultReconnectPolicy(retryDelaysOrReconnectPolicy);
            }
            else {
                this.reconnectPolicy = retryDelaysOrReconnectPolicy;
            }
            return this;
        };
        /** Creates a {@link @microsoft/signalr.HubConnection} from the configuration options specified in this builder.
         *
         * @returns {HubConnection} The configured {@link @microsoft/signalr.HubConnection}.
         */
        HubConnectionBuilder.prototype.build = function () {
            // If httpConnectionOptions has a logger, use it. Otherwise, override it with the one
            // provided to configureLogger
            var httpConnectionOptions = this.httpConnectionOptions || {};
            // If it's 'null', the user **explicitly** asked for null, don't mess with it.
            if (httpConnectionOptions.logger === undefined) {
                // If our logger is undefined or null, that's OK, the HttpConnection constructor will handle it.
                httpConnectionOptions.logger = this.logger;
            }
            // Now create the connection
            if (!this.url) {
                throw new Error("The 'HubConnectionBuilder.withUrl' method must be called before building the connection.");
            }
            var connection = new HttpConnection(this.url, httpConnectionOptions);
            return HubConnection.create(connection, this.logger || NullLogger.instance, this.protocol || new JsonHubProtocol(), this.reconnectPolicy);
        };
        return HubConnectionBuilder;
    }());
    function isLogger(logger) {
        return logger.log !== undefined;
    }

    // const coneccion = new HubConnectionBuilder().withUrl("/hub").build()

    // let colaDeSubscripciones = []



    // function subscribirseAHilo(hiloid) {
    //     colaDeSubscripciones.push(() => coneccion.invoke("SubscribirseAHilo", hiloid))
    // }
    class Signal {
        static coneccion = new HubConnectionBuilder().withUrl("/hub").build()
        static colaDeSubscripciones = []

        static subscribirseAHilo(hiloid) {
            this.colaDeSubscripciones.push(() => this.coneccion.invoke("SubscribirseAHilo", hiloid));
        }
        static subscribirAHome() {
            this.colaDeSubscripciones.push(() => this.coneccion.invoke("SubscribirAHome"));
        }
        static subscribirAModeracion() {
            this.colaDeSubscripciones.push(() => this.coneccion.invoke("SubscribirAModeracion"));
        }
    }
    Signal.coneccion.start().then(() => {
        console.log("ConectandoSignal");
        Signal.colaDeSubscripciones.forEach(s => {
            s();
        });
        
    }).catch(console.error);

    /* src\components\Comentarios\CarpetaMedia.svelte generated by Svelte v3.29.0 */
    const file$c = "src\\components\\Comentarios\\CarpetaMedia.svelte";

    function get_each_context$5(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[4] = list[i];
    	return child_ctx;
    }

    // (13:0) {#if visible}
    function create_if_block$a(ctx) {
    	let div;
    	let section;
    	let h3;
    	let t1;
    	let ul;
    	let div_transition;
    	let current;
    	let mounted;
    	let dispose;
    	let each_value = /*comentarios*/ ctx[1];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$5(get_each_context$5(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			div = element("div");
    			section = element("section");
    			h3 = element("h3");
    			h3.textContent = "Archivos del roz";
    			t1 = space();
    			ul = element("ul");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(h3, "class", "svelte-1mkcueb");
    			add_location(h3, file$c, 15, 12, 425);
    			attr_dev(ul, "class", "svelte-1mkcueb");
    			add_location(ul, file$c, 16, 12, 464);
    			attr_dev(section, "class", "carpeta-media panel svelte-1mkcueb");
    			add_location(section, file$c, 14, 8, 374);
    			attr_dev(div, "class", "fondo svelte-1mkcueb");
    			set_style(div, "z-index", "20");
    			add_location(div, file$c, 13, 4, 260);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, section);
    			append_dev(section, h3);
    			append_dev(section, t1);
    			append_dev(section, ul);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(ul, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(div, "click", /*click_handler*/ ctx[3], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*comentarios, onMediaClick*/ 6) {
    				each_value = /*comentarios*/ ctx[1];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$5(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$5(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(ul, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			add_render_callback(() => {
    				if (!div_transition) div_transition = create_bidirectional_transition(div, fade, { duration: 150 }, true);
    				div_transition.run(1);
    			});

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			if (!div_transition) div_transition = create_bidirectional_transition(div, fade, { duration: 150 }, false);
    			div_transition.run(0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_each(each_blocks, detaching);
    			if (detaching && div_transition) div_transition.end();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$a.name,
    		type: "if",
    		source: "(13:0) {#if visible}",
    		ctx
    	});

    	return block;
    }

    // (19:20) {#if c.media}
    function create_if_block_1$5(ctx) {
    	let li;
    	let media;
    	let t0;
    	let a;
    	let a_href_value;
    	let t1;
    	let current;
    	let mounted;
    	let dispose;

    	media = new Media({
    			props: {
    				media: /*c*/ ctx[4].media,
    				modoCuadrado: true
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			li = element("li");
    			create_component(media.$$.fragment);
    			t0 = space();
    			a = element("a");
    			t1 = space();
    			attr_dev(a, "href", a_href_value = "#" + /*c*/ ctx[4].id);
    			attr_dev(a, "class", "click-area svelte-1mkcueb");
    			add_location(a, file$c, 21, 28, 680);
    			attr_dev(li, "class", "svelte-1mkcueb");
    			add_location(li, file$c, 19, 24, 571);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			mount_component(media, li, null);
    			append_dev(li, t0);
    			append_dev(li, a);
    			append_dev(li, t1);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(a, "click", /*onMediaClick*/ ctx[2], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			const media_changes = {};
    			if (dirty & /*comentarios*/ 2) media_changes.media = /*c*/ ctx[4].media;
    			media.$set(media_changes);

    			if (!current || dirty & /*comentarios*/ 2 && a_href_value !== (a_href_value = "#" + /*c*/ ctx[4].id)) {
    				attr_dev(a, "href", a_href_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(media.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(media.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			destroy_component(media);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$5.name,
    		type: "if",
    		source: "(19:20) {#if c.media}",
    		ctx
    	});

    	return block;
    }

    // (18:16) {#each comentarios as c}
    function create_each_block$5(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*c*/ ctx[4].media && create_if_block_1$5(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*c*/ ctx[4].media) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*comentarios*/ 2) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_1$5(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$5.name,
    		type: "each",
    		source: "(18:16) {#each comentarios as c}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$c(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*visible*/ ctx[0] && create_if_block$a(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*visible*/ ctx[0]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*visible*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$a(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$c.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$c($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("CarpetaMedia", slots, []);
    	let { comentarios = [] } = $$props;
    	let { visible = true } = $$props;

    	function onMediaClick(e) {
    		$$invalidate(0, visible = false);
    	}

    	const writable_props = ["comentarios", "visible"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<CarpetaMedia> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => $$invalidate(0, visible = false);

    	$$self.$$set = $$props => {
    		if ("comentarios" in $$props) $$invalidate(1, comentarios = $$props.comentarios);
    		if ("visible" in $$props) $$invalidate(0, visible = $$props.visible);
    	};

    	$$self.$capture_state = () => ({
    		Media,
    		fade,
    		comentarios,
    		visible,
    		onMediaClick
    	});

    	$$self.$inject_state = $$props => {
    		if ("comentarios" in $$props) $$invalidate(1, comentarios = $$props.comentarios);
    		if ("visible" in $$props) $$invalidate(0, visible = $$props.visible);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [visible, comentarios, onMediaClick, click_handler];
    }

    class CarpetaMedia extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$c, create_fragment$c, safe_not_equal, { comentarios: 1, visible: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "CarpetaMedia",
    			options,
    			id: create_fragment$c.name
    		});
    	}

    	get comentarios() {
    		throw new Error("<CarpetaMedia>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set comentarios(value) {
    		throw new Error("<CarpetaMedia>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get visible() {
    		throw new Error("<CarpetaMedia>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set visible(value) {
    		throw new Error("<CarpetaMedia>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\components\Comentarios\Comentarios.svelte generated by Svelte v3.29.0 */
    const file$d = "src\\components\\Comentarios\\Comentarios.svelte";

    function get_each_context$6(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[23] = list[i];
    	child_ctx[24] = list;
    	child_ctx[25] = i;
    	return child_ctx;
    }

    // (123:4) {#if !window.config.general.modoMessi || $globalStore.usuario.esMod}
    function create_if_block_2$4(ctx) {
    	let formulario;
    	let current;

    	formulario = new Formulario({
    			props: { hilo: /*hilo*/ ctx[1] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(formulario.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(formulario, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const formulario_changes = {};
    			if (dirty & /*hilo*/ 2) formulario_changes.hilo = /*hilo*/ ctx[1];
    			formulario.$set(formulario_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(formulario.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(formulario.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(formulario, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$4.name,
    		type: "if",
    		source: "(123:4) {#if !window.config.general.modoMessi || $globalStore.usuario.esMod}",
    		ctx
    	});

    	return block;
    }

    // (129:8) {#if nuevosComentarios.length != 0}
    function create_if_block_1$6(ctx) {
    	let div;
    	let span;
    	let t0;
    	let t1_value = /*nuevosComentarios*/ ctx[2].length + "";
    	let t1;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div = element("div");
    			span = element("span");
    			t0 = text("+ ");
    			t1 = text(t1_value);
    			add_location(span, file$d, 130, 16, 4710);
    			attr_dev(div, "class", "badge");
    			set_style(div, "font-size", "18px");
    			set_style(div, "height", "auto");
    			set_style(div, "cursor", "pointer");
    			add_location(div, file$d, 129, 12, 4615);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, span);
    			append_dev(span, t0);
    			append_dev(span, t1);

    			if (!mounted) {
    				dispose = listen_dev(span, "click", /*cargarNuevosComentarios*/ ctx[6], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*nuevosComentarios*/ 4 && t1_value !== (t1_value = /*nuevosComentarios*/ ctx[2].length + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$6.name,
    		type: "if",
    		source: "(129:8) {#if nuevosComentarios.length != 0}",
    		ctx
    	});

    	return block;
    }

    // (136:12) <Button on:click={() => carpetaMedia = !carpetaMedia}                   dense icon>
    function create_default_slot_1$7(ctx) {
    	let icon;

    	const block = {
    		c: function create() {
    			icon = element("icon");
    			attr_dev(icon, "class", "fe fe-folder");
    			add_location(icon, file$d, 136, 27, 5058);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, icon, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(icon);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$7.name,
    		type: "slot",
    		source: "(136:12) <Button on:click={() => carpetaMedia = !carpetaMedia}                   dense icon>",
    		ctx
    	});

    	return block;
    }

    // (139:12) {#if comentarios.length > 0}
    function create_if_block$b(ctx) {
    	let a;
    	let button;
    	let a_href_value;
    	let current;

    	button = new ye({
    			props: {
    				dense: true,
    				icon: true,
    				$$slots: { default: [create_default_slot$8] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			a = element("a");
    			create_component(button.$$.fragment);
    			attr_dev(a, "href", a_href_value = "#" + /*comentarios*/ ctx[0][/*comentarios*/ ctx[0].length - 1].id);
    			set_style(a, "margin", "0");
    			add_location(a, file$d, 139, 16, 5175);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);
    			mount_component(button, a, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button_changes = {};

    			if (dirty & /*$$scope*/ 67108864) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);

    			if (!current || dirty & /*comentarios*/ 1 && a_href_value !== (a_href_value = "#" + /*comentarios*/ ctx[0][/*comentarios*/ ctx[0].length - 1].id)) {
    				attr_dev(a, "href", a_href_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    			destroy_component(button);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$b.name,
    		type: "if",
    		source: "(139:12) {#if comentarios.length > 0}",
    		ctx
    	});

    	return block;
    }

    // (141:20) <Button                          dense icon>
    function create_default_slot$8(ctx) {
    	let icon;

    	const block = {
    		c: function create() {
    			icon = element("icon");
    			attr_dev(icon, "class", "fe fe-arrow-down");
    			add_location(icon, file$d, 141, 35, 5311);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, icon, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(icon);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$8.name,
    		type: "slot",
    		source: "(141:20) <Button                          dense icon>",
    		ctx
    	});

    	return block;
    }

    // (149:8) {#each comentarios as comentario (comentario.id)}
    function create_each_block$6(key_1, ctx) {
    	let li;
    	let comentario_1;
    	let updating_comentario;
    	let updating_comentariosDic;
    	let t;
    	let li_transition;
    	let current;

    	function comentario_1_comentario_binding(value) {
    		/*comentario_1_comentario_binding*/ ctx[12].call(null, value, /*comentario*/ ctx[23], /*each_value*/ ctx[24], /*comentario_index*/ ctx[25]);
    	}

    	function comentario_1_comentariosDic_binding(value) {
    		/*comentario_1_comentariosDic_binding*/ ctx[13].call(null, value);
    	}

    	let comentario_1_props = { hilo: /*hilo*/ ctx[1] };

    	if (/*comentario*/ ctx[23] !== void 0) {
    		comentario_1_props.comentario = /*comentario*/ ctx[23];
    	}

    	if (/*diccionarioComentarios*/ ctx[3] !== void 0) {
    		comentario_1_props.comentariosDic = /*diccionarioComentarios*/ ctx[3];
    	}

    	comentario_1 = new Comentario({
    			props: comentario_1_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(comentario_1, "comentario", comentario_1_comentario_binding));
    	binding_callbacks.push(() => bind(comentario_1, "comentariosDic", comentario_1_comentariosDic_binding));
    	comentario_1.$on("colorClick", /*colorClick_handler*/ ctx[14]);
    	comentario_1.$on("tagClickeado", /*tagCliqueado*/ ctx[8]);
    	comentario_1.$on("idUnicoClickeado", /*idUnicoClickeado*/ ctx[9]);

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			li = element("li");
    			create_component(comentario_1.$$.fragment);
    			t = space();
    			add_location(li, file$d, 149, 12, 5559);
    			this.first = li;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			mount_component(comentario_1, li, null);
    			append_dev(li, t);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const comentario_1_changes = {};
    			if (dirty & /*hilo*/ 2) comentario_1_changes.hilo = /*hilo*/ ctx[1];

    			if (!updating_comentario && dirty & /*comentarios*/ 1) {
    				updating_comentario = true;
    				comentario_1_changes.comentario = /*comentario*/ ctx[23];
    				add_flush_callback(() => updating_comentario = false);
    			}

    			if (!updating_comentariosDic && dirty & /*diccionarioComentarios*/ 8) {
    				updating_comentariosDic = true;
    				comentario_1_changes.comentariosDic = /*diccionarioComentarios*/ ctx[3];
    				add_flush_callback(() => updating_comentariosDic = false);
    			}

    			comentario_1.$set(comentario_1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(comentario_1.$$.fragment, local);

    			if (local) {
    				add_render_callback(() => {
    					if (!li_transition) li_transition = create_bidirectional_transition(li, fly, { y: -50, duration: 250 }, true);
    					li_transition.run(1);
    				});
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(comentario_1.$$.fragment, local);

    			if (local) {
    				if (!li_transition) li_transition = create_bidirectional_transition(li, fly, { y: -50, duration: 250 }, false);
    				li_transition.run(0);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			destroy_component(comentario_1);
    			if (detaching && li_transition) li_transition.end();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$6.name,
    		type: "each",
    		source: "(149:8) {#each comentarios as comentario (comentario.id)}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$d(ctx) {
    	let carpetamedia;
    	let updating_visible;
    	let t0;
    	let div4;
    	let t1;
    	let div1;
    	let h3;
    	let t2;
    	let t3_value = /*comentarios*/ ctx[0].length + "";
    	let t3;
    	let t4;
    	let t5;
    	let t6;
    	let div0;
    	let button;
    	let t7;
    	let t8;
    	let div2;
    	let each_blocks = [];
    	let each_1_lookup = new Map();
    	let t9;
    	let div3;
    	let current;

    	function carpetamedia_visible_binding(value) {
    		/*carpetamedia_visible_binding*/ ctx[10].call(null, value);
    	}

    	let carpetamedia_props = { comentarios: /*comentarios*/ ctx[0] };

    	if (/*carpetaMedia*/ ctx[4] !== void 0) {
    		carpetamedia_props.visible = /*carpetaMedia*/ ctx[4];
    	}

    	carpetamedia = new CarpetaMedia({
    			props: carpetamedia_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(carpetamedia, "visible", carpetamedia_visible_binding));
    	let if_block0 = (!window.config.general.modoMessi || /*$globalStore*/ ctx[5].usuario.esMod) && create_if_block_2$4(ctx);
    	let if_block1 = /*nuevosComentarios*/ ctx[2].length != 0 && create_if_block_1$6(ctx);

    	button = new ye({
    			props: {
    				dense: true,
    				icon: true,
    				$$slots: { default: [create_default_slot_1$7] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button.$on("click", /*click_handler*/ ctx[11]);
    	let if_block2 = /*comentarios*/ ctx[0].length > 0 && create_if_block$b(ctx);
    	let each_value = /*comentarios*/ ctx[0];
    	validate_each_argument(each_value);
    	const get_key = ctx => /*comentario*/ ctx[23].id;
    	validate_each_keys(ctx, each_value, get_each_context$6, get_key);

    	for (let i = 0; i < each_value.length; i += 1) {
    		let child_ctx = get_each_context$6(ctx, each_value, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block$6(key, child_ctx));
    	}

    	const block = {
    		c: function create() {
    			create_component(carpetamedia.$$.fragment);
    			t0 = space();
    			div4 = element("div");
    			if (if_block0) if_block0.c();
    			t1 = space();
    			div1 = element("div");
    			h3 = element("h3");
    			t2 = text("Comentarios (");
    			t3 = text(t3_value);
    			t4 = text(")");
    			t5 = space();
    			if (if_block1) if_block1.c();
    			t6 = space();
    			div0 = element("div");
    			create_component(button.$$.fragment);
    			t7 = space();
    			if (if_block2) if_block2.c();
    			t8 = space();
    			div2 = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t9 = space();
    			div3 = element("div");
    			add_location(h3, file$d, 126, 8, 4502);
    			attr_dev(div0, "class", "acciones-comentario");
    			add_location(div0, file$d, 133, 8, 4831);
    			attr_dev(div1, "class", "contador-comentarios panel");
    			add_location(div1, file$d, 125, 4, 4452);
    			attr_dev(div2, "class", "lista-comentarios");
    			add_location(div2, file$d, 147, 4, 5455);
    			attr_dev(div3, "class", "espacio-vacio svelte-6vx46");
    			add_location(div3, file$d, 162, 8, 6076);
    			attr_dev(div4, "class", "comentarios");
    			add_location(div4, file$d, 121, 0, 4306);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(carpetamedia, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div4, anchor);
    			if (if_block0) if_block0.m(div4, null);
    			append_dev(div4, t1);
    			append_dev(div4, div1);
    			append_dev(div1, h3);
    			append_dev(h3, t2);
    			append_dev(h3, t3);
    			append_dev(h3, t4);
    			append_dev(div1, t5);
    			if (if_block1) if_block1.m(div1, null);
    			append_dev(div1, t6);
    			append_dev(div1, div0);
    			mount_component(button, div0, null);
    			append_dev(div0, t7);
    			if (if_block2) if_block2.m(div0, null);
    			append_dev(div4, t8);
    			append_dev(div4, div2);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div2, null);
    			}

    			append_dev(div4, t9);
    			append_dev(div4, div3);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const carpetamedia_changes = {};
    			if (dirty & /*comentarios*/ 1) carpetamedia_changes.comentarios = /*comentarios*/ ctx[0];

    			if (!updating_visible && dirty & /*carpetaMedia*/ 16) {
    				updating_visible = true;
    				carpetamedia_changes.visible = /*carpetaMedia*/ ctx[4];
    				add_flush_callback(() => updating_visible = false);
    			}

    			carpetamedia.$set(carpetamedia_changes);

    			if (!window.config.general.modoMessi || /*$globalStore*/ ctx[5].usuario.esMod) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty & /*$globalStore*/ 32) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_2$4(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(div4, t1);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if ((!current || dirty & /*comentarios*/ 1) && t3_value !== (t3_value = /*comentarios*/ ctx[0].length + "")) set_data_dev(t3, t3_value);

    			if (/*nuevosComentarios*/ ctx[2].length != 0) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block_1$6(ctx);
    					if_block1.c();
    					if_block1.m(div1, t6);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			const button_changes = {};

    			if (dirty & /*$$scope*/ 67108864) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);

    			if (/*comentarios*/ ctx[0].length > 0) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);

    					if (dirty & /*comentarios*/ 1) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block$b(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(div0, null);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}

    			if (dirty & /*hilo, comentarios, diccionarioComentarios, resaltarComentariosDeUsuario, tagCliqueado, idUnicoClickeado*/ 907) {
    				const each_value = /*comentarios*/ ctx[0];
    				validate_each_argument(each_value);
    				group_outros();
    				validate_each_keys(ctx, each_value, get_each_context$6, get_key);
    				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, div2, outro_and_destroy_block, create_each_block$6, null, get_each_context$6);
    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(carpetamedia.$$.fragment, local);
    			transition_in(if_block0);
    			transition_in(button.$$.fragment, local);
    			transition_in(if_block2);

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(carpetamedia.$$.fragment, local);
    			transition_out(if_block0);
    			transition_out(button.$$.fragment, local);
    			transition_out(if_block2);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(carpetamedia, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div4);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			destroy_component(button);
    			if (if_block2) if_block2.d();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].d();
    			}
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$d.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$d($$self, $$props, $$invalidate) {
    	let $globalStore;
    	validate_store(globalStore, "globalStore");
    	component_subscribe($$self, globalStore, $$value => $$invalidate(5, $globalStore = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Comentarios", slots, []);
    	let { hilo } = $$props;
    	let { comentarios } = $$props;
    	let nuevosComentarios = [];

    	function cargarNuevosComentarios() {
    		$$invalidate(0, comentarios = [...nuevosComentarios, ...comentarios]);
    		$$invalidate(2, nuevosComentarios = []);
    		comentarios.forEach(agregarComentarioADiccionario);
    		comentarios.forEach(cargarRespuestas);

    		// Añadir el restag a los comentarios tageados por este comentario
    		agregarComentarioADiccionario(comentario);

    		cargarRespuestas(comentario);
    		$$invalidate(0, comentarios);
    	}

    	let diccionarioRespuestas = {};
    	let diccionarioComentarios = {};

    	function agregarComentarioADiccionario(comentario) {
    		$$invalidate(3, diccionarioComentarios[comentario.id] = comentario, diccionarioComentarios);
    		let tags = comentario.contenido.match(/#([A-Z0-9]{8})/g);
    		if (!tags) return;
    		let id = comentario.id;

    		for (const tag of tags) {
    			let otraId = tag.slice(1, 9);
    			if (!diccionarioRespuestas[otraId]) diccionarioRespuestas[otraId] = [];
    			diccionarioRespuestas[otraId].push(id);
    			diccionarioRespuestas[otraId] = diccionarioRespuestas[otraId];
    		}

    		diccionarioRespuestas = diccionarioRespuestas;
    	}

    	function cargarRespuestas(comentario) {
    		if (diccionarioRespuestas[comentario.id]) comentario.respuestas = [...diccionarioRespuestas[comentario.id]]; else comentario.respuestas = [];
    		comentario.respuestas = Array.from(new Set(comentario.respuestas));
    	}

    	comentarios.forEach(agregarComentarioADiccionario);
    	comentarios.forEach(cargarRespuestas);

    	function onComentarioCreado(comentario) {
    		$$invalidate(2, nuevosComentarios = [comentario, ...nuevosComentarios]);
    		comentario.respuestas = [];
    	}

    	Signal.coneccion.on("NuevoComentario", onComentarioCreado);
    	Signal.subscribirseAHilo(hilo.id);

    	Signal.coneccion.on("ComentariosEliminados", ids => {
    		$$invalidate(0, comentarios = comentarios.filter(c => !ids.includes(c.id)));
    		$$invalidate(2, nuevosComentarios = nuevosComentarios.filter(c => !ids.includes(c.id)));
    	});

    	let resaltando = false;

    	function resaltarComentariosDeUsuario(usuarioId) {
    		if (!$globalStore.usuario.esMod) return;

    		if (resaltando) {
    			comentarios.forEach(c => c.resaltado = false);
    			$$invalidate(0, comentarios);
    			resaltando = false;
    			return;
    		}

    		comentarios.forEach(c => {
    			if (c.usuarioId == c.usuarioId) {
    				resaltando = true;
    			}

    			c.resaltado = usuarioId == c.usuarioId;
    		});

    		$$invalidate(0, comentarios);
    	}

    	function tagCliqueado(e) {
    		comentarios.forEach(c => c.resaltado = false);
    		$$invalidate(0, comentarios);
    		$$invalidate(3, diccionarioComentarios[e.detail].resaltado = true, diccionarioComentarios);
    	}

    	let comentarioUrl = window.location.hash.replace("#", "");

    	async function irAComentario(comentarioId) {
    		if (diccionarioComentarios[comentarioId]) {
    			$$invalidate(3, diccionarioComentarios[comentarioId].resaltado = true, diccionarioComentarios);
    			let comentarioDOM = document.getElementById(comentarioId);
    			await tick();
    			if (comentarioDOM) comentarioDOM.scrollIntoView({ block: "center" });
    		}
    	}

    	onMount(() => irAComentario(comentarioUrl));
    	irAComentario(comentarioUrl);
    	let resaltadoIdUnico = false;

    	function idUnicoClickeado(e) {
    		comentarios.forEach(c => {
    			if (!resaltadoIdUnico) {
    				c.resaltado = c.idUnico == e.detail;
    			} else {
    				c.resaltado = false;
    			}
    		});

    		$$invalidate(0, comentarios);
    		resaltadoIdUnico = !resaltadoIdUnico;
    	}

    	let carpetaMedia = false;
    	const writable_props = ["hilo", "comentarios"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Comentarios> was created with unknown prop '${key}'`);
    	});

    	function carpetamedia_visible_binding(value) {
    		carpetaMedia = value;
    		$$invalidate(4, carpetaMedia);
    	}

    	const click_handler = () => $$invalidate(4, carpetaMedia = !carpetaMedia);

    	function comentario_1_comentario_binding(value, comentario, each_value, comentario_index) {
    		each_value[comentario_index] = value;
    		$$invalidate(0, comentarios);
    	}

    	function comentario_1_comentariosDic_binding(value) {
    		diccionarioComentarios = value;
    		$$invalidate(3, diccionarioComentarios);
    	}

    	const colorClick_handler = e => resaltarComentariosDeUsuario(e.detail.usuarioId || "");

    	$$self.$$set = $$props => {
    		if ("hilo" in $$props) $$invalidate(1, hilo = $$props.hilo);
    		if ("comentarios" in $$props) $$invalidate(0, comentarios = $$props.comentarios);
    	};

    	$$self.$capture_state = () => ({
    		fly,
    		Button: ye,
    		Comentario,
    		Formulario,
    		globalStore,
    		DialogoReporte,
    		Signal,
    		CarpetaMedia,
    		onMount,
    		tick,
    		hilo,
    		comentarios,
    		nuevosComentarios,
    		cargarNuevosComentarios,
    		diccionarioRespuestas,
    		diccionarioComentarios,
    		agregarComentarioADiccionario,
    		cargarRespuestas,
    		onComentarioCreado,
    		resaltando,
    		resaltarComentariosDeUsuario,
    		tagCliqueado,
    		comentarioUrl,
    		irAComentario,
    		resaltadoIdUnico,
    		idUnicoClickeado,
    		carpetaMedia,
    		$globalStore
    	});

    	$$self.$inject_state = $$props => {
    		if ("hilo" in $$props) $$invalidate(1, hilo = $$props.hilo);
    		if ("comentarios" in $$props) $$invalidate(0, comentarios = $$props.comentarios);
    		if ("nuevosComentarios" in $$props) $$invalidate(2, nuevosComentarios = $$props.nuevosComentarios);
    		if ("diccionarioRespuestas" in $$props) diccionarioRespuestas = $$props.diccionarioRespuestas;
    		if ("diccionarioComentarios" in $$props) $$invalidate(3, diccionarioComentarios = $$props.diccionarioComentarios);
    		if ("resaltando" in $$props) resaltando = $$props.resaltando;
    		if ("comentarioUrl" in $$props) comentarioUrl = $$props.comentarioUrl;
    		if ("resaltadoIdUnico" in $$props) resaltadoIdUnico = $$props.resaltadoIdUnico;
    		if ("carpetaMedia" in $$props) $$invalidate(4, carpetaMedia = $$props.carpetaMedia);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		comentarios,
    		hilo,
    		nuevosComentarios,
    		diccionarioComentarios,
    		carpetaMedia,
    		$globalStore,
    		cargarNuevosComentarios,
    		resaltarComentariosDeUsuario,
    		tagCliqueado,
    		idUnicoClickeado,
    		carpetamedia_visible_binding,
    		click_handler,
    		comentario_1_comentario_binding,
    		comentario_1_comentariosDic_binding,
    		colorClick_handler
    	];
    }

    class Comentarios extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$d, create_fragment$d, safe_not_equal, { hilo: 1, comentarios: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Comentarios",
    			options,
    			id: create_fragment$d.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*hilo*/ ctx[1] === undefined && !("hilo" in props)) {
    			console.warn("<Comentarios> was created without expected prop 'hilo'");
    		}

    		if (/*comentarios*/ ctx[0] === undefined && !("comentarios" in props)) {
    			console.warn("<Comentarios> was created without expected prop 'comentarios'");
    		}
    	}

    	get hilo() {
    		throw new Error("<Comentarios>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set hilo(value) {
    		throw new Error("<Comentarios>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get comentarios() {
    		throw new Error("<Comentarios>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set comentarios(value) {
    		throw new Error("<Comentarios>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\components\Acciones.svelte generated by Svelte v3.29.0 */
    const file$e = "src\\components\\Acciones.svelte";

    // (27:4) <Button bind:active={acciones.seguido} on:click={seguir} color={acciones.seguido?'var(--color5)':'grey'}  shaped  >
    function create_default_slot_4$4(ctx) {
    	let i;
    	let t;

    	const block = {
    		c: function create() {
    			i = element("i");
    			t = text("Seg");
    			attr_dev(i, "class", "fe fe-eye");
    			add_location(i, file$e, 26, 119, 947);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, i, anchor);
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(i);
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$4.name,
    		type: "slot",
    		source: "(27:4) <Button bind:active={acciones.seguido} on:click={seguir} color={acciones.seguido?'var(--color5)':'grey'}  shaped  >",
    		ctx
    	});

    	return block;
    }

    // (28:4) <Button bind:active={acciones.favorito} on:click={favoritear} color={acciones.favorito?'var(--color5)':'grey'}  shaped  >
    function create_default_slot_3$7(ctx) {
    	let i;
    	let t;

    	const block = {
    		c: function create() {
    			i = element("i");
    			t = text("Fav");
    			attr_dev(i, "class", "fe fe-star");
    			add_location(i, file$e, 27, 125, 1111);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, i, anchor);
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(i);
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$7.name,
    		type: "slot",
    		source: "(28:4) <Button bind:active={acciones.favorito} on:click={favoritear} color={acciones.favorito?'var(--color5)':'grey'}  shaped  >",
    		ctx
    	});

    	return block;
    }

    // (29:4) <Button bind:active={acciones.hideado} on:click={ocultar} color={acciones.hideado?'var(--color5)':'grey'}  shaped  >
    function create_default_slot_2$7(ctx) {
    	let i;
    	let t;

    	const block = {
    		c: function create() {
    			i = element("i");
    			t = text("Hide");
    			attr_dev(i, "class", "fe fe-eye-off");
    			add_location(i, file$e, 28, 120, 1271);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, i, anchor);
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(i);
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$7.name,
    		type: "slot",
    		source: "(29:4) <Button bind:active={acciones.hideado} on:click={ocultar} color={acciones.hideado?'var(--color5)':'grey'}  shaped  >",
    		ctx
    	});

    	return block;
    }

    // (31:4) <Button  on:click={() => mostrarReporte = true} shaped color="red" >
    function create_default_slot_1$8(ctx) {
    	let i;
    	let t;

    	const block = {
    		c: function create() {
    			i = element("i");
    			t = text("Denunciar");
    			attr_dev(i, "class", "fe fe-flag");
    			add_location(i, file$e, 30, 72, 1389);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, i, anchor);
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(i);
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$8.name,
    		type: "slot",
    		source: "(31:4) <Button  on:click={() => mostrarReporte = true} shaped color=\\\"red\\\" >",
    		ctx
    	});

    	return block;
    }

    // (32:4) <Button  color="white"  shaped  disabled >
    function create_default_slot$9(ctx) {
    	let i;
    	let tiempo;
    	let current;

    	tiempo = new Tiempo({
    			props: { date: /*hilo*/ ctx[1].creacion },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			i = element("i");
    			create_component(tiempo.$$.fragment);
    			attr_dev(i, "class", "fe fe-clock");
    			add_location(i, file$e, 31, 46, 1481);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, i, anchor);
    			mount_component(tiempo, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const tiempo_changes = {};
    			if (dirty & /*hilo*/ 2) tiempo_changes.date = /*hilo*/ ctx[1].creacion;
    			tiempo.$set(tiempo_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(tiempo.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(tiempo.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(i);
    			destroy_component(tiempo, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$9.name,
    		type: "slot",
    		source: "(32:4) <Button  color=\\\"white\\\"  shaped  disabled >",
    		ctx
    	});

    	return block;
    }

    // (34:4) {#if hilo.rango > CreacionRango.Anon || hilo.nombre}
    function create_if_block$c(ctx) {
    	let span;
    	let t;
    	let if_block0 = /*hilo*/ ctx[1].rango > CreacionRango.Anon && create_if_block_2$5(ctx);
    	let if_block1 = /*hilo*/ ctx[1].nombre && create_if_block_1$7(ctx);

    	const block = {
    		c: function create() {
    			span = element("span");
    			if (if_block0) if_block0.c();
    			t = space();
    			if (if_block1) if_block1.c();
    			attr_dev(span, "class", "mod svelte-q7w7pq");
    			add_location(span, file$e, 34, 8, 1618);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			if (if_block0) if_block0.m(span, null);
    			append_dev(span, t);
    			if (if_block1) if_block1.m(span, null);
    		},
    		p: function update(ctx, dirty) {
    			if (/*hilo*/ ctx[1].rango > CreacionRango.Anon) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_2$5(ctx);
    					if_block0.c();
    					if_block0.m(span, t);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (/*hilo*/ ctx[1].nombre) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block_1$7(ctx);
    					if_block1.c();
    					if_block1.m(span, null);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$c.name,
    		type: "if",
    		source: "(34:4) {#if hilo.rango > CreacionRango.Anon || hilo.nombre}",
    		ctx
    	});

    	return block;
    }

    // (36:12) {#if hilo.rango > CreacionRango.Anon}
    function create_if_block_2$5(ctx) {
    	let t_value = CreacionRango.aString(/*hilo*/ ctx[1].rango).toUpperCase() + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*hilo*/ 2 && t_value !== (t_value = CreacionRango.aString(/*hilo*/ ctx[1].rango).toUpperCase() + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$5.name,
    		type: "if",
    		source: "(36:12) {#if hilo.rango > CreacionRango.Anon}",
    		ctx
    	});

    	return block;
    }

    // (40:12) {#if hilo.nombre}
    function create_if_block_1$7(ctx) {
    	let t_value = /*hilo*/ ctx[1].nombre + "";
    	let t;

    	const block = {
    		c: function create() {
    			t = text(t_value);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*hilo*/ 2 && t_value !== (t_value = /*hilo*/ ctx[1].nombre + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$7.name,
    		type: "if",
    		source: "(40:12) {#if hilo.nombre}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$e(ctx) {
    	let div;
    	let button0;
    	let updating_active;
    	let t0;
    	let button1;
    	let updating_active_1;
    	let t1;
    	let button2;
    	let updating_active_2;
    	let t2;
    	let button3;
    	let t3;
    	let button4;
    	let t4;
    	let t5;
    	let dialogoreporte;
    	let updating_visible;
    	let current;

    	function button0_active_binding(value) {
    		/*button0_active_binding*/ ctx[6].call(null, value);
    	}

    	let button0_props = {
    		color: /*acciones*/ ctx[0].seguido ? "var(--color5)" : "grey",
    		shaped: true,
    		$$slots: { default: [create_default_slot_4$4] },
    		$$scope: { ctx }
    	};

    	if (/*acciones*/ ctx[0].seguido !== void 0) {
    		button0_props.active = /*acciones*/ ctx[0].seguido;
    	}

    	button0 = new ye({ props: button0_props, $$inline: true });
    	binding_callbacks.push(() => bind(button0, "active", button0_active_binding));
    	button0.$on("click", /*seguir*/ ctx[3]);

    	function button1_active_binding(value) {
    		/*button1_active_binding*/ ctx[7].call(null, value);
    	}

    	let button1_props = {
    		color: /*acciones*/ ctx[0].favorito ? "var(--color5)" : "grey",
    		shaped: true,
    		$$slots: { default: [create_default_slot_3$7] },
    		$$scope: { ctx }
    	};

    	if (/*acciones*/ ctx[0].favorito !== void 0) {
    		button1_props.active = /*acciones*/ ctx[0].favorito;
    	}

    	button1 = new ye({ props: button1_props, $$inline: true });
    	binding_callbacks.push(() => bind(button1, "active", button1_active_binding));
    	button1.$on("click", /*favoritear*/ ctx[5]);

    	function button2_active_binding(value) {
    		/*button2_active_binding*/ ctx[8].call(null, value);
    	}

    	let button2_props = {
    		color: /*acciones*/ ctx[0].hideado ? "var(--color5)" : "grey",
    		shaped: true,
    		$$slots: { default: [create_default_slot_2$7] },
    		$$scope: { ctx }
    	};

    	if (/*acciones*/ ctx[0].hideado !== void 0) {
    		button2_props.active = /*acciones*/ ctx[0].hideado;
    	}

    	button2 = new ye({ props: button2_props, $$inline: true });
    	binding_callbacks.push(() => bind(button2, "active", button2_active_binding));
    	button2.$on("click", /*ocultar*/ ctx[4]);

    	button3 = new ye({
    			props: {
    				shaped: true,
    				color: "red",
    				$$slots: { default: [create_default_slot_1$8] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button3.$on("click", /*click_handler*/ ctx[9]);

    	button4 = new ye({
    			props: {
    				color: "white",
    				shaped: true,
    				disabled: true,
    				$$slots: { default: [create_default_slot$9] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	let if_block = (/*hilo*/ ctx[1].rango > CreacionRango.Anon || /*hilo*/ ctx[1].nombre) && create_if_block$c(ctx);

    	function dialogoreporte_visible_binding(value) {
    		/*dialogoreporte_visible_binding*/ ctx[10].call(null, value);
    	}

    	let dialogoreporte_props = { tipo: "hilo", hiloId: /*hilo*/ ctx[1].id };

    	if (/*mostrarReporte*/ ctx[2] !== void 0) {
    		dialogoreporte_props.visible = /*mostrarReporte*/ ctx[2];
    	}

    	dialogoreporte = new DialogoReporte({
    			props: dialogoreporte_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(dialogoreporte, "visible", dialogoreporte_visible_binding));

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(button0.$$.fragment);
    			t0 = space();
    			create_component(button1.$$.fragment);
    			t1 = space();
    			create_component(button2.$$.fragment);
    			t2 = space();
    			create_component(button3.$$.fragment);
    			t3 = space();
    			create_component(button4.$$.fragment);
    			t4 = space();
    			if (if_block) if_block.c();
    			t5 = space();
    			create_component(dialogoreporte.$$.fragment);
    			attr_dev(div, "class", "panel acciones svelte-q7w7pq");
    			add_location(div, file$e, 25, 0, 798);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(button0, div, null);
    			append_dev(div, t0);
    			mount_component(button1, div, null);
    			append_dev(div, t1);
    			mount_component(button2, div, null);
    			append_dev(div, t2);
    			mount_component(button3, div, null);
    			append_dev(div, t3);
    			mount_component(button4, div, null);
    			append_dev(div, t4);
    			if (if_block) if_block.m(div, null);
    			insert_dev(target, t5, anchor);
    			mount_component(dialogoreporte, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const button0_changes = {};
    			if (dirty & /*acciones*/ 1) button0_changes.color = /*acciones*/ ctx[0].seguido ? "var(--color5)" : "grey";

    			if (dirty & /*$$scope*/ 2048) {
    				button0_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_active && dirty & /*acciones*/ 1) {
    				updating_active = true;
    				button0_changes.active = /*acciones*/ ctx[0].seguido;
    				add_flush_callback(() => updating_active = false);
    			}

    			button0.$set(button0_changes);
    			const button1_changes = {};
    			if (dirty & /*acciones*/ 1) button1_changes.color = /*acciones*/ ctx[0].favorito ? "var(--color5)" : "grey";

    			if (dirty & /*$$scope*/ 2048) {
    				button1_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_active_1 && dirty & /*acciones*/ 1) {
    				updating_active_1 = true;
    				button1_changes.active = /*acciones*/ ctx[0].favorito;
    				add_flush_callback(() => updating_active_1 = false);
    			}

    			button1.$set(button1_changes);
    			const button2_changes = {};
    			if (dirty & /*acciones*/ 1) button2_changes.color = /*acciones*/ ctx[0].hideado ? "var(--color5)" : "grey";

    			if (dirty & /*$$scope*/ 2048) {
    				button2_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_active_2 && dirty & /*acciones*/ 1) {
    				updating_active_2 = true;
    				button2_changes.active = /*acciones*/ ctx[0].hideado;
    				add_flush_callback(() => updating_active_2 = false);
    			}

    			button2.$set(button2_changes);
    			const button3_changes = {};

    			if (dirty & /*$$scope*/ 2048) {
    				button3_changes.$$scope = { dirty, ctx };
    			}

    			button3.$set(button3_changes);
    			const button4_changes = {};

    			if (dirty & /*$$scope, hilo*/ 2050) {
    				button4_changes.$$scope = { dirty, ctx };
    			}

    			button4.$set(button4_changes);

    			if (/*hilo*/ ctx[1].rango > CreacionRango.Anon || /*hilo*/ ctx[1].nombre) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$c(ctx);
    					if_block.c();
    					if_block.m(div, null);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			const dialogoreporte_changes = {};
    			if (dirty & /*hilo*/ 2) dialogoreporte_changes.hiloId = /*hilo*/ ctx[1].id;

    			if (!updating_visible && dirty & /*mostrarReporte*/ 4) {
    				updating_visible = true;
    				dialogoreporte_changes.visible = /*mostrarReporte*/ ctx[2];
    				add_flush_callback(() => updating_visible = false);
    			}

    			dialogoreporte.$set(dialogoreporte_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button0.$$.fragment, local);
    			transition_in(button1.$$.fragment, local);
    			transition_in(button2.$$.fragment, local);
    			transition_in(button3.$$.fragment, local);
    			transition_in(button4.$$.fragment, local);
    			transition_in(dialogoreporte.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button0.$$.fragment, local);
    			transition_out(button1.$$.fragment, local);
    			transition_out(button2.$$.fragment, local);
    			transition_out(button3.$$.fragment, local);
    			transition_out(button4.$$.fragment, local);
    			transition_out(dialogoreporte.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(button0);
    			destroy_component(button1);
    			destroy_component(button2);
    			destroy_component(button3);
    			destroy_component(button4);
    			if (if_block) if_block.d();
    			if (detaching) detach_dev(t5);
    			destroy_component(dialogoreporte, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$e.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$e($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Acciones", slots, []);
    	let { hilo } = $$props;
    	let { acciones } = $$props;
    	let mostrarReporte = false;

    	async function seguir() {
    		await RChanClient.agregar("seguidos", hilo.id);
    		$$invalidate(0, acciones.seguido = !acciones.seguido, acciones);
    	}

    	async function ocultar() {
    		await RChanClient.agregar("ocultos", hilo.id);
    		$$invalidate(0, acciones.hideado = !acciones.hideado, acciones);
    	}

    	async function favoritear() {
    		await RChanClient.agregar("favoritos", hilo.id);
    		$$invalidate(0, acciones.favorito = !acciones.favorito, acciones);
    	}

    	const writable_props = ["hilo", "acciones"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Acciones> was created with unknown prop '${key}'`);
    	});

    	function button0_active_binding(value) {
    		acciones.seguido = value;
    		$$invalidate(0, acciones);
    	}

    	function button1_active_binding(value) {
    		acciones.favorito = value;
    		$$invalidate(0, acciones);
    	}

    	function button2_active_binding(value) {
    		acciones.hideado = value;
    		$$invalidate(0, acciones);
    	}

    	const click_handler = () => $$invalidate(2, mostrarReporte = true);

    	function dialogoreporte_visible_binding(value) {
    		mostrarReporte = value;
    		$$invalidate(2, mostrarReporte);
    	}

    	$$self.$$set = $$props => {
    		if ("hilo" in $$props) $$invalidate(1, hilo = $$props.hilo);
    		if ("acciones" in $$props) $$invalidate(0, acciones = $$props.acciones);
    	};

    	$$self.$capture_state = () => ({
    		Tiempo,
    		RChanClient,
    		DialogoReporte,
    		Button: ye,
    		ButtonGroup: $e,
    		CreacionRango,
    		hilo,
    		acciones,
    		mostrarReporte,
    		seguir,
    		ocultar,
    		favoritear
    	});

    	$$self.$inject_state = $$props => {
    		if ("hilo" in $$props) $$invalidate(1, hilo = $$props.hilo);
    		if ("acciones" in $$props) $$invalidate(0, acciones = $$props.acciones);
    		if ("mostrarReporte" in $$props) $$invalidate(2, mostrarReporte = $$props.mostrarReporte);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		acciones,
    		hilo,
    		mostrarReporte,
    		seguir,
    		ocultar,
    		favoritear,
    		button0_active_binding,
    		button1_active_binding,
    		button2_active_binding,
    		click_handler,
    		dialogoreporte_visible_binding
    	];
    }

    class Acciones extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$e, create_fragment$e, safe_not_equal, { hilo: 1, acciones: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Acciones",
    			options,
    			id: create_fragment$e.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*hilo*/ ctx[1] === undefined && !("hilo" in props)) {
    			console.warn("<Acciones> was created without expected prop 'hilo'");
    		}

    		if (/*acciones*/ ctx[0] === undefined && !("acciones" in props)) {
    			console.warn("<Acciones> was created without expected prop 'acciones'");
    		}
    	}

    	get hilo() {
    		throw new Error("<Acciones>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set hilo(value) {
    		throw new Error("<Acciones>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get acciones() {
    		throw new Error("<Acciones>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set acciones(value) {
    		throw new Error("<Acciones>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\components\Hilos\HiloCuerpo.svelte generated by Svelte v3.29.0 */
    const file$f = "src\\components\\Hilos\\HiloCuerpo.svelte";

    function create_fragment$f(ctx) {
    	let div1;
    	let media;
    	let updating_abierto;
    	let t0;
    	let h1;
    	let t1_value = /*hilo*/ ctx[0].titulo + "";
    	let t1;
    	let t2;
    	let div0;
    	let raw_value = /*hilo*/ ctx[0].contenido + "";
    	let current;

    	function media_abierto_binding(value) {
    		/*media_abierto_binding*/ ctx[2].call(null, value);
    	}

    	let media_props = { media: /*hilo*/ ctx[0].media };

    	if (/*mediaExpandido*/ ctx[1] !== void 0) {
    		media_props.abierto = /*mediaExpandido*/ ctx[1];
    	}

    	media = new Media({ props: media_props, $$inline: true });
    	binding_callbacks.push(() => bind(media, "abierto", media_abierto_binding));

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			create_component(media.$$.fragment);
    			t0 = space();
    			h1 = element("h1");
    			t1 = text(t1_value);
    			t2 = space();
    			div0 = element("div");
    			set_style(h1, "margin-bottom", "16px");
    			attr_dev(h1, "class", "svelte-2zvjsj");
    			add_location(h1, file$f, 10, 4, 238);
    			attr_dev(div0, "class", "texto");
    			set_style(div0, "white-space", "pre-wrap");
    			set_style(div0, "word-break", "break-word");
    			add_location(div0, file$f, 11, 4, 293);
    			attr_dev(div1, "class", "cuerpo svelte-2zvjsj");
    			toggle_class(div1, "mediaExpandido", /*mediaExpandido*/ ctx[1]);
    			add_location(div1, file$f, 8, 0, 128);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			mount_component(media, div1, null);
    			append_dev(div1, t0);
    			append_dev(div1, h1);
    			append_dev(h1, t1);
    			append_dev(div1, t2);
    			append_dev(div1, div0);
    			div0.innerHTML = raw_value;
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const media_changes = {};
    			if (dirty & /*hilo*/ 1) media_changes.media = /*hilo*/ ctx[0].media;

    			if (!updating_abierto && dirty & /*mediaExpandido*/ 2) {
    				updating_abierto = true;
    				media_changes.abierto = /*mediaExpandido*/ ctx[1];
    				add_flush_callback(() => updating_abierto = false);
    			}

    			media.$set(media_changes);
    			if ((!current || dirty & /*hilo*/ 1) && t1_value !== (t1_value = /*hilo*/ ctx[0].titulo + "")) set_data_dev(t1, t1_value);
    			if ((!current || dirty & /*hilo*/ 1) && raw_value !== (raw_value = /*hilo*/ ctx[0].contenido + "")) div0.innerHTML = raw_value;
    			if (dirty & /*mediaExpandido*/ 2) {
    				toggle_class(div1, "mediaExpandido", /*mediaExpandido*/ ctx[1]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(media.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(media.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			destroy_component(media);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$f.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$f($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("HiloCuerpo", slots, []);
    	let { hilo = null } = $$props;
    	let mediaExpandido = false;
    	const writable_props = ["hilo"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<HiloCuerpo> was created with unknown prop '${key}'`);
    	});

    	function media_abierto_binding(value) {
    		mediaExpandido = value;
    		$$invalidate(1, mediaExpandido);
    	}

    	$$self.$$set = $$props => {
    		if ("hilo" in $$props) $$invalidate(0, hilo = $$props.hilo);
    	};

    	$$self.$capture_state = () => ({ Media, hilo, mediaExpandido });

    	$$self.$inject_state = $$props => {
    		if ("hilo" in $$props) $$invalidate(0, hilo = $$props.hilo);
    		if ("mediaExpandido" in $$props) $$invalidate(1, mediaExpandido = $$props.mediaExpandido);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [hilo, mediaExpandido, media_abierto_binding];
    }

    class HiloCuerpo extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$f, create_fragment$f, safe_not_equal, { hilo: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "HiloCuerpo",
    			options,
    			id: create_fragment$f.name
    		});
    	}

    	get hilo() {
    		throw new Error("<HiloCuerpo>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set hilo(value) {
    		throw new Error("<HiloCuerpo>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\components\Hilos\Encuesta.svelte generated by Svelte v3.29.0 */
    const file$g = "src\\components\\Hilos\\Encuesta.svelte";

    function get_each_context$7(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[13] = list[i];
    	return child_ctx;
    }

    function get_each_context_1$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[13] = list[i];
    	return child_ctx;
    }

    function get_each_context_2$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[13] = list[i];
    	return child_ctx;
    }

    // (58:4) {#if encuesta}
    function create_if_block$d(ctx) {
    	let div;
    	let ripple;
    	let t0;
    	let t1;
    	let t2;
    	let if_block1_anchor;
    	let current;
    	let mounted;
    	let dispose;

    	ripple = new he({
    			props: { color: "var(--color5)" },
    			$$inline: true
    		});

    	let each_value_2 = /*encuesta*/ ctx[0].opciones;
    	validate_each_argument(each_value_2);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_2.length; i += 1) {
    		each_blocks[i] = create_each_block_2$1(get_each_context_2$1(ctx, each_value_2, i));
    	}

    	let if_block0 = /*estado*/ ctx[2] == 1 && create_if_block_2$6(ctx);
    	let if_block1 = /*estado*/ ctx[2] == 3 && create_if_block_1$8(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(ripple.$$.fragment);
    			t0 = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t1 = space();
    			if (if_block0) if_block0.c();
    			t2 = space();
    			if (if_block1) if_block1.c();
    			if_block1_anchor = empty();
    			attr_dev(div, "class", "preview svelte-vykyvz");
    			add_location(div, file$g, 58, 8, 1710);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(ripple, div, null);
    			append_dev(div, t0);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div, null);
    			}

    			insert_dev(target, t1, anchor);
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t2, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, if_block1_anchor, anchor);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(div, "click", /*abrirEncuesta*/ ctx[4], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*calcularPorcentaje, encuesta, estado*/ 69) {
    				each_value_2 = /*encuesta*/ ctx[0].opciones;
    				validate_each_argument(each_value_2);
    				let i;

    				for (i = 0; i < each_value_2.length; i += 1) {
    					const child_ctx = get_each_context_2$1(ctx, each_value_2, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_2$1(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_2.length;
    			}

    			if (/*estado*/ ctx[2] == 1) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty & /*estado*/ 4) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_2$6(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(t2.parentNode, t2);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (/*estado*/ ctx[2] == 3) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty & /*estado*/ 4) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_1$8(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(ripple.$$.fragment, local);
    			transition_in(if_block0);
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(ripple.$$.fragment, local);
    			transition_out(if_block0);
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(ripple);
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(t1);
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t2);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(if_block1_anchor);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$d.name,
    		type: "if",
    		source: "(58:4) {#if encuesta}",
    		ctx
    	});

    	return block;
    }

    // (61:12) {#each encuesta.opciones as o}
    function create_each_block_2$1(ctx) {
    	let div;
    	let span;
    	let t0_value = /*o*/ ctx[13].nombre + "";
    	let t0;
    	let t1;
    	let div_title_value;

    	const block = {
    		c: function create() {
    			div = element("div");
    			span = element("span");
    			t0 = text(t0_value);
    			t1 = space();
    			add_location(span, file$g, 62, 20, 1998);
    			attr_dev(div, "class", "opcion svelte-vykyvz");
    			attr_dev(div, "title", div_title_value = "" + (/*calcularPorcentaje*/ ctx[6](/*o*/ ctx[13].nombre) + "% " + /*o*/ ctx[13].nombre));
    			set_style(div, "flex", /*estado*/ ctx[2] < 2 ? 1 : /*o*/ ctx[13].votos);
    			add_location(div, file$g, 61, 12, 1867);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, span);
    			append_dev(span, t0);
    			append_dev(div, t1);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*encuesta*/ 1 && t0_value !== (t0_value = /*o*/ ctx[13].nombre + "")) set_data_dev(t0, t0_value);

    			if (dirty & /*encuesta*/ 1 && div_title_value !== (div_title_value = "" + (/*calcularPorcentaje*/ ctx[6](/*o*/ ctx[13].nombre) + "% " + /*o*/ ctx[13].nombre))) {
    				attr_dev(div, "title", div_title_value);
    			}

    			if (dirty & /*estado, encuesta*/ 5) {
    				set_style(div, "flex", /*estado*/ ctx[2] < 2 ? 1 : /*o*/ ctx[13].votos);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_2$1.name,
    		type: "each",
    		source: "(61:12) {#each encuesta.opciones as o}",
    		ctx
    	});

    	return block;
    }

    // (70:8) {#if estado == 1}
    function create_if_block_2$6(ctx) {
    	let dialog;
    	let current;

    	dialog = new pn({
    			props: {
    				visible: true,
    				modal: true,
    				$$slots: {
    					default: [create_default_slot_2$8],
    					title: [create_title_slot_1]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dialog.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dialog, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dialog_changes = {};

    			if (dirty & /*$$scope, votando, encuesta*/ 1048579) {
    				dialog_changes.$$scope = { dirty, ctx };
    			}

    			dialog.$set(dialog_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dialog.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dialog.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dialog, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$6.name,
    		type: "if",
    		source: "(70:8) {#if estado == 1}",
    		ctx
    	});

    	return block;
    }

    // (72:16) <div slot="title">
    function create_title_slot_1(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			div.textContent = "Elija una opcion padre";
    			attr_dev(div, "slot", "title");
    			add_location(div, file$g, 71, 16, 2233);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_title_slot_1.name,
    		type: "slot",
    		source: "(72:16) <div slot=\\\"title\\\">",
    		ctx
    	});

    	return block;
    }

    // (75:24) {#each encuesta.opciones as o}
    function create_each_block_1$1(ctx) {
    	let li;
    	let t0_value = /*o*/ ctx[13].nombre + "";
    	let t0;
    	let t1;
    	let ripple;
    	let current;
    	let mounted;
    	let dispose;
    	ripple = new he({ $$inline: true });

    	function click_handler(...args) {
    		return /*click_handler*/ ctx[8](/*o*/ ctx[13], ...args);
    	}

    	const block = {
    		c: function create() {
    			li = element("li");
    			t0 = text(t0_value);
    			t1 = space();
    			create_component(ripple.$$.fragment);
    			attr_dev(li, "class", "svelte-vykyvz");
    			add_location(li, file$g, 75, 28, 2437);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			append_dev(li, t0);
    			append_dev(li, t1);
    			mount_component(ripple, li, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(li, "click", click_handler, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if ((!current || dirty & /*encuesta*/ 1) && t0_value !== (t0_value = /*o*/ ctx[13].nombre + "")) set_data_dev(t0, t0_value);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(ripple.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(ripple.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			destroy_component(ripple);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$1.name,
    		type: "each",
    		source: "(75:24) {#each encuesta.opciones as o}",
    		ctx
    	});

    	return block;
    }

    // (74:20) <Spinner cargando={votando}>
    function create_default_slot_3$8(ctx) {
    	let each_1_anchor;
    	let current;
    	let each_value_1 = /*encuesta*/ ctx[0].opciones;
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$1(get_each_context_1$1(ctx, each_value_1, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			each_1_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(target, anchor);
    			}

    			insert_dev(target, each_1_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*votar, encuesta*/ 33) {
    				each_value_1 = /*encuesta*/ ctx[0].opciones;
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$1(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block_1$1(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
    					}
    				}

    				group_outros();

    				for (i = each_value_1.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value_1.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(each_1_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$8.name,
    		type: "slot",
    		source: "(74:20) <Spinner cargando={votando}>",
    		ctx
    	});

    	return block;
    }

    // (71:12) <Dialog  visible={true} modal={true}>
    function create_default_slot_2$8(ctx) {
    	let t;
    	let ul;
    	let spinner;
    	let current;

    	spinner = new Spinner({
    			props: {
    				cargando: /*votando*/ ctx[1],
    				$$slots: { default: [create_default_slot_3$8] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			t = space();
    			ul = element("ul");
    			create_component(spinner.$$.fragment);
    			add_location(ul, file$g, 72, 16, 2297);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    			insert_dev(target, ul, anchor);
    			mount_component(spinner, ul, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const spinner_changes = {};
    			if (dirty & /*votando*/ 2) spinner_changes.cargando = /*votando*/ ctx[1];

    			if (dirty & /*$$scope, encuesta*/ 1048577) {
    				spinner_changes.$$scope = { dirty, ctx };
    			}

    			spinner.$set(spinner_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(spinner.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(spinner.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    			if (detaching) detach_dev(ul);
    			destroy_component(spinner);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$8.name,
    		type: "slot",
    		source: "(71:12) <Dialog  visible={true} modal={true}>",
    		ctx
    	});

    	return block;
    }

    // (82:8) {#if estado == 3}
    function create_if_block_1$8(ctx) {
    	let dialog;
    	let current;

    	dialog = new pn({
    			props: {
    				visible: true,
    				modal: true,
    				$$slots: {
    					default: [create_default_slot$a],
    					actions: [create_actions_slot$1],
    					title: [create_title_slot$1]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dialog.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dialog, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dialog_changes = {};

    			if (dirty & /*$$scope, estado, encuesta, totalDeVotos*/ 1048589) {
    				dialog_changes.$$scope = { dirty, ctx };
    			}

    			dialog.$set(dialog_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dialog.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dialog.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dialog, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$8.name,
    		type: "if",
    		source: "(82:8) {#if estado == 3}",
    		ctx
    	});

    	return block;
    }

    // (84:16) <div slot="title">
    function create_title_slot$1(ctx) {
    	let div;
    	let t0;
    	let t1;
    	let t2;
    	let t3_value = (/*totalDeVotos*/ ctx[3] != 1 ? "votos" : "voto") + "";
    	let t3;
    	let t4;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text("Resultados (");
    			t1 = text(/*totalDeVotos*/ ctx[3]);
    			t2 = space();
    			t3 = text(t3_value);
    			t4 = text(")");
    			attr_dev(div, "slot", "title");
    			add_location(div, file$g, 83, 16, 2722);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);
    			append_dev(div, t2);
    			append_dev(div, t3);
    			append_dev(div, t4);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*totalDeVotos*/ 8) set_data_dev(t1, /*totalDeVotos*/ ctx[3]);
    			if (dirty & /*totalDeVotos*/ 8 && t3_value !== (t3_value = (/*totalDeVotos*/ ctx[3] != 1 ? "votos" : "voto") + "")) set_data_dev(t3, t3_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_title_slot$1.name,
    		type: "slot",
    		source: "(84:16) <div slot=\\\"title\\\">",
    		ctx
    	});

    	return block;
    }

    // (86:20) {#each encuesta.opciones as o}
    function create_each_block$7(ctx) {
    	let li;
    	let t0_value = /*calcularPorcentaje*/ ctx[6](/*o*/ ctx[13].nombre) + "";
    	let t0;
    	let t1;
    	let t2_value = /*o*/ ctx[13].nombre + "";
    	let t2;
    	let t3;

    	const block = {
    		c: function create() {
    			li = element("li");
    			t0 = text(t0_value);
    			t1 = text("% ");
    			t2 = text(t2_value);
    			t3 = space();
    			attr_dev(li, "class", "svelte-vykyvz");
    			add_location(li, file$g, 86, 24, 2910);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			append_dev(li, t0);
    			append_dev(li, t1);
    			append_dev(li, t2);
    			append_dev(li, t3);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*encuesta*/ 1 && t0_value !== (t0_value = /*calcularPorcentaje*/ ctx[6](/*o*/ ctx[13].nombre) + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*encuesta*/ 1 && t2_value !== (t2_value = /*o*/ ctx[13].nombre + "")) set_data_dev(t2, t2_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$7.name,
    		type: "each",
    		source: "(86:20) {#each encuesta.opciones as o}",
    		ctx
    	});

    	return block;
    }

    // (91:20) <Button color="primary" on:click={() => estado = 2}>
    function create_default_slot_1$9(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Ok");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$9.name,
    		type: "slot",
    		source: "(91:20) <Button color=\\\"primary\\\" on:click={() => estado = 2}>",
    		ctx
    	});

    	return block;
    }

    // (90:16) <div slot="actions" class="actions center">
    function create_actions_slot$1(ctx) {
    	let div;
    	let button;
    	let current;

    	button = new ye({
    			props: {
    				color: "primary",
    				$$slots: { default: [create_default_slot_1$9] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button.$on("click", /*click_handler_1*/ ctx[9]);

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(button.$$.fragment);
    			attr_dev(div, "slot", "actions");
    			attr_dev(div, "class", "actions center");
    			add_location(div, file$g, 89, 16, 3032);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(button, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button_changes = {};

    			if (dirty & /*$$scope*/ 1048576) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(button);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_actions_slot$1.name,
    		type: "slot",
    		source: "(90:16) <div slot=\\\"actions\\\" class=\\\"actions center\\\">",
    		ctx
    	});

    	return block;
    }

    // (83:12) <Dialog  visible={true} modal={true}>
    function create_default_slot$a(ctx) {
    	let t0;
    	let ul;
    	let t1;
    	let each_value = /*encuesta*/ ctx[0].opciones;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$7(get_each_context$7(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			t0 = space();
    			ul = element("ul");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t1 = space();
    			add_location(ul, file$g, 84, 16, 2828);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, ul, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(ul, null);
    			}

    			insert_dev(target, t1, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*encuesta, calcularPorcentaje*/ 65) {
    				each_value = /*encuesta*/ ctx[0].opciones;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$7(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$7(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(ul, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(ul);
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(t1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$a.name,
    		type: "slot",
    		source: "(83:12) <Dialog  visible={true} modal={true}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$g(ctx) {
    	let div;
    	let current;
    	let if_block = /*encuesta*/ ctx[0] && create_if_block$d(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block) if_block.c();
    			attr_dev(div, "class", "encuesta svelte-vykyvz");
    			add_location(div, file$g, 56, 0, 1658);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block) if_block.m(div, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*encuesta*/ ctx[0]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*encuesta*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$d(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(div, null);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block) if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$g.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$g($$self, $$props, $$invalidate) {
    	let $globalStore;
    	let $comentarioStore;
    	validate_store(globalStore, "globalStore");
    	component_subscribe($$self, globalStore, $$value => $$invalidate(10, $globalStore = $$value));
    	validate_store(comentarioStore, "comentarioStore");
    	component_subscribe($$self, comentarioStore, $$value => $$invalidate(11, $comentarioStore = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Encuesta", slots, []);
    	let { encuesta } = $$props;
    	let { hiloId } = $$props;
    	let { votando = false } = $$props;
    	let dialogo = false;
    	let estado = 0; // 0 no voto // 1 votando // 2 voto //3 detalles
    	if (encuesta.haVotado || !$globalStore.usuario.estaAutenticado) estado = 2;

    	function abrirEncuesta() {
    		if (estado == 0) {
    			$$invalidate(2, estado = 1);
    		} else if (estado == 2) {
    			$$invalidate(2, estado = 3);
    		}
    	}

    	async function votar(opcion) {
    		try {
    			$$invalidate(1, votando = true);
    			let res = await RChanClient.votarEncuesta(hiloId, opcion);
    			set_store_value(comentarioStore, $comentarioStore = `[${opcion}]\n\n` + $comentarioStore, $comentarioStore);
    		} catch(error) {
    			
    		}

    		encuesta.opciones.filter(o => o.nombre == opcion)[0].votos++;
    		$$invalidate(0, encuesta);
    		$$invalidate(1, votando = false);
    		$$invalidate(2, estado = 2);
    	}

    	function calcularPorcentaje(opcion) {
    		let votosTotales = 0;
    		encuesta.opciones.forEach(o => votosTotales += o.votos);
    		if (votosTotales == 0) votosTotales = 1;
    		const votosOpcion = encuesta.opciones.filter(o => o.nombre == opcion)[0].votos;
    		return (votosOpcion / votosTotales * 100).toFixed(2);
    	}

    	if (!$globalStore.usuario.estaAutenticado) estado = 2;
    	const writable_props = ["encuesta", "hiloId", "votando"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Encuesta> was created with unknown prop '${key}'`);
    	});

    	const click_handler = o => votar(o.nombre);
    	const click_handler_1 = () => $$invalidate(2, estado = 2);

    	$$self.$$set = $$props => {
    		if ("encuesta" in $$props) $$invalidate(0, encuesta = $$props.encuesta);
    		if ("hiloId" in $$props) $$invalidate(7, hiloId = $$props.hiloId);
    		if ("votando" in $$props) $$invalidate(1, votando = $$props.votando);
    	};

    	$$self.$capture_state = () => ({
    		Dialog: pn,
    		Ripple: he,
    		Button: ye,
    		globalStore,
    		RChanClient,
    		comentarioStore,
    		Spinner,
    		encuesta,
    		hiloId,
    		votando,
    		dialogo,
    		estado,
    		abrirEncuesta,
    		votar,
    		calcularPorcentaje,
    		$globalStore,
    		totalDeVotos,
    		$comentarioStore
    	});

    	$$self.$inject_state = $$props => {
    		if ("encuesta" in $$props) $$invalidate(0, encuesta = $$props.encuesta);
    		if ("hiloId" in $$props) $$invalidate(7, hiloId = $$props.hiloId);
    		if ("votando" in $$props) $$invalidate(1, votando = $$props.votando);
    		if ("dialogo" in $$props) dialogo = $$props.dialogo;
    		if ("estado" in $$props) $$invalidate(2, estado = $$props.estado);
    		if ("totalDeVotos" in $$props) $$invalidate(3, totalDeVotos = $$props.totalDeVotos);
    	};

    	let totalDeVotos;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*encuesta*/ 1) {
    			 $$invalidate(3, totalDeVotos = encuesta.opciones.map(e => e.votos).reduce((a, b) => a + b));
    		}
    	};

    	return [
    		encuesta,
    		votando,
    		estado,
    		totalDeVotos,
    		abrirEncuesta,
    		votar,
    		calcularPorcentaje,
    		hiloId,
    		click_handler,
    		click_handler_1
    	];
    }

    class Encuesta extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$g, create_fragment$g, safe_not_equal, { encuesta: 0, hiloId: 7, votando: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Encuesta",
    			options,
    			id: create_fragment$g.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*encuesta*/ ctx[0] === undefined && !("encuesta" in props)) {
    			console.warn("<Encuesta> was created without expected prop 'encuesta'");
    		}

    		if (/*hiloId*/ ctx[7] === undefined && !("hiloId" in props)) {
    			console.warn("<Encuesta> was created without expected prop 'hiloId'");
    		}
    	}

    	get encuesta() {
    		throw new Error("<Encuesta>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set encuesta(value) {
    		throw new Error("<Encuesta>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get hiloId() {
    		throw new Error("<Encuesta>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set hiloId(value) {
    		throw new Error("<Encuesta>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get votando() {
    		throw new Error("<Encuesta>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set votando(value) {
    		throw new Error("<Encuesta>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\App.svelte generated by Svelte v3.29.0 */
    const file$h = "src\\App.svelte";

    function get_each_context$8(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[19] = list[i];
    	return child_ctx;
    }

    // (44:2) {#if hilo.encuestaData}
    function create_if_block_6$2(ctx) {
    	let encuesta;
    	let updating_encuesta;
    	let current;

    	function encuesta_encuesta_binding(value) {
    		/*encuesta_encuesta_binding*/ ctx[8].call(null, value);
    	}

    	let encuesta_props = { hiloId: /*hilo*/ ctx[0].id };

    	if (/*hilo*/ ctx[0].encuestaData !== void 0) {
    		encuesta_props.encuesta = /*hilo*/ ctx[0].encuestaData;
    	}

    	encuesta = new Encuesta({ props: encuesta_props, $$inline: true });
    	binding_callbacks.push(() => bind(encuesta, "encuesta", encuesta_encuesta_binding));

    	const block = {
    		c: function create() {
    			create_component(encuesta.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(encuesta, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const encuesta_changes = {};
    			if (dirty & /*hilo*/ 1) encuesta_changes.hiloId = /*hilo*/ ctx[0].id;

    			if (!updating_encuesta && dirty & /*hilo*/ 1) {
    				updating_encuesta = true;
    				encuesta_changes.encuesta = /*hilo*/ ctx[0].encuestaData;
    				add_flush_callback(() => updating_encuesta = false);
    			}

    			encuesta.$set(encuesta_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(encuesta.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(encuesta.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(encuesta, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_6$2.name,
    		type: "if",
    		source: "(44:2) {#if hilo.encuestaData}",
    		ctx
    	});

    	return block;
    }

    // (48:2) {#if $globalStore.usuario.esAuxiliar}
    function create_if_block$e(ctx) {
    	let t0;
    	let div;
    	let t1;
    	let dialogo;
    	let t2;
    	let t3;
    	let t4;
    	let button;
    	let t5;
    	let current;
    	let if_block0 = /*hilo*/ ctx[0].estado == 2 && create_if_block_5$2(ctx);
    	let if_block1 = /*$globalStore*/ ctx[4].usuario.esMod && create_if_block_4$2(ctx);

    	dialogo = new Dialogo({
    			props: {
    				textoActivador: "Categoria",
    				titulo: "Cambiar categoria",
    				accion: /*func*/ ctx[12],
    				$$slots: { body: [create_body_slot$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	let if_block2 = /*hilo*/ ctx[0].estado != HiloEstado.eliminado && create_if_block_3$3(ctx);
    	let if_block3 = /*hilo*/ ctx[0].estado == HiloEstado.eliminado && create_if_block_2$7(ctx);

    	button = new ye({
    			props: {
    				$$slots: { default: [create_default_slot_1$a] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button.$on("click", /*click_handler_2*/ ctx[15]);
    	let if_block4 = /*$globalStore*/ ctx[4].usuario.esMod && create_if_block_1$9(ctx);

    	const block = {
    		c: function create() {
    			if (if_block0) if_block0.c();
    			t0 = space();
    			div = element("div");
    			if (if_block1) if_block1.c();
    			t1 = space();
    			create_component(dialogo.$$.fragment);
    			t2 = space();
    			if (if_block2) if_block2.c();
    			t3 = space();
    			if (if_block3) if_block3.c();
    			t4 = space();
    			create_component(button.$$.fragment);
    			t5 = space();
    			if (if_block4) if_block4.c();
    			attr_dev(div, "class", "acciones-mod panel");
    			add_location(div, file$h, 51, 3, 1732);
    		},
    		m: function mount(target, anchor) {
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, div, anchor);
    			if (if_block1) if_block1.m(div, null);
    			append_dev(div, t1);
    			mount_component(dialogo, div, null);
    			append_dev(div, t2);
    			if (if_block2) if_block2.m(div, null);
    			append_dev(div, t3);
    			if (if_block3) if_block3.m(div, null);
    			append_dev(div, t4);
    			mount_component(button, div, null);
    			append_dev(div, t5);
    			if (if_block4) if_block4.m(div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*hilo*/ ctx[0].estado == 2) {
    				if (if_block0) ; else {
    					if_block0 = create_if_block_5$2(ctx);
    					if_block0.c();
    					if_block0.m(t0.parentNode, t0);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (/*$globalStore*/ ctx[4].usuario.esMod) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty & /*$globalStore*/ 16) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_4$2(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div, t1);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			const dialogo_changes = {};
    			if (dirty & /*hilo, dialogs*/ 9) dialogo_changes.accion = /*func*/ ctx[12];

    			if (dirty & /*$$scope, dialogs*/ 4194312) {
    				dialogo_changes.$$scope = { dirty, ctx };
    			}

    			dialogo.$set(dialogo_changes);

    			if (/*hilo*/ ctx[0].estado != HiloEstado.eliminado) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);

    					if (dirty & /*hilo*/ 1) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block_3$3(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(div, t3);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}

    			if (/*hilo*/ ctx[0].estado == HiloEstado.eliminado) {
    				if (if_block3) {
    					if_block3.p(ctx, dirty);

    					if (dirty & /*hilo*/ 1) {
    						transition_in(if_block3, 1);
    					}
    				} else {
    					if_block3 = create_if_block_2$7(ctx);
    					if_block3.c();
    					transition_in(if_block3, 1);
    					if_block3.m(div, t4);
    				}
    			} else if (if_block3) {
    				group_outros();

    				transition_out(if_block3, 1, 1, () => {
    					if_block3 = null;
    				});

    				check_outros();
    			}

    			const button_changes = {};

    			if (dirty & /*$$scope*/ 4194304) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);

    			if (/*$globalStore*/ ctx[4].usuario.esMod) {
    				if (if_block4) {
    					if_block4.p(ctx, dirty);

    					if (dirty & /*$globalStore*/ 16) {
    						transition_in(if_block4, 1);
    					}
    				} else {
    					if_block4 = create_if_block_1$9(ctx);
    					if_block4.c();
    					transition_in(if_block4, 1);
    					if_block4.m(div, null);
    				}
    			} else if (if_block4) {
    				group_outros();

    				transition_out(if_block4, 1, 1, () => {
    					if_block4 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block1);
    			transition_in(dialogo.$$.fragment, local);
    			transition_in(if_block2);
    			transition_in(if_block3);
    			transition_in(button.$$.fragment, local);
    			transition_in(if_block4);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block1);
    			transition_out(dialogo.$$.fragment, local);
    			transition_out(if_block2);
    			transition_out(if_block3);
    			transition_out(button.$$.fragment, local);
    			transition_out(if_block4);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(div);
    			if (if_block1) if_block1.d();
    			destroy_component(dialogo);
    			if (if_block2) if_block2.d();
    			if (if_block3) if_block3.d();
    			destroy_component(button);
    			if (if_block4) if_block4.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$e.name,
    		type: "if",
    		source: "(48:2) {#if $globalStore.usuario.esAuxiliar}",
    		ctx
    	});

    	return block;
    }

    // (49:3) {#if hilo.estado == 2 }
    function create_if_block_5$2(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "Este roz esta eliminado y pronto sera borrado";
    			set_style(span, "color", "red");
    			add_location(span, file$h, 49, 4, 1641);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5$2.name,
    		type: "if",
    		source: "(49:3) {#if hilo.estado == 2 }",
    		ctx
    	});

    	return block;
    }

    // (54:4) {#if $globalStore.usuario.esMod}
    function create_if_block_4$2(ctx) {
    	let dialogo;
    	let current;

    	dialogo = new Dialogo({
    			props: {
    				textoActivador: "Sticky",
    				titulo: "Configurar Sticky",
    				accion: /*dialogs*/ ctx[3].sticky.accion,
    				$$slots: { body: [create_body_slot_1$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dialogo.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dialogo, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dialogo_changes = {};
    			if (dirty & /*dialogs*/ 8) dialogo_changes.accion = /*dialogs*/ ctx[3].sticky.accion;

    			if (dirty & /*$$scope, dialogs*/ 4194312) {
    				dialogo_changes.$$scope = { dirty, ctx };
    			}

    			dialogo.$set(dialogo_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dialogo.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dialogo.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dialogo, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$2.name,
    		type: "if",
    		source: "(54:4) {#if $globalStore.usuario.esMod}",
    		ctx
    	});

    	return block;
    }

    // (58:7) <Checkbox bind:checked={dialogs.sticky.global}>
    function create_default_slot_6$1(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "Global";
    			add_location(span, file$h, 58, 8, 2070);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_6$1.name,
    		type: "slot",
    		source: "(58:7) <Checkbox bind:checked={dialogs.sticky.global}>",
    		ctx
    	});

    	return block;
    }

    // (56:6) <div slot="body">
    function create_body_slot_1$1(ctx) {
    	let div;
    	let p0;
    	let t1;
    	let checkbox;
    	let updating_checked;
    	let t2;
    	let p1;
    	let t4;
    	let textfield;
    	let updating_value;
    	let current;

    	function checkbox_checked_binding(value) {
    		/*checkbox_checked_binding*/ ctx[9].call(null, value);
    	}

    	let checkbox_props = {
    		$$slots: { default: [create_default_slot_6$1] },
    		$$scope: { ctx }
    	};

    	if (/*dialogs*/ ctx[3].sticky.global !== void 0) {
    		checkbox_props.checked = /*dialogs*/ ctx[3].sticky.global;
    	}

    	checkbox = new Ne({ props: checkbox_props, $$inline: true });
    	binding_callbacks.push(() => bind(checkbox, "checked", checkbox_checked_binding));

    	function textfield_value_binding(value) {
    		/*textfield_value_binding*/ ctx[10].call(null, value);
    	}

    	let textfield_props = {
    		autocomplete: "off",
    		label: "Importancia",
    		type: "number",
    		required: true,
    		message: ""
    	};

    	if (/*dialogs*/ ctx[3].sticky.importancia !== void 0) {
    		textfield_props.value = /*dialogs*/ ctx[3].sticky.importancia;
    	}

    	textfield = new Ve({ props: textfield_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield, "value", textfield_value_binding));

    	const block = {
    		c: function create() {
    			div = element("div");
    			p0 = element("p");
    			p0.textContent = "(Los stickies no globales solo aparecen en su categoria)";
    			t1 = space();
    			create_component(checkbox.$$.fragment);
    			t2 = space();
    			p1 = element("p");
    			p1.textContent = "(Un sticky de importancia 2 sale primero que un sticky de importancia 1 )";
    			t4 = space();
    			create_component(textfield.$$.fragment);
    			add_location(p0, file$h, 56, 7, 1941);
    			add_location(p1, file$h, 60, 7, 2118);
    			attr_dev(div, "slot", "body");
    			add_location(div, file$h, 55, 6, 1915);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, p0);
    			append_dev(div, t1);
    			mount_component(checkbox, div, null);
    			append_dev(div, t2);
    			append_dev(div, p1);
    			append_dev(div, t4);
    			mount_component(textfield, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const checkbox_changes = {};

    			if (dirty & /*$$scope*/ 4194304) {
    				checkbox_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_checked && dirty & /*dialogs*/ 8) {
    				updating_checked = true;
    				checkbox_changes.checked = /*dialogs*/ ctx[3].sticky.global;
    				add_flush_callback(() => updating_checked = false);
    			}

    			checkbox.$set(checkbox_changes);
    			const textfield_changes = {};

    			if (!updating_value && dirty & /*dialogs*/ 8) {
    				updating_value = true;
    				textfield_changes.value = /*dialogs*/ ctx[3].sticky.importancia;
    				add_flush_callback(() => updating_value = false);
    			}

    			textfield.$set(textfield_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(checkbox.$$.fragment, local);
    			transition_in(textfield.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(checkbox.$$.fragment, local);
    			transition_out(textfield.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(checkbox);
    			destroy_component(textfield);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_body_slot_1$1.name,
    		type: "slot",
    		source: "(56:6) <div slot=\\\"body\\\">",
    		ctx
    	});

    	return block;
    }

    // (79:7) {#each config.categorias as c}
    function create_each_block$8(ctx) {
    	let option;
    	let t_value = /*c*/ ctx[19].nombre + "";
    	let t;
    	let option_value_value;

    	const block = {
    		c: function create() {
    			option = element("option");
    			t = text(t_value);
    			option.__value = option_value_value = /*c*/ ctx[19].id;
    			option.value = option.__value;
    			add_location(option, file$h, 79, 7, 2889);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, option, anchor);
    			append_dev(option, t);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(option);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$8.name,
    		type: "each",
    		source: "(79:7) {#each config.categorias as c}",
    		ctx
    	});

    	return block;
    }

    // (75:5) <div slot="body">
    function create_body_slot$3(ctx) {
    	let div;
    	let span;
    	let t0;
    	let select;
    	let option;
    	let mounted;
    	let dispose;
    	let each_value = config.categorias;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$8(get_each_context$8(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			span = element("span");
    			t0 = space();
    			select = element("select");
    			option = element("option");
    			option.textContent = "Categoría";

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(span, "asp-validation-for", "CategoriaId");
    			add_location(span, file$h, 75, 6, 2632);
    			option.__value = "-1";
    			option.value = option.__value;
    			option.selected = "selected";
    			option.disabled = "disabled";
    			add_location(option, file$h, 77, 7, 2764);
    			attr_dev(select, "name", "categoria");
    			if (/*dialogs*/ ctx[3].categoria.categoriaId === void 0) add_render_callback(() => /*select_change_handler*/ ctx[11].call(select));
    			add_location(select, file$h, 76, 6, 2686);
    			attr_dev(div, "slot", "body");
    			add_location(div, file$h, 74, 5, 2607);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, span);
    			append_dev(div, t0);
    			append_dev(div, select);
    			append_dev(select, option);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(select, null);
    			}

    			select_option(select, /*dialogs*/ ctx[3].categoria.categoriaId);

    			if (!mounted) {
    				dispose = listen_dev(select, "change", /*select_change_handler*/ ctx[11]);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*config*/ 0) {
    				each_value = config.categorias;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$8(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$8(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(select, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty & /*dialogs, config*/ 8) {
    				select_option(select, /*dialogs*/ ctx[3].categoria.categoriaId);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_each(each_blocks, detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_body_slot$3.name,
    		type: "slot",
    		source: "(75:5) <div slot=\\\"body\\\">",
    		ctx
    	});

    	return block;
    }

    // (86:4) {#if hilo.estado != HiloEstado.eliminado}
    function create_if_block_3$3(ctx) {
    	let button;
    	let current;

    	button = new ye({
    			props: {
    				$$slots: { default: [create_default_slot_3$9] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button.$on("click", /*click_handler*/ ctx[13]);

    	const block = {
    		c: function create() {
    			create_component(button.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(button, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button_changes = {};

    			if (dirty & /*$$scope*/ 4194304) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(button, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$3.name,
    		type: "if",
    		source: "(86:4) {#if hilo.estado != HiloEstado.eliminado}",
    		ctx
    	});

    	return block;
    }

    // (87:5) <Button on:click={() => abrir.eliminarHilo(hilo.id)} >
    function create_default_slot_3$9(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Eliminar");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$9.name,
    		type: "slot",
    		source: "(87:5) <Button on:click={() => abrir.eliminarHilo(hilo.id)} >",
    		ctx
    	});

    	return block;
    }

    // (89:4) {#if hilo.estado == HiloEstado.eliminado}
    function create_if_block_2$7(ctx) {
    	let button;
    	let current;

    	button = new ye({
    			props: {
    				$$slots: { default: [create_default_slot_2$9] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button.$on("click", /*click_handler_1*/ ctx[14]);

    	const block = {
    		c: function create() {
    			create_component(button.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(button, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button_changes = {};

    			if (dirty & /*$$scope*/ 4194304) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(button, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$7.name,
    		type: "if",
    		source: "(89:4) {#if hilo.estado == HiloEstado.eliminado}",
    		ctx
    	});

    	return block;
    }

    // (90:5) <Button on:click={() => abrir.restaurarHilo(hilo.id)} >
    function create_default_slot_2$9(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Restaurar");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$9.name,
    		type: "slot",
    		source: "(90:5) <Button on:click={() => abrir.restaurarHilo(hilo.id)} >",
    		ctx
    	});

    	return block;
    }

    // (92:4) <Button on:click={() => abrir.ban(hilo.id)}>
    function create_default_slot_1$a(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Banear");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$a.name,
    		type: "slot",
    		source: "(92:4) <Button on:click={() => abrir.ban(hilo.id)}>",
    		ctx
    	});

    	return block;
    }

    // (93:4) {#if $globalStore.usuario.esMod}
    function create_if_block_1$9(ctx) {
    	let a;
    	let button;
    	let a_href_value;
    	let current;

    	button = new ye({
    			props: {
    				$$slots: { default: [create_default_slot$b] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			a = element("a");
    			create_component(button.$$.fragment);
    			attr_dev(a, "href", a_href_value = "/Moderacion/HistorialDeUsuario/" + /*usuario*/ ctx[5].id);
    			attr_dev(a, "class", "svelte-13515v3");
    			add_location(a, file$h, 93, 4, 3384);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);
    			mount_component(button, a, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button_changes = {};

    			if (dirty & /*$$scope*/ 4194304) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    			destroy_component(button);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$9.name,
    		type: "if",
    		source: "(93:4) {#if $globalStore.usuario.esMod}",
    		ctx
    	});

    	return block;
    }

    // (95:5) <Button>
    function create_default_slot$b(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Op");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$b.name,
    		type: "slot",
    		source: "(95:5) <Button>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$h(ctx) {
    	let div2;
    	let div1;
    	let div0;
    	let a0;
    	let t1;
    	let a1;
    	let t2;
    	let t3_value = config.categoriaPorId(/*hilo*/ ctx[0].categoriaId).nombre + "";
    	let t3;
    	let a1_href_value;
    	let t4;
    	let acciones_1;
    	let updating_hilo;
    	let updating_acciones;
    	let t5;
    	let t6;
    	let t7;
    	let hilocuerpo;
    	let t8;
    	let comentarios_1;
    	let updating_comentarios;
    	let div2_r_id_value;
    	let current;

    	function acciones_1_hilo_binding(value) {
    		/*acciones_1_hilo_binding*/ ctx[6].call(null, value);
    	}

    	function acciones_1_acciones_binding(value) {
    		/*acciones_1_acciones_binding*/ ctx[7].call(null, value);
    	}

    	let acciones_1_props = {};

    	if (/*hilo*/ ctx[0] !== void 0) {
    		acciones_1_props.hilo = /*hilo*/ ctx[0];
    	}

    	if (/*acciones*/ ctx[2] !== void 0) {
    		acciones_1_props.acciones = /*acciones*/ ctx[2];
    	}

    	acciones_1 = new Acciones({ props: acciones_1_props, $$inline: true });
    	binding_callbacks.push(() => bind(acciones_1, "hilo", acciones_1_hilo_binding));
    	binding_callbacks.push(() => bind(acciones_1, "acciones", acciones_1_acciones_binding));
    	let if_block0 = /*hilo*/ ctx[0].encuestaData && create_if_block_6$2(ctx);
    	let if_block1 = /*$globalStore*/ ctx[4].usuario.esAuxiliar && create_if_block$e(ctx);

    	hilocuerpo = new HiloCuerpo({
    			props: { hilo: /*hilo*/ ctx[0] },
    			$$inline: true
    		});

    	function comentarios_1_comentarios_binding(value) {
    		/*comentarios_1_comentarios_binding*/ ctx[16].call(null, value);
    	}

    	let comentarios_1_props = { hilo: /*hilo*/ ctx[0] };

    	if (/*comentarios*/ ctx[1] !== void 0) {
    		comentarios_1_props.comentarios = /*comentarios*/ ctx[1];
    	}

    	comentarios_1 = new Comentarios({
    			props: comentarios_1_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(comentarios_1, "comentarios", comentarios_1_comentarios_binding));

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div1 = element("div");
    			div0 = element("div");
    			a0 = element("a");
    			a0.textContent = "Rozed";
    			t1 = space();
    			a1 = element("a");
    			t2 = text("/");
    			t3 = text(t3_value);
    			t4 = space();
    			create_component(acciones_1.$$.fragment);
    			t5 = space();
    			if (if_block0) if_block0.c();
    			t6 = space();
    			if (if_block1) if_block1.c();
    			t7 = space();
    			create_component(hilocuerpo.$$.fragment);
    			t8 = space();
    			create_component(comentarios_1.$$.fragment);
    			attr_dev(a0, "href", "/");
    			attr_dev(a0, "class", "svelte-13515v3");
    			add_location(a0, file$h, 38, 3, 1254);
    			attr_dev(a1, "href", a1_href_value = "/" + config.categoriaPorId(/*hilo*/ ctx[0].categoriaId).nombreCorto);
    			attr_dev(a1, "class", "svelte-13515v3");
    			add_location(a1, file$h, 39, 3, 1280);
    			attr_dev(div0, "class", "panel");
    			add_location(div0, file$h, 37, 2, 1230);
    			attr_dev(div1, "class", "contenido");
    			add_location(div1, file$h, 36, 1, 1203);
    			attr_dev(div2, "class", "hilo-completo svelte-13515v3");
    			attr_dev(div2, "r-id", div2_r_id_value = /*hilo*/ ctx[0].id);
    			add_location(div2, file$h, 35, 0, 1158);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div1);
    			append_dev(div1, div0);
    			append_dev(div0, a0);
    			append_dev(div0, t1);
    			append_dev(div0, a1);
    			append_dev(a1, t2);
    			append_dev(a1, t3);
    			append_dev(div1, t4);
    			mount_component(acciones_1, div1, null);
    			append_dev(div1, t5);
    			if (if_block0) if_block0.m(div1, null);
    			append_dev(div1, t6);
    			if (if_block1) if_block1.m(div1, null);
    			append_dev(div1, t7);
    			mount_component(hilocuerpo, div1, null);
    			append_dev(div2, t8);
    			mount_component(comentarios_1, div2, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if ((!current || dirty & /*hilo*/ 1) && t3_value !== (t3_value = config.categoriaPorId(/*hilo*/ ctx[0].categoriaId).nombre + "")) set_data_dev(t3, t3_value);

    			if (!current || dirty & /*hilo*/ 1 && a1_href_value !== (a1_href_value = "/" + config.categoriaPorId(/*hilo*/ ctx[0].categoriaId).nombreCorto)) {
    				attr_dev(a1, "href", a1_href_value);
    			}

    			const acciones_1_changes = {};

    			if (!updating_hilo && dirty & /*hilo*/ 1) {
    				updating_hilo = true;
    				acciones_1_changes.hilo = /*hilo*/ ctx[0];
    				add_flush_callback(() => updating_hilo = false);
    			}

    			if (!updating_acciones && dirty & /*acciones*/ 4) {
    				updating_acciones = true;
    				acciones_1_changes.acciones = /*acciones*/ ctx[2];
    				add_flush_callback(() => updating_acciones = false);
    			}

    			acciones_1.$set(acciones_1_changes);

    			if (/*hilo*/ ctx[0].encuestaData) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty & /*hilo*/ 1) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_6$2(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(div1, t6);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (/*$globalStore*/ ctx[4].usuario.esAuxiliar) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty & /*$globalStore*/ 16) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block$e(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div1, t7);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			const hilocuerpo_changes = {};
    			if (dirty & /*hilo*/ 1) hilocuerpo_changes.hilo = /*hilo*/ ctx[0];
    			hilocuerpo.$set(hilocuerpo_changes);
    			const comentarios_1_changes = {};
    			if (dirty & /*hilo*/ 1) comentarios_1_changes.hilo = /*hilo*/ ctx[0];

    			if (!updating_comentarios && dirty & /*comentarios*/ 2) {
    				updating_comentarios = true;
    				comentarios_1_changes.comentarios = /*comentarios*/ ctx[1];
    				add_flush_callback(() => updating_comentarios = false);
    			}

    			comentarios_1.$set(comentarios_1_changes);

    			if (!current || dirty & /*hilo*/ 1 && div2_r_id_value !== (div2_r_id_value = /*hilo*/ ctx[0].id)) {
    				attr_dev(div2, "r-id", div2_r_id_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(acciones_1.$$.fragment, local);
    			transition_in(if_block0);
    			transition_in(if_block1);
    			transition_in(hilocuerpo.$$.fragment, local);
    			transition_in(comentarios_1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(acciones_1.$$.fragment, local);
    			transition_out(if_block0);
    			transition_out(if_block1);
    			transition_out(hilocuerpo.$$.fragment, local);
    			transition_out(comentarios_1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			destroy_component(acciones_1);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			destroy_component(hilocuerpo);
    			destroy_component(comentarios_1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$h.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$h($$self, $$props, $$invalidate) {
    	let $globalStore;
    	validate_store(globalStore, "globalStore");
    	component_subscribe($$self, globalStore, $$value => $$invalidate(4, $globalStore = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("App", slots, []);
    	let data = window.data || dataEjemplo;
    	let { hilo, comentarios, acciones, usuario } = data;

    	let dialogs = {
    		sticky: {
    			global: true,
    			importancia: 1,
    			async accion() {
    				return await RChanClient.añadirSticky(hilo.id, dialogs.sticky.global, dialogs.sticky.importancia);
    			}
    		},
    		categoria: { categoriaId: hilo.categoriaId }
    	};

    	let selected = true;
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<App> was created with unknown prop '${key}'`);
    	});

    	function acciones_1_hilo_binding(value) {
    		hilo = value;
    		$$invalidate(0, hilo);
    	}

    	function acciones_1_acciones_binding(value) {
    		acciones = value;
    		$$invalidate(2, acciones);
    	}

    	function encuesta_encuesta_binding(value) {
    		hilo.encuestaData = value;
    		$$invalidate(0, hilo);
    	}

    	function checkbox_checked_binding(value) {
    		dialogs.sticky.global = value;
    		$$invalidate(3, dialogs);
    	}

    	function textfield_value_binding(value) {
    		dialogs.sticky.importancia = value;
    		$$invalidate(3, dialogs);
    	}

    	function select_change_handler() {
    		dialogs.categoria.categoriaId = select_value(this);
    		$$invalidate(3, dialogs);
    	}

    	const func = () => RChanClient.cambiarCategoria(hilo.id, dialogs.categoria.categoriaId);
    	const click_handler = () => abrir.eliminarHilo(hilo.id);
    	const click_handler_1 = () => abrir.restaurarHilo(hilo.id);
    	const click_handler_2 = () => abrir.ban(hilo.id);

    	function comentarios_1_comentarios_binding(value) {
    		comentarios = value;
    		$$invalidate(1, comentarios);
    	}

    	$$self.$capture_state = () => ({
    		Comentarios,
    		Acciones,
    		Tiempo,
    		Button: ye,
    		Dialog: pn,
    		Checkbox: Ne,
    		Textfield: Ve,
    		config,
    		RChanClient,
    		ErrorValidacion,
    		globalStore,
    		Dialogo,
    		Media,
    		HiloCuerpo,
    		abrir,
    		Encuesta,
    		HiloEstado,
    		data,
    		hilo,
    		comentarios,
    		acciones,
    		usuario,
    		dialogs,
    		selected,
    		$globalStore
    	});

    	$$self.$inject_state = $$props => {
    		if ("data" in $$props) data = $$props.data;
    		if ("hilo" in $$props) $$invalidate(0, hilo = $$props.hilo);
    		if ("comentarios" in $$props) $$invalidate(1, comentarios = $$props.comentarios);
    		if ("acciones" in $$props) $$invalidate(2, acciones = $$props.acciones);
    		if ("usuario" in $$props) $$invalidate(5, usuario = $$props.usuario);
    		if ("dialogs" in $$props) $$invalidate(3, dialogs = $$props.dialogs);
    		if ("selected" in $$props) selected = $$props.selected;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		hilo,
    		comentarios,
    		acciones,
    		dialogs,
    		$globalStore,
    		usuario,
    		acciones_1_hilo_binding,
    		acciones_1_acciones_binding,
    		encuesta_encuesta_binding,
    		checkbox_checked_binding,
    		textfield_value_binding,
    		select_change_handler,
    		func,
    		click_handler,
    		click_handler_1,
    		click_handler_2,
    		comentarios_1_comentarios_binding
    	];
    }

    class App extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$h, create_fragment$h, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "App",
    			options,
    			id: create_fragment$h.name
    		});
    	}
    }

    /* src\components\Captcha.svelte generated by Svelte v3.29.0 */
    const file$i = "src\\components\\Captcha.svelte";

    // (27:0) {#if visible}
    function create_if_block$f(ctx) {
    	let div;
    	let div_data_sitekey_value;

    	const block = {
    		c: function create() {
    			div = element("div");
    			attr_dev(div, "class", "h-captcha svelte-f95t63");
    			attr_dev(div, "id", "super-captcha");
    			set_style(div, "display", "flex");
    			attr_dev(div, "data-callback", "onCaptcha");
    			attr_dev(div, "data-theme", "dark");
    			attr_dev(div, "data-sitekey", div_data_sitekey_value = window.config.hCaptchaSiteKey);
    			add_location(div, file$i, 27, 4, 650);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$f.name,
    		type: "if",
    		source: "(27:0) {#if visible}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$i(ctx) {
    	let if_block_anchor;
    	let if_block = /*visible*/ ctx[0] && create_if_block$f(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*visible*/ ctx[0]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block$f(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$i.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function cargarCaptcha() {
    	window.hcaptcha.render("super-captcha", {
    		"theme": "dark",
    		"sitekey": window.config.hCaptchaSiteKey
    	});
    }

    function instance$i($$self, $$props, $$invalidate) {
    	let $globalStore;
    	validate_store(globalStore, "globalStore");
    	component_subscribe($$self, globalStore, $$value => $$invalidate(2, $globalStore = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Captcha", slots, []);
    	let { token } = $$props;
    	let { visible = true } = $$props;
    	if ($globalStore.usuario.estaAutenticado && $globalStore.usuario.esMod) visible = false;

    	onMount(() => {
    		if (window.hcaptcha) cargarCaptcha(); else setTimeout(cargarCaptcha, 500);
    	});

    	window.onCaptcha = e => {
    		$$invalidate(1, token = e);
    	};

    	const writable_props = ["token", "visible"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Captcha> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("token" in $$props) $$invalidate(1, token = $$props.token);
    		if ("visible" in $$props) $$invalidate(0, visible = $$props.visible);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		globalStore,
    		token,
    		visible,
    		cargarCaptcha,
    		$globalStore
    	});

    	$$self.$inject_state = $$props => {
    		if ("token" in $$props) $$invalidate(1, token = $$props.token);
    		if ("visible" in $$props) $$invalidate(0, visible = $$props.visible);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [visible, token];
    }

    class Captcha extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$i, create_fragment$i, safe_not_equal, { token: 1, visible: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Captcha",
    			options,
    			id: create_fragment$i.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*token*/ ctx[1] === undefined && !("token" in props)) {
    			console.warn("<Captcha> was created without expected prop 'token'");
    		}
    	}

    	get token() {
    		throw new Error("<Captcha>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set token(value) {
    		throw new Error("<Captcha>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get visible() {
    		throw new Error("<Captcha>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set visible(value) {
    		throw new Error("<Captcha>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\components\Hilos\FormularioEncuesta.svelte generated by Svelte v3.29.0 */

    const { console: console_1$3 } = globals;
    const file$j = "src\\components\\Hilos\\FormularioEncuesta.svelte";

    function get_each_context$9(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[12] = list[i];
    	return child_ctx;
    }

    // (43:4) {#if estado == 0  || estado == 1}
    function create_if_block_5$3(ctx) {
    	let button;
    	let current;

    	button = new ye({
    			props: {
    				$$slots: { default: [create_default_slot_5$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button.$on("click", /*click_handler*/ ctx[8]);

    	const block = {
    		c: function create() {
    			create_component(button.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(button, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button_changes = {};

    			if (dirty & /*$$scope*/ 32768) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(button, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5$3.name,
    		type: "if",
    		source: "(43:4) {#if estado == 0  || estado == 1}",
    		ctx
    	});

    	return block;
    }

    // (44:8) <Button on:click={() => estado = 1}>
    function create_default_slot_5$2(ctx) {
    	let icon;

    	const block = {
    		c: function create() {
    			icon = element("icon");
    			attr_dev(icon, "class", "fe fe-bar-chart-2");
    			set_style(icon, "font-size", "1.2rem");
    			add_location(icon, file$j, 43, 44, 1181);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, icon, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(icon);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5$2.name,
    		type: "slot",
    		source: "(44:8) <Button on:click={() => estado = 1}>",
    		ctx
    	});

    	return block;
    }

    // (46:4) {#if estado == 2}
    function create_if_block_4$3(ctx) {
    	let button;
    	let current;

    	button = new ye({
    			props: {
    				color: "var(--color5)",
    				$$slots: { default: [create_default_slot_4$5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button.$on("click", /*cancelar*/ ctx[6]);

    	const block = {
    		c: function create() {
    			create_component(button.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(button, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button_changes = {};

    			if (dirty & /*$$scope*/ 32768) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(button, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$3.name,
    		type: "if",
    		source: "(46:4) {#if estado == 2}",
    		ctx
    	});

    	return block;
    }

    // (47:8) <Button color="var(--color5)" on:click={cancelar}>
    function create_default_slot_4$5(ctx) {
    	let icon;

    	const block = {
    		c: function create() {
    			icon = element("icon");
    			attr_dev(icon, "class", "fe fe-bar-chart-2");
    			set_style(icon, "font-size", "1.2rem");
    			add_location(icon, file$j, 46, 58, 1350);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, icon, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(icon);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$5.name,
    		type: "slot",
    		source: "(47:8) <Button color=\\\"var(--color5)\\\" on:click={cancelar}>",
    		ctx
    	});

    	return block;
    }

    // (51:0) {#if estado == 1}
    function create_if_block$g(ctx) {
    	let dialog;
    	let current;

    	dialog = new pn({
    			props: {
    				visible: true,
    				$$slots: {
    					default: [create_default_slot$c],
    					title: [create_title_slot$2]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(dialog.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dialog, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const dialog_changes = {};

    			if (dirty & /*$$scope, opciones, opcionNueva, opcionesArray*/ 32781) {
    				dialog_changes.$$scope = { dirty, ctx };
    			}

    			dialog.$set(dialog_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dialog.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dialog.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dialog, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$g.name,
    		type: "if",
    		source: "(51:0) {#if estado == 1}",
    		ctx
    	});

    	return block;
    }

    // (53:8) <div slot="title">
    function create_title_slot$2(ctx) {
    	let div;
    	let t0;
    	let t1_value = /*opciones*/ ctx[0].size + "";
    	let t1;
    	let t2;
    	let t3;
    	let t4;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = text("Opciones (");
    			t1 = text(t1_value);
    			t2 = text("/");
    			t3 = text(limiteOpciones);
    			t4 = text(")");
    			attr_dev(div, "slot", "title");
    			add_location(div, file$j, 52, 8, 1505);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, t0);
    			append_dev(div, t1);
    			append_dev(div, t2);
    			append_dev(div, t3);
    			append_dev(div, t4);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*opciones*/ 1 && t1_value !== (t1_value = /*opciones*/ ctx[0].size + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_title_slot$2.name,
    		type: "slot",
    		source: "(53:8) <div slot=\\\"title\\\">",
    		ctx
    	});

    	return block;
    }

    // (55:12) {#each opcionesArray as o}
    function create_each_block$9(ctx) {
    	let li;
    	let t0_value = /*o*/ ctx[12] + "";
    	let t0;
    	let t1;
    	let ripple;
    	let current;
    	let mounted;
    	let dispose;
    	ripple = new he({ $$inline: true });

    	function click_handler_1(...args) {
    		return /*click_handler_1*/ ctx[9](/*o*/ ctx[12], ...args);
    	}

    	const block = {
    		c: function create() {
    			li = element("li");
    			t0 = text(t0_value);
    			t1 = space();
    			create_component(ripple.$$.fragment);
    			attr_dev(li, "class", "svelte-1ftt6i3");
    			add_location(li, file$j, 55, 16, 1644);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			append_dev(li, t0);
    			append_dev(li, t1);
    			mount_component(ripple, li, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(li, "click", click_handler_1, false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if ((!current || dirty & /*opcionesArray*/ 4) && t0_value !== (t0_value = /*o*/ ctx[12] + "")) set_data_dev(t0, t0_value);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(ripple.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(ripple.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			destroy_component(ripple);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$9.name,
    		type: "each",
    		source: "(55:12) {#each opcionesArray as o}",
    		ctx
    	});

    	return block;
    }

    // (59:8) {#if opciones.size < 6}
    function create_if_block_3$4(ctx) {
    	let input;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			input = element("input");
    			attr_dev(input, "type", "text");
    			attr_dev(input, "placeholder", "Añadir opcion");
    			add_location(input, file$j, 59, 12, 1777);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, input, anchor);
    			set_input_value(input, /*opcionNueva*/ ctx[3]);

    			if (!mounted) {
    				dispose = listen_dev(input, "input", /*input_input_handler*/ ctx[10]);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*opcionNueva*/ 8 && input.value !== /*opcionNueva*/ ctx[3]) {
    				set_input_value(input, /*opcionNueva*/ ctx[3]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(input);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$4.name,
    		type: "if",
    		source: "(59:8) {#if opciones.size < 6}",
    		ctx
    	});

    	return block;
    }

    // (65:12) {:else}
    function create_else_block$3(ctx) {
    	let button;
    	let current;

    	button = new ye({
    			props: {
    				color: "primary",
    				$$slots: { default: [create_default_slot_3$a] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button.$on("click", /*cancelar*/ ctx[6]);

    	const block = {
    		c: function create() {
    			create_component(button.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(button, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button_changes = {};

    			if (dirty & /*$$scope*/ 32768) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(button, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$3.name,
    		type: "else",
    		source: "(65:12) {:else}",
    		ctx
    	});

    	return block;
    }

    // (63:12) {#if opciones.size > 1}
    function create_if_block_2$8(ctx) {
    	let button;
    	let current;

    	button = new ye({
    			props: {
    				color: "primary",
    				$$slots: { default: [create_default_slot_2$a] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button.$on("click", /*aceptar*/ ctx[7]);

    	const block = {
    		c: function create() {
    			create_component(button.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(button, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button_changes = {};

    			if (dirty & /*$$scope*/ 32768) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(button, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$8.name,
    		type: "if",
    		source: "(63:12) {#if opciones.size > 1}",
    		ctx
    	});

    	return block;
    }

    // (66:16) <Button color="primary" on:click={cancelar}>
    function create_default_slot_3$a(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Cancelar");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$a.name,
    		type: "slot",
    		source: "(66:16) <Button color=\\\"primary\\\" on:click={cancelar}>",
    		ctx
    	});

    	return block;
    }

    // (64:16) <Button on:click={aceptar} color="primary">
    function create_default_slot_2$a(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Aceptar");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$a.name,
    		type: "slot",
    		source: "(64:16) <Button on:click={aceptar} color=\\\"primary\\\">",
    		ctx
    	});

    	return block;
    }

    // (68:12) {#if opciones.size < 6}
    function create_if_block_1$a(ctx) {
    	let button;
    	let current;

    	button = new ye({
    			props: {
    				color: "primary",
    				$$slots: { default: [create_default_slot_1$b] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button.$on("click", /*agregarOpcion*/ ctx[4]);

    	const block = {
    		c: function create() {
    			create_component(button.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(button, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button_changes = {};

    			if (dirty & /*$$scope*/ 32768) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(button, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$a.name,
    		type: "if",
    		source: "(68:12) {#if opciones.size < 6}",
    		ctx
    	});

    	return block;
    }

    // (69:16) <Button color="primary" on:click={agregarOpcion}>
    function create_default_slot_1$b(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Añadir");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$b.name,
    		type: "slot",
    		source: "(69:16) <Button color=\\\"primary\\\" on:click={agregarOpcion}>",
    		ctx
    	});

    	return block;
    }

    // (52:4) <Dialog visible={true}>
    function create_default_slot$c(ctx) {
    	let t0;
    	let ul;
    	let t1;
    	let t2;
    	let div;
    	let current_block_type_index;
    	let if_block1;
    	let t3;
    	let current;
    	let each_value = /*opcionesArray*/ ctx[2];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$9(get_each_context$9(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	let if_block0 = /*opciones*/ ctx[0].size < 6 && create_if_block_3$4(ctx);
    	const if_block_creators = [create_if_block_2$8, create_else_block$3];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*opciones*/ ctx[0].size > 1) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	let if_block2 = /*opciones*/ ctx[0].size < 6 && create_if_block_1$a(ctx);

    	const block = {
    		c: function create() {
    			t0 = space();
    			ul = element("ul");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t1 = space();
    			if (if_block0) if_block0.c();
    			t2 = space();
    			div = element("div");
    			if_block1.c();
    			t3 = space();
    			if (if_block2) if_block2.c();
    			add_location(ul, file$j, 53, 8, 1582);
    			set_style(div, "margin-top", "8px");
    			add_location(div, file$j, 61, 8, 1874);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, ul, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(ul, null);
    			}

    			insert_dev(target, t1, anchor);
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, div, anchor);
    			if_blocks[current_block_type_index].m(div, null);
    			append_dev(div, t3);
    			if (if_block2) if_block2.m(div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*remover, opcionesArray*/ 36) {
    				each_value = /*opcionesArray*/ ctx[2];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$9(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$9(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(ul, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}

    			if (/*opciones*/ ctx[0].size < 6) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_3$4(ctx);
    					if_block0.c();
    					if_block0.m(t2.parentNode, t2);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block1 = if_blocks[current_block_type_index];

    				if (!if_block1) {
    					if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block1.c();
    				}

    				transition_in(if_block1, 1);
    				if_block1.m(div, t3);
    			}

    			if (/*opciones*/ ctx[0].size < 6) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);

    					if (dirty & /*opciones*/ 1) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block_1$a(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(div, null);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			transition_in(if_block1);
    			transition_in(if_block2);
    			current = true;
    		},
    		o: function outro(local) {
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			transition_out(if_block1);
    			transition_out(if_block2);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(ul);
    			destroy_each(each_blocks, detaching);
    			if (detaching) detach_dev(t1);
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(div);
    			if_blocks[current_block_type_index].d();
    			if (if_block2) if_block2.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$c.name,
    		type: "slot",
    		source: "(52:4) <Dialog visible={true}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$j(ctx) {
    	let span;
    	let t0;
    	let t1;
    	let if_block2_anchor;
    	let current;
    	let if_block0 = (/*estado*/ ctx[1] == 0 || /*estado*/ ctx[1] == 1) && create_if_block_5$3(ctx);
    	let if_block1 = /*estado*/ ctx[1] == 2 && create_if_block_4$3(ctx);
    	let if_block2 = /*estado*/ ctx[1] == 1 && create_if_block$g(ctx);

    	const block = {
    		c: function create() {
    			span = element("span");
    			if (if_block0) if_block0.c();
    			t0 = space();
    			if (if_block1) if_block1.c();
    			t1 = space();
    			if (if_block2) if_block2.c();
    			if_block2_anchor = empty();
    			set_style(span, "margin", "4px 0");
    			set_style(span, "display", "flex");
    			set_style(span, "justify-content", "center");
    			add_location(span, file$j, 40, 0, 1028);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			if (if_block0) if_block0.m(span, null);
    			append_dev(span, t0);
    			if (if_block1) if_block1.m(span, null);
    			insert_dev(target, t1, anchor);
    			if (if_block2) if_block2.m(target, anchor);
    			insert_dev(target, if_block2_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*estado*/ ctx[1] == 0 || /*estado*/ ctx[1] == 1) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty & /*estado*/ 2) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_5$3(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(span, t0);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (/*estado*/ ctx[1] == 2) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty & /*estado*/ 2) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_4$3(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(span, null);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (/*estado*/ ctx[1] == 1) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);

    					if (dirty & /*estado*/ 2) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block$g(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block1);
    			transition_in(if_block2);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block1);
    			transition_out(if_block2);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (detaching) detach_dev(t1);
    			if (if_block2) if_block2.d(detaching);
    			if (detaching) detach_dev(if_block2_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$j.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const limiteOpciones = 6;

    function instance$j($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("FormularioEncuesta", slots, []);
    	let visible = true;
    	let estado = 0; // 0 sin encuesta, 1 agregando encuesnta 2 encuesta agregada
    	let { opciones = new Set([]) } = $$props;
    	let opcionesArray = [];
    	let opcionNueva = "";

    	function agregarOpcion() {
    		if (opciones.size >= 6) return;
    		opciones.add(opcionNueva);
    		$$invalidate(0, opciones);
    		$$invalidate(3, opcionNueva = "");
    		$$invalidate(2, opcionesArray = [...opciones]);
    	}

    	function remover(opcion) {
    		opciones.delete(opcion);
    		$$invalidate(0, opciones);
    		$$invalidate(2, opcionesArray = [...opciones]);
    	}

    	function cancelar() {
    		$$invalidate(0, opciones = new Set());
    		$$invalidate(1, estado = 0);
    		$$invalidate(2, opcionesArray = [...opciones]);
    	}

    	function aceptar() {
    		$$invalidate(1, estado = 2);
    		$$invalidate(0, opciones);
    		$$invalidate(2, opcionesArray = [...opciones]);
    		console.log(opcionesArray);
    	}

    	const writable_props = ["opciones"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$3.warn(`<FormularioEncuesta> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => $$invalidate(1, estado = 1);
    	const click_handler_1 = o => remover(o);

    	function input_input_handler() {
    		opcionNueva = this.value;
    		$$invalidate(3, opcionNueva);
    	}

    	$$self.$$set = $$props => {
    		if ("opciones" in $$props) $$invalidate(0, opciones = $$props.opciones);
    	};

    	$$self.$capture_state = () => ({
    		Checkbox: Ne,
    		Dialog: pn,
    		Button: ye,
    		Ripple: he,
    		visible,
    		estado,
    		limiteOpciones,
    		opciones,
    		opcionesArray,
    		opcionNueva,
    		agregarOpcion,
    		remover,
    		cancelar,
    		aceptar
    	});

    	$$self.$inject_state = $$props => {
    		if ("visible" in $$props) visible = $$props.visible;
    		if ("estado" in $$props) $$invalidate(1, estado = $$props.estado);
    		if ("opciones" in $$props) $$invalidate(0, opciones = $$props.opciones);
    		if ("opcionesArray" in $$props) $$invalidate(2, opcionesArray = $$props.opcionesArray);
    		if ("opcionNueva" in $$props) $$invalidate(3, opcionNueva = $$props.opcionNueva);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		opciones,
    		estado,
    		opcionesArray,
    		opcionNueva,
    		agregarOpcion,
    		remover,
    		cancelar,
    		aceptar,
    		click_handler,
    		click_handler_1,
    		input_input_handler
    	];
    }

    class FormularioEncuesta extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$j, create_fragment$j, safe_not_equal, { opciones: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "FormularioEncuesta",
    			options,
    			id: create_fragment$j.name
    		});
    	}

    	get opciones() {
    		throw new Error("<FormularioEncuesta>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set opciones(value) {
    		throw new Error("<FormularioEncuesta>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\components\Hilos\FormularioHilo.svelte generated by Svelte v3.29.0 */

    const { console: console_1$4 } = globals;
    const file$k = "src\\components\\Hilos\\FormularioHilo.svelte";

    function get_each_context$a(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[30] = list[i];
    	return child_ctx;
    }

    // (83:0) {#if mostrar}
    function create_if_block$h(ctx) {
    	let div1;
    	let form;
    	let mediainput;
    	let updating_media;
    	let t0;
    	let input0;
    	let t1;
    	let select;
    	let option;
    	let t3;
    	let formularioencuesta;
    	let updating_opciones;
    	let t4;
    	let textarea;
    	let t5;
    	let t6;
    	let errorvalidacion;
    	let t7;
    	let t8;
    	let captcha_1;
    	let updating_token;
    	let t9;
    	let div0;
    	let button0;
    	let t10;
    	let button1;
    	let t11;
    	let input1;
    	let div1_transition;
    	let current;
    	let mounted;
    	let dispose;

    	function mediainput_media_binding(value) {
    		/*mediainput_media_binding*/ ctx[17].call(null, value);
    	}

    	let mediainput_props = {};

    	if (/*media*/ ctx[4] !== void 0) {
    		mediainput_props.media = /*media*/ ctx[4];
    	}

    	mediainput = new MediaInput({ props: mediainput_props, $$inline: true });
    	binding_callbacks.push(() => bind(mediainput, "media", mediainput_media_binding));
    	let each_value = config.categorias;
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$a(get_each_context$a(ctx, each_value, i));
    	}

    	function formularioencuesta_opciones_binding(value) {
    		/*formularioencuesta_opciones_binding*/ ctx[20].call(null, value);
    	}

    	let formularioencuesta_props = {};

    	if (/*encuesta*/ ctx[6] !== void 0) {
    		formularioencuesta_props.opciones = /*encuesta*/ ctx[6];
    	}

    	formularioencuesta = new FormularioEncuesta({
    			props: formularioencuesta_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(formularioencuesta, "opciones", formularioencuesta_opciones_binding));
    	let if_block0 = /*escribiendoRedactazo*/ ctx[11] && create_if_block_2$9(ctx);

    	errorvalidacion = new ErrorValidacion({
    			props: { error: /*error*/ ctx[10] },
    			$$inline: true
    		});

    	let if_block1 = /*$globalStore*/ ctx[13].usuario.esMod && create_if_block_1$b(ctx);

    	function captcha_1_token_binding(value) {
    		/*captcha_1_token_binding*/ ctx[27].call(null, value);
    	}

    	let captcha_1_props = { visible: config.general.captchaHilo };

    	if (/*captcha*/ ctx[5] !== void 0) {
    		captcha_1_props.token = /*captcha*/ ctx[5];
    	}

    	captcha_1 = new Captcha({ props: captcha_1_props, $$inline: true });
    	binding_callbacks.push(() => bind(captcha_1, "token", captcha_1_token_binding));

    	button0 = new ye({
    			props: {
    				color: "primary",
    				$$slots: { default: [create_default_slot_2$b] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button0.$on("click", /*click_handler*/ ctx[28]);

    	button1 = new ye({
    			props: {
    				color: "primary",
    				disabled: /*cargando*/ ctx[9],
    				$$slots: { default: [create_default_slot$d] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button1.$on("click", /*crear*/ ctx[14]);

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			form = element("form");
    			create_component(mediainput.$$.fragment);
    			t0 = space();
    			input0 = element("input");
    			t1 = space();
    			select = element("select");
    			option = element("option");
    			option.textContent = "Categoría";

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t3 = space();
    			create_component(formularioencuesta.$$.fragment);
    			t4 = space();
    			textarea = element("textarea");
    			t5 = space();
    			if (if_block0) if_block0.c();
    			t6 = space();
    			create_component(errorvalidacion.$$.fragment);
    			t7 = space();
    			if (if_block1) if_block1.c();
    			t8 = space();
    			create_component(captcha_1.$$.fragment);
    			t9 = space();
    			div0 = element("div");
    			create_component(button0.$$.fragment);
    			t10 = space();
    			create_component(button1.$$.fragment);
    			t11 = space();
    			input1 = element("input");
    			attr_dev(input0, "name", "titulo");
    			attr_dev(input0, "placeholder", "Titulo");
    			add_location(input0, file$k, 92, 8, 2516);
    			option.__value = "-1";
    			option.value = option.__value;
    			option.selected = "selected";
    			option.disabled = "disabled";
    			add_location(option, file$k, 95, 12, 2653);
    			attr_dev(select, "name", "categoria");
    			if (/*categoria*/ ctx[2] === void 0) add_render_callback(() => /*select_change_handler*/ ctx[19].call(select));
    			add_location(select, file$k, 94, 8, 2590);
    			attr_dev(textarea, "rows", "15");
    			set_style(textarea, "background", "var(--color4)");
    			attr_dev(textarea, "name", "contenido");
    			attr_dev(textarea, "placeholder", "Escribi un redactazo...");
    			add_location(textarea, file$k, 103, 8, 2944);
    			attr_dev(input1, "type", "submit");
    			set_style(input1, "display", "none");
    			add_location(input1, file$k, 142, 12, 4746);
    			set_style(div0, "display", "flex");
    			set_style(div0, "justify-content", "flex-end");
    			add_location(div0, file$k, 135, 8, 4374);
    			attr_dev(form, "id", "crear-hilo-form");
    			attr_dev(form, "class", "formulario crear-hilo panel svelte-tte2d8");
    			add_location(form, file$k, 84, 4, 2324);
    			attr_dev(div1, "class", "sombra");
    			set_style(div1, "position", "fixed");
    			set_style(div1, "left", "0");
    			set_style(div1, "top", "0");
    			add_location(div1, file$k, 83, 0, 2228);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, form);
    			mount_component(mediainput, form, null);
    			append_dev(form, t0);
    			append_dev(form, input0);
    			set_input_value(input0, /*titulo*/ ctx[1]);
    			append_dev(form, t1);
    			append_dev(form, select);
    			append_dev(select, option);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(select, null);
    			}

    			select_option(select, /*categoria*/ ctx[2]);
    			append_dev(form, t3);
    			mount_component(formularioencuesta, form, null);
    			append_dev(form, t4);
    			append_dev(form, textarea);
    			set_input_value(textarea, /*contenido*/ ctx[3]);
    			append_dev(form, t5);
    			if (if_block0) if_block0.m(form, null);
    			append_dev(form, t6);
    			mount_component(errorvalidacion, form, null);
    			append_dev(form, t7);
    			if (if_block1) if_block1.m(form, null);
    			append_dev(form, t8);
    			mount_component(captcha_1, form, null);
    			append_dev(form, t9);
    			append_dev(form, div0);
    			mount_component(button0, div0, null);
    			append_dev(div0, t10);
    			mount_component(button1, div0, null);
    			append_dev(div0, t11);
    			append_dev(div0, input1);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(input0, "input", /*input0_input_handler*/ ctx[18]),
    					listen_dev(select, "change", /*select_change_handler*/ ctx[19]),
    					listen_dev(textarea, "input", /*textarea_input_handler*/ ctx[21]),
    					listen_dev(textarea, "focus", /*onTeaxtAreaFocus*/ ctx[15], false, false, false),
    					listen_dev(form, "submit", prevent_default(/*submit_handler*/ ctx[16]), false, true, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			const mediainput_changes = {};

    			if (!updating_media && dirty[0] & /*media*/ 16) {
    				updating_media = true;
    				mediainput_changes.media = /*media*/ ctx[4];
    				add_flush_callback(() => updating_media = false);
    			}

    			mediainput.$set(mediainput_changes);

    			if (dirty[0] & /*titulo*/ 2 && input0.value !== /*titulo*/ ctx[1]) {
    				set_input_value(input0, /*titulo*/ ctx[1]);
    			}

    			if (dirty & /*config*/ 0) {
    				each_value = config.categorias;
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$a(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$a(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(select, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}

    			if (dirty[0] & /*categoria*/ 4) {
    				select_option(select, /*categoria*/ ctx[2]);
    			}

    			const formularioencuesta_changes = {};

    			if (!updating_opciones && dirty[0] & /*encuesta*/ 64) {
    				updating_opciones = true;
    				formularioencuesta_changes.opciones = /*encuesta*/ ctx[6];
    				add_flush_callback(() => updating_opciones = false);
    			}

    			formularioencuesta.$set(formularioencuesta_changes);

    			if (dirty[0] & /*contenido*/ 8) {
    				set_input_value(textarea, /*contenido*/ ctx[3]);
    			}

    			if (/*escribiendoRedactazo*/ ctx[11]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty[0] & /*escribiendoRedactazo*/ 2048) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_2$9(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(form, t6);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			const errorvalidacion_changes = {};
    			if (dirty[0] & /*error*/ 1024) errorvalidacion_changes.error = /*error*/ ctx[10];
    			errorvalidacion.$set(errorvalidacion_changes);

    			if (/*$globalStore*/ ctx[13].usuario.esMod) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty[0] & /*$globalStore*/ 8192) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_1$b(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(form, t8);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			const captcha_1_changes = {};

    			if (!updating_token && dirty[0] & /*captcha*/ 32) {
    				updating_token = true;
    				captcha_1_changes.token = /*captcha*/ ctx[5];
    				add_flush_callback(() => updating_token = false);
    			}

    			captcha_1.$set(captcha_1_changes);
    			const button0_changes = {};

    			if (dirty[1] & /*$$scope*/ 4) {
    				button0_changes.$$scope = { dirty, ctx };
    			}

    			button0.$set(button0_changes);
    			const button1_changes = {};
    			if (dirty[0] & /*cargando*/ 512) button1_changes.disabled = /*cargando*/ ctx[9];

    			if (dirty[0] & /*cargando*/ 512 | dirty[1] & /*$$scope*/ 4) {
    				button1_changes.$$scope = { dirty, ctx };
    			}

    			button1.$set(button1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(mediainput.$$.fragment, local);
    			transition_in(formularioencuesta.$$.fragment, local);
    			transition_in(if_block0);
    			transition_in(errorvalidacion.$$.fragment, local);
    			transition_in(if_block1);
    			transition_in(captcha_1.$$.fragment, local);
    			transition_in(button0.$$.fragment, local);
    			transition_in(button1.$$.fragment, local);

    			add_render_callback(() => {
    				if (!div1_transition) div1_transition = create_bidirectional_transition(div1, fly, { duration: 200 }, true);
    				div1_transition.run(1);
    			});

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(mediainput.$$.fragment, local);
    			transition_out(formularioencuesta.$$.fragment, local);
    			transition_out(if_block0);
    			transition_out(errorvalidacion.$$.fragment, local);
    			transition_out(if_block1);
    			transition_out(captcha_1.$$.fragment, local);
    			transition_out(button0.$$.fragment, local);
    			transition_out(button1.$$.fragment, local);
    			if (!div1_transition) div1_transition = create_bidirectional_transition(div1, fly, { duration: 200 }, false);
    			div1_transition.run(0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			destroy_component(mediainput);
    			destroy_each(each_blocks, detaching);
    			destroy_component(formularioencuesta);
    			if (if_block0) if_block0.d();
    			destroy_component(errorvalidacion);
    			if (if_block1) if_block1.d();
    			destroy_component(captcha_1);
    			destroy_component(button0);
    			destroy_component(button1);
    			if (detaching && div1_transition) div1_transition.end();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$h.name,
    		type: "if",
    		source: "(83:0) {#if mostrar}",
    		ctx
    	});

    	return block;
    }

    // (97:12) {#each config.categorias as c}
    function create_each_block$a(ctx) {
    	let option;
    	let t_value = /*c*/ ctx[30].nombre + "";
    	let t;
    	let option_value_value;

    	const block = {
    		c: function create() {
    			option = element("option");
    			t = text(t_value);
    			option.__value = option_value_value = /*c*/ ctx[30].id;
    			option.value = option.__value;
    			add_location(option, file$k, 97, 16, 2792);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, option, anchor);
    			append_dev(option, t);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(option);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$a.name,
    		type: "each",
    		source: "(97:12) {#each config.categorias as c}",
    		ctx
    	});

    	return block;
    }

    // (110:8) {#if escribiendoRedactazo}
    function create_if_block_2$9(ctx) {
    	let div1;
    	let textarea;
    	let t;
    	let div0;
    	let button;
    	let current;
    	let mounted;
    	let dispose;

    	button = new ye({
    			props: {
    				color: "var(--color5)",
    				icon: true,
    				$$slots: { default: [create_default_slot_5$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			textarea = element("textarea");
    			t = space();
    			div0 = element("div");
    			create_component(button.$$.fragment);
    			attr_dev(textarea, "rows", "10");
    			set_style(textarea, "background", "var(--color4)");
    			attr_dev(textarea, "name", "contenido");
    			attr_dev(textarea, "class", "expandida svelte-tte2d8");
    			attr_dev(textarea, "placeholder", "Escribi un redactazo...");
    			add_location(textarea, file$k, 111, 16, 3263);
    			set_style(div0, "position", "absolute");
    			set_style(div0, "z-index", "2");
    			set_style(div0, "bottom", "60px");
    			set_style(div0, "right", "10px");
    			add_location(div0, file$k, 120, 20, 3714);
    			attr_dev(div1, "class", "");
    			add_location(div1, file$k, 110, 8, 3231);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, textarea);
    			/*textarea_binding*/ ctx[22](textarea);
    			set_input_value(textarea, /*contenido*/ ctx[3]);
    			append_dev(div1, t);
    			append_dev(div1, div0);
    			mount_component(button, div0, null);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(textarea, "input", /*textarea_input_handler_1*/ ctx[23]),
    					listen_dev(textarea, "focus", /*onTeaxtAreaFocus*/ ctx[15], false, false, false),
    					listen_dev(textarea, "blur", /*blur_handler*/ ctx[24], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty[0] & /*contenido*/ 8) {
    				set_input_value(textarea, /*contenido*/ ctx[3]);
    			}

    			const button_changes = {};

    			if (dirty[1] & /*$$scope*/ 4) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			/*textarea_binding*/ ctx[22](null);
    			destroy_component(button);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$9.name,
    		type: "if",
    		source: "(110:8) {#if escribiendoRedactazo}",
    		ctx
    	});

    	return block;
    }

    // (122:24) <Button color="var(--color5)" icon >
    function create_default_slot_5$3(ctx) {
    	let icon;

    	const block = {
    		c: function create() {
    			icon = element("icon");
    			attr_dev(icon, "class", "fe fe-check");
    			add_location(icon, file$k, 121, 60, 3842);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, icon, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(icon);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5$3.name,
    		type: "slot",
    		source: "(122:24) <Button color=\\\"var(--color5)\\\" icon >",
    		ctx
    	});

    	return block;
    }

    // (129:8) {#if $globalStore.usuario.esMod}
    function create_if_block_1$b(ctx) {
    	let div;
    	let checkbox0;
    	let updating_checked;
    	let t;
    	let checkbox1;
    	let updating_checked_1;
    	let current;

    	function checkbox0_checked_binding(value) {
    		/*checkbox0_checked_binding*/ ctx[25].call(null, value);
    	}

    	let checkbox0_props = {
    		right: true,
    		$$slots: { default: [create_default_slot_4$6] },
    		$$scope: { ctx }
    	};

    	if (/*mostrarRango*/ ctx[7] !== void 0) {
    		checkbox0_props.checked = /*mostrarRango*/ ctx[7];
    	}

    	checkbox0 = new Ne({ props: checkbox0_props, $$inline: true });
    	binding_callbacks.push(() => bind(checkbox0, "checked", checkbox0_checked_binding));

    	function checkbox1_checked_binding(value) {
    		/*checkbox1_checked_binding*/ ctx[26].call(null, value);
    	}

    	let checkbox1_props = {
    		right: true,
    		$$slots: { default: [create_default_slot_3$b] },
    		$$scope: { ctx }
    	};

    	if (/*mostrarNombre*/ ctx[8] !== void 0) {
    		checkbox1_props.checked = /*mostrarNombre*/ ctx[8];
    	}

    	checkbox1 = new Ne({ props: checkbox1_props, $$inline: true });
    	binding_callbacks.push(() => bind(checkbox1, "checked", checkbox1_checked_binding));

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(checkbox0.$$.fragment);
    			t = space();
    			create_component(checkbox1.$$.fragment);
    			set_style(div, "flex-direction", "row");
    			set_style(div, "display", "flex");
    			add_location(div, file$k, 129, 12, 4043);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(checkbox0, div, null);
    			append_dev(div, t);
    			mount_component(checkbox1, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const checkbox0_changes = {};

    			if (dirty[1] & /*$$scope*/ 4) {
    				checkbox0_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_checked && dirty[0] & /*mostrarRango*/ 128) {
    				updating_checked = true;
    				checkbox0_changes.checked = /*mostrarRango*/ ctx[7];
    				add_flush_callback(() => updating_checked = false);
    			}

    			checkbox0.$set(checkbox0_changes);
    			const checkbox1_changes = {};

    			if (dirty[1] & /*$$scope*/ 4) {
    				checkbox1_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_checked_1 && dirty[0] & /*mostrarNombre*/ 256) {
    				updating_checked_1 = true;
    				checkbox1_changes.checked = /*mostrarNombre*/ ctx[8];
    				add_flush_callback(() => updating_checked_1 = false);
    			}

    			checkbox1.$set(checkbox1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(checkbox0.$$.fragment, local);
    			transition_in(checkbox1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(checkbox0.$$.fragment, local);
    			transition_out(checkbox1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(checkbox0);
    			destroy_component(checkbox1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$b.name,
    		type: "if",
    		source: "(129:8) {#if $globalStore.usuario.esMod}",
    		ctx
    	});

    	return block;
    }

    // (131:16) <Checkbox bind:checked={mostrarRango} right>
    function create_default_slot_4$6(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Tag_Mod");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$6.name,
    		type: "slot",
    		source: "(131:16) <Checkbox bind:checked={mostrarRango} right>",
    		ctx
    	});

    	return block;
    }

    // (132:16) <Checkbox bind:checked={mostrarNombre} right>
    function create_default_slot_3$b(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Nombre");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$b.name,
    		type: "slot",
    		source: "(132:16) <Checkbox bind:checked={mostrarNombre} right>",
    		ctx
    	});

    	return block;
    }

    // (137:12) <Button color="primary" on:click={() => mostrar = false}>
    function create_default_slot_2$b(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Cancelar");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$b.name,
    		type: "slot",
    		source: "(137:12) <Button color=\\\"primary\\\" on:click={() => mostrar = false}>",
    		ctx
    	});

    	return block;
    }

    // (139:20) <Spinner {cargando}>
    function create_default_slot_1$c(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Crear");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$c.name,
    		type: "slot",
    		source: "(139:20) <Spinner {cargando}>",
    		ctx
    	});

    	return block;
    }

    // (138:16) <Button color="primary" disabled={cargando} on:click={crear} >
    function create_default_slot$d(ctx) {
    	let spinner;
    	let current;

    	spinner = new Spinner({
    			props: {
    				cargando: /*cargando*/ ctx[9],
    				$$slots: { default: [create_default_slot_1$c] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(spinner.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(spinner, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const spinner_changes = {};
    			if (dirty[0] & /*cargando*/ 512) spinner_changes.cargando = /*cargando*/ ctx[9];

    			if (dirty[1] & /*$$scope*/ 4) {
    				spinner_changes.$$scope = { dirty, ctx };
    			}

    			spinner.$set(spinner_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(spinner.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(spinner.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(spinner, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$d.name,
    		type: "slot",
    		source: "(138:16) <Button color=\\\"primary\\\" disabled={cargando} on:click={crear} >",
    		ctx
    	});

    	return block;
    }

    function create_fragment$k(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*mostrar*/ ctx[0] && create_if_block$h(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*mostrar*/ ctx[0]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty[0] & /*mostrar*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$h(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$k.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$k($$self, $$props, $$invalidate) {
    	let $globalStore;
    	validate_store(globalStore, "globalStore");
    	component_subscribe($$self, globalStore, $$value => $$invalidate(13, $globalStore = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("FormularioHilo", slots, []);
    	let { mostrar = false } = $$props;
    	let titulo = "";
    	let categoria = "-1";
    	let contenido = "";
    	let media;
    	let captcha = "";
    	let encuesta = new Set([]);
    	let mostrarRango = false;
    	let mostrarNombre = false;
    	let cargando = false;
    	let error = null;

    	async function crear() {
    		$$invalidate(9, cargando = true);
    		$$invalidate(6, encuesta);
    		console.log(encuesta);

    		try {
    			let r = null;

    			if (!$globalStore.usuario.esMod) {
    				r = await await RChanClient.crearHilo(titulo, categoria, contenido, media.archivo, media.link, captcha, [...encuesta]);
    			} else {
    				r = await await RChanClient.crearHilo(titulo, categoria, contenido, media.archivo, media.link, captcha, [...encuesta], mostrarNombre, mostrarRango);
    			}

    			if (r.status == 201) {
    				window.location.replace(r.headers.location);
    			}
    		} catch(e) {
    			$$invalidate(10, error = e.response.data);
    		}

    		$$invalidate(9, cargando = false);
    	}

    	let escribiendoRedactazo = false;
    	let textarea2;

    	async function onTeaxtAreaFocus(params) {
    		console.log(textarea2);
    		$$invalidate(11, escribiendoRedactazo = true);
    		await tick();
    		textarea2.focus();
    	}

    	const writable_props = ["mostrar"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$4.warn(`<FormularioHilo> was created with unknown prop '${key}'`);
    	});

    	function submit_handler(event) {
    		bubble($$self, event);
    	}

    	function mediainput_media_binding(value) {
    		media = value;
    		$$invalidate(4, media);
    	}

    	function input0_input_handler() {
    		titulo = this.value;
    		$$invalidate(1, titulo);
    	}

    	function select_change_handler() {
    		categoria = select_value(this);
    		$$invalidate(2, categoria);
    	}

    	function formularioencuesta_opciones_binding(value) {
    		encuesta = value;
    		$$invalidate(6, encuesta);
    	}

    	function textarea_input_handler() {
    		contenido = this.value;
    		$$invalidate(3, contenido);
    	}

    	function textarea_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			textarea2 = $$value;
    			$$invalidate(12, textarea2);
    		});
    	}

    	function textarea_input_handler_1() {
    		contenido = this.value;
    		$$invalidate(3, contenido);
    	}

    	const blur_handler = () => $$invalidate(11, escribiendoRedactazo = false);

    	function checkbox0_checked_binding(value) {
    		mostrarRango = value;
    		$$invalidate(7, mostrarRango);
    	}

    	function checkbox1_checked_binding(value) {
    		mostrarNombre = value;
    		$$invalidate(8, mostrarNombre);
    	}

    	function captcha_1_token_binding(value) {
    		captcha = value;
    		$$invalidate(5, captcha);
    	}

    	const click_handler = () => $$invalidate(0, mostrar = false);

    	$$self.$$set = $$props => {
    		if ("mostrar" in $$props) $$invalidate(0, mostrar = $$props.mostrar);
    	};

    	$$self.$capture_state = () => ({
    		fade,
    		blur,
    		fly,
    		Button: ye,
    		Ripple: he,
    		Checkbox: Ne,
    		config,
    		RChanClient,
    		ErrorValidacion,
    		MediaType,
    		MediaInput,
    		Captcha,
    		Spinner,
    		globalStore,
    		FormularioEncuesta,
    		tick,
    		mostrar,
    		titulo,
    		categoria,
    		contenido,
    		media,
    		captcha,
    		encuesta,
    		mostrarRango,
    		mostrarNombre,
    		cargando,
    		error,
    		crear,
    		escribiendoRedactazo,
    		textarea2,
    		onTeaxtAreaFocus,
    		encuestaArray,
    		$globalStore
    	});

    	$$self.$inject_state = $$props => {
    		if ("mostrar" in $$props) $$invalidate(0, mostrar = $$props.mostrar);
    		if ("titulo" in $$props) $$invalidate(1, titulo = $$props.titulo);
    		if ("categoria" in $$props) $$invalidate(2, categoria = $$props.categoria);
    		if ("contenido" in $$props) $$invalidate(3, contenido = $$props.contenido);
    		if ("media" in $$props) $$invalidate(4, media = $$props.media);
    		if ("captcha" in $$props) $$invalidate(5, captcha = $$props.captcha);
    		if ("encuesta" in $$props) $$invalidate(6, encuesta = $$props.encuesta);
    		if ("mostrarRango" in $$props) $$invalidate(7, mostrarRango = $$props.mostrarRango);
    		if ("mostrarNombre" in $$props) $$invalidate(8, mostrarNombre = $$props.mostrarNombre);
    		if ("cargando" in $$props) $$invalidate(9, cargando = $$props.cargando);
    		if ("error" in $$props) $$invalidate(10, error = $$props.error);
    		if ("escribiendoRedactazo" in $$props) $$invalidate(11, escribiendoRedactazo = $$props.escribiendoRedactazo);
    		if ("textarea2" in $$props) $$invalidate(12, textarea2 = $$props.textarea2);
    		if ("encuestaArray" in $$props) encuestaArray = $$props.encuestaArray;
    	};

    	let encuestaArray;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty[0] & /*encuesta*/ 64) {
    			 encuestaArray = [...encuesta];
    		}

    		if ($$self.$$.dirty[0] & /*encuesta*/ 64) {
    			 console.log(encuesta);
    		}
    	};

    	return [
    		mostrar,
    		titulo,
    		categoria,
    		contenido,
    		media,
    		captcha,
    		encuesta,
    		mostrarRango,
    		mostrarNombre,
    		cargando,
    		error,
    		escribiendoRedactazo,
    		textarea2,
    		$globalStore,
    		crear,
    		onTeaxtAreaFocus,
    		submit_handler,
    		mediainput_media_binding,
    		input0_input_handler,
    		select_change_handler,
    		formularioencuesta_opciones_binding,
    		textarea_input_handler,
    		textarea_binding,
    		textarea_input_handler_1,
    		blur_handler,
    		checkbox0_checked_binding,
    		checkbox1_checked_binding,
    		captcha_1_token_binding,
    		click_handler
    	];
    }

    class FormularioHilo extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$k, create_fragment$k, safe_not_equal, { mostrar: 0 }, [-1, -1]);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "FormularioHilo",
    			options,
    			id: create_fragment$k.name
    		});
    	}

    	get mostrar() {
    		throw new Error("<FormularioHilo>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set mostrar(value) {
    		throw new Error("<FormularioHilo>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\components\Notificaciones.svelte generated by Svelte v3.29.0 */

    const { console: console_1$5, document: document_1 } = globals;
    const file$l = "src\\components\\Notificaciones.svelte";

    function get_each_context$b(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[8] = list[i];
    	return child_ctx;
    }

    function get_each_context_1$2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[8] = list[i];
    	return child_ctx;
    }

    // (77:4) {#if notificaciones.length != 0}
    function create_if_block_3$5(ctx) {
    	let div;
    	let span;
    	let t;

    	const block = {
    		c: function create() {
    			div = element("div");
    			span = element("span");
    			t = text(/*totalNotificaciones*/ ctx[3]);
    			add_location(span, file$l, 78, 12, 2603);
    			attr_dev(div, "class", "noti-cont");
    			set_style(div, "position", "absolute");
    			add_location(div, file$l, 77, 8, 2538);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, span);
    			append_dev(span, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*totalNotificaciones*/ 8) set_data_dev(t, /*totalNotificaciones*/ ctx[3]);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$5.name,
    		type: "if",
    		source: "(77:4) {#if notificaciones.length != 0}",
    		ctx
    	});

    	return block;
    }

    // (73:4) <Button icon dense          on:click={() => mostrar = !mostrar && totalNotificaciones != 0}      >
    function create_default_slot$e(ctx) {
    	let span;
    	let t0;
    	let t1;
    	let ripple;
    	let current;
    	let if_block = /*notificaciones*/ ctx[0].length != 0 && create_if_block_3$5(ctx);
    	ripple = new he({ $$inline: true });

    	const block = {
    		c: function create() {
    			span = element("span");
    			t0 = space();
    			if (if_block) if_block.c();
    			t1 = space();
    			create_component(ripple.$$.fragment);
    			attr_dev(span, "class", "fe fe-bell");
    			add_location(span, file$l, 75, 4, 2457);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			insert_dev(target, t0, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(ripple, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (/*notificaciones*/ ctx[0].length != 0) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_3$5(ctx);
    					if_block.c();
    					if_block.m(t1.parentNode, t1);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(ripple.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(ripple.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			if (detaching) detach_dev(t0);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(ripple, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$e.name,
    		type: "slot",
    		source: "(73:4) <Button icon dense          on:click={() => mostrar = !mostrar && totalNotificaciones != 0}      >",
    		ctx
    	});

    	return block;
    }

    // (84:4) {#if mostrar}
    function create_if_block_1$c(ctx) {
    	let ul;
    	let t0;
    	let li;
    	let ul_transition;
    	let current;
    	let mounted;
    	let dispose;
    	let each_value_1 = /*notificaciones*/ ctx[0];
    	validate_each_argument(each_value_1);
    	let each_blocks = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks[i] = create_each_block_1$2(get_each_context_1$2(ctx, each_value_1, i));
    	}

    	const block = {
    		c: function create() {
    			ul = element("ul");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t0 = space();
    			li = element("li");
    			li.textContent = "Limpiar todas";
    			attr_dev(li, "class", "noti");
    			set_style(li, "justify-content", "center");
    			add_location(li, file$l, 99, 12, 3498);
    			attr_dev(ul, "class", "notis panel drop-menu abs lista-nav menu1");
    			add_location(ul, file$l, 84, 8, 2723);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, ul, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(ul, null);
    			}

    			append_dev(ul, t0);
    			append_dev(ul, li);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(li, "click", /*limpiar*/ ctx[5], false, false, false),
    					listen_dev(ul, "mouseleave", /*mouseleave_handler*/ ctx[7], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*notificaciones*/ 1) {
    				each_value_1 = /*notificaciones*/ ctx[0];
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$2(ctx, each_value_1, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block_1$2(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(ul, t0);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value_1.length;
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			add_render_callback(() => {
    				if (!ul_transition) ul_transition = create_bidirectional_transition(ul, fly, { x: -50, duration: 150 }, true);
    				ul_transition.run(1);
    			});

    			current = true;
    		},
    		o: function outro(local) {
    			if (!ul_transition) ul_transition = create_bidirectional_transition(ul, fly, { x: -50, duration: 150 }, false);
    			ul_transition.run(0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(ul);
    			destroy_each(each_blocks, detaching);
    			if (detaching && ul_transition) ul_transition.end();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$c.name,
    		type: "if",
    		source: "(84:4) {#if mostrar}",
    		ctx
    	});

    	return block;
    }

    // (94:24) {:else}
    function create_else_block_1$2(ctx) {
    	let span;
    	let t0_value = /*n*/ ctx[8].conteo + "";
    	let t0;
    	let t1;
    	let t2_value = /*n*/ ctx[8].comentarioId + "";
    	let t2;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t0 = text(t0_value);
    			t1 = text(" Respondieron a tu comentario : ");
    			t2 = text(t2_value);
    			add_location(span, file$l, 94, 28, 3312);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t0);
    			append_dev(span, t1);
    			append_dev(span, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*notificaciones*/ 1 && t0_value !== (t0_value = /*n*/ ctx[8].conteo + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*notificaciones*/ 1 && t2_value !== (t2_value = /*n*/ ctx[8].comentarioId + "")) set_data_dev(t2, t2_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$2.name,
    		type: "else",
    		source: "(94:24) {:else}",
    		ctx
    	});

    	return block;
    }

    // (92:24) {#if n.tipo == 0}
    function create_if_block_2$a(ctx) {
    	let span;
    	let t0_value = /*n*/ ctx[8].conteo + "";
    	let t0;
    	let t1;
    	let t2_value = /*n*/ ctx[8].hiloTitulo + "";
    	let t2;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t0 = text(t0_value);
    			t1 = text(" Nuevos Comentarios en : ");
    			t2 = text(t2_value);
    			add_location(span, file$l, 92, 28, 3187);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t0);
    			append_dev(span, t1);
    			append_dev(span, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*notificaciones*/ 1 && t0_value !== (t0_value = /*n*/ ctx[8].conteo + "")) set_data_dev(t0, t0_value);
    			if (dirty & /*notificaciones*/ 1 && t2_value !== (t2_value = /*n*/ ctx[8].hiloTitulo + "")) set_data_dev(t2, t2_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$a.name,
    		type: "if",
    		source: "(92:24) {#if n.tipo == 0}",
    		ctx
    	});

    	return block;
    }

    // (88:12) {#each notificaciones as n}
    function create_each_block_1$2(ctx) {
    	let a;
    	let li;
    	let img;
    	let img_src_value;
    	let t;
    	let a_href_value;

    	function select_block_type(ctx, dirty) {
    		if (/*n*/ ctx[8].tipo == 0) return create_if_block_2$a;
    		return create_else_block_1$2;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			a = element("a");
    			li = element("li");
    			img = element("img");
    			t = space();
    			if_block.c();
    			if (img.src !== (img_src_value = /*n*/ ctx[8].hiloImagen)) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", "");
    			add_location(img, file$l, 90, 24, 3081);
    			attr_dev(li, "class", "noti");
    			add_location(li, file$l, 89, 20, 3038);
    			attr_dev(a, "href", a_href_value = "/Notificacion/" + /*n*/ ctx[8].id + "?hiloId=" + /*n*/ ctx[8].hiloId + "&comentarioId=" + /*n*/ ctx[8].comentarioId);
    			add_location(a, file$l, 88, 16, 2937);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);
    			append_dev(a, li);
    			append_dev(li, img);
    			append_dev(li, t);
    			if_block.m(li, null);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*notificaciones*/ 1 && img.src !== (img_src_value = /*n*/ ctx[8].hiloImagen)) {
    				attr_dev(img, "src", img_src_value);
    			}

    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
    				if_block.p(ctx, dirty);
    			} else {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(li, null);
    				}
    			}

    			if (dirty & /*notificaciones*/ 1 && a_href_value !== (a_href_value = "/Notificacion/" + /*n*/ ctx[8].id + "?hiloId=" + /*n*/ ctx[8].hiloId + "&comentarioId=" + /*n*/ ctx[8].comentarioId)) {
    				attr_dev(a, "href", a_href_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    			if_block.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$2.name,
    		type: "each",
    		source: "(88:12) {#each notificaciones as n}",
    		ctx
    	});

    	return block;
    }

    // (119:24) {:else}
    function create_else_block$4(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "Han respondido tu comentario";
    			set_style(span, "color", "var(--color5)");
    			add_location(span, file$l, 119, 28, 4297);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$4.name,
    		type: "else",
    		source: "(119:24) {:else}",
    		ctx
    	});

    	return block;
    }

    // (117:24) {#if n.tipo == 0}
    function create_if_block$i(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "Han comentado";
    			set_style(span, "color", "var(--color5)");
    			add_location(span, file$l, 117, 28, 4177);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$i.name,
    		type: "if",
    		source: "(117:24) {#if n.tipo == 0}",
    		ctx
    	});

    	return block;
    }

    // (108:4) {#each nuevasNotificaciones as n}
    function create_each_block$b(ctx) {
    	let div1;
    	let a;
    	let li;
    	let img;
    	let img_src_value;
    	let t0;
    	let div0;
    	let h3;
    	let t1_value = /*n*/ ctx[8].hiloTitulo + "";
    	let t1;
    	let t2;
    	let t3;
    	let span;
    	let raw_value = /*n*/ ctx[8].contenido + "";
    	let a_href_value;
    	let t4;
    	let div1_outro;
    	let current;

    	function select_block_type_1(ctx, dirty) {
    		if (/*n*/ ctx[8].tipo == 0) return create_if_block$i;
    		return create_else_block$4;
    	}

    	let current_block_type = select_block_type_1(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			a = element("a");
    			li = element("li");
    			img = element("img");
    			t0 = space();
    			div0 = element("div");
    			h3 = element("h3");
    			t1 = text(t1_value);
    			t2 = space();
    			if_block.c();
    			t3 = space();
    			span = element("span");
    			t4 = space();
    			if (img.src !== (img_src_value = /*n*/ ctx[8].hiloImagen)) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", "");
    			add_location(img, file$l, 112, 20, 3980);
    			attr_dev(h3, "class", "svelte-xb2fc4");
    			add_location(h3, file$l, 114, 24, 4075);
    			add_location(span, file$l, 121, 24, 4425);
    			attr_dev(div0, "class", "");
    			add_location(div0, file$l, 113, 20, 4035);
    			attr_dev(li, "class", "noti svelte-xb2fc4");
    			add_location(li, file$l, 111, 16, 3940);
    			attr_dev(a, "href", a_href_value = "/Notificacion/" + /*n*/ ctx[8].id + "?hiloId=" + /*n*/ ctx[8].hiloId + "&comentarioId=" + /*n*/ ctx[8].comentarioId);
    			add_location(a, file$l, 110, 12, 3842);
    			add_location(div1, file$l, 108, 8, 3780);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, a);
    			append_dev(a, li);
    			append_dev(li, img);
    			append_dev(li, t0);
    			append_dev(li, div0);
    			append_dev(div0, h3);
    			append_dev(h3, t1);
    			append_dev(div0, t2);
    			if_block.m(div0, null);
    			append_dev(div0, t3);
    			append_dev(div0, span);
    			span.innerHTML = raw_value;
    			append_dev(div1, t4);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (!current || dirty & /*nuevasNotificaciones*/ 4 && img.src !== (img_src_value = /*n*/ ctx[8].hiloImagen)) {
    				attr_dev(img, "src", img_src_value);
    			}

    			if ((!current || dirty & /*nuevasNotificaciones*/ 4) && t1_value !== (t1_value = /*n*/ ctx[8].hiloTitulo + "")) set_data_dev(t1, t1_value);

    			if (current_block_type !== (current_block_type = select_block_type_1(ctx))) {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(div0, t3);
    				}
    			}

    			if ((!current || dirty & /*nuevasNotificaciones*/ 4) && raw_value !== (raw_value = /*n*/ ctx[8].contenido + "")) span.innerHTML = raw_value;
    			if (!current || dirty & /*nuevasNotificaciones*/ 4 && a_href_value !== (a_href_value = "/Notificacion/" + /*n*/ ctx[8].id + "?hiloId=" + /*n*/ ctx[8].hiloId + "&comentarioId=" + /*n*/ ctx[8].comentarioId)) {
    				attr_dev(a, "href", a_href_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (div1_outro) div1_outro.end(1);
    			current = true;
    		},
    		o: function outro(local) {
    			if (local) {
    				div1_outro = create_out_transition(div1, fly, { x: -150, duration: 250 });
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			if_block.d();
    			if (detaching && div1_outro) div1_outro.end();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$b.name,
    		type: "each",
    		source: "(108:4) {#each nuevasNotificaciones as n}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$l(ctx) {
    	let title_value;
    	let t0;
    	let span;
    	let button;
    	let t1;
    	let t2;
    	let ul;
    	let current;

    	document_1.title = title_value = "" + ((/*totalNotificaciones*/ ctx[3] != 0
    	? `(${/*totalNotificaciones*/ ctx[3]})`
    	: "") + " " + /*titulo*/ ctx[4]);

    	button = new ye({
    			props: {
    				icon: true,
    				dense: true,
    				$$slots: { default: [create_default_slot$e] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button.$on("click", /*click_handler*/ ctx[6]);
    	let if_block = /*mostrar*/ ctx[1] && create_if_block_1$c(ctx);
    	let each_value = /*nuevasNotificaciones*/ ctx[2];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$b(get_each_context$b(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			t0 = space();
    			span = element("span");
    			create_component(button.$$.fragment);
    			t1 = space();
    			if (if_block) if_block.c();
    			t2 = space();
    			ul = element("ul");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			set_style(span, "position", "relative");
    			add_location(span, file$l, 71, 0, 2312);
    			attr_dev(ul, "class", "nuevas-notificaciones notis panel drop-menu abs lista-nav menu1 svelte-xb2fc4");
    			add_location(ul, file$l, 106, 0, 3655);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, span, anchor);
    			mount_component(button, span, null);
    			append_dev(span, t1);
    			if (if_block) if_block.m(span, null);
    			insert_dev(target, t2, anchor);
    			insert_dev(target, ul, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(ul, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if ((!current || dirty & /*totalNotificaciones, titulo*/ 24) && title_value !== (title_value = "" + ((/*totalNotificaciones*/ ctx[3] != 0
    			? `(${/*totalNotificaciones*/ ctx[3]})`
    			: "") + " " + /*titulo*/ ctx[4]))) {
    				document_1.title = title_value;
    			}

    			const button_changes = {};

    			if (dirty & /*$$scope, totalNotificaciones, notificaciones*/ 8201) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);

    			if (/*mostrar*/ ctx[1]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*mostrar*/ 2) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_1$c(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(span, null);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}

    			if (dirty & /*nuevasNotificaciones*/ 4) {
    				each_value = /*nuevasNotificaciones*/ ctx[2];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$b(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$b(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(ul, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			transition_in(if_block);

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			transition_out(if_block);
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(span);
    			destroy_component(button);
    			if (if_block) if_block.d();
    			if (detaching) detach_dev(t2);
    			if (detaching) detach_dev(ul);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$l.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$l($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Notificaciones", slots, []);
    	let { notificaciones } = $$props;
    	const titulo = document.title;
    	let mostrar = false;
    	let nuevasNotificaciones = [];

    	async function limpiar() {
    		try {
    			await RChanClient.limpiarNotificaciones();
    		} catch(error) {
    			console.log(error);
    			return;
    		}

    		$$invalidate(0, notificaciones = []);
    		$$invalidate(1, mostrar = false);
    	}

    	Signal.coneccion.on("NuevaNotificacion", noti => {
    		$$invalidate(2, nuevasNotificaciones = [noti, ...nuevasNotificaciones]);

    		setTimeout(
    			() => {
    				nuevasNotificaciones.pop();
    				$$invalidate(2, nuevasNotificaciones);
    			},
    			3000 + nuevasNotificaciones.length * 1000
    		);

    		let yaExisteUnaNotiDeEseTipo = false;
    		let notiVieja = null;

    		for (const n of notificaciones) {
    			if (n.hiloId == noti.hiloId && n.tipo == noti.tipo && n.tipo == 0) {
    				n.conteo++;
    				yaExisteUnaNotiDeEseTipo = true;
    				notiVieja = n;
    			} else if (n.hiloId == noti.hiloId && n.comentarioId == noti.comentarioId && n.tipo == noti.tipo && n.tipo == 1) {
    				n.conteo++;
    				yaExisteUnaNotiDeEseTipo = true;
    				notiVieja = n;
    			}
    		}

    		if (!yaExisteUnaNotiDeEseTipo) {
    			noti.conteo = 1;
    			$$invalidate(0, notificaciones = [noti, ...notificaciones]);
    		} else {
    			$$invalidate(0, notificaciones = notificaciones.filter(n => n != notiVieja));
    			$$invalidate(0, notificaciones = [notiVieja, ...notificaciones]);
    		}
    	});

    	Signal.coneccion.on("notificacionesLimpeadas", () => {
    		$$invalidate(0, notificaciones = []);
    	});

    	const writable_props = ["notificaciones"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$5.warn(`<Notificaciones> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => $$invalidate(1, mostrar = !mostrar && totalNotificaciones != 0);
    	const mouseleave_handler = () => $$invalidate(1, mostrar = false);

    	$$self.$$set = $$props => {
    		if ("notificaciones" in $$props) $$invalidate(0, notificaciones = $$props.notificaciones);
    	};

    	$$self.$capture_state = () => ({
    		RChanClient,
    		fade,
    		blur,
    		fly,
    		Ripple: he,
    		Button: ye,
    		Signal,
    		notificaciones,
    		titulo,
    		mostrar,
    		nuevasNotificaciones,
    		limpiar,
    		totalNotificaciones
    	});

    	$$self.$inject_state = $$props => {
    		if ("notificaciones" in $$props) $$invalidate(0, notificaciones = $$props.notificaciones);
    		if ("mostrar" in $$props) $$invalidate(1, mostrar = $$props.mostrar);
    		if ("nuevasNotificaciones" in $$props) $$invalidate(2, nuevasNotificaciones = $$props.nuevasNotificaciones);
    		if ("totalNotificaciones" in $$props) $$invalidate(3, totalNotificaciones = $$props.totalNotificaciones);
    	};

    	let totalNotificaciones;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*notificaciones*/ 1) {
    			 $$invalidate(3, totalNotificaciones = notificaciones.map(n => n.conteo).reduce((c, n) => c += n, 0));
    		}
    	};

    	return [
    		notificaciones,
    		mostrar,
    		nuevasNotificaciones,
    		totalNotificaciones,
    		titulo,
    		limpiar,
    		click_handler,
    		mouseleave_handler
    	];
    }

    class Notificaciones extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$l, create_fragment$l, safe_not_equal, { notificaciones: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Notificaciones",
    			options,
    			id: create_fragment$l.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*notificaciones*/ ctx[0] === undefined && !("notificaciones" in props)) {
    			console_1$5.warn("<Notificaciones> was created without expected prop 'notificaciones'");
    		}
    	}

    	get notificaciones() {
    		throw new Error("<Notificaciones>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set notificaciones(value) {
    		throw new Error("<Notificaciones>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    const localStore = (key, initial) => {                 // receives the key of the local storage and an initial value

      const toString = (value) => JSON.stringify(value, null, 2);  // helper function
      const toObj = JSON.parse;                                    // helper function

      if (localStorage.getItem(key) === null) {                   // item not present in local storage
        localStorage.setItem(key, toString(initial));              // initialize local storage with initial value
      }

      const saved = toObj(localStorage.getItem(key));              // convert to object

      const { subscribe, set, update } = writable(saved);          // create the underlying writable store

      return {
        subscribe,
        set: (value) => {
            // console.log(value)
            localStorage.setItem(key, toString(value));              // save also to local storage as a string
            return set(value)
        },
        update
      }
    };

    /* src\components\Dialogos\Ajustes.svelte generated by Svelte v3.29.0 */

    const { Object: Object_1$3, console: console_1$6 } = globals;
    const file$m = "src\\components\\Dialogos\\Ajustes.svelte";

    // (74:8) <div slot="title">
    function create_title_slot$3(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			div.textContent = "Ajustes";
    			attr_dev(div, "slot", "title");
    			add_location(div, file$m, 73, 8, 2173);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_title_slot$3.name,
    		type: "slot",
    		source: "(74:8) <div slot=\\\"title\\\">",
    		ctx
    	});

    	return block;
    }

    // (76:12) <Checkbox  bind:checked={config.scrollAncho} right>
    function create_default_slot_7$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Scroll ancho");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_7$1.name,
    		type: "slot",
    		source: "(76:12) <Checkbox  bind:checked={config.scrollAncho} right>",
    		ctx
    	});

    	return block;
    }

    // (77:12) <Checkbox  bind:checked={config.fondoAburrido} right>
    function create_default_slot_6$2(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Fondo personalizado");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_6$2.name,
    		type: "slot",
    		source: "(77:12) <Checkbox  bind:checked={config.fondoAburrido} right>",
    		ctx
    	});

    	return block;
    }

    // (78:12) {#if config.fondoAburrido}
    function create_if_block_2$b(ctx) {
    	let checkbox;
    	let updating_checked;
    	let current;

    	function checkbox_checked_binding(value) {
    		/*checkbox_checked_binding*/ ctx[8].call(null, value);
    	}

    	let checkbox_props = {
    		right: true,
    		$$slots: { default: [create_default_slot_5$4] },
    		$$scope: { ctx }
    	};

    	if (/*config*/ ctx[1].usarImagen !== void 0) {
    		checkbox_props.checked = /*config*/ ctx[1].usarImagen;
    	}

    	checkbox = new Ne({ props: checkbox_props, $$inline: true });
    	binding_callbacks.push(() => bind(checkbox, "checked", checkbox_checked_binding));

    	const block = {
    		c: function create() {
    			create_component(checkbox.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(checkbox, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const checkbox_changes = {};

    			if (dirty & /*$$scope*/ 262144) {
    				checkbox_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_checked && dirty & /*config*/ 2) {
    				updating_checked = true;
    				checkbox_changes.checked = /*config*/ ctx[1].usarImagen;
    				add_flush_callback(() => updating_checked = false);
    			}

    			checkbox.$set(checkbox_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(checkbox.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(checkbox.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(checkbox, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$b.name,
    		type: "if",
    		source: "(78:12) {#if config.fondoAburrido}",
    		ctx
    	});

    	return block;
    }

    // (79:16) <Checkbox  bind:checked={config.usarImagen} right>
    function create_default_slot_5$4(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Usar imagen");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5$4.name,
    		type: "slot",
    		source: "(79:16) <Checkbox  bind:checked={config.usarImagen} right>",
    		ctx
    	});

    	return block;
    }

    // (81:16) {#if config.fondoAburrido && !config.usarImagen}
    function create_if_block_1$d(ctx) {
    	let div;
    	let label;
    	let t1;
    	let input;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			div = element("div");
    			label = element("label");
    			label.textContent = "Color:";
    			t1 = space();
    			input = element("input");
    			attr_dev(label, "for", "color");
    			add_location(label, file$m, 82, 20, 2737);
    			attr_dev(input, "class", "colorpicker svelte-anedx2");
    			attr_dev(input, "type", "color");
    			attr_dev(input, "name", "color");
    			add_location(input, file$m, 83, 20, 2795);
    			set_style(div, "display", "flex");
    			add_location(div, file$m, 81, 16, 2688);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, label);
    			append_dev(div, t1);
    			append_dev(div, input);
    			set_input_value(input, /*config*/ ctx[1].colorFondo);

    			if (!mounted) {
    				dispose = listen_dev(input, "input", /*input_input_handler*/ ctx[9]);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*config*/ 2) {
    				set_input_value(input, /*config*/ ctx[1].colorFondo);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$d.name,
    		type: "if",
    		source: "(81:16) {#if config.fondoAburrido && !config.usarImagen}",
    		ctx
    	});

    	return block;
    }

    // (87:16) {#if config.fondoAburrido && config.usarImagen}
    function create_if_block$j(ctx) {
    	let div;
    	let label;
    	let t1;
    	let input;
    	let t2;
    	let checkbox;
    	let updating_checked;
    	let current;
    	let mounted;
    	let dispose;

    	function checkbox_checked_binding_1(value) {
    		/*checkbox_checked_binding_1*/ ctx[11].call(null, value);
    	}

    	let checkbox_props = {
    		right: true,
    		$$slots: { default: [create_default_slot_4$7] },
    		$$scope: { ctx }
    	};

    	if (/*config*/ ctx[1].modoCover !== void 0) {
    		checkbox_props.checked = /*config*/ ctx[1].modoCover;
    	}

    	checkbox = new Ne({ props: checkbox_props, $$inline: true });
    	binding_callbacks.push(() => bind(checkbox, "checked", checkbox_checked_binding_1));

    	const block = {
    		c: function create() {
    			div = element("div");
    			label = element("label");
    			label.textContent = "Imagen:";
    			t1 = space();
    			input = element("input");
    			t2 = space();
    			create_component(checkbox.$$.fragment);
    			attr_dev(label, "for", "imagen");
    			add_location(label, file$m, 88, 20, 3091);
    			set_style(input, "background", "var(--color4)");
    			attr_dev(input, "type", "text");
    			attr_dev(input, "name", "imagen");
    			add_location(input, file$m, 89, 20, 3151);
    			set_style(div, "display", "flex");
    			set_style(div, "align-items", "baseline");
    			set_style(div, "gap", "10px");
    			add_location(div, file$m, 87, 16, 3010);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, label);
    			append_dev(div, t1);
    			append_dev(div, input);
    			set_input_value(input, /*config*/ ctx[1].imagen);
    			insert_dev(target, t2, anchor);
    			mount_component(checkbox, target, anchor);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(input, "input", /*input_input_handler_1*/ ctx[10]);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*config*/ 2 && input.value !== /*config*/ ctx[1].imagen) {
    				set_input_value(input, /*config*/ ctx[1].imagen);
    			}

    			const checkbox_changes = {};

    			if (dirty & /*$$scope*/ 262144) {
    				checkbox_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_checked && dirty & /*config*/ 2) {
    				updating_checked = true;
    				checkbox_changes.checked = /*config*/ ctx[1].modoCover;
    				add_flush_callback(() => updating_checked = false);
    			}

    			checkbox.$set(checkbox_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(checkbox.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(checkbox.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (detaching) detach_dev(t2);
    			destroy_component(checkbox, detaching);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$j.name,
    		type: "if",
    		source: "(87:16) {#if config.fondoAburrido && config.usarImagen}",
    		ctx
    	});

    	return block;
    }

    // (92:16) <Checkbox  bind:checked={config.modoCover} right>
    function create_default_slot_4$7(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Modo Cover");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$7.name,
    		type: "slot",
    		source: "(92:16) <Checkbox  bind:checked={config.modoCover} right>",
    		ctx
    	});

    	return block;
    }

    // (75:8) <ExpansionPanel bind:group name="Personalizacion">
    function create_default_slot_3$c(ctx) {
    	let checkbox0;
    	let updating_checked;
    	let t0;
    	let checkbox1;
    	let updating_checked_1;
    	let t1;
    	let t2;
    	let t3;
    	let if_block2_anchor;
    	let current;

    	function checkbox0_checked_binding(value) {
    		/*checkbox0_checked_binding*/ ctx[6].call(null, value);
    	}

    	let checkbox0_props = {
    		right: true,
    		$$slots: { default: [create_default_slot_7$1] },
    		$$scope: { ctx }
    	};

    	if (/*config*/ ctx[1].scrollAncho !== void 0) {
    		checkbox0_props.checked = /*config*/ ctx[1].scrollAncho;
    	}

    	checkbox0 = new Ne({ props: checkbox0_props, $$inline: true });
    	binding_callbacks.push(() => bind(checkbox0, "checked", checkbox0_checked_binding));

    	function checkbox1_checked_binding(value) {
    		/*checkbox1_checked_binding*/ ctx[7].call(null, value);
    	}

    	let checkbox1_props = {
    		right: true,
    		$$slots: { default: [create_default_slot_6$2] },
    		$$scope: { ctx }
    	};

    	if (/*config*/ ctx[1].fondoAburrido !== void 0) {
    		checkbox1_props.checked = /*config*/ ctx[1].fondoAburrido;
    	}

    	checkbox1 = new Ne({ props: checkbox1_props, $$inline: true });
    	binding_callbacks.push(() => bind(checkbox1, "checked", checkbox1_checked_binding));
    	let if_block0 = /*config*/ ctx[1].fondoAburrido && create_if_block_2$b(ctx);
    	let if_block1 = /*config*/ ctx[1].fondoAburrido && !/*config*/ ctx[1].usarImagen && create_if_block_1$d(ctx);
    	let if_block2 = /*config*/ ctx[1].fondoAburrido && /*config*/ ctx[1].usarImagen && create_if_block$j(ctx);

    	const block = {
    		c: function create() {
    			create_component(checkbox0.$$.fragment);
    			t0 = space();
    			create_component(checkbox1.$$.fragment);
    			t1 = space();
    			if (if_block0) if_block0.c();
    			t2 = space();
    			if (if_block1) if_block1.c();
    			t3 = space();
    			if (if_block2) if_block2.c();
    			if_block2_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			mount_component(checkbox0, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(checkbox1, target, anchor);
    			insert_dev(target, t1, anchor);
    			if (if_block0) if_block0.m(target, anchor);
    			insert_dev(target, t2, anchor);
    			if (if_block1) if_block1.m(target, anchor);
    			insert_dev(target, t3, anchor);
    			if (if_block2) if_block2.m(target, anchor);
    			insert_dev(target, if_block2_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const checkbox0_changes = {};

    			if (dirty & /*$$scope*/ 262144) {
    				checkbox0_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_checked && dirty & /*config*/ 2) {
    				updating_checked = true;
    				checkbox0_changes.checked = /*config*/ ctx[1].scrollAncho;
    				add_flush_callback(() => updating_checked = false);
    			}

    			checkbox0.$set(checkbox0_changes);
    			const checkbox1_changes = {};

    			if (dirty & /*$$scope*/ 262144) {
    				checkbox1_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_checked_1 && dirty & /*config*/ 2) {
    				updating_checked_1 = true;
    				checkbox1_changes.checked = /*config*/ ctx[1].fondoAburrido;
    				add_flush_callback(() => updating_checked_1 = false);
    			}

    			checkbox1.$set(checkbox1_changes);

    			if (/*config*/ ctx[1].fondoAburrido) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty & /*config*/ 2) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_2$b(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(t2.parentNode, t2);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (/*config*/ ctx[1].fondoAburrido && !/*config*/ ctx[1].usarImagen) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);
    				} else {
    					if_block1 = create_if_block_1$d(ctx);
    					if_block1.c();
    					if_block1.m(t3.parentNode, t3);
    				}
    			} else if (if_block1) {
    				if_block1.d(1);
    				if_block1 = null;
    			}

    			if (/*config*/ ctx[1].fondoAburrido && /*config*/ ctx[1].usarImagen) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);

    					if (dirty & /*config*/ 2) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block$j(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(checkbox0.$$.fragment, local);
    			transition_in(checkbox1.$$.fragment, local);
    			transition_in(if_block0);
    			transition_in(if_block2);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(checkbox0.$$.fragment, local);
    			transition_out(checkbox1.$$.fragment, local);
    			transition_out(if_block0);
    			transition_out(if_block2);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(checkbox0, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(checkbox1, detaching);
    			if (detaching) detach_dev(t1);
    			if (if_block0) if_block0.d(detaching);
    			if (detaching) detach_dev(t2);
    			if (if_block1) if_block1.d(detaching);
    			if (detaching) detach_dev(t3);
    			if (if_block2) if_block2.d(detaching);
    			if (detaching) detach_dev(if_block2_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$c.name,
    		type: "slot",
    		source: "(75:8) <ExpansionPanel bind:group name=\\\"Personalizacion\\\">",
    		ctx
    	});

    	return block;
    }

    // (96:8) <ExpansionPanel bind:group name="Auto censura">
    function create_default_slot_2$c(ctx) {
    	let textarea;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			textarea = element("textarea");
    			set_style(textarea, "background", "var(--color3)");
    			attr_dev(textarea, "spellcheck", "false");
    			attr_dev(textarea, "placeholder", "Podes usar palabras y frases(palabras separadas guion bajo en vez de espacios). Ej sidoca huele tengo_un_video minubi insta se_le_da, etc");
    			attr_dev(textarea, "cols", "30");
    			attr_dev(textarea, "rows", "10");
    			add_location(textarea, file$m, 96, 12, 3482);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, textarea, anchor);
    			set_input_value(textarea, /*$palabrasHideadas*/ ctx[3]);

    			if (!mounted) {
    				dispose = listen_dev(textarea, "input", /*textarea_input_handler*/ ctx[13]);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$palabrasHideadas*/ 8) {
    				set_input_value(textarea, /*$palabrasHideadas*/ ctx[3]);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(textarea);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$c.name,
    		type: "slot",
    		source: "(96:8) <ExpansionPanel bind:group name=\\\"Auto censura\\\">",
    		ctx
    	});

    	return block;
    }

    // (106:12) <Button color="primary" on:click={actualizarYCerrar}>
    function create_default_slot_1$d(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Lito");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$d.name,
    		type: "slot",
    		source: "(106:12) <Button color=\\\"primary\\\" on:click={actualizarYCerrar}>",
    		ctx
    	});

    	return block;
    }

    // (105:8) <div slot="actions" class="actions center">
    function create_actions_slot$2(ctx) {
    	let div;
    	let button;
    	let current;

    	button = new ye({
    			props: {
    				color: "primary",
    				$$slots: { default: [create_default_slot_1$d] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button.$on("click", /*actualizarYCerrar*/ ctx[4]);

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(button.$$.fragment);
    			attr_dev(div, "slot", "actions");
    			attr_dev(div, "class", "actions center");
    			add_location(div, file$m, 104, 8, 3895);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(button, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button_changes = {};

    			if (dirty & /*$$scope*/ 262144) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(button);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_actions_slot$2.name,
    		type: "slot",
    		source: "(105:8) <div slot=\\\"actions\\\" class=\\\"actions center\\\">",
    		ctx
    	});

    	return block;
    }

    // (73:4) <Dialog  width="500" bind:visible={visible}>
    function create_default_slot$f(ctx) {
    	let t0;
    	let expansionpanel0;
    	let updating_group;
    	let t1;
    	let expansionpanel1;
    	let updating_group_1;
    	let t2;
    	let current;

    	function expansionpanel0_group_binding(value) {
    		/*expansionpanel0_group_binding*/ ctx[12].call(null, value);
    	}

    	let expansionpanel0_props = {
    		name: "Personalizacion",
    		$$slots: { default: [create_default_slot_3$c] },
    		$$scope: { ctx }
    	};

    	if (/*group*/ ctx[2] !== void 0) {
    		expansionpanel0_props.group = /*group*/ ctx[2];
    	}

    	expansionpanel0 = new bn({
    			props: expansionpanel0_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(expansionpanel0, "group", expansionpanel0_group_binding));

    	function expansionpanel1_group_binding(value) {
    		/*expansionpanel1_group_binding*/ ctx[14].call(null, value);
    	}

    	let expansionpanel1_props = {
    		name: "Auto censura",
    		$$slots: { default: [create_default_slot_2$c] },
    		$$scope: { ctx }
    	};

    	if (/*group*/ ctx[2] !== void 0) {
    		expansionpanel1_props.group = /*group*/ ctx[2];
    	}

    	expansionpanel1 = new bn({
    			props: expansionpanel1_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(expansionpanel1, "group", expansionpanel1_group_binding));

    	const block = {
    		c: function create() {
    			t0 = space();
    			create_component(expansionpanel0.$$.fragment);
    			t1 = space();
    			create_component(expansionpanel1.$$.fragment);
    			t2 = space();
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			mount_component(expansionpanel0, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(expansionpanel1, target, anchor);
    			insert_dev(target, t2, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const expansionpanel0_changes = {};

    			if (dirty & /*$$scope, config*/ 262146) {
    				expansionpanel0_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_group && dirty & /*group*/ 4) {
    				updating_group = true;
    				expansionpanel0_changes.group = /*group*/ ctx[2];
    				add_flush_callback(() => updating_group = false);
    			}

    			expansionpanel0.$set(expansionpanel0_changes);
    			const expansionpanel1_changes = {};

    			if (dirty & /*$$scope, $palabrasHideadas*/ 262152) {
    				expansionpanel1_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_group_1 && dirty & /*group*/ 4) {
    				updating_group_1 = true;
    				expansionpanel1_changes.group = /*group*/ ctx[2];
    				add_flush_callback(() => updating_group_1 = false);
    			}

    			expansionpanel1.$set(expansionpanel1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(expansionpanel0.$$.fragment, local);
    			transition_in(expansionpanel1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(expansionpanel0.$$.fragment, local);
    			transition_out(expansionpanel1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			destroy_component(expansionpanel0, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(expansionpanel1, detaching);
    			if (detaching) detach_dev(t2);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$f.name,
    		type: "slot",
    		source: "(73:4) <Dialog  width=\\\"500\\\" bind:visible={visible}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$m(ctx) {
    	let div;
    	let dialog;
    	let updating_visible;
    	let current;

    	function dialog_visible_binding(value) {
    		/*dialog_visible_binding*/ ctx[15].call(null, value);
    	}

    	let dialog_props = {
    		width: "500",
    		$$slots: {
    			default: [create_default_slot$f],
    			actions: [create_actions_slot$2],
    			title: [create_title_slot$3]
    		},
    		$$scope: { ctx }
    	};

    	if (/*visible*/ ctx[0] !== void 0) {
    		dialog_props.visible = /*visible*/ ctx[0];
    	}

    	dialog = new pn({ props: dialog_props, $$inline: true });
    	binding_callbacks.push(() => bind(dialog, "visible", dialog_visible_binding));

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(dialog.$$.fragment);
    			attr_dev(div, "class", "ajustes svelte-anedx2");
    			add_location(div, file$m, 71, 0, 2092);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(dialog, div, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const dialog_changes = {};

    			if (dirty & /*$$scope, group, $palabrasHideadas, config*/ 262158) {
    				dialog_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_visible && dirty & /*visible*/ 1) {
    				updating_visible = true;
    				dialog_changes.visible = /*visible*/ ctx[0];
    				add_flush_callback(() => updating_visible = false);
    			}

    			dialog.$set(dialog_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dialog.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dialog.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(dialog);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$m.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$m($$self, $$props, $$invalidate) {
    	let $palabrasHideadas;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Ajustes", slots, []);
    	let { visible = true } = $$props;

    	// Configuracion por defecto
    	let config = {
    		fondoAburrido: false,
    		colorFondo: "#101923",
    		usarImagen: false,
    		imagen: "/imagenes/rosed.png",
    		modoCover: true,
    		scrollAncho: false
    	};

    	// Cargo configuracion gudardada
    	let configGuardada = window.localStorage.getItem("ajustes");

    	if (configGuardada) {
    		try {
    			config = Object.assign(config, JSON.parse(configGuardada));
    		} catch(error) {
    			console.log(error);
    		}
    	}

    	setTimeout(actualizarConfiguracion, 1);

    	function actualizarConfiguracion() {
    		//Guardo config
    		let css = `
            body {
                ${config.usarImagen
		? `background-image: url(${config.imagen})`
		: `background:${config.colorFondo}`}!important;
                background-size:${config.modoCover ? "cover" : "auto"};
                background-attachment: fixed;
            }
        `;

    		if (!config.fondoAburrido) {
    			css = `
            body {
                background-image: url(/imagenes/rosed.png) !important;
                background-size:auto !important;
                background-attachment: contain !important;
            }
        `;
    		}

    		let style = window.document.styleSheets[0];
    		style.insertRule(css, style.cssRules.length);

    		if (config.scrollAncho) {
    			style.insertRule(
    				`
            ::-webkit-scrollbar {
                width: 10px !important;
            }`,
    				style.cssRules.length
    			);
    		}

    		window.localStorage.setItem("ajustes", JSON.stringify(config));
    	}

    	function actualizarYCerrar(params) {
    		actualizarConfiguracion();
    		$$invalidate(0, visible = false);
    	}

    	let palabrasHideadas = localStore("palabrasHideadas", "");
    	validate_store(palabrasHideadas, "palabrasHideadas");
    	component_subscribe($$self, palabrasHideadas, value => $$invalidate(3, $palabrasHideadas = value));
    	let group = "";
    	const writable_props = ["visible"];

    	Object_1$3.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$6.warn(`<Ajustes> was created with unknown prop '${key}'`);
    	});

    	function checkbox0_checked_binding(value) {
    		config.scrollAncho = value;
    		$$invalidate(1, config);
    	}

    	function checkbox1_checked_binding(value) {
    		config.fondoAburrido = value;
    		$$invalidate(1, config);
    	}

    	function checkbox_checked_binding(value) {
    		config.usarImagen = value;
    		$$invalidate(1, config);
    	}

    	function input_input_handler() {
    		config.colorFondo = this.value;
    		$$invalidate(1, config);
    	}

    	function input_input_handler_1() {
    		config.imagen = this.value;
    		$$invalidate(1, config);
    	}

    	function checkbox_checked_binding_1(value) {
    		config.modoCover = value;
    		$$invalidate(1, config);
    	}

    	function expansionpanel0_group_binding(value) {
    		group = value;
    		$$invalidate(2, group);
    	}

    	function textarea_input_handler() {
    		$palabrasHideadas = this.value;
    		palabrasHideadas.set($palabrasHideadas);
    	}

    	function expansionpanel1_group_binding(value) {
    		group = value;
    		$$invalidate(2, group);
    	}

    	function dialog_visible_binding(value) {
    		visible = value;
    		$$invalidate(0, visible);
    	}

    	$$self.$$set = $$props => {
    		if ("visible" in $$props) $$invalidate(0, visible = $$props.visible);
    	};

    	$$self.$capture_state = () => ({
    		Dialog: pn,
    		Button: ye,
    		Checkbox: Ne,
    		ExpansionPanel: bn,
    		localStore,
    		visible,
    		config,
    		configGuardada,
    		actualizarConfiguracion,
    		actualizarYCerrar,
    		palabrasHideadas,
    		group,
    		$palabrasHideadas
    	});

    	$$self.$inject_state = $$props => {
    		if ("visible" in $$props) $$invalidate(0, visible = $$props.visible);
    		if ("config" in $$props) $$invalidate(1, config = $$props.config);
    		if ("configGuardada" in $$props) configGuardada = $$props.configGuardada;
    		if ("palabrasHideadas" in $$props) $$invalidate(5, palabrasHideadas = $$props.palabrasHideadas);
    		if ("group" in $$props) $$invalidate(2, group = $$props.group);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*config*/ 2) {
    			 if (config) actualizarConfiguracion();
    		}
    	};

    	return [
    		visible,
    		config,
    		group,
    		$palabrasHideadas,
    		actualizarYCerrar,
    		palabrasHideadas,
    		checkbox0_checked_binding,
    		checkbox1_checked_binding,
    		checkbox_checked_binding,
    		input_input_handler,
    		input_input_handler_1,
    		checkbox_checked_binding_1,
    		expansionpanel0_group_binding,
    		textarea_input_handler,
    		expansionpanel1_group_binding,
    		dialog_visible_binding
    	];
    }

    class Ajustes extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$m, create_fragment$m, safe_not_equal, { visible: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Ajustes",
    			options,
    			id: create_fragment$m.name
    		});
    	}

    	get visible() {
    		throw new Error("<Ajustes>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set visible(value) {
    		throw new Error("<Ajustes>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\components\MenuPrincipal.svelte generated by Svelte v3.29.0 */
    const file$n = "src\\components\\MenuPrincipal.svelte";

    function get_each_context$c(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[12] = list[i];
    	child_ctx[13] = list;
    	child_ctx[14] = i;
    	return child_ctx;
    }

    // (37:12) {#if usuario.estaAutenticado}
    function create_if_block_7$2(ctx) {
    	let span;
    	let t0;
    	let t1_value = /*usuario*/ ctx[4].userName + "";
    	let t1;
    	let t2;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t0 = text("Hola ");
    			t1 = text(t1_value);
    			t2 = text("!");
    			set_style(span, "display", "block");
    			set_style(span, "text-align", "center");
    			add_location(span, file$n, 37, 12, 1223);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t0);
    			append_dev(span, t1);
    			append_dev(span, t2);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*usuario*/ 16 && t1_value !== (t1_value = /*usuario*/ ctx[4].userName + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_7$2.name,
    		type: "if",
    		source: "(37:12) {#if usuario.estaAutenticado}",
    		ctx
    	});

    	return block;
    }

    // (42:12) {#if !usuario.estaAutenticado}
    function create_if_block_6$3(ctx) {
    	let a0;
    	let li0;
    	let icon0;
    	let t0;
    	let ripple0;
    	let t1;
    	let a1;
    	let li1;
    	let icon1;
    	let t2;
    	let ripple1;
    	let current;
    	ripple0 = new he({ $$inline: true });
    	ripple1 = new he({ $$inline: true });

    	const block = {
    		c: function create() {
    			a0 = element("a");
    			li0 = element("li");
    			icon0 = element("icon");
    			t0 = text(" Iniciar Sesion  ");
    			create_component(ripple0.$$.fragment);
    			t1 = space();
    			a1 = element("a");
    			li1 = element("li");
    			icon1 = element("icon");
    			t2 = text(" Crear Sesion  ");
    			create_component(ripple1.$$.fragment);
    			attr_dev(icon0, "class", "fe fe-log-in");
    			add_location(icon0, file$n, 43, 21, 1450);
    			add_location(li0, file$n, 43, 16, 1445);
    			attr_dev(a0, "href", "/Login");
    			add_location(a0, file$n, 42, 12, 1410);
    			attr_dev(icon1, "class", "fe fe-user");
    			add_location(icon1, file$n, 46, 21, 1582);
    			add_location(li1, file$n, 46, 16, 1577);
    			attr_dev(a1, "href", "/Inicio");
    			add_location(a1, file$n, 45, 12, 1541);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a0, anchor);
    			append_dev(a0, li0);
    			append_dev(li0, icon0);
    			append_dev(li0, t0);
    			mount_component(ripple0, li0, null);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, a1, anchor);
    			append_dev(a1, li1);
    			append_dev(li1, icon1);
    			append_dev(li1, t2);
    			mount_component(ripple1, li1, null);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(ripple0.$$.fragment, local);
    			transition_in(ripple1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(ripple0.$$.fragment, local);
    			transition_out(ripple1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a0);
    			destroy_component(ripple0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(a1);
    			destroy_component(ripple1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_6$3.name,
    		type: "if",
    		source: "(42:12) {#if !usuario.estaAutenticado}",
    		ctx
    	});

    	return block;
    }

    // (57:12) {#if mostrarCategorias}
    function create_if_block_5$4(ctx) {
    	let div;
    	let each_blocks = [];
    	let each_1_lookup = new Map();
    	let div_transition;
    	let current;
    	let each_value = /*categorias*/ ctx[3];
    	validate_each_argument(each_value);
    	const get_key = ctx => /*c*/ ctx[12].id;
    	validate_each_keys(ctx, each_value, get_each_context$c, get_key);

    	for (let i = 0; i < each_value.length; i += 1) {
    		let child_ctx = get_each_context$c(ctx, each_value, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block$c(key, child_ctx));
    	}

    	const block = {
    		c: function create() {
    			div = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			add_location(div, file$n, 57, 16, 2105);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*categorias*/ 8) {
    				const each_value = /*categorias*/ ctx[3];
    				validate_each_argument(each_value);
    				group_outros();
    				validate_each_keys(ctx, each_value, get_each_context$c, get_key);
    				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, div, outro_and_destroy_block, create_each_block$c, null, get_each_context$c);
    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			add_render_callback(() => {
    				if (!div_transition) div_transition = create_bidirectional_transition(div, fly, { y: -50, duration: 150 }, true);
    				div_transition.run(1);
    			});

    			current = true;
    		},
    		o: function outro(local) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			if (!div_transition) div_transition = create_bidirectional_transition(div, fly, { y: -50, duration: 150 }, false);
    			div_transition.run(0);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].d();
    			}

    			if (detaching && div_transition) div_transition.end();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5$4.name,
    		type: "if",
    		source: "(57:12) {#if mostrarCategorias}",
    		ctx
    	});

    	return block;
    }

    // (59:20) {#each categorias as c (c.id)}
    function create_each_block$c(key_1, ctx) {
    	let li;
    	let a;
    	let icon;
    	let t0;
    	let t1_value = /*c*/ ctx[12].nombre + "";
    	let t1;
    	let a_href_value;
    	let t2;
    	let span;
    	let checkbox;
    	let updating_checked;
    	let t3;
    	let ripple;
    	let t4;
    	let current;

    	function checkbox_checked_binding(value) {
    		/*checkbox_checked_binding*/ ctx[8].call(null, value, /*c*/ ctx[12]);
    	}

    	let checkbox_props = { right: true };

    	if (/*c*/ ctx[12].activa !== void 0) {
    		checkbox_props.checked = /*c*/ ctx[12].activa;
    	}

    	checkbox = new Ne({ props: checkbox_props, $$inline: true });
    	binding_callbacks.push(() => bind(checkbox, "checked", checkbox_checked_binding));
    	ripple = new he({ $$inline: true });

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			li = element("li");
    			a = element("a");
    			icon = element("icon");
    			t0 = space();
    			t1 = text(t1_value);
    			t2 = space();
    			span = element("span");
    			create_component(checkbox.$$.fragment);
    			t3 = space();
    			create_component(ripple.$$.fragment);
    			t4 = space();
    			attr_dev(icon, "class", "fe fe-circle");
    			add_location(icon, file$n, 61, 32, 2346);
    			attr_dev(a, "href", a_href_value = "/" + /*c*/ ctx[12].nombreCorto);
    			attr_dev(a, "class", "svelte-kz7wdd");
    			add_location(a, file$n, 60, 28, 2285);
    			set_style(span, "width", "fit-content");
    			set_style(span, "margin-left", "auto");
    			add_location(span, file$n, 63, 28, 2450);
    			attr_dev(li, "class", "categoria-link svelte-kz7wdd");
    			add_location(li, file$n, 59, 24, 2228);
    			this.first = li;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			append_dev(li, a);
    			append_dev(a, icon);
    			append_dev(a, t0);
    			append_dev(a, t1);
    			append_dev(li, t2);
    			append_dev(li, span);
    			mount_component(checkbox, span, null);
    			append_dev(li, t3);
    			mount_component(ripple, li, null);
    			append_dev(li, t4);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if ((!current || dirty & /*categorias*/ 8) && t1_value !== (t1_value = /*c*/ ctx[12].nombre + "")) set_data_dev(t1, t1_value);

    			if (!current || dirty & /*categorias*/ 8 && a_href_value !== (a_href_value = "/" + /*c*/ ctx[12].nombreCorto)) {
    				attr_dev(a, "href", a_href_value);
    			}

    			const checkbox_changes = {};

    			if (!updating_checked && dirty & /*categorias*/ 8) {
    				updating_checked = true;
    				checkbox_changes.checked = /*c*/ ctx[12].activa;
    				add_flush_callback(() => updating_checked = false);
    			}

    			checkbox.$set(checkbox_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(checkbox.$$.fragment, local);
    			transition_in(ripple.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(checkbox.$$.fragment, local);
    			transition_out(ripple.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			destroy_component(checkbox);
    			destroy_component(ripple);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$c.name,
    		type: "each",
    		source: "(59:20) {#each categorias as c (c.id)}",
    		ctx
    	});

    	return block;
    }

    // (73:12) {#if $globalStore.usuario.estaAutenticado}
    function create_if_block_4$4(ctx) {
    	let a0;
    	let li0;
    	let icon0;
    	let t0;
    	let ripple0;
    	let t1;
    	let a1;
    	let li1;
    	let icon1;
    	let t2;
    	let ripple1;
    	let t3;
    	let a2;
    	let li2;
    	let icon2;
    	let t4;
    	let ripple2;
    	let t5;
    	let a3;
    	let li3;
    	let icon3;
    	let t6;
    	let ripple3;
    	let t7;
    	let hr;
    	let current;
    	ripple0 = new he({ $$inline: true });
    	ripple1 = new he({ $$inline: true });
    	ripple2 = new he({ $$inline: true });
    	ripple3 = new he({ $$inline: true });

    	const block = {
    		c: function create() {
    			a0 = element("a");
    			li0 = element("li");
    			icon0 = element("icon");
    			t0 = text(" Creados  ");
    			create_component(ripple0.$$.fragment);
    			t1 = space();
    			a1 = element("a");
    			li1 = element("li");
    			icon1 = element("icon");
    			t2 = text(" Favoritos  ");
    			create_component(ripple1.$$.fragment);
    			t3 = space();
    			a2 = element("a");
    			li2 = element("li");
    			icon2 = element("icon");
    			t4 = text(" Seguidos  ");
    			create_component(ripple2.$$.fragment);
    			t5 = space();
    			a3 = element("a");
    			li3 = element("li");
    			icon3 = element("icon");
    			t6 = text(" Ocultos  ");
    			create_component(ripple3.$$.fragment);
    			t7 = space();
    			hr = element("hr");
    			attr_dev(icon0, "class", "fe fe-target");
    			add_location(icon0, file$n, 74, 25, 2877);
    			add_location(li0, file$n, 74, 20, 2872);
    			attr_dev(a0, "href", "/Mis/Creados");
    			add_location(a0, file$n, 73, 16, 2827);
    			attr_dev(icon1, "class", "fe fe-star");
    			add_location(icon1, file$n, 77, 25, 3021);
    			add_location(li1, file$n, 77, 20, 3016);
    			attr_dev(a1, "href", "/Mis/Favoritos");
    			add_location(a1, file$n, 76, 16, 2969);
    			attr_dev(icon2, "class", "fe fe-eye");
    			add_location(icon2, file$n, 80, 25, 3164);
    			add_location(li2, file$n, 80, 20, 3159);
    			attr_dev(a2, "href", "/Mis/Seguidos");
    			add_location(a2, file$n, 79, 16, 3113);
    			attr_dev(icon3, "class", "fe fe-eye-off");
    			add_location(icon3, file$n, 83, 25, 3304);
    			add_location(li3, file$n, 83, 20, 3299);
    			attr_dev(a3, "href", "/Mis/Ocultos");
    			add_location(a3, file$n, 82, 16, 3254);
    			add_location(hr, file$n, 85, 16, 3397);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a0, anchor);
    			append_dev(a0, li0);
    			append_dev(li0, icon0);
    			append_dev(li0, t0);
    			mount_component(ripple0, li0, null);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, a1, anchor);
    			append_dev(a1, li1);
    			append_dev(li1, icon1);
    			append_dev(li1, t2);
    			mount_component(ripple1, li1, null);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, a2, anchor);
    			append_dev(a2, li2);
    			append_dev(li2, icon2);
    			append_dev(li2, t4);
    			mount_component(ripple2, li2, null);
    			insert_dev(target, t5, anchor);
    			insert_dev(target, a3, anchor);
    			append_dev(a3, li3);
    			append_dev(li3, icon3);
    			append_dev(li3, t6);
    			mount_component(ripple3, li3, null);
    			insert_dev(target, t7, anchor);
    			insert_dev(target, hr, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(ripple0.$$.fragment, local);
    			transition_in(ripple1.$$.fragment, local);
    			transition_in(ripple2.$$.fragment, local);
    			transition_in(ripple3.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(ripple0.$$.fragment, local);
    			transition_out(ripple1.$$.fragment, local);
    			transition_out(ripple2.$$.fragment, local);
    			transition_out(ripple3.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a0);
    			destroy_component(ripple0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(a1);
    			destroy_component(ripple1);
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(a2);
    			destroy_component(ripple2);
    			if (detaching) detach_dev(t5);
    			if (detaching) detach_dev(a3);
    			destroy_component(ripple3);
    			if (detaching) detach_dev(t7);
    			if (detaching) detach_dev(hr);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$4.name,
    		type: "if",
    		source: "(73:12) {#if $globalStore.usuario.estaAutenticado}",
    		ctx
    	});

    	return block;
    }

    // (94:12) {#if $globalStore.usuario.tieneToken}
    function create_if_block_3$6(ctx) {
    	let a;
    	let li;
    	let icon;
    	let t;
    	let ripple;
    	let current;
    	ripple = new he({ $$inline: true });

    	const block = {
    		c: function create() {
    			a = element("a");
    			li = element("li");
    			icon = element("icon");
    			t = text(" Ver token ");
    			create_component(ripple.$$.fragment);
    			attr_dev(icon, "class", "fe fe-user-check");
    			add_location(icon, file$n, 95, 25, 3802);
    			add_location(li, file$n, 95, 20, 3797);
    			attr_dev(a, "href", "/Token");
    			add_location(a, file$n, 94, 16, 3758);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);
    			append_dev(a, li);
    			append_dev(li, icon);
    			append_dev(li, t);
    			mount_component(ripple, li, null);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(ripple.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(ripple.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    			destroy_component(ripple);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$6.name,
    		type: "if",
    		source: "(94:12) {#if $globalStore.usuario.tieneToken}",
    		ctx
    	});

    	return block;
    }

    // (99:12) {#if $globalStore.usuario.estaAutenticado}
    function create_if_block_2$c(ctx) {
    	let li;
    	let icon;
    	let t;
    	let ripple;
    	let current;
    	let mounted;
    	let dispose;
    	ripple = new he({ $$inline: true });

    	const block = {
    		c: function create() {
    			li = element("li");
    			icon = element("icon");
    			t = text(" Salir  ");
    			create_component(ripple.$$.fragment);
    			attr_dev(icon, "class", "fe fe-log-out");
    			add_location(icon, file$n, 99, 45, 4003);
    			add_location(li, file$n, 99, 16, 3974);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			append_dev(li, icon);
    			append_dev(li, t);
    			mount_component(ripple, li, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(li, "click", /*desloguearse*/ ctx[6], false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(ripple.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(ripple.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			destroy_component(ripple);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$c.name,
    		type: "if",
    		source: "(99:12) {#if $globalStore.usuario.estaAutenticado}",
    		ctx
    	});

    	return block;
    }

    // (106:12) {#if $globalStore.usuario.esMod}
    function create_if_block_1$e(ctx) {
    	let a;
    	let li;
    	let icon;
    	let t;
    	let ripple;
    	let current;
    	ripple = new he({ $$inline: true });

    	const block = {
    		c: function create() {
    			a = element("a");
    			li = element("li");
    			icon = element("icon");
    			t = text(" Moderacion  ");
    			create_component(ripple.$$.fragment);
    			attr_dev(icon, "class", "fe fe-triangle");
    			add_location(icon, file$n, 107, 21, 4214);
    			add_location(li, file$n, 107, 16, 4209);
    			attr_dev(a, "href", "/Moderacion");
    			add_location(a, file$n, 106, 12, 4169);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);
    			append_dev(a, li);
    			append_dev(li, icon);
    			append_dev(li, t);
    			mount_component(ripple, li, null);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(ripple.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(ripple.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    			destroy_component(ripple);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$e.name,
    		type: "if",
    		source: "(106:12) {#if $globalStore.usuario.esMod}",
    		ctx
    	});

    	return block;
    }

    // (111:12) {#if $globalStore.usuario.esAdmin}
    function create_if_block$k(ctx) {
    	let a;
    	let li;
    	let icon;
    	let t;
    	let ripple;
    	let current;
    	ripple = new he({ $$inline: true });

    	const block = {
    		c: function create() {
    			a = element("a");
    			li = element("li");
    			icon = element("icon");
    			t = text(" Administracion  ");
    			create_component(ripple.$$.fragment);
    			attr_dev(icon, "class", "fe fe-triangle");
    			add_location(icon, file$n, 112, 21, 4419);
    			add_location(li, file$n, 112, 16, 4414);
    			attr_dev(a, "href", "/Administracion");
    			add_location(a, file$n, 111, 12, 4370);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);
    			append_dev(a, li);
    			append_dev(li, icon);
    			append_dev(li, t);
    			mount_component(ripple, li, null);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(ripple.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(ripple.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    			destroy_component(ripple);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$k.name,
    		type: "if",
    		source: "(111:12) {#if $globalStore.usuario.esAdmin}",
    		ctx
    	});

    	return block;
    }

    // (31:0) <Sidepanel left bind:visible={mostrar} style="background: red">
    function create_default_slot$g(ctx) {
    	let section;
    	let div;
    	let a0;
    	let h1;
    	let t1;
    	let t2;
    	let ul;
    	let t3;
    	let li0;
    	let icon0;
    	let t4;
    	let span;
    	let t5;
    	let icon1;
    	let t6;
    	let ripple0;
    	let t7;
    	let t8;
    	let hr0;
    	let t9;
    	let t10;
    	let li1;
    	let icon2;
    	let t11;
    	let ripple1;
    	let t12;
    	let a1;
    	let li2;
    	let icon3;
    	let t13;
    	let ripple2;
    	let t14;
    	let hr1;
    	let t15;
    	let t16;
    	let t17;
    	let hr2;
    	let t18;
    	let t19;
    	let t20;
    	let hr3;
    	let current;
    	let mounted;
    	let dispose;
    	let if_block0 = /*usuario*/ ctx[4].estaAutenticado && create_if_block_7$2(ctx);
    	let if_block1 = !/*usuario*/ ctx[4].estaAutenticado && create_if_block_6$3(ctx);
    	ripple0 = new he({ $$inline: true });
    	let if_block2 = /*mostrarCategorias*/ ctx[1] && create_if_block_5$4(ctx);
    	let if_block3 = /*$globalStore*/ ctx[5].usuario.estaAutenticado && create_if_block_4$4(ctx);
    	ripple1 = new he({ $$inline: true });
    	ripple2 = new he({ $$inline: true });
    	let if_block4 = /*$globalStore*/ ctx[5].usuario.tieneToken && create_if_block_3$6(ctx);
    	let if_block5 = /*$globalStore*/ ctx[5].usuario.estaAutenticado && create_if_block_2$c(ctx);
    	let if_block6 = /*$globalStore*/ ctx[5].usuario.esMod && create_if_block_1$e(ctx);
    	let if_block7 = /*$globalStore*/ ctx[5].usuario.esAdmin && create_if_block$k(ctx);

    	const block = {
    		c: function create() {
    			section = element("section");
    			div = element("div");
    			a0 = element("a");
    			h1 = element("h1");
    			h1.textContent = "ROZED";
    			t1 = space();
    			if (if_block0) if_block0.c();
    			t2 = space();
    			ul = element("ul");
    			if (if_block1) if_block1.c();
    			t3 = space();
    			li0 = element("li");
    			icon0 = element("icon");
    			t4 = text(" Categorias \r\n                ");
    			span = element("span");
    			t5 = space();
    			icon1 = element("icon");
    			t6 = space();
    			create_component(ripple0.$$.fragment);
    			t7 = space();
    			if (if_block2) if_block2.c();
    			t8 = space();
    			hr0 = element("hr");
    			t9 = space();
    			if (if_block3) if_block3.c();
    			t10 = space();
    			li1 = element("li");
    			icon2 = element("icon");
    			t11 = text(" Ajustes  ");
    			create_component(ripple1.$$.fragment);
    			t12 = space();
    			a1 = element("a");
    			li2 = element("li");
    			icon3 = element("icon");
    			t13 = text(" Reglas  ");
    			create_component(ripple2.$$.fragment);
    			t14 = space();
    			hr1 = element("hr");
    			t15 = space();
    			if (if_block4) if_block4.c();
    			t16 = space();
    			if (if_block5) if_block5.c();
    			t17 = space();
    			hr2 = element("hr");
    			t18 = space();
    			if (if_block6) if_block6.c();
    			t19 = space();
    			if (if_block7) if_block7.c();
    			t20 = space();
    			hr3 = element("hr");
    			set_style(h1, "font-family", "'euroFighter'");
    			add_location(h1, file$n, 34, 16, 1098);
    			attr_dev(a0, "href", "/");
    			add_location(a0, file$n, 33, 12, 1068);
    			attr_dev(div, "class", "menu-principal-header");
    			add_location(div, file$n, 32, 8, 1019);
    			attr_dev(icon0, "class", "fe fe-menu");
    			add_location(icon0, file$n, 50, 16, 1766);
    			set_style(span, "margin-left", "auto");
    			add_location(span, file$n, 51, 16, 1822);
    			attr_dev(icon1, "class", "fe fe-chevron-down");
    			set_style(icon1, "padding", "0");
    			set_style(icon1, "transform", "rotate(" + (/*mostrarCategorias*/ ctx[1] ? 180 : 0) + "deg)");
    			set_style(icon1, "transition", "all 0.2s ease 0s");
    			add_location(icon1, file$n, 53, 20, 1884);
    			add_location(li0, file$n, 49, 12, 1688);
    			add_location(hr0, file$n, 71, 12, 2749);
    			attr_dev(icon2, "class", "fe fe-settings");
    			add_location(icon2, file$n, 88, 56, 3480);
    			add_location(li1, file$n, 88, 12, 3436);
    			attr_dev(icon3, "class", "fe fe-align-justify");
    			add_location(icon3, file$n, 90, 22, 3595);
    			add_location(li2, file$n, 90, 16, 3589);
    			attr_dev(a1, "href", "/reglas.html");
    			add_location(a1, file$n, 89, 12, 3548);
    			add_location(hr1, file$n, 92, 12, 3685);
    			add_location(hr2, file$n, 101, 12, 4087);
    			add_location(hr3, file$n, 115, 12, 4531);
    			add_location(ul, file$n, 40, 8, 1348);
    			attr_dev(section, "class", "menu-principal");
    			add_location(section, file$n, 31, 4, 977);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, section, anchor);
    			append_dev(section, div);
    			append_dev(div, a0);
    			append_dev(a0, h1);
    			append_dev(div, t1);
    			if (if_block0) if_block0.m(div, null);
    			append_dev(section, t2);
    			append_dev(section, ul);
    			if (if_block1) if_block1.m(ul, null);
    			append_dev(ul, t3);
    			append_dev(ul, li0);
    			append_dev(li0, icon0);
    			append_dev(li0, t4);
    			append_dev(li0, span);
    			append_dev(li0, t5);
    			append_dev(li0, icon1);
    			append_dev(li0, t6);
    			mount_component(ripple0, li0, null);
    			append_dev(ul, t7);
    			if (if_block2) if_block2.m(ul, null);
    			append_dev(ul, t8);
    			append_dev(ul, hr0);
    			append_dev(ul, t9);
    			if (if_block3) if_block3.m(ul, null);
    			append_dev(ul, t10);
    			append_dev(ul, li1);
    			append_dev(li1, icon2);
    			append_dev(li1, t11);
    			mount_component(ripple1, li1, null);
    			append_dev(ul, t12);
    			append_dev(ul, a1);
    			append_dev(a1, li2);
    			append_dev(li2, icon3);
    			append_dev(li2, t13);
    			mount_component(ripple2, li2, null);
    			append_dev(ul, t14);
    			append_dev(ul, hr1);
    			append_dev(ul, t15);
    			if (if_block4) if_block4.m(ul, null);
    			append_dev(ul, t16);
    			if (if_block5) if_block5.m(ul, null);
    			append_dev(ul, t17);
    			append_dev(ul, hr2);
    			append_dev(ul, t18);
    			if (if_block6) if_block6.m(ul, null);
    			append_dev(ul, t19);
    			if (if_block7) if_block7.m(ul, null);
    			append_dev(ul, t20);
    			append_dev(ul, hr3);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(li0, "click", /*click_handler*/ ctx[7], false, false, false),
    					listen_dev(li1, "click", /*click_handler_1*/ ctx[9], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if (/*usuario*/ ctx[4].estaAutenticado) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_7$2(ctx);
    					if_block0.c();
    					if_block0.m(div, null);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (!/*usuario*/ ctx[4].estaAutenticado) {
    				if (if_block1) {
    					if (dirty & /*usuario*/ 16) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_6$3(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(ul, t3);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (!current || dirty & /*mostrarCategorias*/ 2) {
    				set_style(icon1, "transform", "rotate(" + (/*mostrarCategorias*/ ctx[1] ? 180 : 0) + "deg)");
    			}

    			if (/*mostrarCategorias*/ ctx[1]) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);

    					if (dirty & /*mostrarCategorias*/ 2) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block_5$4(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(ul, t8);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}

    			if (/*$globalStore*/ ctx[5].usuario.estaAutenticado) {
    				if (if_block3) {
    					if (dirty & /*$globalStore*/ 32) {
    						transition_in(if_block3, 1);
    					}
    				} else {
    					if_block3 = create_if_block_4$4(ctx);
    					if_block3.c();
    					transition_in(if_block3, 1);
    					if_block3.m(ul, t10);
    				}
    			} else if (if_block3) {
    				group_outros();

    				transition_out(if_block3, 1, 1, () => {
    					if_block3 = null;
    				});

    				check_outros();
    			}

    			if (/*$globalStore*/ ctx[5].usuario.tieneToken) {
    				if (if_block4) {
    					if (dirty & /*$globalStore*/ 32) {
    						transition_in(if_block4, 1);
    					}
    				} else {
    					if_block4 = create_if_block_3$6(ctx);
    					if_block4.c();
    					transition_in(if_block4, 1);
    					if_block4.m(ul, t16);
    				}
    			} else if (if_block4) {
    				group_outros();

    				transition_out(if_block4, 1, 1, () => {
    					if_block4 = null;
    				});

    				check_outros();
    			}

    			if (/*$globalStore*/ ctx[5].usuario.estaAutenticado) {
    				if (if_block5) {
    					if_block5.p(ctx, dirty);

    					if (dirty & /*$globalStore*/ 32) {
    						transition_in(if_block5, 1);
    					}
    				} else {
    					if_block5 = create_if_block_2$c(ctx);
    					if_block5.c();
    					transition_in(if_block5, 1);
    					if_block5.m(ul, t17);
    				}
    			} else if (if_block5) {
    				group_outros();

    				transition_out(if_block5, 1, 1, () => {
    					if_block5 = null;
    				});

    				check_outros();
    			}

    			if (/*$globalStore*/ ctx[5].usuario.esMod) {
    				if (if_block6) {
    					if (dirty & /*$globalStore*/ 32) {
    						transition_in(if_block6, 1);
    					}
    				} else {
    					if_block6 = create_if_block_1$e(ctx);
    					if_block6.c();
    					transition_in(if_block6, 1);
    					if_block6.m(ul, t19);
    				}
    			} else if (if_block6) {
    				group_outros();

    				transition_out(if_block6, 1, 1, () => {
    					if_block6 = null;
    				});

    				check_outros();
    			}

    			if (/*$globalStore*/ ctx[5].usuario.esAdmin) {
    				if (if_block7) {
    					if (dirty & /*$globalStore*/ 32) {
    						transition_in(if_block7, 1);
    					}
    				} else {
    					if_block7 = create_if_block$k(ctx);
    					if_block7.c();
    					transition_in(if_block7, 1);
    					if_block7.m(ul, t20);
    				}
    			} else if (if_block7) {
    				group_outros();

    				transition_out(if_block7, 1, 1, () => {
    					if_block7 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block1);
    			transition_in(ripple0.$$.fragment, local);
    			transition_in(if_block2);
    			transition_in(if_block3);
    			transition_in(ripple1.$$.fragment, local);
    			transition_in(ripple2.$$.fragment, local);
    			transition_in(if_block4);
    			transition_in(if_block5);
    			transition_in(if_block6);
    			transition_in(if_block7);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block1);
    			transition_out(ripple0.$$.fragment, local);
    			transition_out(if_block2);
    			transition_out(if_block3);
    			transition_out(ripple1.$$.fragment, local);
    			transition_out(ripple2.$$.fragment, local);
    			transition_out(if_block4);
    			transition_out(if_block5);
    			transition_out(if_block6);
    			transition_out(if_block7);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(section);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			destroy_component(ripple0);
    			if (if_block2) if_block2.d();
    			if (if_block3) if_block3.d();
    			destroy_component(ripple1);
    			destroy_component(ripple2);
    			if (if_block4) if_block4.d();
    			if (if_block5) if_block5.d();
    			if (if_block6) if_block6.d();
    			if (if_block7) if_block7.d();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$g.name,
    		type: "slot",
    		source: "(31:0) <Sidepanel left bind:visible={mostrar} style=\\\"background: red\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$n(ctx) {
    	let sidepanel;
    	let updating_visible;
    	let t;
    	let ajustes;
    	let updating_visible_1;
    	let current;

    	function sidepanel_visible_binding(value) {
    		/*sidepanel_visible_binding*/ ctx[10].call(null, value);
    	}

    	let sidepanel_props = {
    		left: true,
    		style: "background: red",
    		$$slots: { default: [create_default_slot$g] },
    		$$scope: { ctx }
    	};

    	if (/*mostrar*/ ctx[0] !== void 0) {
    		sidepanel_props.visible = /*mostrar*/ ctx[0];
    	}

    	sidepanel = new Pn({ props: sidepanel_props, $$inline: true });
    	binding_callbacks.push(() => bind(sidepanel, "visible", sidepanel_visible_binding));

    	function ajustes_visible_binding(value) {
    		/*ajustes_visible_binding*/ ctx[11].call(null, value);
    	}

    	let ajustes_props = {};

    	if (/*mostrarAjustes*/ ctx[2] !== void 0) {
    		ajustes_props.visible = /*mostrarAjustes*/ ctx[2];
    	}

    	ajustes = new Ajustes({ props: ajustes_props, $$inline: true });
    	binding_callbacks.push(() => bind(ajustes, "visible", ajustes_visible_binding));

    	const block = {
    		c: function create() {
    			create_component(sidepanel.$$.fragment);
    			t = space();
    			create_component(ajustes.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(sidepanel, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(ajustes, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const sidepanel_changes = {};

    			if (dirty & /*$$scope, $globalStore, mostrarAjustes, categorias, mostrarCategorias, usuario*/ 32830) {
    				sidepanel_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_visible && dirty & /*mostrar*/ 1) {
    				updating_visible = true;
    				sidepanel_changes.visible = /*mostrar*/ ctx[0];
    				add_flush_callback(() => updating_visible = false);
    			}

    			sidepanel.$set(sidepanel_changes);
    			const ajustes_changes = {};

    			if (!updating_visible_1 && dirty & /*mostrarAjustes*/ 4) {
    				updating_visible_1 = true;
    				ajustes_changes.visible = /*mostrarAjustes*/ ctx[2];
    				add_flush_callback(() => updating_visible_1 = false);
    			}

    			ajustes.$set(ajustes_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(sidepanel.$$.fragment, local);
    			transition_in(ajustes.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(sidepanel.$$.fragment, local);
    			transition_out(ajustes.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(sidepanel, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(ajustes, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$n.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$n($$self, $$props, $$invalidate) {
    	let $globalStore;
    	validate_store(globalStore, "globalStore");
    	component_subscribe($$self, globalStore, $$value => $$invalidate(5, $globalStore = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("MenuPrincipal", slots, []);
    	let { mostrar = true } = $$props;
    	let mostrarCategorias = false;
    	let mostrarAjustes = false;

    	let categorias = config.categorias.map(c => {
    		c.activa = $globalStore.categoriasActivas.includes(c.id);
    		c = c;
    		return c;
    	});

    	async function desloguearse() {
    		await RChanClient.deslogearse();
    		location.reload();
    	}

    	const writable_props = ["mostrar"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<MenuPrincipal> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => $$invalidate(1, mostrarCategorias = !mostrarCategorias);

    	function checkbox_checked_binding(value, c) {
    		c.activa = value;
    		$$invalidate(3, categorias);
    	}

    	const click_handler_1 = () => $$invalidate(2, mostrarAjustes = true);

    	function sidepanel_visible_binding(value) {
    		mostrar = value;
    		($$invalidate(0, mostrar), $$invalidate(2, mostrarAjustes));
    	}

    	function ajustes_visible_binding(value) {
    		mostrarAjustes = value;
    		$$invalidate(2, mostrarAjustes);
    	}

    	$$self.$$set = $$props => {
    		if ("mostrar" in $$props) $$invalidate(0, mostrar = $$props.mostrar);
    	};

    	$$self.$capture_state = () => ({
    		Ripple: he,
    		Sidepanel: Pn,
    		Checkbox: Ne,
    		fly,
    		config,
    		globalStore,
    		RChanClient,
    		Dialogo,
    		Ajustes,
    		mostrar,
    		mostrarCategorias,
    		mostrarAjustes,
    		categorias,
    		desloguearse,
    		usuario,
    		$globalStore
    	});

    	$$self.$inject_state = $$props => {
    		if ("mostrar" in $$props) $$invalidate(0, mostrar = $$props.mostrar);
    		if ("mostrarCategorias" in $$props) $$invalidate(1, mostrarCategorias = $$props.mostrarCategorias);
    		if ("mostrarAjustes" in $$props) $$invalidate(2, mostrarAjustes = $$props.mostrarAjustes);
    		if ("categorias" in $$props) $$invalidate(3, categorias = $$props.categorias);
    		if ("usuario" in $$props) $$invalidate(4, usuario = $$props.usuario);
    	};

    	let usuario;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*categorias*/ 8) {
    			 set_store_value(globalStore, $globalStore.categoriasActivas = categorias.filter(c => c.activa).map(c => c.id), $globalStore);
    		}

    		if ($$self.$$.dirty & /*$globalStore*/ 32) {
    			 $$invalidate(4, usuario = $globalStore.usuario);
    		}

    		if ($$self.$$.dirty & /*mostrarAjustes*/ 4) {
    			 if (mostrarAjustes) $$invalidate(0, mostrar = false);
    		}
    	};

    	return [
    		mostrar,
    		mostrarCategorias,
    		mostrarAjustes,
    		categorias,
    		usuario,
    		$globalStore,
    		desloguearse,
    		click_handler,
    		checkbox_checked_binding,
    		click_handler_1,
    		sidepanel_visible_binding,
    		ajustes_visible_binding
    	];
    }

    class MenuPrincipal extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$n, create_fragment$n, safe_not_equal, { mostrar: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "MenuPrincipal",
    			options,
    			id: create_fragment$n.name
    		});
    	}

    	get mostrar() {
    		throw new Error("<MenuPrincipal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set mostrar(value) {
    		throw new Error("<MenuPrincipal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\components\FormularioLogin.svelte generated by Svelte v3.29.0 */

    const { console: console_1$7 } = globals;
    const file$o = "src\\components\\FormularioLogin.svelte";

    // (37:8) <div slot="title">
    function create_title_slot_1$1(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			div.textContent = "Ingresar";
    			attr_dev(div, "slot", "title");
    			add_location(div, file$o, 36, 8, 1016);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_title_slot_1$1.name,
    		type: "slot",
    		source: "(37:8) <div slot=\\\"title\\\">",
    		ctx
    	});

    	return block;
    }

    // (59:12) <Button color="primary" on:click={login} >
    function create_default_slot_3$d(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Jeje ta bien");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$d.name,
    		type: "slot",
    		source: "(59:12) <Button color=\\\"primary\\\" on:click={login} >",
    		ctx
    	});

    	return block;
    }

    // (58:8) <div slot="actions" class="actions center">
    function create_actions_slot_1(ctx) {
    	let div;
    	let button;
    	let current;

    	button = new ye({
    			props: {
    				color: "primary",
    				$$slots: { default: [create_default_slot_3$d] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button.$on("click", /*login*/ ctx[5]);

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(button.$$.fragment);
    			attr_dev(div, "slot", "actions");
    			attr_dev(div, "class", "actions center");
    			add_location(div, file$o, 57, 8, 1521);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(button, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button_changes = {};

    			if (dirty & /*$$scope*/ 4096) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(button);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_actions_slot_1.name,
    		type: "slot",
    		source: "(58:8) <div slot=\\\"actions\\\" class=\\\"actions center\\\">",
    		ctx
    	});

    	return block;
    }

    // (36:0) <Dialog width="290" bind:visible= {$globalStore.mostrarLogin}>
    function create_default_slot_2$d(ctx) {
    	let t0;
    	let textfield0;
    	let updating_value;
    	let t1;
    	let textfield1;
    	let updating_value_1;
    	let t2;
    	let errorvalidacion;
    	let t3;
    	let current;

    	function textfield0_value_binding(value) {
    		/*textfield0_value_binding*/ ctx[6].call(null, value);
    	}

    	let textfield0_props = {
    		name: "Nick",
    		autocomplete: "off",
    		required: true,
    		label: "nick",
    		message: "Como te llamas tu?"
    	};

    	if (/*nick*/ ctx[0] !== void 0) {
    		textfield0_props.value = /*nick*/ ctx[0];
    	}

    	textfield0 = new Ve({ props: textfield0_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield0, "value", textfield0_value_binding));

    	function textfield1_value_binding(value) {
    		/*textfield1_value_binding*/ ctx[7].call(null, value);
    	}

    	let textfield1_props = {
    		type: "password",
    		name: "Contraseña",
    		autocomplete: "off",
    		required: true,
    		label: "Contraseña",
    		message: "Gordo1234"
    	};

    	if (/*contraseña*/ ctx[1] !== void 0) {
    		textfield1_props.value = /*contraseña*/ ctx[1];
    	}

    	textfield1 = new Ve({ props: textfield1_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield1, "value", textfield1_value_binding));

    	errorvalidacion = new ErrorValidacion({
    			props: { error: /*error*/ ctx[2] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			t0 = space();
    			create_component(textfield0.$$.fragment);
    			t1 = space();
    			create_component(textfield1.$$.fragment);
    			t2 = space();
    			create_component(errorvalidacion.$$.fragment);
    			t3 = space();
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			mount_component(textfield0, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(textfield1, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(errorvalidacion, target, anchor);
    			insert_dev(target, t3, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const textfield0_changes = {};

    			if (!updating_value && dirty & /*nick*/ 1) {
    				updating_value = true;
    				textfield0_changes.value = /*nick*/ ctx[0];
    				add_flush_callback(() => updating_value = false);
    			}

    			textfield0.$set(textfield0_changes);
    			const textfield1_changes = {};

    			if (!updating_value_1 && dirty & /*contraseña*/ 2) {
    				updating_value_1 = true;
    				textfield1_changes.value = /*contraseña*/ ctx[1];
    				add_flush_callback(() => updating_value_1 = false);
    			}

    			textfield1.$set(textfield1_changes);
    			const errorvalidacion_changes = {};
    			if (dirty & /*error*/ 4) errorvalidacion_changes.error = /*error*/ ctx[2];
    			errorvalidacion.$set(errorvalidacion_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(textfield0.$$.fragment, local);
    			transition_in(textfield1.$$.fragment, local);
    			transition_in(errorvalidacion.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(textfield0.$$.fragment, local);
    			transition_out(textfield1.$$.fragment, local);
    			transition_out(errorvalidacion.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			destroy_component(textfield0, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(textfield1, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(errorvalidacion, detaching);
    			if (detaching) detach_dev(t3);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$d.name,
    		type: "slot",
    		source: "(36:0) <Dialog width=\\\"290\\\" bind:visible= {$globalStore.mostrarLogin}>",
    		ctx
    	});

    	return block;
    }

    // (65:4) <div slot="title">
    function create_title_slot$4(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			div.textContent = "Registrate";
    			attr_dev(div, "slot", "title");
    			add_location(div, file$o, 64, 4, 1757);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_title_slot$4.name,
    		type: "slot",
    		source: "(65:4) <div slot=\\\"title\\\">",
    		ctx
    	});

    	return block;
    }

    // (87:8) <Button  on:click={registrar} color="primary" >
    function create_default_slot_1$e(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Jeje ta bien");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$e.name,
    		type: "slot",
    		source: "(87:8) <Button  on:click={registrar} color=\\\"primary\\\" >",
    		ctx
    	});

    	return block;
    }

    // (86:4) <div slot="actions" class="actions center">
    function create_actions_slot$3(ctx) {
    	let div;
    	let button;
    	let current;

    	button = new ye({
    			props: {
    				color: "primary",
    				$$slots: { default: [create_default_slot_1$e] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button.$on("click", /*registrar*/ ctx[4]);

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(button.$$.fragment);
    			attr_dev(div, "slot", "actions");
    			attr_dev(div, "class", "actions center");
    			add_location(div, file$o, 85, 4, 2224);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(button, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button_changes = {};

    			if (dirty & /*$$scope*/ 4096) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(button);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_actions_slot$3.name,
    		type: "slot",
    		source: "(86:4) <div slot=\\\"actions\\\" class=\\\"actions center\\\">",
    		ctx
    	});

    	return block;
    }

    // (64:0) <Dialog width="290" bind:visible= {$globalStore.mostrarRegistro}>
    function create_default_slot$h(ctx) {
    	let t0;
    	let textfield0;
    	let updating_value;
    	let t1;
    	let textfield1;
    	let updating_value_1;
    	let t2;
    	let errorvalidacion;
    	let t3;
    	let current;

    	function textfield0_value_binding_1(value) {
    		/*textfield0_value_binding_1*/ ctx[9].call(null, value);
    	}

    	let textfield0_props = {
    		name: "Nick",
    		autocomplete: "off",
    		required: true,
    		label: "nick",
    		message: "Como te llamas tu?"
    	};

    	if (/*nick*/ ctx[0] !== void 0) {
    		textfield0_props.value = /*nick*/ ctx[0];
    	}

    	textfield0 = new Ve({ props: textfield0_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield0, "value", textfield0_value_binding_1));

    	function textfield1_value_binding_1(value) {
    		/*textfield1_value_binding_1*/ ctx[10].call(null, value);
    	}

    	let textfield1_props = {
    		type: "password",
    		name: "Contraseña",
    		autocomplete: "off",
    		required: true,
    		label: "Contraseña",
    		message: "Gordo1234"
    	};

    	if (/*contraseña*/ ctx[1] !== void 0) {
    		textfield1_props.value = /*contraseña*/ ctx[1];
    	}

    	textfield1 = new Ve({ props: textfield1_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield1, "value", textfield1_value_binding_1));

    	errorvalidacion = new ErrorValidacion({
    			props: { error: /*error*/ ctx[2] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			t0 = space();
    			create_component(textfield0.$$.fragment);
    			t1 = space();
    			create_component(textfield1.$$.fragment);
    			t2 = space();
    			create_component(errorvalidacion.$$.fragment);
    			t3 = space();
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			mount_component(textfield0, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(textfield1, target, anchor);
    			insert_dev(target, t2, anchor);
    			mount_component(errorvalidacion, target, anchor);
    			insert_dev(target, t3, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const textfield0_changes = {};

    			if (!updating_value && dirty & /*nick*/ 1) {
    				updating_value = true;
    				textfield0_changes.value = /*nick*/ ctx[0];
    				add_flush_callback(() => updating_value = false);
    			}

    			textfield0.$set(textfield0_changes);
    			const textfield1_changes = {};

    			if (!updating_value_1 && dirty & /*contraseña*/ 2) {
    				updating_value_1 = true;
    				textfield1_changes.value = /*contraseña*/ ctx[1];
    				add_flush_callback(() => updating_value_1 = false);
    			}

    			textfield1.$set(textfield1_changes);
    			const errorvalidacion_changes = {};
    			if (dirty & /*error*/ 4) errorvalidacion_changes.error = /*error*/ ctx[2];
    			errorvalidacion.$set(errorvalidacion_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(textfield0.$$.fragment, local);
    			transition_in(textfield1.$$.fragment, local);
    			transition_in(errorvalidacion.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(textfield0.$$.fragment, local);
    			transition_out(textfield1.$$.fragment, local);
    			transition_out(errorvalidacion.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			destroy_component(textfield0, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(textfield1, detaching);
    			if (detaching) detach_dev(t2);
    			destroy_component(errorvalidacion, detaching);
    			if (detaching) detach_dev(t3);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$h.name,
    		type: "slot",
    		source: "(64:0) <Dialog width=\\\"290\\\" bind:visible= {$globalStore.mostrarRegistro}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$o(ctx) {
    	let dialog0;
    	let updating_visible;
    	let t;
    	let dialog1;
    	let updating_visible_1;
    	let current;

    	function dialog0_visible_binding(value) {
    		/*dialog0_visible_binding*/ ctx[8].call(null, value);
    	}

    	let dialog0_props = {
    		width: "290",
    		$$slots: {
    			default: [create_default_slot_2$d],
    			actions: [create_actions_slot_1],
    			title: [create_title_slot_1$1]
    		},
    		$$scope: { ctx }
    	};

    	if (/*$globalStore*/ ctx[3].mostrarLogin !== void 0) {
    		dialog0_props.visible = /*$globalStore*/ ctx[3].mostrarLogin;
    	}

    	dialog0 = new pn({ props: dialog0_props, $$inline: true });
    	binding_callbacks.push(() => bind(dialog0, "visible", dialog0_visible_binding));

    	function dialog1_visible_binding(value) {
    		/*dialog1_visible_binding*/ ctx[11].call(null, value);
    	}

    	let dialog1_props = {
    		width: "290",
    		$$slots: {
    			default: [create_default_slot$h],
    			actions: [create_actions_slot$3],
    			title: [create_title_slot$4]
    		},
    		$$scope: { ctx }
    	};

    	if (/*$globalStore*/ ctx[3].mostrarRegistro !== void 0) {
    		dialog1_props.visible = /*$globalStore*/ ctx[3].mostrarRegistro;
    	}

    	dialog1 = new pn({ props: dialog1_props, $$inline: true });
    	binding_callbacks.push(() => bind(dialog1, "visible", dialog1_visible_binding));

    	const block = {
    		c: function create() {
    			create_component(dialog0.$$.fragment);
    			t = space();
    			create_component(dialog1.$$.fragment);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(dialog0, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(dialog1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const dialog0_changes = {};

    			if (dirty & /*$$scope, error, contraseña, nick*/ 4103) {
    				dialog0_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_visible && dirty & /*$globalStore*/ 8) {
    				updating_visible = true;
    				dialog0_changes.visible = /*$globalStore*/ ctx[3].mostrarLogin;
    				add_flush_callback(() => updating_visible = false);
    			}

    			dialog0.$set(dialog0_changes);
    			const dialog1_changes = {};

    			if (dirty & /*$$scope, error, contraseña, nick*/ 4103) {
    				dialog1_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_visible_1 && dirty & /*$globalStore*/ 8) {
    				updating_visible_1 = true;
    				dialog1_changes.visible = /*$globalStore*/ ctx[3].mostrarRegistro;
    				add_flush_callback(() => updating_visible_1 = false);
    			}

    			dialog1.$set(dialog1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dialog0.$$.fragment, local);
    			transition_in(dialog1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dialog0.$$.fragment, local);
    			transition_out(dialog1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dialog0, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(dialog1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$o.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$o($$self, $$props, $$invalidate) {
    	let $globalStore;
    	validate_store(globalStore, "globalStore");
    	component_subscribe($$self, globalStore, $$value => $$invalidate(3, $globalStore = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("FormularioLogin", slots, []);
    	let { nick = "" } = $$props;
    	let { contraseña = "" } = $$props;
    	let error = null;

    	async function registrar() {
    		try {
    			await RChanClient.registrase(nick, contraseña);
    		} catch(e) {
    			console.log(e);
    			$$invalidate(2, error = e.response.data);
    			return;
    		}

    		window.location = "/";
    		location.reload();
    	}

    	async function login() {
    		try {
    			await RChanClient.logearse(nick, contraseña);
    		} catch(e) {
    			console.log(e);
    			console.log(e.response);
    			$$invalidate(2, error = e.response.data);
    			return;
    		}

    		window.location = "/";
    		location.reload();
    	}

    	const writable_props = ["nick", "contraseña"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$7.warn(`<FormularioLogin> was created with unknown prop '${key}'`);
    	});

    	function textfield0_value_binding(value) {
    		nick = value;
    		$$invalidate(0, nick);
    	}

    	function textfield1_value_binding(value) {
    		contraseña = value;
    		$$invalidate(1, contraseña);
    	}

    	function dialog0_visible_binding(value) {
    		$globalStore.mostrarLogin = value;
    		globalStore.set($globalStore);
    	}

    	function textfield0_value_binding_1(value) {
    		nick = value;
    		$$invalidate(0, nick);
    	}

    	function textfield1_value_binding_1(value) {
    		contraseña = value;
    		$$invalidate(1, contraseña);
    	}

    	function dialog1_visible_binding(value) {
    		$globalStore.mostrarRegistro = value;
    		globalStore.set($globalStore);
    	}

    	$$self.$$set = $$props => {
    		if ("nick" in $$props) $$invalidate(0, nick = $$props.nick);
    		if ("contraseña" in $$props) $$invalidate(1, contraseña = $$props.contraseña);
    	};

    	$$self.$capture_state = () => ({
    		Dialog: pn,
    		Textfield: Ve,
    		Button: ye,
    		globalStore,
    		RChanClient,
    		ErrorValidacion,
    		nick,
    		contraseña,
    		error,
    		registrar,
    		login,
    		$globalStore
    	});

    	$$self.$inject_state = $$props => {
    		if ("nick" in $$props) $$invalidate(0, nick = $$props.nick);
    		if ("contraseña" in $$props) $$invalidate(1, contraseña = $$props.contraseña);
    		if ("error" in $$props) $$invalidate(2, error = $$props.error);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		nick,
    		contraseña,
    		error,
    		$globalStore,
    		registrar,
    		login,
    		textfield0_value_binding,
    		textfield1_value_binding,
    		dialog0_visible_binding,
    		textfield0_value_binding_1,
    		textfield1_value_binding_1,
    		dialog1_visible_binding
    	];
    }

    class FormularioLogin extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$o, create_fragment$o, safe_not_equal, { nick: 0, contraseña: 1 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "FormularioLogin",
    			options,
    			id: create_fragment$o.name
    		});
    	}

    	get nick() {
    		throw new Error("<FormularioLogin>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set nick(value) {
    		throw new Error("<FormularioLogin>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get contraseña() {
    		throw new Error("<FormularioLogin>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set contraseña(value) {
    		throw new Error("<FormularioLogin>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\components\MensajeRotativo.svelte generated by Svelte v3.29.0 */
    const file$p = "src\\components\\MensajeRotativo.svelte";

    function create_fragment$p(ctx) {
    	let div1;
    	let div0;
    	let span0;
    	let t0;
    	let span0_resize_listener;
    	let t1;
    	let span1;
    	let t2;
    	let div1_resize_listener;

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			span0 = element("span");
    			t0 = text(/*texto*/ ctx[0]);
    			t1 = space();
    			span1 = element("span");
    			t2 = text(/*texto*/ ctx[0]);
    			attr_dev(span0, "class", "rt1 svelte-c1fezs");
    			add_render_callback(() => /*span0_elementresize_handler*/ ctx[7].call(span0));
    			add_location(span0, file$p, 28, 8, 2530);
    			attr_dev(span1, "class", "rt2 svelte-c1fezs");
    			add_location(span1, file$p, 29, 8, 2617);
    			attr_dev(div0, "class", "mensaje-rotativo svelte-c1fezs");
    			set_style(div0, "--width", /*textWidth*/ ctx[1] + "px");
    			set_style(div0, "--duracion", /*duracion*/ ctx[5] + "s");
    			add_location(div0, file$p, 27, 4, 2434);
    			attr_dev(div1, "class", "container svelte-c1fezs");
    			add_render_callback(() => /*div1_elementresize_handler*/ ctx[9].call(div1));
    			add_location(div1, file$p, 26, 0, 2380);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			append_dev(div0, span0);
    			append_dev(span0, t0);
    			/*span0_binding*/ ctx[6](span0);
    			span0_resize_listener = add_resize_listener(span0, /*span0_elementresize_handler*/ ctx[7].bind(span0));
    			append_dev(div0, t1);
    			append_dev(div0, span1);
    			append_dev(span1, t2);
    			/*span1_binding*/ ctx[8](span1);
    			div1_resize_listener = add_resize_listener(div1, /*div1_elementresize_handler*/ ctx[9].bind(div1));
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*texto*/ 1) set_data_dev(t0, /*texto*/ ctx[0]);
    			if (dirty & /*texto*/ 1) set_data_dev(t2, /*texto*/ ctx[0]);

    			if (dirty & /*textWidth*/ 2) {
    				set_style(div0, "--width", /*textWidth*/ ctx[1] + "px");
    			}

    			if (dirty & /*duracion*/ 32) {
    				set_style(div0, "--duracion", /*duracion*/ ctx[5] + "s");
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			/*span0_binding*/ ctx[6](null);
    			span0_resize_listener();
    			/*span1_binding*/ ctx[8](null);
    			div1_resize_listener();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$p.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$p($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("MensajeRotativo", slots, []);

    	let { texto = `Me agarré a las piñas con la familia de mi novia

Fui a cenar a lo de mi novia y me agarre con el padre.
Les pasó a contar, la cosa es que estoy saliendo hace dos meses con una chica y el sábado pasado fui a cenar a la casa por primera vez.
La cita era en la casa del padre a eso de las 21,00hs. Apenas llego nos atiende una chica de más de 20 años a lo que le pregunto si era la hermana, la chica puso cara rara y me dijo "no, soy la novia del papá" a esto el padre estaba ya sentado en la cabeza de la mesa y escuchó todo, me clavó una mirada de odio terrible. Ahí nomás me presenta con el padre y el hermano que también estaba ahí.
Todo transcurria con normalidad hasta que me ofrece pan para la comida (hicieron ravioles caseros) lo cual le digo que no, gracias,que estoy dejando los carbohidratos y que ya tenía sufriente con los ravioles, a lo que el padre se me caga de risa y me dice"pero si pareces una lombriz, mi nena es mucha carne para tan poco perro". En ese instante me sale del alma " que maleducado que es usted"a lo cual instantaneamente se levanta y dice "que dijiste pendejo de mierda" y me quiere dar un cachetazo, al cual por reflejo se lo freno apartandole la mano violentamente. Al toque salta el hermano y nose que me dice, lo miro y el padre me emboca una piña en la cara, ahí me caigo un poco para atrás se caen unos vasos los platos, me repongo y le devuelvo la piña, se la pego pero de refilón,y ahí salta el hermano a pegarme a traición, lo veo venir con mi vista periférica y trato de esquivarlo, a lo cual la hermana me quiere dar un botellazo.
Esquivo el botellazo y me quiere pegar de nuevo, ahí me doy cuenta que los tres están contra mi, entonces no me quedo otra que, lo tenía que hacer, hago una maniobra para pararme bien y hago la patada 360° sobre mi propio eje, golpeando a los tres a la vez,agarró a mi novia salimos corriendo y pasamos toda la noche haciendo el amor` } = $$props;

    	let textWidth = 0;
    	let rt1;
    	let rt2;
    	let width = 100;
    	let duracion = 100;
    	const writable_props = ["texto"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<MensajeRotativo> was created with unknown prop '${key}'`);
    	});

    	function span0_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			rt1 = $$value;
    			$$invalidate(2, rt1);
    		});
    	}

    	function span0_elementresize_handler() {
    		textWidth = this.offsetWidth;
    		$$invalidate(1, textWidth);
    	}

    	function span1_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			rt2 = $$value;
    			$$invalidate(3, rt2);
    		});
    	}

    	function div1_elementresize_handler() {
    		width = this.offsetWidth;
    		$$invalidate(4, width);
    	}

    	$$self.$$set = $$props => {
    		if ("texto" in $$props) $$invalidate(0, texto = $$props.texto);
    	};

    	$$self.$capture_state = () => ({
    		onMount,
    		texto,
    		textWidth,
    		rt1,
    		rt2,
    		width,
    		duracion
    	});

    	$$self.$inject_state = $$props => {
    		if ("texto" in $$props) $$invalidate(0, texto = $$props.texto);
    		if ("textWidth" in $$props) $$invalidate(1, textWidth = $$props.textWidth);
    		if ("rt1" in $$props) $$invalidate(2, rt1 = $$props.rt1);
    		if ("rt2" in $$props) $$invalidate(3, rt2 = $$props.rt2);
    		if ("width" in $$props) $$invalidate(4, width = $$props.width);
    		if ("duracion" in $$props) $$invalidate(5, duracion = $$props.duracion);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*width, rt1, rt2*/ 28) {
    			 if (width && rt1 && rt2) {
    				$$invalidate(5, duracion = width * width / 2000);
    				rt1.classList.remove("rt1");
    				rt2.classList.remove("rt2");

    				setTimeout(
    					() => {
    						rt1.classList.add("rt1");
    						rt2.classList.add("rt2");
    					},
    					50
    				);
    			}
    		}
    	};

    	return [
    		texto,
    		textWidth,
    		rt1,
    		rt2,
    		width,
    		duracion,
    		span0_binding,
    		span0_elementresize_handler,
    		span1_binding,
    		div1_elementresize_handler
    	];
    }

    class MensajeRotativo extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$p, create_fragment$p, safe_not_equal, { texto: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "MensajeRotativo",
    			options,
    			id: create_fragment$p.name
    		});
    	}

    	get texto() {
    		throw new Error("<MensajeRotativo>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set texto(value) {
    		throw new Error("<MensajeRotativo>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\icons\more-vertical.svg generated by Svelte v3.29.0 */

    const file$q = "src\\icons\\more-vertical.svg";

    function create_fragment$q(ctx) {
    	let svg;
    	let circle0;
    	let circle1;
    	let circle2;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			circle0 = svg_element("circle");
    			circle1 = svg_element("circle");
    			circle2 = svg_element("circle");
    			attr_dev(circle0, "cx", "12");
    			attr_dev(circle0, "cy", "12");
    			attr_dev(circle0, "r", "1");
    			add_location(circle0, file$q, 0, 219, 219);
    			attr_dev(circle1, "cx", "12");
    			attr_dev(circle1, "cy", "5");
    			attr_dev(circle1, "r", "1");
    			add_location(circle1, file$q, 0, 258, 258);
    			attr_dev(circle2, "cx", "12");
    			attr_dev(circle2, "cy", "19");
    			attr_dev(circle2, "r", "1");
    			add_location(circle2, file$q, 0, 296, 296);
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "width", "24");
    			attr_dev(svg, "height", "24");
    			attr_dev(svg, "viewBox", "0 0 24 24");
    			attr_dev(svg, "fill", "none");
    			attr_dev(svg, "stroke", "currentColor");
    			attr_dev(svg, "stroke-width", "2");
    			attr_dev(svg, "stroke-linecap", "round");
    			attr_dev(svg, "stroke-linejoin", "round");
    			attr_dev(svg, "class", "feather feather-more-vertical");
    			add_location(svg, file$q, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, circle0);
    			append_dev(svg, circle1);
    			append_dev(svg, circle2);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$q.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$q($$self, $$props) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("More_vertical", slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<More_vertical> was created with unknown prop '${key}'`);
    	});

    	return [];
    }

    class More_vertical extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$q, create_fragment$q, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "More_vertical",
    			options,
    			id: create_fragment$q.name
    		});
    	}
    }

    /* src\components\Dado.svelte generated by Svelte v3.29.0 */

    const file$r = "src\\components\\Dado.svelte";

    function create_fragment$r(ctx) {
    	let div3;
    	let div0;
    	let span0;
    	let t0;
    	let span1;
    	let t1;
    	let div1;
    	let span2;
    	let t2;
    	let div2;
    	let span3;
    	let t3;
    	let span4;

    	const block = {
    		c: function create() {
    			div3 = element("div");
    			div0 = element("div");
    			span0 = element("span");
    			t0 = space();
    			span1 = element("span");
    			t1 = space();
    			div1 = element("div");
    			span2 = element("span");
    			t2 = space();
    			div2 = element("div");
    			span3 = element("span");
    			t3 = space();
    			span4 = element("span");
    			attr_dev(span0, "class", "dot svelte-8u8x8o");
    			add_location(span0, file$r, 4, 6, 69);
    			attr_dev(span1, "class", "dot svelte-8u8x8o");
    			add_location(span1, file$r, 5, 6, 102);
    			attr_dev(div0, "class", "column svelte-8u8x8o");
    			add_location(div0, file$r, 3, 4, 41);
    			attr_dev(span2, "class", "dot svelte-8u8x8o");
    			add_location(span2, file$r, 9, 6, 179);
    			attr_dev(div1, "class", "column svelte-8u8x8o");
    			add_location(div1, file$r, 8, 4, 151);
    			attr_dev(span3, "class", "dot svelte-8u8x8o");
    			add_location(span3, file$r, 13, 6, 256);
    			attr_dev(span4, "class", "dot svelte-8u8x8o");
    			add_location(span4, file$r, 14, 6, 289);
    			attr_dev(div2, "class", "column svelte-8u8x8o");
    			add_location(div2, file$r, 12, 4, 228);
    			attr_dev(div3, "class", "fifth-face dice svelte-8u8x8o");
    			add_location(div3, file$r, 1, 0, 2);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div3, anchor);
    			append_dev(div3, div0);
    			append_dev(div0, span0);
    			append_dev(div0, t0);
    			append_dev(div0, span1);
    			append_dev(div3, t1);
    			append_dev(div3, div1);
    			append_dev(div1, span2);
    			append_dev(div3, t2);
    			append_dev(div3, div2);
    			append_dev(div2, span3);
    			append_dev(div2, t3);
    			append_dev(div2, span4);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div3);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$r.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$r($$self, $$props) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Dado", slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Dado> was created with unknown prop '${key}'`);
    	});

    	return [];
    }

    class Dado extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$r, create_fragment$r, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Dado",
    			options,
    			id: create_fragment$r.name
    		});
    	}
    }

    /* src\components\Hilos\HiloPreview.svelte generated by Svelte v3.29.0 */

    const { console: console_1$8 } = globals;
    const file$s = "src\\components\\Hilos\\HiloPreview.svelte";

    // (66:0) {#if visible}
    function create_if_block$l(ctx) {
    	let li;
    	let div0;
    	let menu;
    	let t0;
    	let a;
    	let t1;
    	let div3;
    	let t2;
    	let t3;
    	let div1;
    	let t4_value = (config.categoriaPorId(/*hilo*/ ctx[0].categoriaId) || { nombreCorto: "??" }).nombreCorto + "";
    	let t4;
    	let t5;
    	let t6;
    	let t7;
    	let t8;
    	let t9;
    	let div2;
    	let t10_value = /*hilo*/ ctx[0].cantidadComentarios + "";
    	let t10;
    	let t11;
    	let h3;
    	let t12_value = /*hilo*/ ctx[0].titulo + "";
    	let t12;
    	let a_href_value;
    	let a_transition;
    	let current;
    	let mounted;
    	let dispose;

    	menu = new Menu_1({
    			props: {
    				$$slots: {
    					default: [create_default_slot$i],
    					activador: [create_activador_slot$4]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	let if_block0 = /*destellando*/ ctx[1] && create_if_block_7$3(ctx);
    	let if_block1 = /*hilo*/ ctx[0].sticky > 0 && create_if_block_6$4(ctx);
    	let if_block2 = /*hilo*/ ctx[0].nuevo && create_if_block_5$5(ctx);
    	let if_block3 = /*media*/ ctx[5].tipo == MediaType.Video && create_if_block_4$5(ctx);
    	let if_block4 = /*media*/ ctx[5].tipo == MediaType.Youtube && create_if_block_3$7(ctx);
    	let if_block5 = /*hilo*/ ctx[0].encuesta && create_if_block_2$d(ctx);
    	let if_block6 = /*hilo*/ ctx[0].dados && create_if_block_1$f(ctx);

    	const block = {
    		c: function create() {
    			li = element("li");
    			div0 = element("div");
    			create_component(menu.$$.fragment);
    			t0 = space();
    			a = element("a");
    			if (if_block0) if_block0.c();
    			t1 = space();
    			div3 = element("div");
    			if (if_block1) if_block1.c();
    			t2 = space();
    			if (if_block2) if_block2.c();
    			t3 = space();
    			div1 = element("div");
    			t4 = text(t4_value);
    			t5 = space();
    			if (if_block3) if_block3.c();
    			t6 = space();
    			if (if_block4) if_block4.c();
    			t7 = space();
    			if (if_block5) if_block5.c();
    			t8 = space();
    			if (if_block6) if_block6.c();
    			t9 = space();
    			div2 = element("div");
    			t10 = text(t10_value);
    			t11 = space();
    			h3 = element("h3");
    			t12 = text(t12_value);
    			attr_dev(div0, "class", "");
    			set_style(div0, "top", "0");
    			set_style(div0, "right", "0");
    			set_style(div0, "z-index", "232");
    			set_style(div0, "display", "flex");
    			set_style(div0, "flex-direction", "column");
    			set_style(div0, "position", "absolute");
    			add_location(div0, file$s, 70, 4, 1676);
    			attr_dev(div1, "class", "info svelte-12j5r62");
    			add_location(div1, file$s, 101, 16, 3469);
    			attr_dev(div2, "class", "info svelte-12j5r62");
    			add_location(div2, file$s, 107, 16, 4066);
    			attr_dev(div3, "class", "infos");
    			add_location(div3, file$s, 98, 12, 3133);
    			add_location(h3, file$s, 111, 12, 4170);
    			set_style(a, "background", "url(" + /*media*/ ctx[5].vistaPreviaCuadrado + ")");
    			attr_dev(a, "href", a_href_value = "/Hilo/" + /*hilo*/ ctx[0].id);
    			attr_dev(a, "class", "hilo-in");
    			add_location(a, file$s, 92, 8, 2704);
    			attr_dev(li, "class", "hilo svelte-12j5r62");
    			add_location(li, file$s, 66, 0, 1561);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			append_dev(li, div0);
    			mount_component(menu, div0, null);
    			append_dev(li, t0);
    			append_dev(li, a);
    			if (if_block0) if_block0.m(a, null);
    			append_dev(a, t1);
    			append_dev(a, div3);
    			if (if_block1) if_block1.m(div3, null);
    			append_dev(div3, t2);
    			if (if_block2) if_block2.m(div3, null);
    			append_dev(div3, t3);
    			append_dev(div3, div1);
    			append_dev(div1, t4);
    			append_dev(div3, t5);
    			if (if_block3) if_block3.m(div3, null);
    			append_dev(div3, t6);
    			if (if_block4) if_block4.m(div3, null);
    			append_dev(div3, t7);
    			if (if_block5) if_block5.m(div3, null);
    			append_dev(div3, t8);
    			if (if_block6) if_block6.m(div3, null);
    			append_dev(div3, t9);
    			append_dev(div3, div2);
    			append_dev(div2, t10);
    			append_dev(a, t11);
    			append_dev(a, h3);
    			append_dev(h3, t12);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(a, "click", /*onClick*/ ctx[7], false, false, false),
    					listen_dev(li, "mouseleave", /*mouseleave_handler*/ ctx[14], false, false, false),
    					listen_dev(li, "contextmenu", /*onContextMenu*/ ctx[8], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			const menu_changes = {};

    			if (dirty & /*$$scope, hilo, $globalStore, visible, mostrarMenu*/ 524317) {
    				menu_changes.$$scope = { dirty, ctx };
    			}

    			menu.$set(menu_changes);

    			if (/*destellando*/ ctx[1]) {
    				if (if_block0) ; else {
    					if_block0 = create_if_block_7$3(ctx);
    					if_block0.c();
    					if_block0.m(a, t1);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (/*hilo*/ ctx[0].sticky > 0) {
    				if (if_block1) {
    					if (dirty & /*hilo*/ 1) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_6$4(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div3, t2);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (/*hilo*/ ctx[0].nuevo) {
    				if (if_block2) ; else {
    					if_block2 = create_if_block_5$5(ctx);
    					if_block2.c();
    					if_block2.m(div3, t3);
    				}
    			} else if (if_block2) {
    				if_block2.d(1);
    				if_block2 = null;
    			}

    			if ((!current || dirty & /*hilo*/ 1) && t4_value !== (t4_value = (config.categoriaPorId(/*hilo*/ ctx[0].categoriaId) || { nombreCorto: "??" }).nombreCorto + "")) set_data_dev(t4, t4_value);

    			if (/*hilo*/ ctx[0].encuesta) {
    				if (if_block5) ; else {
    					if_block5 = create_if_block_2$d(ctx);
    					if_block5.c();
    					if_block5.m(div3, t8);
    				}
    			} else if (if_block5) {
    				if_block5.d(1);
    				if_block5 = null;
    			}

    			if (/*hilo*/ ctx[0].dados) {
    				if (if_block6) {
    					if (dirty & /*hilo*/ 1) {
    						transition_in(if_block6, 1);
    					}
    				} else {
    					if_block6 = create_if_block_1$f(ctx);
    					if_block6.c();
    					transition_in(if_block6, 1);
    					if_block6.m(div3, t9);
    				}
    			} else if (if_block6) {
    				group_outros();

    				transition_out(if_block6, 1, 1, () => {
    					if_block6 = null;
    				});

    				check_outros();
    			}

    			if ((!current || dirty & /*hilo*/ 1) && t10_value !== (t10_value = /*hilo*/ ctx[0].cantidadComentarios + "")) set_data_dev(t10, t10_value);
    			if ((!current || dirty & /*hilo*/ 1) && t12_value !== (t12_value = /*hilo*/ ctx[0].titulo + "")) set_data_dev(t12, t12_value);

    			if (!current || dirty & /*hilo*/ 1 && a_href_value !== (a_href_value = "/Hilo/" + /*hilo*/ ctx[0].id)) {
    				attr_dev(a, "href", a_href_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(menu.$$.fragment, local);
    			transition_in(if_block1);
    			transition_in(if_block6);

    			if (local) {
    				add_render_callback(() => {
    					if (!a_transition) a_transition = create_bidirectional_transition(a, fly, { duration: 250 }, true);
    					a_transition.run(1);
    				});
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(menu.$$.fragment, local);
    			transition_out(if_block1);
    			transition_out(if_block6);

    			if (local) {
    				if (!a_transition) a_transition = create_bidirectional_transition(a, fly, { duration: 250 }, false);
    				a_transition.run(0);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			destroy_component(menu);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (if_block2) if_block2.d();
    			if (if_block3) if_block3.d();
    			if (if_block4) if_block4.d();
    			if (if_block5) if_block5.d();
    			if (if_block6) if_block6.d();
    			if (detaching && a_transition) a_transition.end();
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$l.name,
    		type: "if",
    		source: "(66:0) {#if visible}",
    		ctx
    	});

    	return block;
    }

    // (80:20) <Icon>
    function create_default_slot_2$e(ctx) {
    	let switch_instance;
    	let switch_instance_anchor;
    	let current;
    	var switch_value = More_vertical;

    	function switch_props(ctx) {
    		return { $$inline: true };
    	}

    	if (switch_value) {
    		switch_instance = new switch_value(switch_props());
    	}

    	const block = {
    		c: function create() {
    			if (switch_instance) create_component(switch_instance.$$.fragment);
    			switch_instance_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			if (switch_instance) {
    				mount_component(switch_instance, target, anchor);
    			}

    			insert_dev(target, switch_instance_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (switch_value !== (switch_value = More_vertical)) {
    				if (switch_instance) {
    					group_outros();
    					const old_component = switch_instance;

    					transition_out(old_component.$$.fragment, 1, 0, () => {
    						destroy_component(old_component, 1);
    					});

    					check_outros();
    				}

    				if (switch_value) {
    					switch_instance = new switch_value(switch_props());
    					create_component(switch_instance.$$.fragment);
    					transition_in(switch_instance.$$.fragment, 1);
    					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
    				} else {
    					switch_instance = null;
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(switch_instance_anchor);
    			if (switch_instance) destroy_component(switch_instance, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$e.name,
    		type: "slot",
    		source: "(80:20) <Icon>",
    		ctx
    	});

    	return block;
    }

    // (79:16) <Button  icon color="white" style="margin-left: auto;"  on:click={()=> mostrarMenu = !mostrarMenu}>
    function create_default_slot_1$f(ctx) {
    	let icon;
    	let current;

    	icon = new Me({
    			props: {
    				$$slots: { default: [create_default_slot_2$e] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(icon.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(icon, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const icon_changes = {};

    			if (dirty & /*$$scope*/ 524288) {
    				icon_changes.$$scope = { dirty, ctx };
    			}

    			icon.$set(icon_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(icon, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$f.name,
    		type: "slot",
    		source: "(79:16) <Button  icon color=\\\"white\\\" style=\\\"margin-left: auto;\\\"  on:click={()=> mostrarMenu = !mostrarMenu}>",
    		ctx
    	});

    	return block;
    }

    // (78:12) <span slot="activador">
    function create_activador_slot$4(ctx) {
    	let span;
    	let button;
    	let current;

    	button = new ye({
    			props: {
    				icon: true,
    				color: "white",
    				style: "margin-left: auto;",
    				$$slots: { default: [create_default_slot_1$f] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button.$on("click", /*click_handler*/ ctx[9]);

    	const block = {
    		c: function create() {
    			span = element("span");
    			create_component(button.$$.fragment);
    			attr_dev(span, "slot", "activador");
    			add_location(span, file$s, 77, 12, 1844);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			mount_component(button, span, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button_changes = {};

    			if (dirty & /*$$scope*/ 524288) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			destroy_component(button);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_activador_slot$4.name,
    		type: "slot",
    		source: "(78:12) <span slot=\\\"activador\\\">",
    		ctx
    	});

    	return block;
    }

    // (86:12) {#if $globalStore.usuario.esAuxiliar}
    function create_if_block_8$1(ctx) {
    	let li0;
    	let t0;
    	let ripple0;
    	let t1;
    	let li1;
    	let t2;
    	let ripple1;
    	let t3;
    	let li2;
    	let t4;
    	let ripple2;
    	let current;
    	let mounted;
    	let dispose;
    	ripple0 = new he({ $$inline: true });
    	ripple1 = new he({ $$inline: true });
    	ripple2 = new he({ $$inline: true });

    	const block = {
    		c: function create() {
    			li0 = element("li");
    			t0 = text("Categoria ");
    			create_component(ripple0.$$.fragment);
    			t1 = space();
    			li1 = element("li");
    			t2 = text("Eliminar ");
    			create_component(ripple1.$$.fragment);
    			t3 = space();
    			li2 = element("li");
    			t4 = text("Banear ");
    			create_component(ripple2.$$.fragment);
    			add_location(li0, file$s, 86, 16, 2393);
    			add_location(li1, file$s, 87, 16, 2489);
    			add_location(li2, file$s, 88, 16, 2584);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li0, anchor);
    			append_dev(li0, t0);
    			mount_component(ripple0, li0, null);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, li1, anchor);
    			append_dev(li1, t2);
    			mount_component(ripple1, li1, null);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, li2, anchor);
    			append_dev(li2, t4);
    			mount_component(ripple2, li2, null);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(li0, "click", /*click_handler_2*/ ctx[11], false, false, false),
    					listen_dev(li1, "click", /*click_handler_3*/ ctx[12], false, false, false),
    					listen_dev(li2, "click", /*click_handler_4*/ ctx[13], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(ripple0.$$.fragment, local);
    			transition_in(ripple1.$$.fragment, local);
    			transition_in(ripple2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(ripple0.$$.fragment, local);
    			transition_out(ripple1.$$.fragment, local);
    			transition_out(ripple2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li0);
    			destroy_component(ripple0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(li1);
    			destroy_component(ripple1);
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(li2);
    			destroy_component(ripple2);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_8$1.name,
    		type: "if",
    		source: "(86:12) {#if $globalStore.usuario.esAuxiliar}",
    		ctx
    	});

    	return block;
    }

    // (77:8) <Menu>
    function create_default_slot$i(ctx) {
    	let t0;
    	let li0;
    	let t1_value = (/*visible*/ ctx[2] ? "Ocultar" : "Mostrar") + "";
    	let t1;
    	let t2;
    	let ripple0;
    	let t3;
    	let li1;
    	let t4;
    	let ripple1;
    	let t5;
    	let if_block_anchor;
    	let current;
    	let mounted;
    	let dispose;
    	ripple0 = new he({ $$inline: true });
    	ripple1 = new he({ $$inline: true });
    	let if_block = /*$globalStore*/ ctx[4].usuario.esAuxiliar && create_if_block_8$1(ctx);

    	const block = {
    		c: function create() {
    			t0 = space();
    			li0 = element("li");
    			t1 = text(t1_value);
    			t2 = space();
    			create_component(ripple0.$$.fragment);
    			t3 = space();
    			li1 = element("li");
    			t4 = text("Reportar ");
    			create_component(ripple1.$$.fragment);
    			t5 = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    			add_location(li0, file$s, 83, 12, 2173);
    			add_location(li1, file$s, 84, 12, 2253);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, li0, anchor);
    			append_dev(li0, t1);
    			append_dev(li0, t2);
    			mount_component(ripple0, li0, null);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, li1, anchor);
    			append_dev(li1, t4);
    			mount_component(ripple1, li1, null);
    			insert_dev(target, t5, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(li0, "click", /*toggle*/ ctx[6], false, false, false),
    					listen_dev(li1, "click", /*click_handler_1*/ ctx[10], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty & /*visible*/ 4) && t1_value !== (t1_value = (/*visible*/ ctx[2] ? "Ocultar" : "Mostrar") + "")) set_data_dev(t1, t1_value);

    			if (/*$globalStore*/ ctx[4].usuario.esAuxiliar) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*$globalStore*/ 16) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_8$1(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(ripple0.$$.fragment, local);
    			transition_in(ripple1.$$.fragment, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(ripple0.$$.fragment, local);
    			transition_out(ripple1.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(li0);
    			destroy_component(ripple0);
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(li1);
    			destroy_component(ripple1);
    			if (detaching) detach_dev(t5);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$i.name,
    		type: "slot",
    		source: "(77:8) <Menu>",
    		ctx
    	});

    	return block;
    }

    // (95:12) {#if destellando}
    function create_if_block_7$3(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			attr_dev(div, "class", "destello");
    			add_location(div, file$s, 95, 16, 2976);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_7$3.name,
    		type: "if",
    		source: "(95:12) {#if destellando}",
    		ctx
    	});

    	return block;
    }

    // (100:16) {#if hilo.sticky > 0}
    function create_if_block_6$4(ctx) {
    	let div;
    	let icon;
    	let current;

    	icon = new Me({
    			props: {
    				size: "17",
    				path: "M16,12V4H17V2H7V4H8V12L6,14V16H11.2V22H12.8V16H18V14L16,12M8.8,14L10,12.8V4H14V12.8L15.2,14H8.8Z"
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(icon.$$.fragment);
    			attr_dev(div, "class", "info sticky-info svelte-12j5r62");
    			add_location(div, file$s, 99, 38, 3192);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(icon, div, null);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(icon.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(icon.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(icon);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_6$4.name,
    		type: "if",
    		source: "(100:16) {#if hilo.sticky > 0}",
    		ctx
    	});

    	return block;
    }

    // (101:16) {#if hilo.nuevo}
    function create_if_block_5$5(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			div.textContent = "NUEVO";
    			attr_dev(div, "class", "info svelte-12j5r62");
    			set_style(div, "background", "#18222D");
    			add_location(div, file$s, 100, 33, 3390);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5$5.name,
    		type: "if",
    		source: "(101:16) {#if hilo.nuevo}",
    		ctx
    	});

    	return block;
    }

    // (103:16) {#if media.tipo == MediaType.Video}
    function create_if_block_4$5(ctx) {
    	let div;
    	let span;

    	const block = {
    		c: function create() {
    			div = element("div");
    			span = element("span");
    			attr_dev(span, "class", "fe fe-play");
    			add_location(span, file$s, 102, 97, 3696);
    			attr_dev(div, "class", "info svelte-12j5r62");
    			set_style(div, "background", "#18222D");
    			add_location(div, file$s, 102, 52, 3651);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, span);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$5.name,
    		type: "if",
    		source: "(103:16) {#if media.tipo == MediaType.Video}",
    		ctx
    	});

    	return block;
    }

    // (104:16) {#if media.tipo == MediaType.Youtube}
    function create_if_block_3$7(ctx) {
    	let div;
    	let span;

    	const block = {
    		c: function create() {
    			div = element("div");
    			span = element("span");
    			attr_dev(span, "class", "fe fe-play");
    			add_location(span, file$s, 103, 94, 3835);
    			attr_dev(div, "class", "info svelte-12j5r62");
    			attr_dev(div, "style", "var(--color5)");
    			add_location(div, file$s, 103, 54, 3795);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, span);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$7.name,
    		type: "if",
    		source: "(104:16) {#if media.tipo == MediaType.Youtube}",
    		ctx
    	});

    	return block;
    }

    // (105:16) {#if hilo.encuesta}
    function create_if_block_2$d(ctx) {
    	let div;
    	let span;

    	const block = {
    		c: function create() {
    			div = element("div");
    			span = element("span");
    			attr_dev(span, "class", "fe fe-bar-chart-2");
    			add_location(span, file$s, 104, 64, 3944);
    			attr_dev(div, "class", "info encuesta svelte-12j5r62");
    			add_location(div, file$s, 104, 36, 3916);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, span);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$d.name,
    		type: "if",
    		source: "(105:16) {#if hilo.encuesta}",
    		ctx
    	});

    	return block;
    }

    // (106:16) {#if hilo.dados}
    function create_if_block_1$f(ctx) {
    	let dado;
    	let current;
    	dado = new Dado({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(dado.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(dado, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(dado.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(dado.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(dado, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$f.name,
    		type: "if",
    		source: "(106:16) {#if hilo.dados}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$s(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*visible*/ ctx[2] && create_if_block$l(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*visible*/ ctx[2]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*visible*/ 4) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$l(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$s.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$s($$self, $$props, $$invalidate) {
    	let $globalStore;
    	validate_store(globalStore, "globalStore");
    	component_subscribe($$self, globalStore, $$value => $$invalidate(4, $globalStore = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("HiloPreview", slots, []);
    	let { hilo } = $$props;
    	if (!hilo.cantidadComentarios) hilo.cantidadComentarios = 0;
    	let categorias = config.categorias;
    	let media = hilo.media;
    	let destellando = false;
    	let visible = true;
    	let mostrarMenu = false;
    	let recienCargado = true;

    	function destellar(cantidadComentarios) {
    		if (recienCargado) {
    			recienCargado = false;
    			return;
    		}

    		$$invalidate(1, destellando = true);
    		setTimeout(() => $$invalidate(1, destellando = false), 2000);
    	}

    	async function toggle() {
    		$$invalidate(2, visible = !visible);

    		if ($globalStore.usuario.estaAutenticado) {
    			await RChanClient.agregar("ocultos", hilo.id);
    		}
    	}

    	// setInterval(() => {
    	//     hilo.cantidadComentarios+=1
    	// }, Math.random() * 5000 + 4000);
    	function onClick(e) {
    		console.log(e.target.nodeName);

    		if (e.target.nodeName == "A" || e.target.nodeName == "H3") {
    			window.location = `/Hilo/${hilo.id}`;
    		}
    	}

    	function onContextMenu(e) {
    		if (!e.ctrlKey) return;
    		e.preventDefault();
    		toggle();
    	}

    	const writable_props = ["hilo"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$8.warn(`<HiloPreview> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => $$invalidate(3, mostrarMenu = !mostrarMenu);
    	const click_handler_1 = () => abrir.reporte(hilo.id, "");
    	const click_handler_2 = () => abrir.cambiarCategoria(hilo.id);
    	const click_handler_3 = () => abrir.eliminarHilo(hilo.id, "");
    	const click_handler_4 = () => abrir.ban(hilo.id);

    	const mouseleave_handler = () => {
    		$$invalidate(3, mostrarMenu = false);
    	};

    	$$self.$$set = $$props => {
    		if ("hilo" in $$props) $$invalidate(0, hilo = $$props.hilo);
    	};

    	$$self.$capture_state = () => ({
    		Ripple: he,
    		Button: ye,
    		Icon: Me,
    		abrir,
    		Menu: Menu_1,
    		config,
    		globalStore,
    		MediaType,
    		fly,
    		more: More_vertical,
    		RChanClient,
    		Dado,
    		hilo,
    		categorias,
    		media,
    		destellando,
    		visible,
    		mostrarMenu,
    		recienCargado,
    		destellar,
    		toggle,
    		onClick,
    		onContextMenu,
    		cantidadComentarios,
    		$globalStore
    	});

    	$$self.$inject_state = $$props => {
    		if ("hilo" in $$props) $$invalidate(0, hilo = $$props.hilo);
    		if ("categorias" in $$props) categorias = $$props.categorias;
    		if ("media" in $$props) $$invalidate(5, media = $$props.media);
    		if ("destellando" in $$props) $$invalidate(1, destellando = $$props.destellando);
    		if ("visible" in $$props) $$invalidate(2, visible = $$props.visible);
    		if ("mostrarMenu" in $$props) $$invalidate(3, mostrarMenu = $$props.mostrarMenu);
    		if ("recienCargado" in $$props) recienCargado = $$props.recienCargado;
    		if ("cantidadComentarios" in $$props) $$invalidate(16, cantidadComentarios = $$props.cantidadComentarios);
    	};

    	let cantidadComentarios;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*hilo*/ 1) {
    			 $$invalidate(16, cantidadComentarios = hilo.cantidadComentarios);
    		}

    		if ($$self.$$.dirty & /*cantidadComentarios*/ 65536) {
    			 destellar();
    		}
    	};

    	return [
    		hilo,
    		destellando,
    		visible,
    		mostrarMenu,
    		$globalStore,
    		media,
    		toggle,
    		onClick,
    		onContextMenu,
    		click_handler,
    		click_handler_1,
    		click_handler_2,
    		click_handler_3,
    		click_handler_4,
    		mouseleave_handler
    	];
    }

    class HiloPreview extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$s, create_fragment$s, safe_not_equal, { hilo: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "HiloPreview",
    			options,
    			id: create_fragment$s.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*hilo*/ ctx[0] === undefined && !("hilo" in props)) {
    			console_1$8.warn("<HiloPreview> was created without expected prop 'hilo'");
    		}
    	}

    	get hilo() {
    		throw new Error("<HiloPreview>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set hilo(value) {
    		throw new Error("<HiloPreview>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\components\Moderacion\HiloPreviewMod.svelte generated by Svelte v3.29.0 */
    const file$t = "src\\components\\Moderacion\\HiloPreviewMod.svelte";

    function create_fragment$t(ctx) {
    	let div;
    	let hilopreview;
    	let current;

    	hilopreview = new HiloPreview({
    			props: { hilo: /*hilo*/ ctx[0] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(hilopreview.$$.fragment);
    			attr_dev(div, "class", "hilo-preview-mod svelte-u3ue3s");
    			toggle_class(div, "eliminado", /*hilo*/ ctx[0].estado == HiloEstado.eliminado);
    			add_location(div, file$t, 6, 4, 152);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(hilopreview, div, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const hilopreview_changes = {};
    			if (dirty & /*hilo*/ 1) hilopreview_changes.hilo = /*hilo*/ ctx[0];
    			hilopreview.$set(hilopreview_changes);

    			if (dirty & /*hilo, HiloEstado*/ 1) {
    				toggle_class(div, "eliminado", /*hilo*/ ctx[0].estado == HiloEstado.eliminado);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(hilopreview.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(hilopreview.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(hilopreview);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$t.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$t($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("HiloPreviewMod", slots, []);
    	let { hilo } = $$props;
    	const writable_props = ["hilo"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<HiloPreviewMod> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("hilo" in $$props) $$invalidate(0, hilo = $$props.hilo);
    	};

    	$$self.$capture_state = () => ({ HiloPreview, HiloEstado, hilo });

    	$$self.$inject_state = $$props => {
    		if ("hilo" in $$props) $$invalidate(0, hilo = $$props.hilo);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [hilo];
    }

    class HiloPreviewMod extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$t, create_fragment$t, safe_not_equal, { hilo: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "HiloPreviewMod",
    			options,
    			id: create_fragment$t.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*hilo*/ ctx[0] === undefined && !("hilo" in props)) {
    			console.warn("<HiloPreviewMod> was created without expected prop 'hilo'");
    		}
    	}

    	get hilo() {
    		throw new Error("<HiloPreviewMod>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set hilo(value) {
    		throw new Error("<HiloPreviewMod>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\components\Denuncia.svelte generated by Svelte v3.29.0 */

    const { Object: Object_1$4 } = globals;
    const file$u = "src\\components\\Denuncia.svelte";

    // (49:9) {:else}
    function create_else_block_1$3(ctx) {
    	let a;
    	let t_value = /*comentario*/ ctx[6].usuario.userName + "";
    	let t;
    	let a_href_value;

    	const block = {
    		c: function create() {
    			a = element("a");
    			t = text(t_value);
    			attr_dev(a, "class", "userlink svelte-u2edks");
    			attr_dev(a, "href", a_href_value = "/Moderacion/HistorialDeUsuario/" + /*comentario*/ ctx[6].usuario.id);
    			add_location(a, file$u, 49, 9, 1706);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);
    			append_dev(a, t);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block_1$3.name,
    		type: "else",
    		source: "(49:9) {:else}",
    		ctx
    	});

    	return block;
    }

    // (47:9) {#if denuncia.tipo == 0}
    function create_if_block_2$e(ctx) {
    	let a;
    	let t_value = /*hilo*/ ctx[1].usuario.userName + "";
    	let t;
    	let a_href_value;

    	const block = {
    		c: function create() {
    			a = element("a");
    			t = text(t_value);
    			attr_dev(a, "class", "userlink svelte-u2edks");
    			attr_dev(a, "href", a_href_value = "/Moderacion/HistorialDeUsuario/" + /*hilo*/ ctx[1].usuario.id);
    			add_location(a, file$u, 47, 9, 1574);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);
    			append_dev(a, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*hilo*/ 2 && t_value !== (t_value = /*hilo*/ ctx[1].usuario.userName + "")) set_data_dev(t, t_value);

    			if (dirty & /*hilo*/ 2 && a_href_value !== (a_href_value = "/Moderacion/HistorialDeUsuario/" + /*hilo*/ ctx[1].usuario.id)) {
    				attr_dev(a, "href", a_href_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$e.name,
    		type: "if",
    		source: "(47:9) {#if denuncia.tipo == 0}",
    		ctx
    	});

    	return block;
    }

    // (56:8) <Button  dense on:click={() => mostrarVistaPrevia = !mostrarVistaPrevia}>
    function create_default_slot_2$f(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Previsualizar");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$f.name,
    		type: "slot",
    		source: "(56:8) <Button  dense on:click={() => mostrarVistaPrevia = !mostrarVistaPrevia}>",
    		ctx
    	});

    	return block;
    }

    // (59:12) <Button dense  >
    function create_default_slot_1$g(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Ir");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$g.name,
    		type: "slot",
    		source: "(59:12) <Button dense  >",
    		ctx
    	});

    	return block;
    }

    // (61:8) <Button dense  on:click={rechazar}>
    function create_default_slot$j(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Rechazar");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$j.name,
    		type: "slot",
    		source: "(61:8) <Button dense  on:click={rechazar}>",
    		ctx
    	});

    	return block;
    }

    // (64:8) {:else}
    function create_else_block$5(ctx) {
    	let comentario_1;
    	let current;

    	comentario_1 = new Comentario({
    			props: { comentario: /*comentario*/ ctx[6] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(comentario_1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(comentario_1, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(comentario_1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(comentario_1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(comentario_1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$5.name,
    		type: "else",
    		source: "(64:8) {:else}",
    		ctx
    	});

    	return block;
    }

    // (62:8) {#if denuncia.tipo == 0}
    function create_if_block_1$g(ctx) {
    	let hilopreviewmod;
    	let current;

    	hilopreviewmod = new HiloPreviewMod({
    			props: { hilo: /*hilo*/ ctx[1] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(hilopreviewmod.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(hilopreviewmod, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const hilopreviewmod_changes = {};
    			if (dirty & /*hilo*/ 2) hilopreviewmod_changes.hilo = /*hilo*/ ctx[1];
    			hilopreviewmod.$set(hilopreviewmod_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(hilopreviewmod.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(hilopreviewmod.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(hilopreviewmod, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$g.name,
    		type: "if",
    		source: "(62:8) {#if denuncia.tipo == 0}",
    		ctx
    	});

    	return block;
    }

    // (67:8) {#if mostrarVistaPrevia}
    function create_if_block$m(ctx) {
    	let div;
    	let hilocuerpo;
    	let current;
    	let mounted;
    	let dispose;

    	hilocuerpo = new HiloCuerpo({
    			props: { hilo: /*hilo*/ ctx[1] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(hilocuerpo.$$.fragment);
    			attr_dev(div, "class", "vista-previa svelte-u2edks");
    			add_location(div, file$u, 67, 12, 2545);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(hilocuerpo, div, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(div, "mouseleave", /*mouseleave_handler*/ ctx[10], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			const hilocuerpo_changes = {};
    			if (dirty & /*hilo*/ 2) hilocuerpo_changes.hilo = /*hilo*/ ctx[1];
    			hilocuerpo.$set(hilocuerpo_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(hilocuerpo.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(hilocuerpo.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(hilocuerpo);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$m.name,
    		type: "if",
    		source: "(67:8) {#if mostrarVistaPrevia}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$u(ctx) {
    	let div2;
    	let div0;
    	let span;
    	let tiempo;
    	let t0;
    	let a0;
    	let t1_value = /*usuario*/ ctx[2].userName + "";
    	let t1;
    	let a0_href_value;
    	let t2;
    	let t3;
    	let t4_value = /*motivos*/ ctx[7][/*denuncia*/ ctx[0].motivo] + "";
    	let t4;
    	let t5;

    	let t6_value = (/*denuncia*/ ctx[0].aclaracion
    	? `(${/*denuncia*/ ctx[0].aclaracion})`
    	: "") + "";

    	let t6;
    	let t7;
    	let div1;
    	let button0;
    	let t8;
    	let a1;
    	let button1;
    	let a1_href_value;
    	let t9;
    	let button2;
    	let t10;
    	let current_block_type_index;
    	let if_block1;
    	let t11;
    	let current;

    	tiempo = new Tiempo({
    			props: { date: /*denuncia*/ ctx[0].creacion },
    			$$inline: true
    		});

    	function select_block_type(ctx, dirty) {
    		if (/*denuncia*/ ctx[0].tipo == 0) return create_if_block_2$e;
    		return create_else_block_1$3;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block0 = current_block_type(ctx);

    	button0 = new ye({
    			props: {
    				dense: true,
    				$$slots: { default: [create_default_slot_2$f] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button0.$on("click", /*click_handler*/ ctx[9]);

    	button1 = new ye({
    			props: {
    				dense: true,
    				$$slots: { default: [create_default_slot_1$g] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button2 = new ye({
    			props: {
    				dense: true,
    				$$slots: { default: [create_default_slot$j] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button2.$on("click", /*rechazar*/ ctx[8]);
    	const if_block_creators = [create_if_block_1$g, create_else_block$5];
    	const if_blocks = [];

    	function select_block_type_1(ctx, dirty) {
    		if (/*denuncia*/ ctx[0].tipo == 0) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type_1(ctx);
    	if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	let if_block2 = /*mostrarVistaPrevia*/ ctx[3] && create_if_block$m(ctx);

    	const block = {
    		c: function create() {
    			div2 = element("div");
    			div0 = element("div");
    			span = element("span");
    			create_component(tiempo.$$.fragment);
    			t0 = space();
    			a0 = element("a");
    			t1 = text(t1_value);
    			t2 = text("\r\n         denuncio a \r\n         ");
    			if_block0.c();
    			t3 = text("\r\n          por ");
    			t4 = text(t4_value);
    			t5 = space();
    			t6 = text(t6_value);
    			t7 = space();
    			div1 = element("div");
    			create_component(button0.$$.fragment);
    			t8 = space();
    			a1 = element("a");
    			create_component(button1.$$.fragment);
    			t9 = space();
    			create_component(button2.$$.fragment);
    			t10 = space();
    			if_block1.c();
    			t11 = space();
    			if (if_block2) if_block2.c();
    			set_style(span, "background", "var(--color2)");
    			set_style(span, "padding", "2px");
    			set_style(span, "border-radius", "4px");
    			add_location(span, file$u, 41, 8, 1266);
    			attr_dev(a0, "class", "userlink svelte-u2edks");
    			attr_dev(a0, "href", a0_href_value = "/Moderacion/HistorialDeUsuario/" + /*usuario*/ ctx[2].id);
    			add_location(a0, file$u, 44, 8, 1413);
    			attr_dev(div0, "class", "header svelte-u2edks");
    			add_location(div0, file$u, 40, 4, 1236);

    			attr_dev(a1, "href", a1_href_value = "/Hilo/" + /*hilo*/ ctx[1].id + "#" + (/*comentario*/ ctx[6] && /*comentario*/ ctx[6].id
    			? /*comentario*/ ctx[6].id
    			: ""));

    			add_location(a1, file$u, 57, 8, 2151);
    			attr_dev(div1, "class", "body");
    			add_location(div1, file$u, 54, 4, 1952);
    			attr_dev(div2, "class", "denuncia svelte-u2edks");
    			toggle_class(div2, "rechazada", /*rechazada*/ ctx[4]);
    			toggle_class(div2, "aceptada", /*aceptada*/ ctx[5]);
    			add_location(div2, file$u, 39, 0, 1176);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div2, anchor);
    			append_dev(div2, div0);
    			append_dev(div0, span);
    			mount_component(tiempo, span, null);
    			append_dev(div0, t0);
    			append_dev(div0, a0);
    			append_dev(a0, t1);
    			append_dev(div0, t2);
    			if_block0.m(div0, null);
    			append_dev(div0, t3);
    			append_dev(div0, t4);
    			append_dev(div0, t5);
    			append_dev(div0, t6);
    			append_dev(div2, t7);
    			append_dev(div2, div1);
    			mount_component(button0, div1, null);
    			append_dev(div1, t8);
    			append_dev(div1, a1);
    			mount_component(button1, a1, null);
    			append_dev(div1, t9);
    			mount_component(button2, div1, null);
    			append_dev(div1, t10);
    			if_blocks[current_block_type_index].m(div1, null);
    			append_dev(div1, t11);
    			if (if_block2) if_block2.m(div1, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const tiempo_changes = {};
    			if (dirty & /*denuncia*/ 1) tiempo_changes.date = /*denuncia*/ ctx[0].creacion;
    			tiempo.$set(tiempo_changes);
    			if ((!current || dirty & /*usuario*/ 4) && t1_value !== (t1_value = /*usuario*/ ctx[2].userName + "")) set_data_dev(t1, t1_value);

    			if (!current || dirty & /*usuario*/ 4 && a0_href_value !== (a0_href_value = "/Moderacion/HistorialDeUsuario/" + /*usuario*/ ctx[2].id)) {
    				attr_dev(a0, "href", a0_href_value);
    			}

    			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block0) {
    				if_block0.p(ctx, dirty);
    			} else {
    				if_block0.d(1);
    				if_block0 = current_block_type(ctx);

    				if (if_block0) {
    					if_block0.c();
    					if_block0.m(div0, t3);
    				}
    			}

    			if ((!current || dirty & /*denuncia*/ 1) && t4_value !== (t4_value = /*motivos*/ ctx[7][/*denuncia*/ ctx[0].motivo] + "")) set_data_dev(t4, t4_value);

    			if ((!current || dirty & /*denuncia*/ 1) && t6_value !== (t6_value = (/*denuncia*/ ctx[0].aclaracion
    			? `(${/*denuncia*/ ctx[0].aclaracion})`
    			: "") + "")) set_data_dev(t6, t6_value);

    			const button0_changes = {};

    			if (dirty & /*$$scope*/ 4096) {
    				button0_changes.$$scope = { dirty, ctx };
    			}

    			button0.$set(button0_changes);
    			const button1_changes = {};

    			if (dirty & /*$$scope*/ 4096) {
    				button1_changes.$$scope = { dirty, ctx };
    			}

    			button1.$set(button1_changes);

    			if (!current || dirty & /*hilo*/ 2 && a1_href_value !== (a1_href_value = "/Hilo/" + /*hilo*/ ctx[1].id + "#" + (/*comentario*/ ctx[6] && /*comentario*/ ctx[6].id
    			? /*comentario*/ ctx[6].id
    			: ""))) {
    				attr_dev(a1, "href", a1_href_value);
    			}

    			const button2_changes = {};

    			if (dirty & /*$$scope*/ 4096) {
    				button2_changes.$$scope = { dirty, ctx };
    			}

    			button2.$set(button2_changes);
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type_1(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block1 = if_blocks[current_block_type_index];

    				if (!if_block1) {
    					if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block1.c();
    				}

    				transition_in(if_block1, 1);
    				if_block1.m(div1, t11);
    			}

    			if (/*mostrarVistaPrevia*/ ctx[3]) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);

    					if (dirty & /*mostrarVistaPrevia*/ 8) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block$m(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(div1, null);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}

    			if (dirty & /*rechazada*/ 16) {
    				toggle_class(div2, "rechazada", /*rechazada*/ ctx[4]);
    			}

    			if (dirty & /*aceptada*/ 32) {
    				toggle_class(div2, "aceptada", /*aceptada*/ ctx[5]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(tiempo.$$.fragment, local);
    			transition_in(button0.$$.fragment, local);
    			transition_in(button1.$$.fragment, local);
    			transition_in(button2.$$.fragment, local);
    			transition_in(if_block1);
    			transition_in(if_block2);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(tiempo.$$.fragment, local);
    			transition_out(button0.$$.fragment, local);
    			transition_out(button1.$$.fragment, local);
    			transition_out(button2.$$.fragment, local);
    			transition_out(if_block1);
    			transition_out(if_block2);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div2);
    			destroy_component(tiempo);
    			if_block0.d();
    			destroy_component(button0);
    			destroy_component(button1);
    			destroy_component(button2);
    			if_blocks[current_block_type_index].d();
    			if (if_block2) if_block2.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$u.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$u($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Denuncia", slots, []);
    	const dispatch = createEventDispatcher();
    	let { denuncia } = $$props;
    	let { hilo, comentario, usuario } = denuncia;
    	usuario = usuario || { id: "", userName: "Anonimo" };
    	hilo.cantidadComentarios = "";
    	let mostrarVistaPrevia = false;
    	const motivos = Object.keys(MotivoDenuncia);

    	async function rechazar() {
    		try {
    			let res = await RChanClient.rechazarDenuncia(denuncia.id);
    			dispatch("rechazar", denuncia.id);
    			$$invalidate(0, denuncia.estado = 1, denuncia);
    		} catch(error) {
    			
    		}
    	}

    	const writable_props = ["denuncia"];

    	Object_1$4.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Denuncia> was created with unknown prop '${key}'`);
    	});

    	const click_handler = () => $$invalidate(3, mostrarVistaPrevia = !mostrarVistaPrevia);
    	const mouseleave_handler = () => $$invalidate(3, mostrarVistaPrevia = false);

    	$$self.$$set = $$props => {
    		if ("denuncia" in $$props) $$invalidate(0, denuncia = $$props.denuncia);
    	};

    	$$self.$capture_state = () => ({
    		HiloCuerpo,
    		Button: ye,
    		Tiempo,
    		Comentario,
    		RChanClient,
    		createEventDispatcher,
    		HiloPreviewMod,
    		EstadoDenuncia,
    		MotivoDenuncia,
    		dispatch,
    		denuncia,
    		hilo,
    		comentario,
    		usuario,
    		mostrarVistaPrevia,
    		motivos,
    		rechazar,
    		rechazada,
    		aceptada
    	});

    	$$self.$inject_state = $$props => {
    		if ("denuncia" in $$props) $$invalidate(0, denuncia = $$props.denuncia);
    		if ("hilo" in $$props) $$invalidate(1, hilo = $$props.hilo);
    		if ("comentario" in $$props) $$invalidate(6, comentario = $$props.comentario);
    		if ("usuario" in $$props) $$invalidate(2, usuario = $$props.usuario);
    		if ("mostrarVistaPrevia" in $$props) $$invalidate(3, mostrarVistaPrevia = $$props.mostrarVistaPrevia);
    		if ("rechazada" in $$props) $$invalidate(4, rechazada = $$props.rechazada);
    		if ("aceptada" in $$props) $$invalidate(5, aceptada = $$props.aceptada);
    	};

    	let rechazada;
    	let aceptada;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*denuncia*/ 1) {
    			 $$invalidate(4, rechazada = denuncia.estado == EstadoDenuncia.Rechazada);
    		}

    		if ($$self.$$.dirty & /*denuncia*/ 1) {
    			 $$invalidate(5, aceptada = denuncia.estado == EstadoDenuncia.Aceptada);
    		}
    	};

    	return [
    		denuncia,
    		hilo,
    		usuario,
    		mostrarVistaPrevia,
    		rechazada,
    		aceptada,
    		comentario,
    		motivos,
    		rechazar,
    		click_handler,
    		mouseleave_handler
    	];
    }

    class Denuncia extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$u, create_fragment$u, safe_not_equal, { denuncia: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Denuncia",
    			options,
    			id: create_fragment$u.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*denuncia*/ ctx[0] === undefined && !("denuncia" in props)) {
    			console.warn("<Denuncia> was created without expected prop 'denuncia'");
    		}
    	}

    	get denuncia() {
    		throw new Error("<Denuncia>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set denuncia(value) {
    		throw new Error("<Denuncia>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\components\Moderacion\DenunciasNav.svelte generated by Svelte v3.29.0 */

    const { document: document_1$1 } = globals;
    const file$v = "src\\components\\Moderacion\\DenunciasNav.svelte";

    function get_each_context$d(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[10] = list[i];
    	child_ctx[11] = list;
    	child_ctx[12] = i;
    	return child_ctx;
    }

    // (58:0) {#if $globalStore.usuario.esAuxiliar}
    function create_if_block$n(ctx) {
    	let button;
    	let t;
    	let if_block_anchor;
    	let current;

    	button = new ye({
    			props: {
    				icon: true,
    				dense: true,
    				style: "position:relative",
    				$$slots: { default: [create_default_slot$k] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button.$on("click", /*click_handler*/ ctx[6]);
    	let if_block = /*mostrar*/ ctx[1] && create_if_block_1$h(ctx);

    	const block = {
    		c: function create() {
    			create_component(button.$$.fragment);
    			t = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		m: function mount(target, anchor) {
    			mount_component(button, target, anchor);
    			insert_dev(target, t, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button_changes = {};

    			if (dirty & /*$$scope, denuncias*/ 8193) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);

    			if (/*mostrar*/ ctx[1]) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*mostrar*/ 2) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block_1$h(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(button, detaching);
    			if (detaching) detach_dev(t);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$n.name,
    		type: "if",
    		source: "(58:0) {#if $globalStore.usuario.esAuxiliar}",
    		ctx
    	});

    	return block;
    }

    // (63:8) {#if denuncias.filter(d => d.estado == EstadoDenuncia.NoRevisada).length != 0}
    function create_if_block_2$f(ctx) {
    	let div;
    	let span;
    	let t_value = /*denuncias*/ ctx[0].filter(/*func_1*/ ctx[5]).length + "";
    	let t;

    	const block = {
    		c: function create() {
    			div = element("div");
    			span = element("span");
    			t = text(t_value);
    			add_location(span, file$v, 64, 16, 2028);
    			attr_dev(div, "class", "noti-cont");
    			set_style(div, "position", "absolute");
    			add_location(div, file$v, 63, 12, 1959);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, span);
    			append_dev(span, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*denuncias*/ 1 && t_value !== (t_value = /*denuncias*/ ctx[0].filter(/*func_1*/ ctx[5]).length + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$f.name,
    		type: "if",
    		source: "(63:8) {#if denuncias.filter(d => d.estado == EstadoDenuncia.NoRevisada).length != 0}",
    		ctx
    	});

    	return block;
    }

    // (60:4) <Button icon dense on:click={() => mostrar = !mostrar } style="position:relative">
    function create_default_slot$k(ctx) {
    	let span;
    	let t;
    	let show_if = /*denuncias*/ ctx[0].filter(/*func*/ ctx[4]).length != 0;
    	let if_block_anchor;
    	let if_block = show_if && create_if_block_2$f(ctx);

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    			attr_dev(span, "class", "fe fe-alert-circle");
    			add_location(span, file$v, 61, 8, 1822);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			insert_dev(target, t, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*denuncias*/ 1) show_if = /*denuncias*/ ctx[0].filter(/*func*/ ctx[4]).length != 0;

    			if (show_if) {
    				if (if_block) {
    					if_block.p(ctx, dirty);
    				} else {
    					if_block = create_if_block_2$f(ctx);
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    			if (detaching) detach_dev(t);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$k.name,
    		type: "slot",
    		source: "(60:4) <Button icon dense on:click={() => mostrar = !mostrar } style=\\\"position:relative\\\">",
    		ctx
    	});

    	return block;
    }

    // (70:4) {#if mostrar}
    function create_if_block_1$h(ctx) {
    	let div;
    	let ul;
    	let each_blocks = [];
    	let each_1_lookup = new Map();
    	let current;
    	let each_value = /*denuncias*/ ctx[0];
    	validate_each_argument(each_value);
    	const get_key = ctx => /*d*/ ctx[10].id;
    	validate_each_keys(ctx, each_value, get_each_context$d, get_key);

    	for (let i = 0; i < each_value.length; i += 1) {
    		let child_ctx = get_each_context$d(ctx, each_value, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block$d(key, child_ctx));
    	}

    	let each_1_else = null;

    	if (!each_value.length) {
    		each_1_else = create_else_block$6(ctx);
    	}

    	const block = {
    		c: function create() {
    			div = element("div");
    			ul = element("ul");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			if (each_1_else) {
    				each_1_else.c();
    			}

    			attr_dev(ul, "class", "svelte-2zjzlq");
    			add_location(ul, file$v, 71, 12, 2232);
    			attr_dev(div, "class", "denuncias-nav svelte-2zjzlq");
    			add_location(div, file$v, 70, 8, 2191);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, ul);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(ul, null);
    			}

    			if (each_1_else) {
    				each_1_else.m(ul, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*denuncias*/ 1) {
    				const each_value = /*denuncias*/ ctx[0];
    				validate_each_argument(each_value);
    				group_outros();
    				validate_each_keys(ctx, each_value, get_each_context$d, get_key);
    				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, ul, outro_and_destroy_block, create_each_block$d, null, get_each_context$d);
    				check_outros();

    				if (each_value.length) {
    					if (each_1_else) {
    						each_1_else.d(1);
    						each_1_else = null;
    					}
    				} else if (!each_1_else) {
    					each_1_else = create_else_block$6(ctx);
    					each_1_else.c();
    					each_1_else.m(ul, null);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].d();
    			}

    			if (each_1_else) each_1_else.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$h.name,
    		type: "if",
    		source: "(70:4) {#if mostrar}",
    		ctx
    	});

    	return block;
    }

    // (75:16) {:else}
    function create_else_block$6(ctx) {
    	let h3;

    	const block = {
    		c: function create() {
    			h3 = element("h3");
    			h3.textContent = "No hay denuncias";
    			set_style(h3, "text-align", "center");
    			add_location(h3, file$v, 75, 20, 2382);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h3, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h3);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$6.name,
    		type: "else",
    		source: "(75:16) {:else}",
    		ctx
    	});

    	return block;
    }

    // (73:16) {#each denuncias as d (d.id)}
    function create_each_block$d(key_1, ctx) {
    	let first;
    	let denuncia;
    	let updating_denuncia;
    	let current;

    	function denuncia_denuncia_binding(value) {
    		/*denuncia_denuncia_binding*/ ctx[7].call(null, value, /*d*/ ctx[10], /*each_value*/ ctx[11], /*d_index*/ ctx[12]);
    	}

    	let denuncia_props = {};

    	if (/*d*/ ctx[10] !== void 0) {
    		denuncia_props.denuncia = /*d*/ ctx[10];
    	}

    	denuncia = new Denuncia({ props: denuncia_props, $$inline: true });
    	binding_callbacks.push(() => bind(denuncia, "denuncia", denuncia_denuncia_binding));

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			first = empty();
    			create_component(denuncia.$$.fragment);
    			this.first = first;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, first, anchor);
    			mount_component(denuncia, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const denuncia_changes = {};

    			if (!updating_denuncia && dirty & /*denuncias*/ 1) {
    				updating_denuncia = true;
    				denuncia_changes.denuncia = /*d*/ ctx[10];
    				add_flush_callback(() => updating_denuncia = false);
    			}

    			denuncia.$set(denuncia_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(denuncia.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(denuncia.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(first);
    			destroy_component(denuncia, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$d.name,
    		type: "each",
    		source: "(73:16) {#each denuncias as d (d.id)}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$v(ctx) {
    	let title_value;
    	let t;
    	let if_block_anchor;
    	let current;

    	document_1$1.title = title_value = "" + ((/*denunciasActivas*/ ctx[2].length != 0
    	? `{${/*denunciasActivas*/ ctx[2].length}}!`
    	: "") + " " + document.title.split("!").pop());

    	let if_block = /*$globalStore*/ ctx[3].usuario.esAuxiliar && create_if_block$n(ctx);

    	const block = {
    		c: function create() {
    			t = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if ((!current || dirty & /*denunciasActivas, document*/ 4) && title_value !== (title_value = "" + ((/*denunciasActivas*/ ctx[2].length != 0
    			? `{${/*denunciasActivas*/ ctx[2].length}}!`
    			: "") + " " + document.title.split("!").pop()))) {
    				document_1$1.title = title_value;
    			}

    			if (/*$globalStore*/ ctx[3].usuario.esAuxiliar) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*$globalStore*/ 8) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$n(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$v.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$v($$self, $$props, $$invalidate) {
    	let $globalStore;
    	validate_store(globalStore, "globalStore");
    	component_subscribe($$self, globalStore, $$value => $$invalidate(3, $globalStore = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("DenunciasNav", slots, []);
    	let denuncias = window.denuncias || [];
    	let mostrar = false;

    	if ($globalStore.usuario.esMod) {
    		Signal.subscribirAModeracion();
    	}

    	const underAttack = new Audio("/audio/underAttack.mp3");
    	const toing = new Audio("/audio/toing.mp3");

    	Signal.coneccion.on("nuevaDenuncia", denuncia => {
    		underAttack.play();
    		$$invalidate(0, denuncias = [denuncia, ...denuncias]);
    		$$invalidate(1, mostrar = true);
    	});

    	Signal.coneccion.on("denunciasRechazadas", ids => {
    		if (ids.length == 0) return;
    		toing.play();

    		$$invalidate(0, denuncias = denuncias.map(d => {
    			if (ids.includes(d.id)) d.estado = EstadoDenuncia.Rechazada;
    			return d;
    		}));
    	});

    	Signal.coneccion.on("denunciasAceptadas", ids => {
    		if (ids.length == 0) return;
    		toing.play();

    		$$invalidate(0, denuncias = denuncias.map(d => {
    			if (ids.includes(d.id)) d.estado = EstadoDenuncia.Aceptada;
    			return d;
    		}));
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<DenunciasNav> was created with unknown prop '${key}'`);
    	});

    	const func = d => d.estado == EstadoDenuncia.NoRevisada;
    	const func_1 = d => d.estado == EstadoDenuncia.NoRevisada;
    	const click_handler = () => $$invalidate(1, mostrar = !mostrar);

    	function denuncia_denuncia_binding(value, d, each_value, d_index) {
    		each_value[d_index] = value;
    		$$invalidate(0, denuncias);
    	}

    	$$self.$capture_state = () => ({
    		Ripple: he,
    		Button: ye,
    		EstadoDenuncia,
    		globalStore,
    		Signal,
    		Denuncia,
    		denuncias,
    		mostrar,
    		underAttack,
    		toing,
    		denunciasActivas,
    		$globalStore
    	});

    	$$self.$inject_state = $$props => {
    		if ("denuncias" in $$props) $$invalidate(0, denuncias = $$props.denuncias);
    		if ("mostrar" in $$props) $$invalidate(1, mostrar = $$props.mostrar);
    		if ("denunciasActivas" in $$props) $$invalidate(2, denunciasActivas = $$props.denunciasActivas);
    	};

    	let denunciasActivas;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*denuncias*/ 1) {
    			 $$invalidate(2, denunciasActivas = denuncias.filter(d => d.estado == EstadoDenuncia.NoRevisada));
    		}

    		if ($$self.$$.dirty & /*denuncias*/ 1) {
    			 if (denuncias.filter(d => d.estado == EstadoDenuncia.NoRevisada).length == 0) {
    				$$invalidate(1, mostrar = false);
    			}
    		}
    	};

    	return [
    		denuncias,
    		mostrar,
    		denunciasActivas,
    		$globalStore,
    		func,
    		func_1,
    		click_handler,
    		denuncia_denuncia_binding
    	];
    }

    class DenunciasNav extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$v, create_fragment$v, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "DenunciasNav",
    			options,
    			id: create_fragment$v.name
    		});
    	}
    }

    /* src\components\Moderacion\SelectorDeComentarios.svelte generated by Svelte v3.29.0 */
    const file$w = "src\\components\\Moderacion\\SelectorDeComentarios.svelte";

    // (15:0) {#if $selectorStore.seleccionados.size != 0}
    function create_if_block$o(ctx) {
    	let div;
    	let button;
    	let current;

    	button = new ye({
    			props: {
    				color: "var(--color5)",
    				raised: true,
    				$$slots: { default: [create_default_slot$l] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button.$on("click", /*eliminarComentariosSeleccionados*/ ctx[1]);

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(button.$$.fragment);
    			attr_dev(div, "class", "selector-comentarios svelte-rrcziw");
    			add_location(div, file$w, 15, 4, 416);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(button, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button_changes = {};

    			if (dirty & /*$$scope, $selectorStore*/ 5) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(button);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$o.name,
    		type: "if",
    		source: "(15:0) {#if $selectorStore.seleccionados.size != 0}",
    		ctx
    	});

    	return block;
    }

    // (17:8) <Button on:click={eliminarComentariosSeleccionados} color="var(--color5)" raised>
    function create_default_slot$l(ctx) {
    	let t0;
    	let t1_value = /*$selectorStore*/ ctx[0].seleccionados.size + "";
    	let t1;
    	let t2;

    	const block = {
    		c: function create() {
    			t0 = text("Eliminar ");
    			t1 = text(t1_value);
    			t2 = text(" Comentario/s");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, t2, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*$selectorStore*/ 1 && t1_value !== (t1_value = /*$selectorStore*/ ctx[0].seleccionados.size + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(t2);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$l.name,
    		type: "slot",
    		source: "(17:8) <Button on:click={eliminarComentariosSeleccionados} color=\\\"var(--color5)\\\" raised>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$w(ctx) {
    	let if_block_anchor;
    	let current;
    	let if_block = /*$selectorStore*/ ctx[0].seleccionados.size != 0 && create_if_block$o(ctx);

    	const block = {
    		c: function create() {
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*$selectorStore*/ ctx[0].seleccionados.size != 0) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*$selectorStore*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$o(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$w.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$w($$self, $$props, $$invalidate) {
    	let $selectorStore;
    	validate_store(selectorStore, "selectorStore");
    	component_subscribe($$self, selectorStore, $$value => $$invalidate(0, $selectorStore = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("SelectorDeComentarios", slots, []);

    	function eliminarComentariosSeleccionados() {
    		abrir.eliminarComentarios(Array.from($selectorStore.seleccionados));
    		set_store_value(selectorStore, $selectorStore.seleccionados = new Set([]), $selectorStore);
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<SelectorDeComentarios> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		selectorStore,
    		Button: ye,
    		abrir,
    		eliminarComentariosSeleccionados,
    		$selectorStore
    	});

    	return [$selectorStore, eliminarComentariosSeleccionados];
    }

    class SelectorDeComentarios extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$w, create_fragment$w, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "SelectorDeComentarios",
    			options,
    			id: create_fragment$w.name
    		});
    	}
    }

    /* src\components\Subir.svelte generated by Svelte v3.29.0 */

    const file$x = "src\\components\\Subir.svelte";

    function create_fragment$x(ctx) {
    	let scrolling = false;

    	let clear_scrolling = () => {
    		scrolling = false;
    	};

    	let scrolling_timeout;
    	let div;
    	let icon;
    	let mounted;
    	let dispose;
    	add_render_callback(/*onwindowscroll*/ ctx[2]);

    	const block = {
    		c: function create() {
    			div = element("div");
    			icon = element("icon");
    			attr_dev(icon, "class", "fe fe-arrow-up");
    			add_location(icon, file$x, 16, 4, 395);
    			attr_dev(div, "class", "subir svelte-1oocozg");
    			toggle_class(div, "oculta", /*oculta*/ ctx[0]);
    			add_location(div, file$x, 15, 0, 340);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, icon);

    			if (!mounted) {
    				dispose = [
    					listen_dev(window, "scroll", () => {
    						scrolling = true;
    						clearTimeout(scrolling_timeout);
    						scrolling_timeout = setTimeout(clear_scrolling, 100);
    						/*onwindowscroll*/ ctx[2]();
    					}),
    					listen_dev(div, "click", subir, false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*scrollY*/ 2 && !scrolling) {
    				scrolling = true;
    				clearTimeout(scrolling_timeout);
    				scrollTo(window.pageXOffset, /*scrollY*/ ctx[1]);
    				scrolling_timeout = setTimeout(clear_scrolling, 100);
    			}

    			if (dirty & /*oculta*/ 1) {
    				toggle_class(div, "oculta", /*oculta*/ ctx[0]);
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$x.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function subir() {
    	document.body.scrollTop = 0;
    	document.documentElement.scrollTop = 0;
    }

    function instance$x($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Subir", slots, []);
    	let oculta = true;
    	let scrollY = 0;
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Subir> was created with unknown prop '${key}'`);
    	});

    	function onwindowscroll() {
    		$$invalidate(1, scrollY = window.pageYOffset);
    	}

    	$$self.$capture_state = () => ({ oculta, scrollY, subir });

    	$$self.$inject_state = $$props => {
    		if ("oculta" in $$props) $$invalidate(0, oculta = $$props.oculta);
    		if ("scrollY" in $$props) $$invalidate(1, scrollY = $$props.scrollY);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*scrollY*/ 2) {
    			 if (scrollY > 1000) {
    				$$invalidate(0, oculta = false);
    			} else {
    				$$invalidate(0, oculta = true);
    			}
    		}
    	};

    	return [oculta, scrollY, onwindowscroll];
    }

    class Subir extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$x, create_fragment$x, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Subir",
    			options,
    			id: create_fragment$x.name
    		});
    	}
    }

    /* src\components\NavCategorias.svelte generated by Svelte v3.29.0 */

    const { console: console_1$9 } = globals;
    const file$y = "src\\components\\NavCategorias.svelte";

    function get_each_context$e(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[5] = list[i];
    	return child_ctx;
    }

    // (24:4) {#each config.categorias as c (c.id)}
    function create_each_block$e(key_1, ctx) {
    	let a;
    	let t_value = /*c*/ ctx[5].nombreCorto + "";
    	let t;
    	let a_href_value;
    	let a_title_value;

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			a = element("a");
    			t = text(t_value);
    			attr_dev(a, "class", "categoria svelte-pxbf35");
    			attr_dev(a, "href", a_href_value = "/" + /*c*/ ctx[5].nombreCorto);
    			attr_dev(a, "title", a_title_value = /*c*/ ctx[5].nombre);
    			add_location(a, file$y, 24, 8, 724);
    			this.first = a;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);
    			append_dev(a, t);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$e.name,
    		type: "each",
    		source: "(24:4) {#each config.categorias as c (c.id)}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$y(ctx) {
    	let nav;
    	let div1;
    	let div0;
    	let t0;
    	let ripple;
    	let t1;
    	let each_blocks = [];
    	let each_1_lookup = new Map();
    	let current;
    	let mounted;
    	let dispose;

    	ripple = new he({
    			props: { color: "var(--color5)" },
    			$$inline: true
    		});

    	let each_value = config.categorias;
    	validate_each_argument(each_value);
    	const get_key = ctx => /*c*/ ctx[5].id;
    	validate_each_keys(ctx, each_value, get_each_context$e, get_key);

    	for (let i = 0; i < each_value.length; i += 1) {
    		let child_ctx = get_each_context$e(ctx, each_value, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block$e(key, child_ctx));
    	}

    	const block = {
    		c: function create() {
    			nav = element("nav");
    			div1 = element("div");
    			div0 = element("div");
    			t0 = space();
    			create_component(ripple.$$.fragment);
    			t1 = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(div0, "class", "fe fe-circle");
    			add_location(div0, file$y, 20, 8, 586);
    			attr_dev(div1, "class", "colapsar-categorias categoria svelte-pxbf35");
    			add_location(div1, file$y, 19, 4, 515);
    			attr_dev(nav, "class", "nav-categorias svelte-pxbf35");
    			toggle_class(nav, "visible", /*visible*/ ctx[0]);
    			toggle_class(nav, "oculta", /*oculta*/ ctx[1]);
    			add_location(nav, file$y, 16, 0, 444);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, nav, anchor);
    			append_dev(nav, div1);
    			append_dev(div1, div0);
    			append_dev(div1, t0);
    			mount_component(ripple, div1, null);
    			append_dev(nav, t1);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(nav, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(div1, "click", /*toggle*/ ctx[3], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*config*/ 0) {
    				const each_value = config.categorias;
    				validate_each_argument(each_value);
    				validate_each_keys(ctx, each_value, get_each_context$e, get_key);
    				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, nav, destroy_block, create_each_block$e, null, get_each_context$e);
    			}

    			if (dirty & /*visible*/ 1) {
    				toggle_class(nav, "visible", /*visible*/ ctx[0]);
    			}

    			if (dirty & /*oculta*/ 2) {
    				toggle_class(nav, "oculta", /*oculta*/ ctx[1]);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(ripple.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(ripple.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(nav);
    			destroy_component(ripple);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].d();
    			}

    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$y.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$y($$self, $$props, $$invalidate) {
    	let $localConfig;
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("NavCategorias", slots, []);
    	let { visible = true } = $$props;
    	let localConfig = localStore("NavCategorias", { oculta: true });
    	validate_store(localConfig, "localConfig");
    	component_subscribe($$self, localConfig, value => $$invalidate(4, $localConfig = value));
    	console.log($localConfig);

    	function toggle(params) {
    		console.log(localConfig);
    		set_store_value(localConfig, $localConfig.oculta = !$localConfig.oculta, $localConfig);
    	}

    	const writable_props = ["visible"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$9.warn(`<NavCategorias> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("visible" in $$props) $$invalidate(0, visible = $$props.visible);
    	};

    	$$self.$capture_state = () => ({
    		config,
    		Ripple: he,
    		localStore,
    		visible,
    		localConfig,
    		toggle,
    		$localConfig,
    		oculta
    	});

    	$$self.$inject_state = $$props => {
    		if ("visible" in $$props) $$invalidate(0, visible = $$props.visible);
    		if ("localConfig" in $$props) $$invalidate(2, localConfig = $$props.localConfig);
    		if ("oculta" in $$props) $$invalidate(1, oculta = $$props.oculta);
    	};

    	let oculta;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*$localConfig*/ 16) {
    			 $$invalidate(1, oculta = $localConfig.oculta);
    		}
    	};

    	return [visible, oculta, localConfig, toggle];
    }

    class NavCategorias extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$y, create_fragment$y, safe_not_equal, { visible: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "NavCategorias",
    			options,
    			id: create_fragment$y.name
    		});
    	}

    	get visible() {
    		throw new Error("<NavCategorias>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set visible(value) {
    		throw new Error("<NavCategorias>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\components\Lucesitas.svelte generated by Svelte v3.29.0 */

    const { console: console_1$a } = globals;
    const file$z = "src\\components\\Lucesitas.svelte";

    function get_each_context$f(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[1] = list[i];
    	return child_ctx;
    }

    // (28:4) {#each luces as luz}
    function create_each_block$f(ctx) {
    	let div;
    	let div_style_value;

    	const block = {
    		c: function create() {
    			div = element("div");
    			attr_dev(div, "class", "luz svelte-16kdly2");

    			attr_dev(div, "style", div_style_value = `transform:translateX(${0}px) translateY(${0}px);
            background: red;
            opacity: ${/*luz*/ ctx[1].opacity}
            `);

    			add_location(div, file$z, 28, 8, 664);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*luces*/ 1 && div_style_value !== (div_style_value = `transform:translateX(${0}px) translateY(${0}px);
            background: red;
            opacity: ${/*luz*/ ctx[1].opacity}
            `)) {
    				attr_dev(div, "style", div_style_value);
    			}
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$f.name,
    		type: "each",
    		source: "(28:4) {#each luces as luz}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$z(ctx) {
    	let div;
    	let each_value = /*luces*/ ctx[0];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$f(get_each_context$f(ctx, each_value, i));
    	}

    	const block = {
    		c: function create() {
    			div = element("div");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(div, "class", "lucesitas svelte-16kdly2");
    			add_location(div, file$z, 26, 0, 605);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(div, null);
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*luces*/ 1) {
    				each_value = /*luces*/ ctx[0];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$f(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    					} else {
    						each_blocks[i] = create_each_block$f(child_ctx);
    						each_blocks[i].c();
    						each_blocks[i].m(div, null);
    					}
    				}

    				for (; i < each_blocks.length; i += 1) {
    					each_blocks[i].d(1);
    				}

    				each_blocks.length = each_value.length;
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$z.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function colorRandom() {
    	let colores = ["255,253,65", "126,255,76", "153,250,255", "255,136,241"];
    	return colores[Math.floor(Math.random() * colores.length)];
    }

    function instance$z($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Lucesitas", slots, []);
    	let luces = [];

    	for (let i = 0; i < 50; i++) {
    		luces.push({ color: colorRandom(), opacity: 1 });
    	}

    	luces = luces;

    	setInterval(
    		() => {
    			$$invalidate(0, luces = luces.map(l => {
    				if (Math.random() < 0.1) {
    					l.opacity = Math.random();
    				}

    				return l;
    			}));

    			$$invalidate(0, luces);
    		},
    		200
    	);

    	console.log(luces);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$a.warn(`<Lucesitas> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({ luces, colorRandom });

    	$$self.$inject_state = $$props => {
    		if ("luces" in $$props) $$invalidate(0, luces = $$props.luces);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [luces];
    }

    class Lucesitas extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$z, create_fragment$z, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Lucesitas",
    			options,
    			id: create_fragment$z.name
    		});
    	}
    }

    /* src\components\Navbar.svelte generated by Svelte v3.29.0 */

    const { window: window_1 } = globals;
    const file$A = "src\\components\\Navbar.svelte";

    // (95:12) {#if protocoloMessi}
    function create_if_block_5$6(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			attr_dev(div, "class", "messi svelte-hj9fec");
    			add_location(div, file$A, 95, 16, 3529);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_5$6.name,
    		type: "if",
    		source: "(95:12) {#if protocoloMessi}",
    		ctx
    	});

    	return block;
    }

    // (101:16) {#if $globalStore.usuario.esAuxiliar}
    function create_if_block_4$6(ctx) {
    	let a;
    	let button;
    	let current;

    	button = new ye({
    			props: {
    				icon: true,
    				dense: true,
    				$$slots: { default: [create_default_slot_2$g] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			a = element("a");
    			create_component(button.$$.fragment);
    			attr_dev(a, "href", "/Moderacion");
    			attr_dev(a, "class", "svelte-hj9fec");
    			add_location(a, file$A, 101, 20, 3737);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);
    			mount_component(button, a, null);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    			destroy_component(button);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$6.name,
    		type: "if",
    		source: "(101:16) {#if $globalStore.usuario.esAuxiliar}",
    		ctx
    	});

    	return block;
    }

    // (108:24) <Button icon dense>
    function create_default_slot_2$g(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "✡";
    			set_style(span, "top", "-1px");
    			set_style(span, "font-size", "24px");
    			set_style(span, "padding", "0 4px");
    			attr_dev(span, "class", "svelte-hj9fec");
    			add_location(span, file$A, 108, 28, 4119);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$g.name,
    		type: "slot",
    		source: "(108:24) <Button icon dense>",
    		ctx
    	});

    	return block;
    }

    // (115:16) {#if $globalStore.usuario.esAuxiliar}
    function create_if_block_3$8(ctx) {
    	let denunciasnav;
    	let current;
    	denunciasnav = new DenunciasNav({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(denunciasnav.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(denunciasnav, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(denunciasnav.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(denunciasnav.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(denunciasnav, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$8.name,
    		type: "if",
    		source: "(115:16) {#if $globalStore.usuario.esAuxiliar}",
    		ctx
    	});

    	return block;
    }

    // (121:20) <Button icon dense>
    function create_default_slot_1$h(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			attr_dev(span, "class", "fe fe-search svelte-hj9fec");
    			add_location(span, file$A, 121, 24, 4625);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$h.name,
    		type: "slot",
    		source: "(121:20) <Button icon dense>",
    		ctx
    	});

    	return block;
    }

    // (127:16) {:else}
    function create_else_block$7(ctx) {
    	let a;
    	let button;
    	let current;

    	button = new ye({
    			props: {
    				icon: true,
    				dense: true,
    				$$slots: { default: [create_default_slot$m] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			a = element("a");
    			create_component(button.$$.fragment);
    			attr_dev(a, "href", "/Login");
    			attr_dev(a, "class", "nav-boton svelte-hj9fec");
    			set_style(a, "height", "100%");
    			add_location(a, file$A, 127, 20, 4878);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);
    			mount_component(button, a, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button_changes = {};

    			if (dirty & /*$$scope*/ 2097152) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    			destroy_component(button);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$7.name,
    		type: "else",
    		source: "(127:16) {:else}",
    		ctx
    	});

    	return block;
    }

    // (125:16) {#if $globalStore.usuario.estaAutenticado}
    function create_if_block_2$g(ctx) {
    	let notificaciones_1;
    	let updating_notificaciones;
    	let current;

    	function notificaciones_1_notificaciones_binding(value) {
    		/*notificaciones_1_notificaciones_binding*/ ctx[12].call(null, value);
    	}

    	let notificaciones_1_props = {};

    	if (/*notificaciones*/ ctx[0] !== void 0) {
    		notificaciones_1_props.notificaciones = /*notificaciones*/ ctx[0];
    	}

    	notificaciones_1 = new Notificaciones({
    			props: notificaciones_1_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(notificaciones_1, "notificaciones", notificaciones_1_notificaciones_binding));

    	const block = {
    		c: function create() {
    			create_component(notificaciones_1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(notificaciones_1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const notificaciones_1_changes = {};

    			if (!updating_notificaciones && dirty & /*notificaciones*/ 1) {
    				updating_notificaciones = true;
    				notificaciones_1_changes.notificaciones = /*notificaciones*/ ctx[0];
    				add_flush_callback(() => updating_notificaciones = false);
    			}

    			notificaciones_1.$set(notificaciones_1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(notificaciones_1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(notificaciones_1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(notificaciones_1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$g.name,
    		type: "if",
    		source: "(125:16) {#if $globalStore.usuario.estaAutenticado}",
    		ctx
    	});

    	return block;
    }

    // (130:24) <Button icon dense>
    function create_default_slot$m(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			attr_dev(span, "class", "fe fe-user svelte-hj9fec");
    			add_location(span, file$A, 130, 28, 5052);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$m.name,
    		type: "slot",
    		source: "(130:24) <Button icon dense>",
    		ctx
    	});

    	return block;
    }

    // (137:12) {#if !protocoloMessi || $globalStore.usuario.esMod}
    function create_if_block_1$i(ctx) {
    	let span2;
    	let span0;
    	let t1;
    	let span1;
    	let t2;
    	let ripple;
    	let current;
    	let mounted;
    	let dispose;
    	ripple = new he({ $$inline: true });

    	const block = {
    		c: function create() {
    			span2 = element("span");
    			span0 = element("span");
    			span0.textContent = "Roz";
    			t1 = space();
    			span1 = element("span");
    			t2 = space();
    			create_component(ripple.$$.fragment);
    			set_style(span0, "width", "max-content");
    			set_style(span0, "margin-right", "6px");
    			set_style(span0, "cursor", "pointer");
    			attr_dev(span0, "class", "svelte-hj9fec");
    			add_location(span0, file$A, 138, 20, 5382);
    			attr_dev(span1, "class", "fe fe-plus-square svelte-hj9fec");
    			add_location(span1, file$A, 139, 20, 5482);
    			attr_dev(span2, "class", "nav-boton crear-hilo-boton svelte-hj9fec");
    			add_location(span2, file$A, 137, 16, 5273);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span2, anchor);
    			append_dev(span2, span0);
    			append_dev(span2, t1);
    			append_dev(span2, span1);
    			append_dev(span2, t2);
    			mount_component(ripple, span2, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(span2, "click", /*click_handler_1*/ ctx[13], false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(ripple.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(ripple.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span2);
    			destroy_component(ripple);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$i.name,
    		type: "if",
    		source: "(137:12) {#if !protocoloMessi || $globalStore.usuario.esMod}",
    		ctx
    	});

    	return block;
    }

    // (155:0) {#if $globalStore.usuario.estaAutenticado && $globalStore.usuario.esMod}
    function create_if_block$p(ctx) {
    	let selectordecomentarios;
    	let current;
    	selectordecomentarios = new SelectorDeComentarios({ $$inline: true });

    	const block = {
    		c: function create() {
    			create_component(selectordecomentarios.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(selectordecomentarios, target, anchor);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(selectordecomentarios.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(selectordecomentarios.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(selectordecomentarios, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$p.name,
    		type: "if",
    		source: "(155:0) {#if $globalStore.usuario.estaAutenticado && $globalStore.usuario.esMod}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$A(ctx) {
    	let scrolling = false;

    	let clear_scrolling = () => {
    		scrolling = false;
    	};

    	let scrolling_timeout;
    	let header;
    	let nav;
    	let div2;
    	let span0;
    	let icon;
    	let t0;
    	let ripple0;
    	let t1;
    	let a0;
    	let h3;
    	let t2;
    	let span1;
    	let t4;
    	let ripple1;
    	let t5;
    	let div0;
    	let t6;
    	let t7;
    	let div1;
    	let t8;
    	let t9;
    	let a1;
    	let button;
    	let t10;
    	let current_block_type_index;
    	let if_block3;
    	let t11;
    	let t12;
    	let formulariohilo;
    	let updating_mostrar;
    	let t13;
    	let formulariologin;
    	let t14;
    	let navcategorias;
    	let header_resize_listener;
    	let t15;
    	let menuprincipal;
    	let updating_mostrar_1;
    	let t16;
    	let dialogos;
    	let t17;
    	let t18;
    	let subir;
    	let current;
    	let mounted;
    	let dispose;
    	add_render_callback(/*onwindowscroll*/ ctx[10]);
    	ripple0 = new he({ $$inline: true });
    	ripple1 = new he({ $$inline: true });
    	let if_block0 = /*protocoloMessi*/ ctx[8] && create_if_block_5$6(ctx);
    	let if_block1 = /*$globalStore*/ ctx[7].usuario.esAuxiliar && create_if_block_4$6(ctx);
    	let if_block2 = /*$globalStore*/ ctx[7].usuario.esAuxiliar && create_if_block_3$8(ctx);

    	button = new ye({
    			props: {
    				icon: true,
    				dense: true,
    				$$slots: { default: [create_default_slot_1$h] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const if_block_creators = [create_if_block_2$g, create_else_block$7];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (/*$globalStore*/ ctx[7].usuario.estaAutenticado) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block3 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    	let if_block4 = (!/*protocoloMessi*/ ctx[8] || /*$globalStore*/ ctx[7].usuario.esMod) && create_if_block_1$i(ctx);

    	function formulariohilo_mostrar_binding(value) {
    		/*formulariohilo_mostrar_binding*/ ctx[14].call(null, value);
    	}

    	let formulariohilo_props = {};

    	if (/*mostrarFormularioHilo*/ ctx[2] !== void 0) {
    		formulariohilo_props.mostrar = /*mostrarFormularioHilo*/ ctx[2];
    	}

    	formulariohilo = new FormularioHilo({
    			props: formulariohilo_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(formulariohilo, "mostrar", formulariohilo_mostrar_binding));
    	formulariologin = new FormularioLogin({ $$inline: true });

    	navcategorias = new NavCategorias({
    			props: { visible: !/*ocultarCategorias*/ ctx[4] },
    			$$inline: true
    		});

    	function menuprincipal_mostrar_binding(value) {
    		/*menuprincipal_mostrar_binding*/ ctx[16].call(null, value);
    	}

    	let menuprincipal_props = {};

    	if (/*mostrarMenu*/ ctx[1] !== void 0) {
    		menuprincipal_props.mostrar = /*mostrarMenu*/ ctx[1];
    	}

    	menuprincipal = new MenuPrincipal({
    			props: menuprincipal_props,
    			$$inline: true
    		});

    	binding_callbacks.push(() => bind(menuprincipal, "mostrar", menuprincipal_mostrar_binding));
    	dialogos = new Dialogos({ $$inline: true });
    	let if_block5 = /*$globalStore*/ ctx[7].usuario.estaAutenticado && /*$globalStore*/ ctx[7].usuario.esMod && create_if_block$p(ctx);
    	subir = new Subir({ $$inline: true });

    	const block = {
    		c: function create() {
    			header = element("header");
    			nav = element("nav");
    			div2 = element("div");
    			span0 = element("span");
    			icon = element("icon");
    			t0 = space();
    			create_component(ripple0.$$.fragment);
    			t1 = space();
    			a0 = element("a");
    			h3 = element("h3");
    			t2 = text("ROZED ");
    			span1 = element("span");

    			span1.textContent = `${!/*protocoloMessi*/ ctx[8]
			? `Union de Religiones - Version Chad ${window.config.general.version}`
			: `Protocolo Messi activado - Version Chad ${window.config.general.version}`}`;

    			t4 = space();
    			create_component(ripple1.$$.fragment);
    			t5 = space();
    			div0 = element("div");
    			t6 = space();
    			if (if_block0) if_block0.c();
    			t7 = space();
    			div1 = element("div");
    			if (if_block1) if_block1.c();
    			t8 = space();
    			if (if_block2) if_block2.c();
    			t9 = space();
    			a1 = element("a");
    			create_component(button.$$.fragment);
    			t10 = space();
    			if_block3.c();
    			t11 = space();
    			if (if_block4) if_block4.c();
    			t12 = space();
    			create_component(formulariohilo.$$.fragment);
    			t13 = space();
    			create_component(formulariologin.$$.fragment);
    			t14 = space();
    			create_component(navcategorias.$$.fragment);
    			t15 = space();
    			create_component(menuprincipal.$$.fragment);
    			t16 = space();
    			create_component(dialogos.$$.fragment);
    			t17 = space();
    			if (if_block5) if_block5.c();
    			t18 = space();
    			create_component(subir.$$.fragment);
    			attr_dev(icon, "class", "fe fe-menu");
    			add_location(icon, file$A, 78, 16, 2576);
    			set_style(span0, "padding", "0 8px");
    			attr_dev(span0, "class", "svelte-hj9fec");
    			add_location(span0, file$A, 77, 12, 2484);
    			attr_dev(span1, "class", "version svelte-hj9fec");
    			add_location(span1, file$A, 82, 40, 2751);
    			attr_dev(h3, "class", "rozed svelte-hj9fec");
    			add_location(h3, file$A, 82, 16, 2727);
    			attr_dev(a0, "href", "/");
    			set_style(a0, "font-family", "euroFighter");
    			attr_dev(a0, "class", "svelte-hj9fec");
    			add_location(a0, file$A, 81, 12, 2664);
    			attr_dev(div0, "class", "estadisticas svelte-hj9fec");
    			add_location(div0, file$A, 87, 12, 3051);
    			attr_dev(a1, "href", "/Buscar");
    			attr_dev(a1, "class", "nav-boton svelte-hj9fec");
    			set_style(a1, "height", "100%");
    			add_location(a1, file$A, 118, 16, 4462);
    			attr_dev(div1, "class", "nav-botones svelte-hj9fec");
    			set_style(div1, "position", "relative");
    			add_location(div1, file$A, 98, 12, 3589);
    			attr_dev(div2, "class", "nav-principal svelte-hj9fec");
    			toggle_class(div2, "modoSticky", /*scrollY*/ ctx[6] > 200);
    			add_location(div2, file$A, 76, 8, 2410);
    			add_location(nav, file$A, 74, 4, 2364);
    			attr_dev(header, "class", "svelte-hj9fec");
    			add_render_callback(() => /*header_elementresize_handler*/ ctx[15].call(header));
    			toggle_class(header, "oculta", /*oculta*/ ctx[3]);
    			toggle_class(header, "protocoloMessi", /*protocoloMessi*/ ctx[8]);
    			add_location(header, file$A, 69, 0, 2272);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, header, anchor);
    			append_dev(header, nav);
    			append_dev(nav, div2);
    			append_dev(div2, span0);
    			append_dev(span0, icon);
    			append_dev(span0, t0);
    			mount_component(ripple0, span0, null);
    			append_dev(div2, t1);
    			append_dev(div2, a0);
    			append_dev(a0, h3);
    			append_dev(h3, t2);
    			append_dev(h3, span1);
    			append_dev(a0, t4);
    			mount_component(ripple1, a0, null);
    			append_dev(div2, t5);
    			append_dev(div2, div0);
    			append_dev(div2, t6);
    			if (if_block0) if_block0.m(div2, null);
    			append_dev(div2, t7);
    			append_dev(div2, div1);
    			if (if_block1) if_block1.m(div1, null);
    			append_dev(div1, t8);
    			if (if_block2) if_block2.m(div1, null);
    			append_dev(div1, t9);
    			append_dev(div1, a1);
    			mount_component(button, a1, null);
    			append_dev(div1, t10);
    			if_blocks[current_block_type_index].m(div1, null);
    			append_dev(div2, t11);
    			if (if_block4) if_block4.m(div2, null);
    			append_dev(div2, t12);
    			mount_component(formulariohilo, div2, null);
    			append_dev(div2, t13);
    			mount_component(formulariologin, div2, null);
    			append_dev(header, t14);
    			mount_component(navcategorias, header, null);
    			header_resize_listener = add_resize_listener(header, /*header_elementresize_handler*/ ctx[15].bind(header));
    			insert_dev(target, t15, anchor);
    			mount_component(menuprincipal, target, anchor);
    			insert_dev(target, t16, anchor);
    			mount_component(dialogos, target, anchor);
    			insert_dev(target, t17, anchor);
    			if (if_block5) if_block5.m(target, anchor);
    			insert_dev(target, t18, anchor);
    			mount_component(subir, target, anchor);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(window_1, "scroll", /*onScroll*/ ctx[9], false, false, false),
    					listen_dev(window_1, "scroll", () => {
    						scrolling = true;
    						clearTimeout(scrolling_timeout);
    						scrolling_timeout = setTimeout(clear_scrolling, 100);
    						/*onwindowscroll*/ ctx[10]();
    					}),
    					listen_dev(span0, "click", /*click_handler*/ ctx[11], false, false, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*scrollY*/ 64 && !scrolling) {
    				scrolling = true;
    				clearTimeout(scrolling_timeout);
    				scrollTo(window_1.pageXOffset, /*scrollY*/ ctx[6]);
    				scrolling_timeout = setTimeout(clear_scrolling, 100);
    			}

    			if (/*$globalStore*/ ctx[7].usuario.esAuxiliar) {
    				if (if_block1) {
    					if (dirty & /*$globalStore*/ 128) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_4$6(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div1, t8);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (/*$globalStore*/ ctx[7].usuario.esAuxiliar) {
    				if (if_block2) {
    					if (dirty & /*$globalStore*/ 128) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block_3$8(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(div1, t9);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}

    			const button_changes = {};

    			if (dirty & /*$$scope*/ 2097152) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block3 = if_blocks[current_block_type_index];

    				if (!if_block3) {
    					if_block3 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block3.c();
    				}

    				transition_in(if_block3, 1);
    				if_block3.m(div1, null);
    			}

    			if (!/*protocoloMessi*/ ctx[8] || /*$globalStore*/ ctx[7].usuario.esMod) {
    				if (if_block4) {
    					if_block4.p(ctx, dirty);

    					if (dirty & /*$globalStore*/ 128) {
    						transition_in(if_block4, 1);
    					}
    				} else {
    					if_block4 = create_if_block_1$i(ctx);
    					if_block4.c();
    					transition_in(if_block4, 1);
    					if_block4.m(div2, t12);
    				}
    			} else if (if_block4) {
    				group_outros();

    				transition_out(if_block4, 1, 1, () => {
    					if_block4 = null;
    				});

    				check_outros();
    			}

    			const formulariohilo_changes = {};

    			if (!updating_mostrar && dirty & /*mostrarFormularioHilo*/ 4) {
    				updating_mostrar = true;
    				formulariohilo_changes.mostrar = /*mostrarFormularioHilo*/ ctx[2];
    				add_flush_callback(() => updating_mostrar = false);
    			}

    			formulariohilo.$set(formulariohilo_changes);

    			if (dirty & /*scrollY*/ 64) {
    				toggle_class(div2, "modoSticky", /*scrollY*/ ctx[6] > 200);
    			}

    			const navcategorias_changes = {};
    			if (dirty & /*ocultarCategorias*/ 16) navcategorias_changes.visible = !/*ocultarCategorias*/ ctx[4];
    			navcategorias.$set(navcategorias_changes);

    			if (dirty & /*oculta*/ 8) {
    				toggle_class(header, "oculta", /*oculta*/ ctx[3]);
    			}

    			if (dirty & /*protocoloMessi*/ 256) {
    				toggle_class(header, "protocoloMessi", /*protocoloMessi*/ ctx[8]);
    			}

    			const menuprincipal_changes = {};

    			if (!updating_mostrar_1 && dirty & /*mostrarMenu*/ 2) {
    				updating_mostrar_1 = true;
    				menuprincipal_changes.mostrar = /*mostrarMenu*/ ctx[1];
    				add_flush_callback(() => updating_mostrar_1 = false);
    			}

    			menuprincipal.$set(menuprincipal_changes);

    			if (/*$globalStore*/ ctx[7].usuario.estaAutenticado && /*$globalStore*/ ctx[7].usuario.esMod) {
    				if (if_block5) {
    					if (dirty & /*$globalStore*/ 128) {
    						transition_in(if_block5, 1);
    					}
    				} else {
    					if_block5 = create_if_block$p(ctx);
    					if_block5.c();
    					transition_in(if_block5, 1);
    					if_block5.m(t18.parentNode, t18);
    				}
    			} else if (if_block5) {
    				group_outros();

    				transition_out(if_block5, 1, 1, () => {
    					if_block5 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(ripple0.$$.fragment, local);
    			transition_in(ripple1.$$.fragment, local);
    			transition_in(if_block1);
    			transition_in(if_block2);
    			transition_in(button.$$.fragment, local);
    			transition_in(if_block3);
    			transition_in(if_block4);
    			transition_in(formulariohilo.$$.fragment, local);
    			transition_in(formulariologin.$$.fragment, local);
    			transition_in(navcategorias.$$.fragment, local);
    			transition_in(menuprincipal.$$.fragment, local);
    			transition_in(dialogos.$$.fragment, local);
    			transition_in(if_block5);
    			transition_in(subir.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(ripple0.$$.fragment, local);
    			transition_out(ripple1.$$.fragment, local);
    			transition_out(if_block1);
    			transition_out(if_block2);
    			transition_out(button.$$.fragment, local);
    			transition_out(if_block3);
    			transition_out(if_block4);
    			transition_out(formulariohilo.$$.fragment, local);
    			transition_out(formulariologin.$$.fragment, local);
    			transition_out(navcategorias.$$.fragment, local);
    			transition_out(menuprincipal.$$.fragment, local);
    			transition_out(dialogos.$$.fragment, local);
    			transition_out(if_block5);
    			transition_out(subir.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(header);
    			destroy_component(ripple0);
    			destroy_component(ripple1);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (if_block2) if_block2.d();
    			destroy_component(button);
    			if_blocks[current_block_type_index].d();
    			if (if_block4) if_block4.d();
    			destroy_component(formulariohilo);
    			destroy_component(formulariologin);
    			destroy_component(navcategorias);
    			header_resize_listener();
    			if (detaching) detach_dev(t15);
    			destroy_component(menuprincipal, detaching);
    			if (detaching) detach_dev(t16);
    			destroy_component(dialogos, detaching);
    			if (detaching) detach_dev(t17);
    			if (if_block5) if_block5.d(detaching);
    			if (detaching) detach_dev(t18);
    			destroy_component(subir, detaching);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$A.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$A($$self, $$props, $$invalidate) {
    	let $globalStore;
    	validate_store(globalStore, "globalStore");
    	component_subscribe($$self, globalStore, $$value => $$invalidate(7, $globalStore = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Navbar", slots, []);
    	let { notificaciones = window.notificaciones || [] } = $$props;
    	let mostrarMenu = false;
    	let mostrarFormularioHilo = false;
    	let computadorasConectadas = window.estadisticas.computadorasConectadas;
    	let protocoloMessi = window.config.general.modoMessi;
    	let mostrarComputadorasConectadas = false;

    	Signal.coneccion.on("estadisticas", e => {
    		computadorasConectadas = e;
    		mostrarComputadorasConectadas = true;
    	});

    	let oculta;
    	let ocultarCategorias = false;
    	let compacta = false;
    	let prevScrollpos = window.pageYOffset;

    	function onScroll(e) {
    		compacta = !(window.pageYOffset == 0);
    		$$invalidate(4, ocultarCategorias = compacta);
    		let currentScrollPos = window.pageYOffset;
    		$$invalidate(3, oculta = currentScrollPos > prevScrollpos);
    		prevScrollpos = currentScrollPos;
    	}

    	let height = 0;

    	// $: if(height) {
    	//     try {
    	//         document.querySelector("main").style.marginTop = (height - 17) + "px"
    	//     } catch (error) {console.log(error)}
    	// }
    	if (protocoloMessi) {
    		document.body.style.setProperty("--color5", "rgb(28 185 208)");
    	}

    	let scrollY;
    	const writable_props = ["notificaciones"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Navbar> was created with unknown prop '${key}'`);
    	});

    	function onwindowscroll() {
    		$$invalidate(6, scrollY = window_1.pageYOffset);
    	}

    	const click_handler = () => $$invalidate(1, mostrarMenu = !mostrarMenu);

    	function notificaciones_1_notificaciones_binding(value) {
    		notificaciones = value;
    		$$invalidate(0, notificaciones);
    	}

    	const click_handler_1 = () => $$invalidate(2, mostrarFormularioHilo = true);

    	function formulariohilo_mostrar_binding(value) {
    		mostrarFormularioHilo = value;
    		$$invalidate(2, mostrarFormularioHilo);
    	}

    	function header_elementresize_handler() {
    		height = this.offsetHeight;
    		$$invalidate(5, height);
    	}

    	function menuprincipal_mostrar_binding(value) {
    		mostrarMenu = value;
    		$$invalidate(1, mostrarMenu);
    	}

    	$$self.$$set = $$props => {
    		if ("notificaciones" in $$props) $$invalidate(0, notificaciones = $$props.notificaciones);
    	};

    	$$self.$capture_state = () => ({
    		Ripple: he,
    		Button: ye,
    		config,
    		FormularioHilo,
    		Notificaciones,
    		MenuPrincipal,
    		FormularioLogin,
    		globalStore,
    		MensajeRotativo,
    		Dialogos,
    		DenunciasNav,
    		Signal,
    		SelectorDeComentarios,
    		Subir,
    		onMount,
    		NavCategorias,
    		Lucesitas,
    		notificaciones,
    		mostrarMenu,
    		mostrarFormularioHilo,
    		computadorasConectadas,
    		protocoloMessi,
    		mostrarComputadorasConectadas,
    		oculta,
    		ocultarCategorias,
    		compacta,
    		prevScrollpos,
    		onScroll,
    		height,
    		scrollY,
    		$globalStore
    	});

    	$$self.$inject_state = $$props => {
    		if ("notificaciones" in $$props) $$invalidate(0, notificaciones = $$props.notificaciones);
    		if ("mostrarMenu" in $$props) $$invalidate(1, mostrarMenu = $$props.mostrarMenu);
    		if ("mostrarFormularioHilo" in $$props) $$invalidate(2, mostrarFormularioHilo = $$props.mostrarFormularioHilo);
    		if ("computadorasConectadas" in $$props) computadorasConectadas = $$props.computadorasConectadas;
    		if ("protocoloMessi" in $$props) $$invalidate(8, protocoloMessi = $$props.protocoloMessi);
    		if ("mostrarComputadorasConectadas" in $$props) mostrarComputadorasConectadas = $$props.mostrarComputadorasConectadas;
    		if ("oculta" in $$props) $$invalidate(3, oculta = $$props.oculta);
    		if ("ocultarCategorias" in $$props) $$invalidate(4, ocultarCategorias = $$props.ocultarCategorias);
    		if ("compacta" in $$props) compacta = $$props.compacta;
    		if ("prevScrollpos" in $$props) prevScrollpos = $$props.prevScrollpos;
    		if ("height" in $$props) $$invalidate(5, height = $$props.height);
    		if ("scrollY" in $$props) $$invalidate(6, scrollY = $$props.scrollY);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*mostrarFormularioHilo, $globalStore*/ 132) {
    			 if (mostrarFormularioHilo && !$globalStore.usuario.estaAutenticado) {
    				window.location = "/Inicio";
    			}
    		}
    	};

    	return [
    		notificaciones,
    		mostrarMenu,
    		mostrarFormularioHilo,
    		oculta,
    		ocultarCategorias,
    		height,
    		scrollY,
    		$globalStore,
    		protocoloMessi,
    		onScroll,
    		onwindowscroll,
    		click_handler,
    		notificaciones_1_notificaciones_binding,
    		click_handler_1,
    		formulariohilo_mostrar_binding,
    		header_elementresize_handler,
    		menuprincipal_mostrar_binding
    	];
    }

    class Navbar extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$A, create_fragment$A, safe_not_equal, { notificaciones: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Navbar",
    			options,
    			id: create_fragment$A.name
    		});
    	}

    	get notificaciones() {
    		throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set notificaciones(value) {
    		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\svelte-infinite-loading\src\Spinner.svelte generated by Svelte v3.29.0 */

    const file$B = "node_modules\\svelte-infinite-loading\\src\\Spinner.svelte";

    // (49:0) {:else}
    function create_else_block$8(ctx) {
    	let i;

    	const block = {
    		c: function create() {
    			i = element("i");
    			attr_dev(i, "class", "loading-default svelte-10h86fq");
    			add_location(i, file$B, 51, 1, 1184);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, i, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(i);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$8.name,
    		type: "else",
    		source: "(49:0) {:else}",
    		ctx
    	});

    	return block;
    }

    // (38:33) 
    function create_if_block_3$9(ctx) {
    	let span5;
    	let span0;
    	let t0;
    	let span1;
    	let t1;
    	let span2;
    	let t2;
    	let span3;
    	let t3;
    	let span4;

    	const block = {
    		c: function create() {
    			span5 = element("span");
    			span0 = element("span");
    			t0 = space();
    			span1 = element("span");
    			t1 = space();
    			span2 = element("span");
    			t2 = space();
    			span3 = element("span");
    			t3 = space();
    			span4 = element("span");
    			attr_dev(span0, "class", "wave-item svelte-10h86fq");
    			add_location(span0, file$B, 41, 2, 978);
    			attr_dev(span1, "class", "wave-item svelte-10h86fq");
    			add_location(span1, file$B, 42, 2, 1012);
    			attr_dev(span2, "class", "wave-item svelte-10h86fq");
    			add_location(span2, file$B, 43, 2, 1046);
    			attr_dev(span3, "class", "wave-item svelte-10h86fq");
    			add_location(span3, file$B, 44, 2, 1080);
    			attr_dev(span4, "class", "wave-item svelte-10h86fq");
    			add_location(span4, file$B, 45, 2, 1114);
    			attr_dev(span5, "class", "loading-wave-dots svelte-10h86fq");
    			add_location(span5, file$B, 40, 1, 943);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span5, anchor);
    			append_dev(span5, span0);
    			append_dev(span5, t0);
    			append_dev(span5, span1);
    			append_dev(span5, t1);
    			append_dev(span5, span2);
    			append_dev(span5, t2);
    			append_dev(span5, span3);
    			append_dev(span5, t3);
    			append_dev(span5, span4);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span5);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$9.name,
    		type: "if",
    		source: "(38:33) ",
    		ctx
    	});

    	return block;
    }

    // (33:31) 
    function create_if_block_2$h(ctx) {
    	let i;

    	const block = {
    		c: function create() {
    			i = element("i");
    			attr_dev(i, "class", "loading-spiral svelte-10h86fq");
    			add_location(i, file$B, 35, 1, 856);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, i, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(i);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$h.name,
    		type: "if",
    		source: "(33:31) ",
    		ctx
    	});

    	return block;
    }

    // (19:32) 
    function create_if_block_1$j(ctx) {
    	let span8;
    	let span0;
    	let t0;
    	let span1;
    	let t1;
    	let span2;
    	let t2;
    	let span3;
    	let t3;
    	let span4;
    	let t4;
    	let span5;
    	let t5;
    	let span6;
    	let t6;
    	let span7;

    	const block = {
    		c: function create() {
    			span8 = element("span");
    			span0 = element("span");
    			t0 = space();
    			span1 = element("span");
    			t1 = space();
    			span2 = element("span");
    			t2 = space();
    			span3 = element("span");
    			t3 = space();
    			span4 = element("span");
    			t4 = space();
    			span5 = element("span");
    			t5 = space();
    			span6 = element("span");
    			t6 = space();
    			span7 = element("span");
    			attr_dev(span0, "class", "circle-item svelte-10h86fq");
    			add_location(span0, file$B, 22, 2, 509);
    			attr_dev(span1, "class", "circle-item svelte-10h86fq");
    			add_location(span1, file$B, 23, 2, 545);
    			attr_dev(span2, "class", "circle-item svelte-10h86fq");
    			add_location(span2, file$B, 24, 2, 581);
    			attr_dev(span3, "class", "circle-item svelte-10h86fq");
    			add_location(span3, file$B, 25, 2, 617);
    			attr_dev(span4, "class", "circle-item svelte-10h86fq");
    			add_location(span4, file$B, 26, 2, 653);
    			attr_dev(span5, "class", "circle-item svelte-10h86fq");
    			add_location(span5, file$B, 27, 2, 689);
    			attr_dev(span6, "class", "circle-item svelte-10h86fq");
    			add_location(span6, file$B, 28, 2, 725);
    			attr_dev(span7, "class", "circle-item svelte-10h86fq");
    			add_location(span7, file$B, 29, 2, 761);
    			attr_dev(span8, "class", "loading-circles svelte-10h86fq");
    			add_location(span8, file$B, 21, 1, 476);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span8, anchor);
    			append_dev(span8, span0);
    			append_dev(span8, t0);
    			append_dev(span8, span1);
    			append_dev(span8, t1);
    			append_dev(span8, span2);
    			append_dev(span8, t2);
    			append_dev(span8, span3);
    			append_dev(span8, t3);
    			append_dev(span8, span4);
    			append_dev(span8, t4);
    			append_dev(span8, span5);
    			append_dev(span8, t5);
    			append_dev(span8, span6);
    			append_dev(span8, t6);
    			append_dev(span8, span7);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span8);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$j.name,
    		type: "if",
    		source: "(19:32) ",
    		ctx
    	});

    	return block;
    }

    // (5:0) {#if spinner === 'bubbles'}
    function create_if_block$q(ctx) {
    	let span8;
    	let span0;
    	let t0;
    	let span1;
    	let t1;
    	let span2;
    	let t2;
    	let span3;
    	let t3;
    	let span4;
    	let t4;
    	let span5;
    	let t5;
    	let span6;
    	let t6;
    	let span7;

    	const block = {
    		c: function create() {
    			span8 = element("span");
    			span0 = element("span");
    			t0 = space();
    			span1 = element("span");
    			t1 = space();
    			span2 = element("span");
    			t2 = space();
    			span3 = element("span");
    			t3 = space();
    			span4 = element("span");
    			t4 = space();
    			span5 = element("span");
    			t5 = space();
    			span6 = element("span");
    			t6 = space();
    			span7 = element("span");
    			attr_dev(span0, "class", "bubble-item svelte-10h86fq");
    			add_location(span0, file$B, 8, 2, 127);
    			attr_dev(span1, "class", "bubble-item svelte-10h86fq");
    			add_location(span1, file$B, 9, 2, 163);
    			attr_dev(span2, "class", "bubble-item svelte-10h86fq");
    			add_location(span2, file$B, 10, 2, 199);
    			attr_dev(span3, "class", "bubble-item svelte-10h86fq");
    			add_location(span3, file$B, 11, 2, 235);
    			attr_dev(span4, "class", "bubble-item svelte-10h86fq");
    			add_location(span4, file$B, 12, 2, 271);
    			attr_dev(span5, "class", "bubble-item svelte-10h86fq");
    			add_location(span5, file$B, 13, 2, 307);
    			attr_dev(span6, "class", "bubble-item svelte-10h86fq");
    			add_location(span6, file$B, 14, 2, 343);
    			attr_dev(span7, "class", "bubble-item svelte-10h86fq");
    			add_location(span7, file$B, 15, 2, 379);
    			attr_dev(span8, "class", "loading-bubbles svelte-10h86fq");
    			add_location(span8, file$B, 7, 1, 94);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span8, anchor);
    			append_dev(span8, span0);
    			append_dev(span8, t0);
    			append_dev(span8, span1);
    			append_dev(span8, t1);
    			append_dev(span8, span2);
    			append_dev(span8, t2);
    			append_dev(span8, span3);
    			append_dev(span8, t3);
    			append_dev(span8, span4);
    			append_dev(span8, t4);
    			append_dev(span8, span5);
    			append_dev(span8, t5);
    			append_dev(span8, span6);
    			append_dev(span8, t6);
    			append_dev(span8, span7);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span8);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$q.name,
    		type: "if",
    		source: "(5:0) {#if spinner === 'bubbles'}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$B(ctx) {
    	let if_block_anchor;

    	function select_block_type(ctx, dirty) {
    		if (/*spinner*/ ctx[0] === "bubbles") return create_if_block$q;
    		if (/*spinner*/ ctx[0] === "circles") return create_if_block_1$j;
    		if (/*spinner*/ ctx[0] === "spiral") return create_if_block_2$h;
    		if (/*spinner*/ ctx[0] === "wavedots") return create_if_block_3$9;
    		return create_else_block$8;
    	}

    	let current_block_type = select_block_type(ctx);
    	let if_block = current_block_type(ctx);

    	const block = {
    		c: function create() {
    			if_block.c();
    			if_block_anchor = empty();
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    		},
    		p: function update(ctx, [dirty]) {
    			if (current_block_type !== (current_block_type = select_block_type(ctx))) {
    				if_block.d(1);
    				if_block = current_block_type(ctx);

    				if (if_block) {
    					if_block.c();
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			}
    		},
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$B.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$B($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Spinner", slots, []);
    	let { spinner = "" } = $$props;
    	const writable_props = ["spinner"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Spinner> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("spinner" in $$props) $$invalidate(0, spinner = $$props.spinner);
    	};

    	$$self.$capture_state = () => ({ spinner });

    	$$self.$inject_state = $$props => {
    		if ("spinner" in $$props) $$invalidate(0, spinner = $$props.spinner);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [spinner];
    }

    class Spinner$1 extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$B, create_fragment$B, safe_not_equal, { spinner: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Spinner",
    			options,
    			id: create_fragment$B.name
    		});
    	}

    	get spinner() {
    		throw new Error("<Spinner>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set spinner(value) {
    		throw new Error("<Spinner>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* node_modules\svelte-infinite-loading\src\InfiniteLoading.svelte generated by Svelte v3.29.0 */

    const { Object: Object_1$5, console: console_1$b } = globals;
    const file$C = "node_modules\\svelte-infinite-loading\\src\\InfiniteLoading.svelte";
    const get_error_slot_changes = dirty => ({});
    const get_error_slot_context = ctx => ({ attemptLoad: /*attemptLoad*/ ctx[7] });
    const get_noMore_slot_changes = dirty => ({});
    const get_noMore_slot_context = ctx => ({});
    const get_noResults_slot_changes = dirty => ({});
    const get_noResults_slot_context = ctx => ({});
    const get_spinner_slot_changes = dirty => ({ isFirstLoad: dirty & /*isFirstLoad*/ 2 });
    const get_spinner_slot_context = ctx => ({ isFirstLoad: /*isFirstLoad*/ ctx[1] });

    // (323:1) {#if showSpinner}
    function create_if_block_3$a(ctx) {
    	let div;
    	let current;
    	const spinner_slot_template = /*#slots*/ ctx[13].spinner;
    	const spinner_slot = create_slot(spinner_slot_template, ctx, /*$$scope*/ ctx[12], get_spinner_slot_context);
    	const spinner_slot_or_fallback = spinner_slot || fallback_block_3(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (spinner_slot_or_fallback) spinner_slot_or_fallback.c();
    			attr_dev(div, "class", "infinite-status-prompt");
    			add_location(div, file$C, 323, 2, 8082);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (spinner_slot_or_fallback) {
    				spinner_slot_or_fallback.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (spinner_slot) {
    				if (spinner_slot.p && dirty & /*$$scope, isFirstLoad*/ 4098) {
    					update_slot(spinner_slot, spinner_slot_template, ctx, /*$$scope*/ ctx[12], dirty, get_spinner_slot_changes, get_spinner_slot_context);
    				}
    			} else {
    				if (spinner_slot_or_fallback && spinner_slot_or_fallback.p && dirty & /*spinner*/ 1) {
    					spinner_slot_or_fallback.p(ctx, dirty);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(spinner_slot_or_fallback, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(spinner_slot_or_fallback, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (spinner_slot_or_fallback) spinner_slot_or_fallback.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$a.name,
    		type: "if",
    		source: "(323:1) {#if showSpinner}",
    		ctx
    	});

    	return block;
    }

    // (325:38)      
    function fallback_block_3(ctx) {
    	let spinner_1;
    	let current;

    	spinner_1 = new Spinner$1({
    			props: { spinner: /*spinner*/ ctx[0] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(spinner_1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(spinner_1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const spinner_1_changes = {};
    			if (dirty & /*spinner*/ 1) spinner_1_changes.spinner = /*spinner*/ ctx[0];
    			spinner_1.$set(spinner_1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(spinner_1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(spinner_1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(spinner_1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block_3.name,
    		type: "fallback",
    		source: "(325:38)      ",
    		ctx
    	});

    	return block;
    }

    // (331:1) {#if showNoResults}
    function create_if_block_2$i(ctx) {
    	let div;
    	let current;
    	const noResults_slot_template = /*#slots*/ ctx[13].noResults;
    	const noResults_slot = create_slot(noResults_slot_template, ctx, /*$$scope*/ ctx[12], get_noResults_slot_context);
    	const noResults_slot_or_fallback = noResults_slot || fallback_block_2(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (noResults_slot_or_fallback) noResults_slot_or_fallback.c();
    			attr_dev(div, "class", "infinite-status-prompt");
    			add_location(div, file$C, 331, 2, 8235);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (noResults_slot_or_fallback) {
    				noResults_slot_or_fallback.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (noResults_slot) {
    				if (noResults_slot.p && dirty & /*$$scope*/ 4096) {
    					update_slot(noResults_slot, noResults_slot_template, ctx, /*$$scope*/ ctx[12], dirty, get_noResults_slot_changes, get_noResults_slot_context);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(noResults_slot_or_fallback, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(noResults_slot_or_fallback, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (noResults_slot_or_fallback) noResults_slot_or_fallback.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$i.name,
    		type: "if",
    		source: "(331:1) {#if showNoResults}",
    		ctx
    	});

    	return block;
    }

    // (333:26)      No results :(    
    function fallback_block_2(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("No results :(");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block_2.name,
    		type: "fallback",
    		source: "(333:26)      No results :(    ",
    		ctx
    	});

    	return block;
    }

    // (339:1) {#if showNoMore}
    function create_if_block_1$k(ctx) {
    	let div;
    	let current;
    	const noMore_slot_template = /*#slots*/ ctx[13].noMore;
    	const noMore_slot = create_slot(noMore_slot_template, ctx, /*$$scope*/ ctx[12], get_noMore_slot_context);
    	const noMore_slot_or_fallback = noMore_slot || fallback_block_1$1(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (noMore_slot_or_fallback) noMore_slot_or_fallback.c();
    			attr_dev(div, "class", "infinite-status-prompt");
    			add_location(div, file$C, 339, 2, 8365);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (noMore_slot_or_fallback) {
    				noMore_slot_or_fallback.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (noMore_slot) {
    				if (noMore_slot.p && dirty & /*$$scope*/ 4096) {
    					update_slot(noMore_slot, noMore_slot_template, ctx, /*$$scope*/ ctx[12], dirty, get_noMore_slot_changes, get_noMore_slot_context);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(noMore_slot_or_fallback, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(noMore_slot_or_fallback, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (noMore_slot_or_fallback) noMore_slot_or_fallback.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$k.name,
    		type: "if",
    		source: "(339:1) {#if showNoMore}",
    		ctx
    	});

    	return block;
    }

    // (341:23)      No more data :)    
    function fallback_block_1$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("No more data :)");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block_1$1.name,
    		type: "fallback",
    		source: "(341:23)      No more data :)    ",
    		ctx
    	});

    	return block;
    }

    // (347:1) {#if showError}
    function create_if_block$r(ctx) {
    	let div;
    	let current;
    	const error_slot_template = /*#slots*/ ctx[13].error;
    	const error_slot = create_slot(error_slot_template, ctx, /*$$scope*/ ctx[12], get_error_slot_context);
    	const error_slot_or_fallback = error_slot || fallback_block(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (error_slot_or_fallback) error_slot_or_fallback.c();
    			attr_dev(div, "class", "infinite-status-prompt");
    			add_location(div, file$C, 347, 2, 8493);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);

    			if (error_slot_or_fallback) {
    				error_slot_or_fallback.m(div, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if (error_slot) {
    				if (error_slot.p && dirty & /*$$scope*/ 4096) {
    					update_slot(error_slot, error_slot_template, ctx, /*$$scope*/ ctx[12], dirty, get_error_slot_changes, get_error_slot_context);
    				}
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(error_slot_or_fallback, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(error_slot_or_fallback, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (error_slot_or_fallback) error_slot_or_fallback.d(detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$r.name,
    		type: "if",
    		source: "(347:1) {#if showError}",
    		ctx
    	});

    	return block;
    }

    // (349:36)      Oops, something went wrong :(     
    function fallback_block(ctx) {
    	let t0;
    	let br;
    	let t1;
    	let button;
    	let mounted;
    	let dispose;

    	const block = {
    		c: function create() {
    			t0 = text("Oops, something went wrong :(\n\t\t\t\t");
    			br = element("br");
    			t1 = space();
    			button = element("button");
    			button.textContent = "Retry";
    			add_location(br, file$C, 350, 4, 8605);
    			attr_dev(button, "class", "btn-try-infinite svelte-o3w4bf");
    			add_location(button, file$C, 351, 4, 8614);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, br, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, button, anchor);

    			if (!mounted) {
    				dispose = listen_dev(button, "click", /*attemptLoad*/ ctx[7], false, false, false);
    				mounted = true;
    			}
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(br);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: fallback_block.name,
    		type: "fallback",
    		source: "(349:36)      Oops, something went wrong :(     ",
    		ctx
    	});

    	return block;
    }

    function create_fragment$C(ctx) {
    	let div;
    	let t0;
    	let t1;
    	let t2;
    	let current;
    	let if_block0 = /*showSpinner*/ ctx[3] && create_if_block_3$a(ctx);
    	let if_block1 = /*showNoResults*/ ctx[5] && create_if_block_2$i(ctx);
    	let if_block2 = /*showNoMore*/ ctx[6] && create_if_block_1$k(ctx);
    	let if_block3 = /*showError*/ ctx[4] && create_if_block$r(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			if (if_block0) if_block0.c();
    			t0 = space();
    			if (if_block1) if_block1.c();
    			t1 = space();
    			if (if_block2) if_block2.c();
    			t2 = space();
    			if (if_block3) if_block3.c();
    			attr_dev(div, "class", "infinite-loading-container svelte-o3w4bf");
    			add_location(div, file$C, 321, 0, 7996);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			if (if_block0) if_block0.m(div, null);
    			append_dev(div, t0);
    			if (if_block1) if_block1.m(div, null);
    			append_dev(div, t1);
    			if (if_block2) if_block2.m(div, null);
    			append_dev(div, t2);
    			if (if_block3) if_block3.m(div, null);
    			/*div_binding*/ ctx[14](div);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*showSpinner*/ ctx[3]) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty & /*showSpinner*/ 8) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_3$a(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(div, t0);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (/*showNoResults*/ ctx[5]) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty & /*showNoResults*/ 32) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_2$i(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div, t1);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (/*showNoMore*/ ctx[6]) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);

    					if (dirty & /*showNoMore*/ 64) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block_1$k(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(div, t2);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}

    			if (/*showError*/ ctx[4]) {
    				if (if_block3) {
    					if_block3.p(ctx, dirty);

    					if (dirty & /*showError*/ 16) {
    						transition_in(if_block3, 1);
    					}
    				} else {
    					if_block3 = create_if_block$r(ctx);
    					if_block3.c();
    					transition_in(if_block3, 1);
    					if_block3.m(div, null);
    				}
    			} else if (if_block3) {
    				group_outros();

    				transition_out(if_block3, 1, 1, () => {
    					if_block3 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block1);
    			transition_in(if_block2);
    			transition_in(if_block3);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block1);
    			transition_out(if_block2);
    			transition_out(if_block3);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (if_block2) if_block2.d();
    			if (if_block3) if_block3.d();
    			/*div_binding*/ ctx[14](null);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$C.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    const STATUS = {
    	READY: 0,
    	LOADING: 1,
    	COMPLETE: 2,
    	ERROR: 3
    };

    const THROTTLE_LIMIT = 50;
    const LOOP_CHECK_TIMEOUT = 1000;
    const LOOP_CHECK_MAX_CALLS = 10;

    const ERROR_INFINITE_LOOP = [
    	`executed the callback function more than ${LOOP_CHECK_MAX_CALLS} times for a short time, it looks like searched a wrong scroll wrapper that doest not has fixed height or maximum height, please check it. If you want to force to set a element as scroll wrapper rather than automatic searching, you can do this:`,
    	"<!-- add a special attribute for the real scroll wrapper (can also be data-infinite-wrapper) -->",
    	"<div infinite-wrapper>",
    	"  ...",
    	"  <!-- set forceUseInfiniteWrapper -->",
    	"  <InfiniteLoading forceUseInfiniteWrapper>",
    	"</div>",
    	"or",
    	"<div class=\"infinite-wrapper\">",
    	"  ...",
    	"  <!-- set forceUseInfiniteWrapper as css selector of the real scroll wrapper -->",
    	"  <InfiniteLoading forceUseInfiniteWrapper=\".infinite-wrapper\" />",
    	"</div>"
    ].join("\n");

    /**
     * the third argument for event bundler
     * @see https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md
     */
    const thirdEventArg = (() => {
    	let result = false;

    	try {
    		const arg = Object.defineProperty({}, "passive", {
    			get() {
    				result = { passive: true };
    				return true;
    			}
    		});

    		window.addEventListener("testpassive", arg, arg);
    		window.remove("testpassive", arg, arg);
    	} catch(e) {
    		
    	} /* */

    	return result;
    })();

    const throttler = {
    	timers: [],
    	caches: [],
    	throttle(fn) {
    		if (this.caches.indexOf(fn) === -1) {
    			// cache current handler
    			this.caches.push(fn);

    			// save timer for current handler
    			this.timers.push(setTimeout(
    				() => {
    					fn();

    					// empty cache and timer
    					this.caches.splice(this.caches.indexOf(fn), 1);

    					this.timers.shift();
    				},
    				THROTTLE_LIMIT
    			));
    		}
    	},
    	reset() {
    		// reset all timers
    		this.timers.forEach(timer => {
    			clearTimeout(timer);
    		});

    		this.timers.length = 0;

    		// empty caches
    		this.caches = [];
    	}
    };

    const loopTracker = {
    	isChecked: false,
    	timer: null,
    	times: 0,
    	track() {
    		// record track times
    		this.times += 1;

    		// try to mark check status
    		clearTimeout(this.timer);

    		this.timer = setTimeout(
    			() => {
    				this.isChecked = true;
    			},
    			LOOP_CHECK_TIMEOUT
    		);

    		// throw warning if the times of continuous calls large than the maximum times
    		if (this.times > LOOP_CHECK_MAX_CALLS) {
    			console.error(ERROR_INFINITE_LOOP);
    			this.isChecked = true;
    		}
    	}
    };

    const scrollBarStorage = {
    	key: "_infiniteScrollHeight",
    	getScrollElement(element) {
    		return element === window ? document.documentElement : element;
    	},
    	save(element) {
    		const target = this.getScrollElement(element);

    		// save scroll height on the scroll parent
    		target[this.key] = target.scrollHeight;
    	},
    	restore(element) {
    		const target = this.getScrollElement(element);

    		/* istanbul ignore else */
    		if (typeof target[this.key] === "number") {
    			target.scrollTop = target.scrollHeight - target[this.key] + target.scrollTop;
    		}

    		this.remove(target);
    	},
    	remove(element) {
    		if (element[this.key] !== undefined) {
    			// remove scroll height
    			delete element[this.key]; // eslint-disable-line no-param-reassign
    		}
    	}
    };

    function isVisible(element) {
    	return element.offsetWidth + element.offsetHeight > 0;
    }

    function instance$C($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("InfiniteLoading", slots, ['spinner','noResults','noMore','error']);
    	const dispatch = createEventDispatcher();
    	let { distance = 100 } = $$props;
    	let { spinner = "" } = $$props;
    	let { direction = "bottom" } = $$props;
    	let { forceUseInfiniteWrapper = false } = $$props;
    	let { identifier = +new Date() } = $$props;
    	let isFirstLoad = true; // save the current loading whether it is the first loading
    	let status = STATUS.READY;
    	let mounted = false;
    	let thisElement;
    	let scrollParent;

    	const stateChanger = {
    		loaded: async () => {
    			$$invalidate(1, isFirstLoad = false);

    			if (direction === "top") {
    				// wait for DOM updated
    				await tick();

    				scrollBarStorage.restore(scrollParent);
    			}

    			if (status === STATUS.LOADING) {
    				await tick();
    				await attemptLoad(true);
    			}
    		},
    		complete: async () => {
    			$$invalidate(15, status = STATUS.COMPLETE);

    			// force re-complation computed properties to fix the problem of get slot text delay
    			await tick();

    			scrollParent.removeEventListener("scroll", scrollHandler, thirdEventArg);
    		},
    		reset: async () => {
    			$$invalidate(15, status = STATUS.READY);
    			$$invalidate(1, isFirstLoad = true);
    			scrollBarStorage.remove(scrollParent);
    			scrollParent.addEventListener("scroll", scrollHandler, thirdEventArg);

    			// wait for list to be empty and the empty action may trigger a scroll event
    			setTimeout(
    				() => {
    					throttler.reset();
    					scrollHandler();
    				},
    				1
    			);
    		},
    		error: () => {
    			$$invalidate(15, status = STATUS.ERROR);
    			throttler.reset();
    		}
    	};

    	function scrollHandler(event) {
    		if (status === STATUS.READY) {
    			if (event && event.constructor === Event && isVisible(thisElement)) {
    				throttler.throttle(attemptLoad);
    			} else {
    				attemptLoad();
    			}
    		}
    	}

    	// Attempt to trigger load
    	async function attemptLoad(isContinuousCall) {
    		if (status !== STATUS.COMPLETE && isVisible(thisElement) && getCurrentDistance() <= distance) {
    			$$invalidate(15, status = STATUS.LOADING);

    			if (direction === "top") {
    				// wait for spinner display
    				await tick();

    				scrollBarStorage.save(scrollParent);
    			}

    			dispatch("infinite", stateChanger);

    			if (isContinuousCall && !forceUseInfiniteWrapper && !loopTracker.isChecked) {
    				// check this component whether be in an infinite loop if it is not checked
    				loopTracker.track();
    			}
    		} else if (status === STATUS.LOADING) {
    			$$invalidate(15, status = STATUS.READY);
    		}
    	}

    	// Get current distance from the specified direction
    	function getCurrentDistance() {
    		let distance;

    		if (direction === "top") {
    			distance = typeof scrollParent.scrollTop === "number"
    			? scrollParent.scrollTop
    			: scrollParent.pageYOffset;
    		} else {
    			const infiniteElementOffsetTopFromBottom = thisElement.getBoundingClientRect().top;

    			const scrollElementOffsetTopFromBottom = scrollParent === window
    			? window.innerHeight
    			: scrollParent.getBoundingClientRect().bottom;

    			distance = infiniteElementOffsetTopFromBottom - scrollElementOffsetTopFromBottom;
    		}

    		return distance;
    	}

    	// Get the first scroll parent of an element
    	function getScrollParent(element = thisElement) {
    		let result;

    		if (typeof forceUseInfiniteWrapper === "string") {
    			result = document.querySelector(forceUseInfiniteWrapper);
    		}

    		if (!result) {
    			if (element.tagName === "BODY") {
    				result = window;
    			} else if (!forceUseInfiniteWrapper && ["scroll", "auto"].indexOf(getComputedStyle(element).overflowY) > -1) {
    				result = element;
    			} else if (element.hasAttribute("infinite-wrapper") || element.hasAttribute("data-infinite-wrapper")) {
    				result = element;
    			}
    		}

    		return result || getScrollParent(element.parentNode);
    	}

    	function updateScrollParent() {
    		if (mounted) scrollParent = getScrollParent();
    	}

    	function identifierUpdated() {
    		if (mounted) stateChanger.reset();
    	}

    	onMount(async () => {
    		$$invalidate(16, mounted = true);

    		setTimeout(
    			() => {
    				scrollHandler();
    				scrollParent.addEventListener("scroll", scrollHandler, thirdEventArg);
    			},
    			1
    		);
    	});

    	onDestroy(() => {
    		if (mounted && status !== STATUS.COMPLETE) {
    			throttler.reset();
    			scrollBarStorage.remove(scrollParent);
    			scrollParent.removeEventListener("scroll", scrollHandler, thirdEventArg);
    		}
    	});

    	const writable_props = ["distance", "spinner", "direction", "forceUseInfiniteWrapper", "identifier"];

    	Object_1$5.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$b.warn(`<InfiniteLoading> was created with unknown prop '${key}'`);
    	});

    	function div_binding($$value) {
    		binding_callbacks[$$value ? "unshift" : "push"](() => {
    			thisElement = $$value;
    			$$invalidate(2, thisElement);
    		});
    	}

    	$$self.$$set = $$props => {
    		if ("distance" in $$props) $$invalidate(8, distance = $$props.distance);
    		if ("spinner" in $$props) $$invalidate(0, spinner = $$props.spinner);
    		if ("direction" in $$props) $$invalidate(9, direction = $$props.direction);
    		if ("forceUseInfiniteWrapper" in $$props) $$invalidate(10, forceUseInfiniteWrapper = $$props.forceUseInfiniteWrapper);
    		if ("identifier" in $$props) $$invalidate(11, identifier = $$props.identifier);
    		if ("$$scope" in $$props) $$invalidate(12, $$scope = $$props.$$scope);
    	};

    	$$self.$capture_state = () => ({
    		STATUS,
    		THROTTLE_LIMIT,
    		LOOP_CHECK_TIMEOUT,
    		LOOP_CHECK_MAX_CALLS,
    		ERROR_INFINITE_LOOP,
    		thirdEventArg,
    		throttler,
    		loopTracker,
    		scrollBarStorage,
    		isVisible,
    		onMount,
    		onDestroy,
    		tick,
    		createEventDispatcher,
    		Spinner: Spinner$1,
    		dispatch,
    		distance,
    		spinner,
    		direction,
    		forceUseInfiniteWrapper,
    		identifier,
    		isFirstLoad,
    		status,
    		mounted,
    		thisElement,
    		scrollParent,
    		stateChanger,
    		scrollHandler,
    		attemptLoad,
    		getCurrentDistance,
    		getScrollParent,
    		updateScrollParent,
    		identifierUpdated,
    		showSpinner,
    		showError,
    		showNoResults,
    		showNoMore
    	});

    	$$self.$inject_state = $$props => {
    		if ("distance" in $$props) $$invalidate(8, distance = $$props.distance);
    		if ("spinner" in $$props) $$invalidate(0, spinner = $$props.spinner);
    		if ("direction" in $$props) $$invalidate(9, direction = $$props.direction);
    		if ("forceUseInfiniteWrapper" in $$props) $$invalidate(10, forceUseInfiniteWrapper = $$props.forceUseInfiniteWrapper);
    		if ("identifier" in $$props) $$invalidate(11, identifier = $$props.identifier);
    		if ("isFirstLoad" in $$props) $$invalidate(1, isFirstLoad = $$props.isFirstLoad);
    		if ("status" in $$props) $$invalidate(15, status = $$props.status);
    		if ("mounted" in $$props) $$invalidate(16, mounted = $$props.mounted);
    		if ("thisElement" in $$props) $$invalidate(2, thisElement = $$props.thisElement);
    		if ("scrollParent" in $$props) scrollParent = $$props.scrollParent;
    		if ("showSpinner" in $$props) $$invalidate(3, showSpinner = $$props.showSpinner);
    		if ("showError" in $$props) $$invalidate(4, showError = $$props.showError);
    		if ("showNoResults" in $$props) $$invalidate(5, showNoResults = $$props.showNoResults);
    		if ("showNoMore" in $$props) $$invalidate(6, showNoMore = $$props.showNoMore);
    	};

    	let showSpinner;
    	let showError;
    	let showNoResults;
    	let showNoMore;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*status*/ 32768) {
    			 $$invalidate(3, showSpinner = status === STATUS.LOADING);
    		}

    		if ($$self.$$.dirty & /*status*/ 32768) {
    			 $$invalidate(4, showError = status === STATUS.ERROR);
    		}

    		if ($$self.$$.dirty & /*status, isFirstLoad*/ 32770) {
    			 $$invalidate(5, showNoResults = status === STATUS.COMPLETE && isFirstLoad);
    		}

    		if ($$self.$$.dirty & /*status, isFirstLoad*/ 32770) {
    			 $$invalidate(6, showNoMore = status === STATUS.COMPLETE && !isFirstLoad);
    		}

    		if ($$self.$$.dirty & /*forceUseInfiniteWrapper, mounted*/ 66560) {
    			// Watch forceUseInfiniteWrapper and mounted
    			 (updateScrollParent());
    		}

    		if ($$self.$$.dirty & /*identifier, mounted*/ 67584) {
    			// Watch identifier and mounted
    			 (identifierUpdated());
    		}
    	};

    	return [
    		spinner,
    		isFirstLoad,
    		thisElement,
    		showSpinner,
    		showError,
    		showNoResults,
    		showNoMore,
    		attemptLoad,
    		distance,
    		direction,
    		forceUseInfiniteWrapper,
    		identifier,
    		$$scope,
    		slots,
    		div_binding
    	];
    }

    class InfiniteLoading extends SvelteComponentDev {
    	constructor(options) {
    		super(options);

    		init(this, options, instance$C, create_fragment$C, safe_not_equal, {
    			distance: 8,
    			spinner: 0,
    			direction: 9,
    			forceUseInfiniteWrapper: 10,
    			identifier: 11
    		});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "InfiniteLoading",
    			options,
    			id: create_fragment$C.name
    		});
    	}

    	get distance() {
    		throw new Error("<InfiniteLoading>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set distance(value) {
    		throw new Error("<InfiniteLoading>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get spinner() {
    		throw new Error("<InfiniteLoading>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set spinner(value) {
    		throw new Error("<InfiniteLoading>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get direction() {
    		throw new Error("<InfiniteLoading>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set direction(value) {
    		throw new Error("<InfiniteLoading>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get forceUseInfiniteWrapper() {
    		throw new Error("<InfiniteLoading>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set forceUseInfiniteWrapper(value) {
    		throw new Error("<InfiniteLoading>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get identifier() {
    		throw new Error("<InfiniteLoading>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set identifier(value) {
    		throw new Error("<InfiniteLoading>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\components\Hilos\HiloList.svelte generated by Svelte v3.29.0 */
    const file$D = "src\\components\\Hilos\\HiloList.svelte";

    function get_each_context$g(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[14] = list[i];
    	child_ctx[15] = list;
    	child_ctx[16] = i;
    	return child_ctx;
    }

    // (97:4) {#if nuevoshilos.length > 0}
    function create_if_block$s(ctx) {
    	let div;
    	let icon;
    	let t0;
    	let t1_value = /*nuevoshilos*/ ctx[1].length + "";
    	let t1;
    	let t2;

    	let t3_value = (/*nuevoshilos*/ ctx[1].length == 1
    	? "roz nuevo"
    	: "rozes nuevos") + "";

    	let t3;
    	let t4;
    	let ripple;
    	let div_transition;
    	let current;
    	let mounted;
    	let dispose;
    	ripple = new he({ $$inline: true });

    	const block = {
    		c: function create() {
    			div = element("div");
    			icon = element("icon");
    			t0 = text(" \r\n            Cargar ");
    			t1 = text(t1_value);
    			t2 = space();
    			t3 = text(t3_value);
    			t4 = space();
    			create_component(ripple.$$.fragment);
    			attr_dev(icon, "class", "fe fe-rotate-cw");
    			set_style(icon, "margin-right", "8px");
    			add_location(icon, file$D, 98, 12, 3330);
    			attr_dev(div, "class", "cargar-nuevos-hilos svelte-1ppblzz");
    			add_location(div, file$D, 97, 8, 3228);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, icon);
    			append_dev(div, t0);
    			append_dev(div, t1);
    			append_dev(div, t2);
    			append_dev(div, t3);
    			append_dev(div, t4);
    			mount_component(ripple, div, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(div, "click", /*cargarNuevos*/ ctx[2], false, false, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty & /*nuevoshilos*/ 2) && t1_value !== (t1_value = /*nuevoshilos*/ ctx[1].length + "")) set_data_dev(t1, t1_value);

    			if ((!current || dirty & /*nuevoshilos*/ 2) && t3_value !== (t3_value = (/*nuevoshilos*/ ctx[1].length == 1
    			? "roz nuevo"
    			: "rozes nuevos") + "")) set_data_dev(t3, t3_value);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(ripple.$$.fragment, local);

    			if (local) {
    				add_render_callback(() => {
    					if (!div_transition) div_transition = create_bidirectional_transition(div, fly, { x: 100 }, true);
    					div_transition.run(1);
    				});
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(ripple.$$.fragment, local);

    			if (local) {
    				if (!div_transition) div_transition = create_bidirectional_transition(div, fly, { x: 100 }, false);
    				div_transition.run(0);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(ripple);
    			if (detaching && div_transition) div_transition.end();
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$s.name,
    		type: "if",
    		source: "(97:4) {#if nuevoshilos.length > 0}",
    		ctx
    	});

    	return block;
    }

    // (104:4) {#each hiloList.hilos as hilo (hilo.id)}
    function create_each_block$g(key_1, ctx) {
    	let first;
    	let hilopreview;
    	let updating_hilo;
    	let current;

    	function hilopreview_hilo_binding(value) {
    		/*hilopreview_hilo_binding*/ ctx[6].call(null, value, /*hilo*/ ctx[14], /*each_value*/ ctx[15], /*hilo_index*/ ctx[16]);
    	}

    	let hilopreview_props = {};

    	if (/*hilo*/ ctx[14] !== void 0) {
    		hilopreview_props.hilo = /*hilo*/ ctx[14];
    	}

    	hilopreview = new HiloPreview({ props: hilopreview_props, $$inline: true });
    	binding_callbacks.push(() => bind(hilopreview, "hilo", hilopreview_hilo_binding));

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			first = empty();
    			create_component(hilopreview.$$.fragment);
    			this.first = first;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, first, anchor);
    			mount_component(hilopreview, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const hilopreview_changes = {};

    			if (!updating_hilo && dirty & /*hiloList*/ 1) {
    				updating_hilo = true;
    				hilopreview_changes.hilo = /*hilo*/ ctx[14];
    				add_flush_callback(() => updating_hilo = false);
    			}

    			hilopreview.$set(hilopreview_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(hilopreview.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(hilopreview.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(first);
    			destroy_component(hilopreview, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$g.name,
    		type: "each",
    		source: "(104:4) {#each hiloList.hilos as hilo (hilo.id)}",
    		ctx
    	});

    	return block;
    }

    // (109:4) <div style="text-align:center" slot="noMore">
    function create_noMore_slot(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			div.textContent = "No hay mas hilos padre, recargue la pagina";
    			set_style(div, "text-align", "center");
    			attr_dev(div, "slot", "noMore");
    			add_location(div, file$D, 108, 4, 3708);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_noMore_slot.name,
    		type: "slot",
    		source: "(109:4) <div style=\\\"text-align:center\\\" slot=\\\"noMore\\\">",
    		ctx
    	});

    	return block;
    }

    // (110:4) <div style="text-align:center" slot="noResults">
    function create_noResults_slot(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			set_style(div, "text-align", "center");
    			attr_dev(div, "slot", "noResults");
    			add_location(div, file$D, 109, 4, 3807);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_noResults_slot.name,
    		type: "slot",
    		source: "(110:4) <div style=\\\"text-align:center\\\" slot=\\\"noResults\\\">",
    		ctx
    	});

    	return block;
    }

    // (108:0) <InfiniteLoading on:infinite={cargarViejos} distance={600}>
    function create_default_slot$n(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = space();
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$n.name,
    		type: "slot",
    		source: "(108:0) <InfiniteLoading on:infinite={cargarViejos} distance={600}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$D(ctx) {
    	let ul;
    	let t0;
    	let each_blocks = [];
    	let each_1_lookup = new Map();
    	let t1;
    	let infiniteloading;
    	let current;
    	let if_block = /*nuevoshilos*/ ctx[1].length > 0 && create_if_block$s(ctx);
    	let each_value = /*hiloList*/ ctx[0].hilos;
    	validate_each_argument(each_value);
    	const get_key = ctx => /*hilo*/ ctx[14].id;
    	validate_each_keys(ctx, each_value, get_each_context$g, get_key);

    	for (let i = 0; i < each_value.length; i += 1) {
    		let child_ctx = get_each_context$g(ctx, each_value, i);
    		let key = get_key(child_ctx);
    		each_1_lookup.set(key, each_blocks[i] = create_each_block$g(key, child_ctx));
    	}

    	infiniteloading = new InfiniteLoading({
    			props: {
    				distance: 600,
    				$$slots: {
    					default: [create_default_slot$n],
    					noResults: [create_noResults_slot],
    					noMore: [create_noMore_slot]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	infiniteloading.$on("infinite", /*cargarViejos*/ ctx[3]);

    	const block = {
    		c: function create() {
    			ul = element("ul");
    			if (if_block) if_block.c();
    			t0 = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t1 = space();
    			create_component(infiniteloading.$$.fragment);
    			attr_dev(ul, "class", "hilo-list");
    			add_location(ul, file$D, 95, 0, 3162);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, ul, anchor);
    			if (if_block) if_block.m(ul, null);
    			append_dev(ul, t0);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(ul, null);
    			}

    			insert_dev(target, t1, anchor);
    			mount_component(infiniteloading, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*nuevoshilos*/ ctx[1].length > 0) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*nuevoshilos*/ 2) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$s(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(ul, t0);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}

    			if (dirty & /*hiloList*/ 1) {
    				const each_value = /*hiloList*/ ctx[0].hilos;
    				validate_each_argument(each_value);
    				group_outros();
    				validate_each_keys(ctx, each_value, get_each_context$g, get_key);
    				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, ul, outro_and_destroy_block, create_each_block$g, null, get_each_context$g);
    				check_outros();
    			}

    			const infiniteloading_changes = {};

    			if (dirty & /*$$scope*/ 131072) {
    				infiniteloading_changes.$$scope = { dirty, ctx };
    			}

    			infiniteloading.$set(infiniteloading_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			transition_in(infiniteloading.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			transition_out(infiniteloading.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(ul);
    			if (if_block) if_block.d();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].d();
    			}

    			if (detaching) detach_dev(t1);
    			destroy_component(infiniteloading, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$D.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$D($$self, $$props, $$invalidate) {
    	let $globalStore;
    	let $palabrasHideadasStore;
    	validate_store(globalStore, "globalStore");
    	component_subscribe($$self, globalStore, $$value => $$invalidate(7, $globalStore = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("HiloList", slots, []);
    	let { hiloList } = $$props;
    	let { noCargarNuevos = false } = $$props;
    	hiloList.categoriasActivas == hiloList.categoriasActivas || $globalStore.categoriasActivas.includes(hilo.categoriaId); //??quitado

    	// let palabrasHideadasString = localStore("palabrasHideadas", "")
    	// $:if($pahi) {hiloList.hilos = hiloList.hilos.filter(h => !estaOculto(h))}
    	let nuevoshilos = [];

    	Signal.subscribirAHome();
    	Signal.coneccion.on("HiloCreado", onHiloCreado);
    	Signal.coneccion.on("HiloComentado", onHiloComentado);

    	Signal.coneccion.on("HilosEliminados", ids => {
    		$$invalidate(0, hiloList.hilos = hiloList.hilos.filter(h => !ids.includes(h.id)), hiloList);
    		$$invalidate(1, nuevoshilos = nuevoshilos.filter(h => !ids.includes(h.id)));
    	});

    	function onHiloCreado(hilo) {
    		if (noCargarNuevos) return;

    		if (hiloList.categoriasActivas.includes(hilo.categoriaId)) {
    			$$invalidate(1, nuevoshilos = [hilo, ...nuevoshilos]);
    		}
    	}

    	function onHiloComentado(id, comentario) {
    		let hiloComentado = hiloList.hilos.filter(h => h.id == id);

    		if (hiloComentado.length != 0) {
    			hiloComentado[0].cantidadComentarios += 1;
    		}

    		$$invalidate(0, hiloList);
    	}

    	function cargarNuevos() {
    		let stickies = [];

    		while (hiloList.hilos.length != 0 && hiloList.hilos[0].sticky != 0) {
    			stickies.push(hiloList.hilos.shift());
    		}

    		$$invalidate(0, hiloList.hilos = [...stickies, ...nuevoshilos, ...hiloList.hilos], hiloList);
    		$$invalidate(1, nuevoshilos = []);
    		window.document.body.scrollTop = 0;
    		window.document.documentElement.scrollTop = 0;
    	}

    	async function cargarViejos({ detail: { loaded, complete } }) {
    		if (hiloList.hilos.length == 0) complete();

    		try {
    			let { data } = await RChanClient.cargarMasHilos(hiloList.hilos[hiloList.hilos.length - 1].bump, hiloList.categoriasActivas);
    			$$invalidate(0, hiloList.hilos = [...hiloList.hilos, ...data], hiloList);
    			if (data.length == 0) complete();
    			loaded();
    		} catch {
    			complete();
    		}
    	}

    	let palabrasHideadasStore = localStore("palabrasHideadas", "");
    	validate_store(palabrasHideadasStore, "palabrasHideadasStore");
    	component_subscribe($$self, palabrasHideadasStore, value => $$invalidate(8, $palabrasHideadasStore = value));
    	let palabrasHideadas = $palabrasHideadasStore.toLowerCase().split(" ").map(p => p.trim()).map(p => p.replace(/\_/g, " ")).filter(p => p);

    	function estaOculto(hilo) {
    		let titulo = hilo.titulo.toLowerCase();

    		for (const palabra of palabrasHideadas) {
    			if (titulo.includes(palabra)) return true;
    		}

    		return false;
    	}

    	let tienaMas = true;
    	const writable_props = ["hiloList", "noCargarNuevos"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<HiloList> was created with unknown prop '${key}'`);
    	});

    	function hilopreview_hilo_binding(value, hilo, each_value, hilo_index) {
    		each_value[hilo_index] = value;
    		$$invalidate(0, hiloList);
    	}

    	$$self.$$set = $$props => {
    		if ("hiloList" in $$props) $$invalidate(0, hiloList = $$props.hiloList);
    		if ("noCargarNuevos" in $$props) $$invalidate(5, noCargarNuevos = $$props.noCargarNuevos);
    	};

    	$$self.$capture_state = () => ({
    		HiloPreview,
    		globalStore,
    		Ripple: he,
    		fly,
    		InfiniteLoading,
    		HubConnectionBuilder,
    		RChanClient,
    		Signal,
    		localStore,
    		hiloList,
    		noCargarNuevos,
    		nuevoshilos,
    		onHiloCreado,
    		onHiloComentado,
    		cargarNuevos,
    		cargarViejos,
    		palabrasHideadasStore,
    		palabrasHideadas,
    		estaOculto,
    		tienaMas,
    		$globalStore,
    		$palabrasHideadasStore
    	});

    	$$self.$inject_state = $$props => {
    		if ("hiloList" in $$props) $$invalidate(0, hiloList = $$props.hiloList);
    		if ("noCargarNuevos" in $$props) $$invalidate(5, noCargarNuevos = $$props.noCargarNuevos);
    		if ("nuevoshilos" in $$props) $$invalidate(1, nuevoshilos = $$props.nuevoshilos);
    		if ("palabrasHideadasStore" in $$props) $$invalidate(4, palabrasHideadasStore = $$props.palabrasHideadasStore);
    		if ("palabrasHideadas" in $$props) palabrasHideadas = $$props.palabrasHideadas;
    		if ("tienaMas" in $$props) tienaMas = $$props.tienaMas;
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*hiloList*/ 1) {
    			 $$invalidate(0, hiloList.hilos = hiloList.hilos.filter(h => !estaOculto(h)), hiloList);
    		}
    	};

    	return [
    		hiloList,
    		nuevoshilos,
    		cargarNuevos,
    		cargarViejos,
    		palabrasHideadasStore,
    		noCargarNuevos,
    		hilopreview_hilo_binding
    	];
    }

    class HiloList extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$D, create_fragment$D, safe_not_equal, { hiloList: 0, noCargarNuevos: 5 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "HiloList",
    			options,
    			id: create_fragment$D.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*hiloList*/ ctx[0] === undefined && !("hiloList" in props)) {
    			console.warn("<HiloList> was created without expected prop 'hiloList'");
    		}
    	}

    	get hiloList() {
    		throw new Error("<HiloList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set hiloList(value) {
    		throw new Error("<HiloList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	get noCargarNuevos() {
    		throw new Error("<HiloList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set noCargarNuevos(value) {
    		throw new Error("<HiloList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\components\Administracion\Administracion.svelte generated by Svelte v3.29.0 */

    const { Object: Object_1$6, console: console_1$c } = globals;
    const file$E = "src\\components\\Administracion\\Administracion.svelte";

    function get_each_context$h(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[34] = list[i];
    	return child_ctx;
    }

    function get_each_context_1$3(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[37] = list[i];
    	return child_ctx;
    }

    function get_each_context_2$2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[37] = list[i];
    	return child_ctx;
    }

    function get_each_context_3$1(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[42] = list[i];
    	return child_ctx;
    }

    // (77:102) <Button on:click={() => añadir(nickAdmin, "admin")}>
    function create_default_slot_11(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Añadir");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_11.name,
    		type: "slot",
    		source: "(77:102) <Button on:click={() => añadir(nickAdmin, \\\"admin\\\")}>",
    		ctx
    	});

    	return block;
    }

    // (80:62) <Button on:click={() => eliminar(a.id, "admin")}>
    function create_default_slot_10(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Eliminar");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_10.name,
    		type: "slot",
    		source: "(80:62) <Button on:click={() => eliminar(a.id, \\\"admin\\\")}>",
    		ctx
    	});

    	return block;
    }

    // (79:16) {#each model.admins as a (a.id)}
    function create_each_block_3$1(key_1, ctx) {
    	let li;
    	let t0_value = /*a*/ ctx[42].userName + "";
    	let t0;
    	let t1;
    	let span;
    	let button;
    	let current;

    	function click_handler_1(...args) {
    		return /*click_handler_1*/ ctx[11](/*a*/ ctx[42], ...args);
    	}

    	button = new ye({
    			props: {
    				$$slots: { default: [create_default_slot_10] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button.$on("click", click_handler_1);

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			li = element("li");
    			t0 = text(t0_value);
    			t1 = space();
    			span = element("span");
    			create_component(button.$$.fragment);
    			attr_dev(span, "class", "sep svelte-qt5lwv");
    			add_location(span, file$E, 79, 37, 2351);
    			add_location(li, file$E, 79, 20, 2334);
    			this.first = li;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			append_dev(li, t0);
    			append_dev(li, t1);
    			append_dev(li, span);
    			mount_component(button, li, null);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if ((!current || dirty[0] & /*model*/ 1) && t0_value !== (t0_value = /*a*/ ctx[42].userName + "")) set_data_dev(t0, t0_value);
    			const button_changes = {};

    			if (dirty[1] & /*$$scope*/ 16384) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			destroy_component(button);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_3$1.name,
    		type: "each",
    		source: "(79:16) {#each model.admins as a (a.id)}",
    		ctx
    	});

    	return block;
    }

    // (85:100) <Button on:click={() => añadir(nickMod, "mod")}>
    function create_default_slot_9(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Añadir");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_9.name,
    		type: "slot",
    		source: "(85:100) <Button on:click={() => añadir(nickMod, \\\"mod\\\")}>",
    		ctx
    	});

    	return block;
    }

    // (88:62) <Button on:click={() => eliminar(m.id, "mod")}>
    function create_default_slot_8$1(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Eliminar");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_8$1.name,
    		type: "slot",
    		source: "(88:62) <Button on:click={() => eliminar(m.id, \\\"mod\\\")}>",
    		ctx
    	});

    	return block;
    }

    // (87:16) {#each model.mods as m (m.id)}
    function create_each_block_2$2(key_1, ctx) {
    	let li;
    	let t0_value = /*m*/ ctx[37].userName + "";
    	let t0;
    	let t1;
    	let span;
    	let button;
    	let current;

    	function click_handler_3(...args) {
    		return /*click_handler_3*/ ctx[14](/*m*/ ctx[37], ...args);
    	}

    	button = new ye({
    			props: {
    				$$slots: { default: [create_default_slot_8$1] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button.$on("click", click_handler_3);

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			li = element("li");
    			t0 = text(t0_value);
    			t1 = space();
    			span = element("span");
    			create_component(button.$$.fragment);
    			attr_dev(span, "class", "sep svelte-qt5lwv");
    			add_location(span, file$E, 87, 37, 2865);
    			add_location(li, file$E, 87, 20, 2848);
    			this.first = li;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			append_dev(li, t0);
    			append_dev(li, t1);
    			append_dev(li, span);
    			mount_component(button, li, null);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if ((!current || dirty[0] & /*model*/ 1) && t0_value !== (t0_value = /*m*/ ctx[37].userName + "")) set_data_dev(t0, t0_value);
    			const button_changes = {};

    			if (dirty[1] & /*$$scope*/ 16384) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			destroy_component(button);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_2$2.name,
    		type: "each",
    		source: "(87:16) {#each model.mods as m (m.id)}",
    		ctx
    	});

    	return block;
    }

    // (92:100) <Button on:click={() => añadir(nickMod, "auxiliar")}>
    function create_default_slot_7$2(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Añadir");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_7$2.name,
    		type: "slot",
    		source: "(92:100) <Button on:click={() => añadir(nickMod, \\\"auxiliar\\\")}>",
    		ctx
    	});

    	return block;
    }

    // (95:62) <Button on:click={() => eliminar(m.id, "auxiliar")}>
    function create_default_slot_6$3(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Eliminar");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_6$3.name,
    		type: "slot",
    		source: "(95:62) <Button on:click={() => eliminar(m.id, \\\"auxiliar\\\")}>",
    		ctx
    	});

    	return block;
    }

    // (94:16) {#each model.auxiliares as m (m.id)}
    function create_each_block_1$3(key_1, ctx) {
    	let li;
    	let t0_value = /*m*/ ctx[37].userName + "";
    	let t0;
    	let t1;
    	let span;
    	let button;
    	let current;

    	function click_handler_5(...args) {
    		return /*click_handler_5*/ ctx[17](/*m*/ ctx[37], ...args);
    	}

    	button = new ye({
    			props: {
    				$$slots: { default: [create_default_slot_6$3] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button.$on("click", click_handler_5);

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			li = element("li");
    			t0 = text(t0_value);
    			t1 = space();
    			span = element("span");
    			create_component(button.$$.fragment);
    			attr_dev(span, "class", "sep svelte-qt5lwv");
    			add_location(span, file$E, 94, 37, 3364);
    			add_location(li, file$E, 94, 20, 3347);
    			this.first = li;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			append_dev(li, t0);
    			append_dev(li, t1);
    			append_dev(li, span);
    			mount_component(button, li, null);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			if ((!current || dirty[0] & /*model*/ 1) && t0_value !== (t0_value = /*m*/ ctx[37].userName + "")) set_data_dev(t0, t0_value);
    			const button_changes = {};

    			if (dirty[1] & /*$$scope*/ 16384) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			destroy_component(button);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$3.name,
    		type: "each",
    		source: "(94:16) {#each model.auxiliares as m (m.id)}",
    		ctx
    	});

    	return block;
    }

    // (115:77) <Button on:click={actualizarConfig}>
    function create_default_slot_5$5(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Guardar");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5$5.name,
    		type: "slot",
    		source: "(115:77) <Button on:click={actualizarConfig}>",
    		ctx
    	});

    	return block;
    }

    // (127:16) {#if !model.config.registroAbierto}
    function create_if_block$t(ctx) {
    	let li0;
    	let h4;
    	let t1;
    	let li1;
    	let a;
    	let t2;
    	let t3_value = /*model*/ ctx[0].config.linkDeInvitacion + "";
    	let t3;
    	let a_href_value;
    	let t4;
    	let button;
    	let current;

    	button = new ye({
    			props: {
    				$$slots: { default: [create_default_slot_4$8] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button.$on("click", /*generarLink*/ ctx[7]);

    	const block = {
    		c: function create() {
    			li0 = element("li");
    			h4 = element("h4");
    			h4.textContent = "Link de invitacion";
    			t1 = space();
    			li1 = element("li");
    			a = element("a");
    			t2 = text("/Registro?codigoDeInvitacion=");
    			t3 = text(t3_value);
    			t4 = space();
    			create_component(button.$$.fragment);
    			add_location(h4, file$E, 128, 28, 5259);
    			add_location(li0, file$E, 127, 20, 5225);
    			set_style(a, "color", "var(--color5)");
    			attr_dev(a, "href", a_href_value = "/Registro?codigoDeInvitacion=" + /*model*/ ctx[0].config.linkDeInvitacion);
    			add_location(a, file$E, 131, 24, 5365);
    			add_location(li1, file$E, 130, 20, 5335);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li0, anchor);
    			append_dev(li0, h4);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, li1, anchor);
    			append_dev(li1, a);
    			append_dev(a, t2);
    			append_dev(a, t3);
    			insert_dev(target, t4, anchor);
    			mount_component(button, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			if ((!current || dirty[0] & /*model*/ 1) && t3_value !== (t3_value = /*model*/ ctx[0].config.linkDeInvitacion + "")) set_data_dev(t3, t3_value);

    			if (!current || dirty[0] & /*model*/ 1 && a_href_value !== (a_href_value = "/Registro?codigoDeInvitacion=" + /*model*/ ctx[0].config.linkDeInvitacion)) {
    				attr_dev(a, "href", a_href_value);
    			}

    			const button_changes = {};

    			if (dirty[1] & /*$$scope*/ 16384) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(li1);
    			if (detaching) detach_dev(t4);
    			destroy_component(button, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$t.name,
    		type: "if",
    		source: "(127:16) {#if !model.config.registroAbierto}",
    		ctx
    	});

    	return block;
    }

    // (135:20) <Button on:click={generarLink}>
    function create_default_slot_4$8(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Nuevo link");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$8.name,
    		type: "slot",
    		source: "(135:20) <Button on:click={generarLink}>",
    		ctx
    	});

    	return block;
    }

    // (137:77) <Button on:click={actualizarConfig}>
    function create_default_slot_3$e(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Guardar");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$e.name,
    		type: "slot",
    		source: "(137:77) <Button on:click={actualizarConfig}>",
    		ctx
    	});

    	return block;
    }

    // (149:20) <Radio right bind:group={model.config.restriccionDeAcceso} value={restriccionesDeAcesso[key]}>
    function create_default_slot_2$h(ctx) {
    	let span;
    	let t_value = /*key*/ ctx[34] + "";
    	let t;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = text(t_value);
    			add_location(span, file$E, 149, 24, 6307);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$h.name,
    		type: "slot",
    		source: "(149:20) <Radio right bind:group={model.config.restriccionDeAcceso} value={restriccionesDeAcesso[key]}>",
    		ctx
    	});

    	return block;
    }

    // (147:16) {#each Object.keys(restriccionesDeAcesso) as key}
    function create_each_block$h(ctx) {
    	let li;
    	let radio;
    	let updating_group;
    	let current;

    	function radio_group_binding(value) {
    		/*radio_group_binding*/ ctx[29].call(null, value);
    	}

    	let radio_props = {
    		right: true,
    		value: /*restriccionesDeAcesso*/ ctx[8][/*key*/ ctx[34]],
    		$$slots: { default: [create_default_slot_2$h] },
    		$$scope: { ctx }
    	};

    	if (/*model*/ ctx[0].config.restriccionDeAcceso !== void 0) {
    		radio_props.group = /*model*/ ctx[0].config.restriccionDeAcceso;
    	}

    	radio = new Fn({ props: radio_props, $$inline: true });
    	binding_callbacks.push(() => bind(radio, "group", radio_group_binding));

    	const block = {
    		c: function create() {
    			li = element("li");
    			create_component(radio.$$.fragment);
    			add_location(li, file$E, 147, 16, 6161);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			mount_component(radio, li, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const radio_changes = {};

    			if (dirty[1] & /*$$scope*/ 16384) {
    				radio_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_group && dirty[0] & /*model*/ 1) {
    				updating_group = true;
    				radio_changes.group = /*model*/ ctx[0].config.restriccionDeAcceso;
    				add_flush_callback(() => updating_group = false);
    			}

    			radio.$set(radio_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(radio.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(radio.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			destroy_component(radio);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$h.name,
    		type: "each",
    		source: "(147:16) {#each Object.keys(restriccionesDeAcesso) as key}",
    		ctx
    	});

    	return block;
    }

    // (156:77) <Button on:click={actualizarConfig}>
    function create_default_slot_1$i(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Guardar");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$i.name,
    		type: "slot",
    		source: "(156:77) <Button on:click={actualizarConfig}>",
    		ctx
    	});

    	return block;
    }

    // (168:20) <div slot="body">
    function create_body_slot$4(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			div.textContent = "Eliminar los rozs con mas de 48 horas de su  eliminados o archivacion";
    			attr_dev(div, "slot", "body");
    			add_location(div, file$E, 167, 20, 7087);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_body_slot$4.name,
    		type: "slot",
    		source: "(168:20) <div slot=\\\"body\\\">",
    		ctx
    	});

    	return block;
    }

    function create_fragment$E(ctx) {
    	let main;
    	let section0;
    	let h30;
    	let t1;
    	let errorvalidacion0;
    	let t2;
    	let div0;
    	let ul0;
    	let li0;
    	let t4;
    	let li1;
    	let input0;
    	let t5;
    	let button0;
    	let t6;
    	let each_blocks_3 = [];
    	let each0_lookup = new Map();
    	let t7;
    	let hr;
    	let t8;
    	let li2;
    	let t10;
    	let li3;
    	let input1;
    	let t11;
    	let button1;
    	let t12;
    	let each_blocks_2 = [];
    	let each1_lookup = new Map();
    	let t13;
    	let li4;
    	let t15;
    	let li5;
    	let input2;
    	let t16;
    	let button2;
    	let t17;
    	let each_blocks_1 = [];
    	let each2_lookup = new Map();
    	let t18;
    	let section1;
    	let h31;
    	let t20;
    	let errorvalidacion1;
    	let t21;
    	let div1;
    	let ul1;
    	let li6;
    	let t22;
    	let input3;
    	let t23;
    	let li7;
    	let t24;
    	let input4;
    	let t25;
    	let li8;
    	let t26;
    	let input5;
    	let t27;
    	let li9;
    	let t28;
    	let input6;
    	let t29;
    	let li10;
    	let t30;
    	let input7;
    	let t31;
    	let li11;
    	let t32;
    	let checkbox0;
    	let updating_checked;
    	let t33;
    	let li12;
    	let t34;
    	let checkbox1;
    	let updating_checked_1;
    	let t35;
    	let li13;
    	let t36;
    	let checkbox2;
    	let updating_checked_2;
    	let t37;
    	let li14;
    	let span0;
    	let t38;
    	let button3;
    	let t39;
    	let section2;
    	let h32;
    	let t41;
    	let errorvalidacion2;
    	let t42;
    	let div2;
    	let ul2;
    	let li15;
    	let t43;
    	let input8;
    	let t44;
    	let li16;
    	let t45;
    	let checkbox3;
    	let updating_checked_3;
    	let t46;
    	let t47;
    	let li17;
    	let span1;
    	let t48;
    	let button4;
    	let t49;
    	let section3;
    	let h33;
    	let t51;
    	let errorvalidacion3;
    	let t52;
    	let div3;
    	let ul3;
    	let li18;
    	let t53;
    	let checkbox4;
    	let updating_checked_4;
    	let t54;
    	let t55;
    	let li19;
    	let t57;
    	let textarea;
    	let t58;
    	let li20;
    	let span2;
    	let t59;
    	let button5;
    	let t60;
    	let section4;
    	let h34;
    	let t62;
    	let errorvalidacion4;
    	let t63;
    	let div4;
    	let ul4;
    	let dialogo;
    	let current;
    	let mounted;
    	let dispose;

    	errorvalidacion0 = new ErrorValidacion({
    			props: { error: /*error*/ ctx[1] },
    			$$inline: true
    		});

    	button0 = new ye({
    			props: {
    				$$slots: { default: [create_default_slot_11] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button0.$on("click", /*click_handler*/ ctx[10]);
    	let each_value_3 = /*model*/ ctx[0].admins;
    	validate_each_argument(each_value_3);
    	const get_key = ctx => /*a*/ ctx[42].id;
    	validate_each_keys(ctx, each_value_3, get_each_context_3$1, get_key);

    	for (let i = 0; i < each_value_3.length; i += 1) {
    		let child_ctx = get_each_context_3$1(ctx, each_value_3, i);
    		let key = get_key(child_ctx);
    		each0_lookup.set(key, each_blocks_3[i] = create_each_block_3$1(key, child_ctx));
    	}

    	button1 = new ye({
    			props: {
    				$$slots: { default: [create_default_slot_9] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button1.$on("click", /*click_handler_2*/ ctx[13]);
    	let each_value_2 = /*model*/ ctx[0].mods;
    	validate_each_argument(each_value_2);
    	const get_key_1 = ctx => /*m*/ ctx[37].id;
    	validate_each_keys(ctx, each_value_2, get_each_context_2$2, get_key_1);

    	for (let i = 0; i < each_value_2.length; i += 1) {
    		let child_ctx = get_each_context_2$2(ctx, each_value_2, i);
    		let key = get_key_1(child_ctx);
    		each1_lookup.set(key, each_blocks_2[i] = create_each_block_2$2(key, child_ctx));
    	}

    	button2 = new ye({
    			props: {
    				$$slots: { default: [create_default_slot_7$2] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button2.$on("click", /*click_handler_4*/ ctx[16]);
    	let each_value_1 = /*model*/ ctx[0].auxiliares;
    	validate_each_argument(each_value_1);
    	const get_key_2 = ctx => /*m*/ ctx[37].id;
    	validate_each_keys(ctx, each_value_1, get_each_context_1$3, get_key_2);

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		let child_ctx = get_each_context_1$3(ctx, each_value_1, i);
    		let key = get_key_2(child_ctx);
    		each2_lookup.set(key, each_blocks_1[i] = create_each_block_1$3(key, child_ctx));
    	}

    	errorvalidacion1 = new ErrorValidacion({
    			props: { error: /*error*/ ctx[1] },
    			$$inline: true
    		});

    	function checkbox0_checked_binding(value) {
    		/*checkbox0_checked_binding*/ ctx[23].call(null, value);
    	}

    	let checkbox0_props = { right: true };

    	if (/*model*/ ctx[0].config.captchaRegistro !== void 0) {
    		checkbox0_props.checked = /*model*/ ctx[0].config.captchaRegistro;
    	}

    	checkbox0 = new Ne({ props: checkbox0_props, $$inline: true });
    	binding_callbacks.push(() => bind(checkbox0, "checked", checkbox0_checked_binding));

    	function checkbox1_checked_binding(value) {
    		/*checkbox1_checked_binding*/ ctx[24].call(null, value);
    	}

    	let checkbox1_props = { right: true };

    	if (/*model*/ ctx[0].config.captchaHilo !== void 0) {
    		checkbox1_props.checked = /*model*/ ctx[0].config.captchaHilo;
    	}

    	checkbox1 = new Ne({ props: checkbox1_props, $$inline: true });
    	binding_callbacks.push(() => bind(checkbox1, "checked", checkbox1_checked_binding));

    	function checkbox2_checked_binding(value) {
    		/*checkbox2_checked_binding*/ ctx[25].call(null, value);
    	}

    	let checkbox2_props = { right: true };

    	if (/*model*/ ctx[0].config.captchaComentario !== void 0) {
    		checkbox2_props.checked = /*model*/ ctx[0].config.captchaComentario;
    	}

    	checkbox2 = new Ne({ props: checkbox2_props, $$inline: true });
    	binding_callbacks.push(() => bind(checkbox2, "checked", checkbox2_checked_binding));

    	button3 = new ye({
    			props: {
    				$$slots: { default: [create_default_slot_5$5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button3.$on("click", /*actualizarConfig*/ ctx[6]);

    	errorvalidacion2 = new ErrorValidacion({
    			props: { error: /*error*/ ctx[1] },
    			$$inline: true
    		});

    	function checkbox3_checked_binding(value) {
    		/*checkbox3_checked_binding*/ ctx[27].call(null, value);
    	}

    	let checkbox3_props = { right: true };

    	if (/*model*/ ctx[0].config.registroAbierto !== void 0) {
    		checkbox3_props.checked = /*model*/ ctx[0].config.registroAbierto;
    	}

    	checkbox3 = new Ne({ props: checkbox3_props, $$inline: true });
    	binding_callbacks.push(() => bind(checkbox3, "checked", checkbox3_checked_binding));
    	let if_block = !/*model*/ ctx[0].config.registroAbierto && create_if_block$t(ctx);

    	button4 = new ye({
    			props: {
    				$$slots: { default: [create_default_slot_3$e] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button4.$on("click", /*actualizarConfig*/ ctx[6]);

    	errorvalidacion3 = new ErrorValidacion({
    			props: { error: /*error*/ ctx[1] },
    			$$inline: true
    		});

    	function checkbox4_checked_binding(value) {
    		/*checkbox4_checked_binding*/ ctx[28].call(null, value);
    	}

    	let checkbox4_props = { right: true };

    	if (/*model*/ ctx[0].config.modoMessi !== void 0) {
    		checkbox4_props.checked = /*model*/ ctx[0].config.modoMessi;
    	}

    	checkbox4 = new Ne({ props: checkbox4_props, $$inline: true });
    	binding_callbacks.push(() => bind(checkbox4, "checked", checkbox4_checked_binding));
    	let each_value = Object.keys(/*restriccionesDeAcesso*/ ctx[8]);
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$h(get_each_context$h(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	button5 = new ye({
    			props: {
    				$$slots: { default: [create_default_slot_1$i] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button5.$on("click", /*actualizarConfig*/ ctx[6]);

    	errorvalidacion4 = new ErrorValidacion({
    			props: { error: /*error*/ ctx[1] },
    			$$inline: true
    		});

    	dialogo = new Dialogo({
    			props: {
    				accion: /*func*/ ctx[31],
    				titulo: "Limpiar rozes viejos",
    				textoActivador: "Limpiar rozes viejos",
    				$$slots: { body: [create_body_slot$4] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			main = element("main");
    			section0 = element("section");
    			h30 = element("h3");
    			h30.textContent = "Equipo";
    			t1 = space();
    			create_component(errorvalidacion0.$$.fragment);
    			t2 = space();
    			div0 = element("div");
    			ul0 = element("ul");
    			li0 = element("li");
    			li0.textContent = "Admninistradores";
    			t4 = space();
    			li1 = element("li");
    			input0 = element("input");
    			t5 = space();
    			create_component(button0.$$.fragment);
    			t6 = space();

    			for (let i = 0; i < each_blocks_3.length; i += 1) {
    				each_blocks_3[i].c();
    			}

    			t7 = space();
    			hr = element("hr");
    			t8 = space();
    			li2 = element("li");
    			li2.textContent = "Moderadores(medz)";
    			t10 = space();
    			li3 = element("li");
    			input1 = element("input");
    			t11 = space();
    			create_component(button1.$$.fragment);
    			t12 = space();

    			for (let i = 0; i < each_blocks_2.length; i += 1) {
    				each_blocks_2[i].c();
    			}

    			t13 = space();
    			li4 = element("li");
    			li4.textContent = "Auxiliares(aux)";
    			t15 = space();
    			li5 = element("li");
    			input2 = element("input");
    			t16 = space();
    			create_component(button2.$$.fragment);
    			t17 = space();

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].c();
    			}

    			t18 = space();
    			section1 = element("section");
    			h31 = element("h3");
    			h31.textContent = "Configuracion";
    			t20 = space();
    			create_component(errorvalidacion1.$$.fragment);
    			t21 = space();
    			div1 = element("div");
    			ul1 = element("ul");
    			li6 = element("li");
    			t22 = text("Limite bump ");
    			input3 = element("input");
    			t23 = space();
    			li7 = element("li");
    			t24 = text("Tiempo entre comentario ");
    			input4 = element("input");
    			t25 = space();
    			li8 = element("li");
    			t26 = text("Tiempo entre hilos");
    			input5 = element("input");
    			t27 = space();
    			li9 = element("li");
    			t28 = text("Hilos maximos por categoria");
    			input6 = element("input");
    			t29 = space();
    			li10 = element("li");
    			t30 = text("Limite archivo");
    			input7 = element("input");
    			t31 = space();
    			li11 = element("li");
    			t32 = text("Captcha registro ");
    			create_component(checkbox0.$$.fragment);
    			t33 = space();
    			li12 = element("li");
    			t34 = text("Captcha hilo ");
    			create_component(checkbox1.$$.fragment);
    			t35 = space();
    			li13 = element("li");
    			t36 = text("Captcha comentario ");
    			create_component(checkbox2.$$.fragment);
    			t37 = space();
    			li14 = element("li");
    			span0 = element("span");
    			t38 = space();
    			create_component(button3.$$.fragment);
    			t39 = space();
    			section2 = element("section");
    			h32 = element("h3");
    			h32.textContent = "Registro";
    			t41 = space();
    			create_component(errorvalidacion2.$$.fragment);
    			t42 = space();
    			div2 = element("div");
    			ul2 = element("ul");
    			li15 = element("li");
    			t43 = text("Registros maximos por ip");
    			input8 = element("input");
    			t44 = space();
    			li16 = element("li");
    			t45 = text("Registro publico ");
    			create_component(checkbox3.$$.fragment);
    			t46 = space();
    			if (if_block) if_block.c();
    			t47 = space();
    			li17 = element("li");
    			span1 = element("span");
    			t48 = space();
    			create_component(button4.$$.fragment);
    			t49 = space();
    			section3 = element("section");
    			h33 = element("h3");
    			h33.textContent = "Acceso";
    			t51 = space();
    			create_component(errorvalidacion3.$$.fragment);
    			t52 = space();
    			div3 = element("div");
    			ul3 = element("ul");
    			li18 = element("li");
    			t53 = text("Protocolo Messi");
    			create_component(checkbox4.$$.fragment);
    			t54 = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			t55 = space();
    			li19 = element("li");
    			li19.textContent = "Mensaje pagina de choque";
    			t57 = space();
    			textarea = element("textarea");
    			t58 = space();
    			li20 = element("li");
    			span2 = element("span");
    			t59 = space();
    			create_component(button5.$$.fragment);
    			t60 = space();
    			section4 = element("section");
    			h34 = element("h3");
    			h34.textContent = "Mantenimiento";
    			t62 = space();
    			create_component(errorvalidacion4.$$.fragment);
    			t63 = space();
    			div4 = element("div");
    			ul4 = element("ul");
    			create_component(dialogo.$$.fragment);
    			add_location(h30, file$E, 70, 8, 1869);
    			attr_dev(li0, "class", "header svelte-qt5lwv");
    			add_location(li0, file$E, 74, 16, 1991);
    			attr_dev(input0, "type", "text");
    			attr_dev(input0, "placeholder", "Id o nick del usuario");
    			add_location(input0, file$E, 76, 20, 2090);
    			attr_dev(li1, "class", "noback");
    			add_location(li1, file$E, 75, 16, 2049);
    			add_location(hr, file$E, 81, 16, 2490);
    			attr_dev(li2, "class", "header svelte-qt5lwv");
    			add_location(li2, file$E, 82, 16, 2512);
    			attr_dev(input1, "type", "text");
    			attr_dev(input1, "placeholder", "Id o nick del usuario");
    			add_location(input1, file$E, 84, 20, 2612);
    			attr_dev(li3, "class", "noback");
    			add_location(li3, file$E, 83, 16, 2571);
    			attr_dev(li4, "class", "header svelte-qt5lwv");
    			add_location(li4, file$E, 89, 16, 3002);
    			attr_dev(input2, "type", "text");
    			attr_dev(input2, "placeholder", "Id o nick del usuario");
    			add_location(input2, file$E, 91, 20, 3100);
    			attr_dev(li5, "class", "noback");
    			add_location(li5, file$E, 90, 16, 3059);
    			add_location(ul0, file$E, 73, 12, 1968);
    			attr_dev(div0, "class", "menu");
    			add_location(div0, file$E, 72, 8, 1936);
    			attr_dev(section0, "class", "svelte-qt5lwv");
    			add_location(section0, file$E, 69, 4, 1849);
    			add_location(h31, file$E, 102, 8, 3569);
    			attr_dev(input3, "type", "number");
    			add_location(input3, file$E, 106, 32, 3714);
    			add_location(li6, file$E, 106, 16, 3698);
    			attr_dev(input4, "type", "number");
    			add_location(input4, file$E, 107, 44, 3823);
    			add_location(li7, file$E, 107, 16, 3795);
    			attr_dev(input5, "type", "number");
    			add_location(input5, file$E, 108, 38, 3938);
    			add_location(li8, file$E, 108, 16, 3916);
    			attr_dev(input6, "type", "number");
    			add_location(input6, file$E, 109, 47, 4056);
    			add_location(li9, file$E, 109, 16, 4025);
    			attr_dev(input7, "type", "number");
    			add_location(input7, file$E, 110, 34, 4169);
    			add_location(li10, file$E, 110, 16, 4151);
    			add_location(li11, file$E, 111, 16, 4253);
    			add_location(li12, file$E, 112, 16, 4368);
    			add_location(li13, file$E, 113, 16, 4475);
    			set_style(span0, "margin-right", "auto");
    			add_location(span0, file$E, 114, 36, 4614);
    			attr_dev(li14, "class", "header svelte-qt5lwv");
    			add_location(li14, file$E, 114, 16, 4594);
    			add_location(ul1, file$E, 105, 12, 3675);
    			attr_dev(div1, "class", "menu");
    			add_location(div1, file$E, 104, 8, 3643);
    			attr_dev(section1, "class", "svelte-qt5lwv");
    			add_location(section1, file$E, 101, 4, 3549);
    			add_location(h32, file$E, 119, 8, 4789);
    			attr_dev(input8, "type", "number");
    			add_location(input8, file$E, 123, 44, 4941);
    			add_location(li15, file$E, 123, 16, 4913);
    			add_location(li16, file$E, 124, 16, 5038);
    			set_style(span1, "margin-right", "auto");
    			add_location(span1, file$E, 136, 36, 5690);
    			attr_dev(li17, "class", "header svelte-qt5lwv");
    			add_location(li17, file$E, 136, 16, 5670);
    			add_location(ul2, file$E, 122, 12, 4890);
    			attr_dev(div2, "class", "menu");
    			add_location(div2, file$E, 121, 8, 4858);
    			attr_dev(section2, "class", "svelte-qt5lwv");
    			add_location(section2, file$E, 118, 4, 4769);
    			add_location(h33, file$E, 141, 8, 5865);
    			add_location(li18, file$E, 145, 16, 5987);
    			add_location(li19, file$E, 153, 16, 6421);
    			attr_dev(textarea, "cols", "30");
    			attr_dev(textarea, "rows", "10");
    			attr_dev(textarea, "class", "svelte-qt5lwv");
    			add_location(textarea, file$E, 154, 16, 6472);
    			set_style(span2, "margin-right", "auto");
    			add_location(span2, file$E, 155, 36, 6599);
    			attr_dev(li20, "class", "header svelte-qt5lwv");
    			add_location(li20, file$E, 155, 16, 6579);
    			add_location(ul3, file$E, 144, 12, 5964);
    			attr_dev(div3, "class", "menu");
    			add_location(div3, file$E, 143, 8, 5932);
    			attr_dev(section3, "class", "svelte-qt5lwv");
    			add_location(section3, file$E, 140, 4, 5845);
    			add_location(h34, file$E, 160, 8, 6774);
    			add_location(ul4, file$E, 163, 12, 6880);
    			attr_dev(div4, "class", "menu");
    			add_location(div4, file$E, 162, 8, 6848);
    			attr_dev(section4, "class", "svelte-qt5lwv");
    			add_location(section4, file$E, 159, 4, 6754);
    			attr_dev(main, "class", "administracion svelte-qt5lwv");
    			add_location(main, file$E, 68, 0, 1814);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			append_dev(main, section0);
    			append_dev(section0, h30);
    			append_dev(section0, t1);
    			mount_component(errorvalidacion0, section0, null);
    			append_dev(section0, t2);
    			append_dev(section0, div0);
    			append_dev(div0, ul0);
    			append_dev(ul0, li0);
    			append_dev(ul0, t4);
    			append_dev(ul0, li1);
    			append_dev(li1, input0);
    			set_input_value(input0, /*nickAdmin*/ ctx[2]);
    			append_dev(li1, t5);
    			mount_component(button0, li1, null);
    			append_dev(ul0, t6);

    			for (let i = 0; i < each_blocks_3.length; i += 1) {
    				each_blocks_3[i].m(ul0, null);
    			}

    			append_dev(ul0, t7);
    			append_dev(ul0, hr);
    			append_dev(ul0, t8);
    			append_dev(ul0, li2);
    			append_dev(ul0, t10);
    			append_dev(ul0, li3);
    			append_dev(li3, input1);
    			set_input_value(input1, /*nickMod*/ ctx[3]);
    			append_dev(li3, t11);
    			mount_component(button1, li3, null);
    			append_dev(ul0, t12);

    			for (let i = 0; i < each_blocks_2.length; i += 1) {
    				each_blocks_2[i].m(ul0, null);
    			}

    			append_dev(ul0, t13);
    			append_dev(ul0, li4);
    			append_dev(ul0, t15);
    			append_dev(ul0, li5);
    			append_dev(li5, input2);
    			set_input_value(input2, /*nickMod*/ ctx[3]);
    			append_dev(li5, t16);
    			mount_component(button2, li5, null);
    			append_dev(ul0, t17);

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].m(ul0, null);
    			}

    			append_dev(main, t18);
    			append_dev(main, section1);
    			append_dev(section1, h31);
    			append_dev(section1, t20);
    			mount_component(errorvalidacion1, section1, null);
    			append_dev(section1, t21);
    			append_dev(section1, div1);
    			append_dev(div1, ul1);
    			append_dev(ul1, li6);
    			append_dev(li6, t22);
    			append_dev(li6, input3);
    			set_input_value(input3, /*model*/ ctx[0].config.limiteBump);
    			append_dev(ul1, t23);
    			append_dev(ul1, li7);
    			append_dev(li7, t24);
    			append_dev(li7, input4);
    			set_input_value(input4, /*model*/ ctx[0].config.tiempoEntreComentarios);
    			append_dev(ul1, t25);
    			append_dev(ul1, li8);
    			append_dev(li8, t26);
    			append_dev(li8, input5);
    			set_input_value(input5, /*model*/ ctx[0].config.tiempoEntreHilos);
    			append_dev(ul1, t27);
    			append_dev(ul1, li9);
    			append_dev(li9, t28);
    			append_dev(li9, input6);
    			set_input_value(input6, /*model*/ ctx[0].config.hilosMaximosPorCategoria);
    			append_dev(ul1, t29);
    			append_dev(ul1, li10);
    			append_dev(li10, t30);
    			append_dev(li10, input7);
    			set_input_value(input7, /*model*/ ctx[0].config.limiteArchivo);
    			append_dev(ul1, t31);
    			append_dev(ul1, li11);
    			append_dev(li11, t32);
    			mount_component(checkbox0, li11, null);
    			append_dev(ul1, t33);
    			append_dev(ul1, li12);
    			append_dev(li12, t34);
    			mount_component(checkbox1, li12, null);
    			append_dev(ul1, t35);
    			append_dev(ul1, li13);
    			append_dev(li13, t36);
    			mount_component(checkbox2, li13, null);
    			append_dev(ul1, t37);
    			append_dev(ul1, li14);
    			append_dev(li14, span0);
    			append_dev(li14, t38);
    			mount_component(button3, li14, null);
    			append_dev(main, t39);
    			append_dev(main, section2);
    			append_dev(section2, h32);
    			append_dev(section2, t41);
    			mount_component(errorvalidacion2, section2, null);
    			append_dev(section2, t42);
    			append_dev(section2, div2);
    			append_dev(div2, ul2);
    			append_dev(ul2, li15);
    			append_dev(li15, t43);
    			append_dev(li15, input8);
    			set_input_value(input8, /*model*/ ctx[0].config.numeroMaximoDeCuentasPorIp);
    			append_dev(ul2, t44);
    			append_dev(ul2, li16);
    			append_dev(li16, t45);
    			mount_component(checkbox3, li16, null);
    			append_dev(ul2, t46);
    			if (if_block) if_block.m(ul2, null);
    			append_dev(ul2, t47);
    			append_dev(ul2, li17);
    			append_dev(li17, span1);
    			append_dev(li17, t48);
    			mount_component(button4, li17, null);
    			append_dev(main, t49);
    			append_dev(main, section3);
    			append_dev(section3, h33);
    			append_dev(section3, t51);
    			mount_component(errorvalidacion3, section3, null);
    			append_dev(section3, t52);
    			append_dev(section3, div3);
    			append_dev(div3, ul3);
    			append_dev(ul3, li18);
    			append_dev(li18, t53);
    			mount_component(checkbox4, li18, null);
    			append_dev(ul3, t54);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(ul3, null);
    			}

    			append_dev(ul3, t55);
    			append_dev(ul3, li19);
    			append_dev(ul3, t57);
    			append_dev(ul3, textarea);
    			set_input_value(textarea, /*model*/ ctx[0].config.mensajePaginaDeChoque);
    			append_dev(ul3, t58);
    			append_dev(ul3, li20);
    			append_dev(li20, span2);
    			append_dev(li20, t59);
    			mount_component(button5, li20, null);
    			append_dev(main, t60);
    			append_dev(main, section4);
    			append_dev(section4, h34);
    			append_dev(section4, t62);
    			mount_component(errorvalidacion4, section4, null);
    			append_dev(section4, t63);
    			append_dev(section4, div4);
    			append_dev(div4, ul4);
    			mount_component(dialogo, ul4, null);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(input0, "input", /*input0_input_handler*/ ctx[9]),
    					listen_dev(input1, "input", /*input1_input_handler*/ ctx[12]),
    					listen_dev(input2, "input", /*input2_input_handler*/ ctx[15]),
    					listen_dev(input3, "input", /*input3_input_handler*/ ctx[18]),
    					listen_dev(input4, "input", /*input4_input_handler*/ ctx[19]),
    					listen_dev(input5, "input", /*input5_input_handler*/ ctx[20]),
    					listen_dev(input6, "input", /*input6_input_handler*/ ctx[21]),
    					listen_dev(input7, "input", /*input7_input_handler*/ ctx[22]),
    					listen_dev(input8, "input", /*input8_input_handler*/ ctx[26]),
    					listen_dev(textarea, "input", /*textarea_input_handler*/ ctx[30])
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			const errorvalidacion0_changes = {};
    			if (dirty[0] & /*error*/ 2) errorvalidacion0_changes.error = /*error*/ ctx[1];
    			errorvalidacion0.$set(errorvalidacion0_changes);

    			if (dirty[0] & /*nickAdmin*/ 4 && input0.value !== /*nickAdmin*/ ctx[2]) {
    				set_input_value(input0, /*nickAdmin*/ ctx[2]);
    			}

    			const button0_changes = {};

    			if (dirty[1] & /*$$scope*/ 16384) {
    				button0_changes.$$scope = { dirty, ctx };
    			}

    			button0.$set(button0_changes);

    			if (dirty[0] & /*eliminar, model*/ 17) {
    				const each_value_3 = /*model*/ ctx[0].admins;
    				validate_each_argument(each_value_3);
    				group_outros();
    				validate_each_keys(ctx, each_value_3, get_each_context_3$1, get_key);
    				each_blocks_3 = update_keyed_each(each_blocks_3, dirty, get_key, 1, ctx, each_value_3, each0_lookup, ul0, outro_and_destroy_block, create_each_block_3$1, t7, get_each_context_3$1);
    				check_outros();
    			}

    			if (dirty[0] & /*nickMod*/ 8 && input1.value !== /*nickMod*/ ctx[3]) {
    				set_input_value(input1, /*nickMod*/ ctx[3]);
    			}

    			const button1_changes = {};

    			if (dirty[1] & /*$$scope*/ 16384) {
    				button1_changes.$$scope = { dirty, ctx };
    			}

    			button1.$set(button1_changes);

    			if (dirty[0] & /*eliminar, model*/ 17) {
    				const each_value_2 = /*model*/ ctx[0].mods;
    				validate_each_argument(each_value_2);
    				group_outros();
    				validate_each_keys(ctx, each_value_2, get_each_context_2$2, get_key_1);
    				each_blocks_2 = update_keyed_each(each_blocks_2, dirty, get_key_1, 1, ctx, each_value_2, each1_lookup, ul0, outro_and_destroy_block, create_each_block_2$2, t13, get_each_context_2$2);
    				check_outros();
    			}

    			if (dirty[0] & /*nickMod*/ 8 && input2.value !== /*nickMod*/ ctx[3]) {
    				set_input_value(input2, /*nickMod*/ ctx[3]);
    			}

    			const button2_changes = {};

    			if (dirty[1] & /*$$scope*/ 16384) {
    				button2_changes.$$scope = { dirty, ctx };
    			}

    			button2.$set(button2_changes);

    			if (dirty[0] & /*eliminar, model*/ 17) {
    				const each_value_1 = /*model*/ ctx[0].auxiliares;
    				validate_each_argument(each_value_1);
    				group_outros();
    				validate_each_keys(ctx, each_value_1, get_each_context_1$3, get_key_2);
    				each_blocks_1 = update_keyed_each(each_blocks_1, dirty, get_key_2, 1, ctx, each_value_1, each2_lookup, ul0, outro_and_destroy_block, create_each_block_1$3, null, get_each_context_1$3);
    				check_outros();
    			}

    			const errorvalidacion1_changes = {};
    			if (dirty[0] & /*error*/ 2) errorvalidacion1_changes.error = /*error*/ ctx[1];
    			errorvalidacion1.$set(errorvalidacion1_changes);

    			if (dirty[0] & /*model*/ 1 && to_number(input3.value) !== /*model*/ ctx[0].config.limiteBump) {
    				set_input_value(input3, /*model*/ ctx[0].config.limiteBump);
    			}

    			if (dirty[0] & /*model*/ 1 && to_number(input4.value) !== /*model*/ ctx[0].config.tiempoEntreComentarios) {
    				set_input_value(input4, /*model*/ ctx[0].config.tiempoEntreComentarios);
    			}

    			if (dirty[0] & /*model*/ 1 && to_number(input5.value) !== /*model*/ ctx[0].config.tiempoEntreHilos) {
    				set_input_value(input5, /*model*/ ctx[0].config.tiempoEntreHilos);
    			}

    			if (dirty[0] & /*model*/ 1 && to_number(input6.value) !== /*model*/ ctx[0].config.hilosMaximosPorCategoria) {
    				set_input_value(input6, /*model*/ ctx[0].config.hilosMaximosPorCategoria);
    			}

    			if (dirty[0] & /*model*/ 1 && to_number(input7.value) !== /*model*/ ctx[0].config.limiteArchivo) {
    				set_input_value(input7, /*model*/ ctx[0].config.limiteArchivo);
    			}

    			const checkbox0_changes = {};

    			if (!updating_checked && dirty[0] & /*model*/ 1) {
    				updating_checked = true;
    				checkbox0_changes.checked = /*model*/ ctx[0].config.captchaRegistro;
    				add_flush_callback(() => updating_checked = false);
    			}

    			checkbox0.$set(checkbox0_changes);
    			const checkbox1_changes = {};

    			if (!updating_checked_1 && dirty[0] & /*model*/ 1) {
    				updating_checked_1 = true;
    				checkbox1_changes.checked = /*model*/ ctx[0].config.captchaHilo;
    				add_flush_callback(() => updating_checked_1 = false);
    			}

    			checkbox1.$set(checkbox1_changes);
    			const checkbox2_changes = {};

    			if (!updating_checked_2 && dirty[0] & /*model*/ 1) {
    				updating_checked_2 = true;
    				checkbox2_changes.checked = /*model*/ ctx[0].config.captchaComentario;
    				add_flush_callback(() => updating_checked_2 = false);
    			}

    			checkbox2.$set(checkbox2_changes);
    			const button3_changes = {};

    			if (dirty[1] & /*$$scope*/ 16384) {
    				button3_changes.$$scope = { dirty, ctx };
    			}

    			button3.$set(button3_changes);
    			const errorvalidacion2_changes = {};
    			if (dirty[0] & /*error*/ 2) errorvalidacion2_changes.error = /*error*/ ctx[1];
    			errorvalidacion2.$set(errorvalidacion2_changes);

    			if (dirty[0] & /*model*/ 1 && to_number(input8.value) !== /*model*/ ctx[0].config.numeroMaximoDeCuentasPorIp) {
    				set_input_value(input8, /*model*/ ctx[0].config.numeroMaximoDeCuentasPorIp);
    			}

    			const checkbox3_changes = {};

    			if (!updating_checked_3 && dirty[0] & /*model*/ 1) {
    				updating_checked_3 = true;
    				checkbox3_changes.checked = /*model*/ ctx[0].config.registroAbierto;
    				add_flush_callback(() => updating_checked_3 = false);
    			}

    			checkbox3.$set(checkbox3_changes);

    			if (!/*model*/ ctx[0].config.registroAbierto) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty[0] & /*model*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$t(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(ul2, t47);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}

    			const button4_changes = {};

    			if (dirty[1] & /*$$scope*/ 16384) {
    				button4_changes.$$scope = { dirty, ctx };
    			}

    			button4.$set(button4_changes);
    			const errorvalidacion3_changes = {};
    			if (dirty[0] & /*error*/ 2) errorvalidacion3_changes.error = /*error*/ ctx[1];
    			errorvalidacion3.$set(errorvalidacion3_changes);
    			const checkbox4_changes = {};

    			if (!updating_checked_4 && dirty[0] & /*model*/ 1) {
    				updating_checked_4 = true;
    				checkbox4_changes.checked = /*model*/ ctx[0].config.modoMessi;
    				add_flush_callback(() => updating_checked_4 = false);
    			}

    			checkbox4.$set(checkbox4_changes);

    			if (dirty[0] & /*restriccionesDeAcesso, model*/ 257) {
    				each_value = Object.keys(/*restriccionesDeAcesso*/ ctx[8]);
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$h(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$h(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(ul3, t55);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}

    			if (dirty[0] & /*model*/ 1) {
    				set_input_value(textarea, /*model*/ ctx[0].config.mensajePaginaDeChoque);
    			}

    			const button5_changes = {};

    			if (dirty[1] & /*$$scope*/ 16384) {
    				button5_changes.$$scope = { dirty, ctx };
    			}

    			button5.$set(button5_changes);
    			const errorvalidacion4_changes = {};
    			if (dirty[0] & /*error*/ 2) errorvalidacion4_changes.error = /*error*/ ctx[1];
    			errorvalidacion4.$set(errorvalidacion4_changes);
    			const dialogo_changes = {};

    			if (dirty[1] & /*$$scope*/ 16384) {
    				dialogo_changes.$$scope = { dirty, ctx };
    			}

    			dialogo.$set(dialogo_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(errorvalidacion0.$$.fragment, local);
    			transition_in(button0.$$.fragment, local);

    			for (let i = 0; i < each_value_3.length; i += 1) {
    				transition_in(each_blocks_3[i]);
    			}

    			transition_in(button1.$$.fragment, local);

    			for (let i = 0; i < each_value_2.length; i += 1) {
    				transition_in(each_blocks_2[i]);
    			}

    			transition_in(button2.$$.fragment, local);

    			for (let i = 0; i < each_value_1.length; i += 1) {
    				transition_in(each_blocks_1[i]);
    			}

    			transition_in(errorvalidacion1.$$.fragment, local);
    			transition_in(checkbox0.$$.fragment, local);
    			transition_in(checkbox1.$$.fragment, local);
    			transition_in(checkbox2.$$.fragment, local);
    			transition_in(button3.$$.fragment, local);
    			transition_in(errorvalidacion2.$$.fragment, local);
    			transition_in(checkbox3.$$.fragment, local);
    			transition_in(if_block);
    			transition_in(button4.$$.fragment, local);
    			transition_in(errorvalidacion3.$$.fragment, local);
    			transition_in(checkbox4.$$.fragment, local);

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			transition_in(button5.$$.fragment, local);
    			transition_in(errorvalidacion4.$$.fragment, local);
    			transition_in(dialogo.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(errorvalidacion0.$$.fragment, local);
    			transition_out(button0.$$.fragment, local);

    			for (let i = 0; i < each_blocks_3.length; i += 1) {
    				transition_out(each_blocks_3[i]);
    			}

    			transition_out(button1.$$.fragment, local);

    			for (let i = 0; i < each_blocks_2.length; i += 1) {
    				transition_out(each_blocks_2[i]);
    			}

    			transition_out(button2.$$.fragment, local);

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				transition_out(each_blocks_1[i]);
    			}

    			transition_out(errorvalidacion1.$$.fragment, local);
    			transition_out(checkbox0.$$.fragment, local);
    			transition_out(checkbox1.$$.fragment, local);
    			transition_out(checkbox2.$$.fragment, local);
    			transition_out(button3.$$.fragment, local);
    			transition_out(errorvalidacion2.$$.fragment, local);
    			transition_out(checkbox3.$$.fragment, local);
    			transition_out(if_block);
    			transition_out(button4.$$.fragment, local);
    			transition_out(errorvalidacion3.$$.fragment, local);
    			transition_out(checkbox4.$$.fragment, local);
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			transition_out(button5.$$.fragment, local);
    			transition_out(errorvalidacion4.$$.fragment, local);
    			transition_out(dialogo.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    			destroy_component(errorvalidacion0);
    			destroy_component(button0);

    			for (let i = 0; i < each_blocks_3.length; i += 1) {
    				each_blocks_3[i].d();
    			}

    			destroy_component(button1);

    			for (let i = 0; i < each_blocks_2.length; i += 1) {
    				each_blocks_2[i].d();
    			}

    			destroy_component(button2);

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].d();
    			}

    			destroy_component(errorvalidacion1);
    			destroy_component(checkbox0);
    			destroy_component(checkbox1);
    			destroy_component(checkbox2);
    			destroy_component(button3);
    			destroy_component(errorvalidacion2);
    			destroy_component(checkbox3);
    			if (if_block) if_block.d();
    			destroy_component(button4);
    			destroy_component(errorvalidacion3);
    			destroy_component(checkbox4);
    			destroy_each(each_blocks, detaching);
    			destroy_component(button5);
    			destroy_component(errorvalidacion4);
    			destroy_component(dialogo);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$E.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$E($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Administracion", slots, []);
    	let model = window.model;
    	let error = null;
    	let nickAdmin = "";
    	let nickMod = "";
    	let restAcc = 0;

    	async function eliminar(nick, rol) {
    		try {
    			let res = await RChanClient.removerRol(nick, rol);
    			console.log(res);
    			alert(res.data.mensaje);
    		} catch(e) {
    			console.log(e.resposne);
    			$$invalidate(1, error = e.response.data);
    			return;
    		}
    	}

    	async function añadir(nick, rol) {
    		try {
    			let res = await RChanClient.añadirRol(nick, rol);
    			console.log(res);
    			alert(res.data.mensaje);
    		} catch(e) {
    			console.log(e.resposne);
    			$$invalidate(1, error = e.response.data);
    			return;
    		}
    	}

    	async function actualizarConfig() {
    		try {
    			let res = await RChanClient.ActualizarConfiguracion(model.config);
    			console.log(res);
    			alert(res.data.mensaje);
    		} catch(e) {
    			console.log(e.resposne);
    			$$invalidate(1, error = e.response.data);
    			return;
    		}
    	}

    	async function generarLink() {
    		try {
    			const res = await RChanClient.generarNuevoLinkDeInvitacion();
    			$$invalidate(0, model.config.linkDeInvitacion = res.data.link, model);
    			alert("Nuevo link generado");
    		} catch(error) {
    			
    		}
    	}

    	let restriccionDeAcesso = 2;

    	let restriccionesDeAcesso = {
    		Libre: 0,
    		Registrados: 1,
    		Administradores: 2
    	};

    	const writable_props = [];

    	Object_1$6.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$c.warn(`<Administracion> was created with unknown prop '${key}'`);
    	});

    	function input0_input_handler() {
    		nickAdmin = this.value;
    		$$invalidate(2, nickAdmin);
    	}

    	const click_handler = () => añadir(nickAdmin, "admin");
    	const click_handler_1 = a => eliminar(a.id, "admin");

    	function input1_input_handler() {
    		nickMod = this.value;
    		$$invalidate(3, nickMod);
    	}

    	const click_handler_2 = () => añadir(nickMod, "mod");
    	const click_handler_3 = m => eliminar(m.id, "mod");

    	function input2_input_handler() {
    		nickMod = this.value;
    		$$invalidate(3, nickMod);
    	}

    	const click_handler_4 = () => añadir(nickMod, "auxiliar");
    	const click_handler_5 = m => eliminar(m.id, "auxiliar");

    	function input3_input_handler() {
    		model.config.limiteBump = to_number(this.value);
    		$$invalidate(0, model);
    	}

    	function input4_input_handler() {
    		model.config.tiempoEntreComentarios = to_number(this.value);
    		$$invalidate(0, model);
    	}

    	function input5_input_handler() {
    		model.config.tiempoEntreHilos = to_number(this.value);
    		$$invalidate(0, model);
    	}

    	function input6_input_handler() {
    		model.config.hilosMaximosPorCategoria = to_number(this.value);
    		$$invalidate(0, model);
    	}

    	function input7_input_handler() {
    		model.config.limiteArchivo = to_number(this.value);
    		$$invalidate(0, model);
    	}

    	function checkbox0_checked_binding(value) {
    		model.config.captchaRegistro = value;
    		$$invalidate(0, model);
    	}

    	function checkbox1_checked_binding(value) {
    		model.config.captchaHilo = value;
    		$$invalidate(0, model);
    	}

    	function checkbox2_checked_binding(value) {
    		model.config.captchaComentario = value;
    		$$invalidate(0, model);
    	}

    	function input8_input_handler() {
    		model.config.numeroMaximoDeCuentasPorIp = to_number(this.value);
    		$$invalidate(0, model);
    	}

    	function checkbox3_checked_binding(value) {
    		model.config.registroAbierto = value;
    		$$invalidate(0, model);
    	}

    	function checkbox4_checked_binding(value) {
    		model.config.modoMessi = value;
    		$$invalidate(0, model);
    	}

    	function radio_group_binding(value) {
    		model.config.restriccionDeAcceso = value;
    		$$invalidate(0, model);
    	}

    	function textarea_input_handler() {
    		model.config.mensajePaginaDeChoque = this.value;
    		$$invalidate(0, model);
    	}

    	const func = () => RChanClient.limpiarRozesViejos();

    	$$self.$capture_state = () => ({
    		Button: ye,
    		Checkbox: Ne,
    		Radio: Fn,
    		config,
    		RChanClient,
    		Dialogo,
    		ErrorValidacion,
    		model,
    		error,
    		nickAdmin,
    		nickMod,
    		restAcc,
    		eliminar,
    		añadir,
    		actualizarConfig,
    		generarLink,
    		restriccionDeAcesso,
    		restriccionesDeAcesso
    	});

    	$$self.$inject_state = $$props => {
    		if ("model" in $$props) $$invalidate(0, model = $$props.model);
    		if ("error" in $$props) $$invalidate(1, error = $$props.error);
    		if ("nickAdmin" in $$props) $$invalidate(2, nickAdmin = $$props.nickAdmin);
    		if ("nickMod" in $$props) $$invalidate(3, nickMod = $$props.nickMod);
    		if ("restAcc" in $$props) restAcc = $$props.restAcc;
    		if ("restriccionDeAcesso" in $$props) restriccionDeAcesso = $$props.restriccionDeAcesso;
    		if ("restriccionesDeAcesso" in $$props) $$invalidate(8, restriccionesDeAcesso = $$props.restriccionesDeAcesso);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		model,
    		error,
    		nickAdmin,
    		nickMod,
    		eliminar,
    		añadir,
    		actualizarConfig,
    		generarLink,
    		restriccionesDeAcesso,
    		input0_input_handler,
    		click_handler,
    		click_handler_1,
    		input1_input_handler,
    		click_handler_2,
    		click_handler_3,
    		input2_input_handler,
    		click_handler_4,
    		click_handler_5,
    		input3_input_handler,
    		input4_input_handler,
    		input5_input_handler,
    		input6_input_handler,
    		input7_input_handler,
    		checkbox0_checked_binding,
    		checkbox1_checked_binding,
    		checkbox2_checked_binding,
    		input8_input_handler,
    		checkbox3_checked_binding,
    		checkbox4_checked_binding,
    		radio_group_binding,
    		textarea_input_handler,
    		func
    	];
    }

    class Administracion extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$E, create_fragment$E, safe_not_equal, {}, [-1, -1]);

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Administracion",
    			options,
    			id: create_fragment$E.name
    		});
    	}
    }

    /* src\components\Moderacion\BarraModeracion.svelte generated by Svelte v3.29.0 */
    const file$F = "src\\components\\Moderacion\\BarraModeracion.svelte";

    // (8:30) <Button outlined>
    function create_default_slot_5$6(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Pagina principal");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_5$6.name,
    		type: "slot",
    		source: "(8:30) <Button outlined>",
    		ctx
    	});

    	return block;
    }

    // (9:36) <Button outlined>
    function create_default_slot_4$9(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Imagenes y videos");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_4$9.name,
    		type: "slot",
    		source: "(9:36) <Button outlined>",
    		ctx
    	});

    	return block;
    }

    // (10:8) {#if $globalStore.usuario.esMod}
    function create_if_block$u(ctx) {
    	let a0;
    	let button0;
    	let t0;
    	let a1;
    	let button1;
    	let t1;
    	let a2;
    	let button2;
    	let current;

    	button0 = new ye({
    			props: {
    				outlined: true,
    				$$slots: { default: [create_default_slot_3$f] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button1 = new ye({
    			props: {
    				outlined: true,
    				$$slots: { default: [create_default_slot_2$i] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button2 = new ye({
    			props: {
    				outlined: true,
    				$$slots: { default: [create_default_slot_1$j] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			a0 = element("a");
    			create_component(button0.$$.fragment);
    			t0 = space();
    			a1 = element("a");
    			create_component(button1.$$.fragment);
    			t1 = space();
    			a2 = element("a");
    			create_component(button2.$$.fragment);
    			attr_dev(a0, "href", "/Moderacion/ListaDeUsuarios");
    			add_location(a0, file$F, 10, 12, 448);
    			attr_dev(a1, "href", "/Moderacion/EliminadosYDesactivados");
    			add_location(a1, file$F, 11, 12, 548);
    			attr_dev(a2, "href", "/Moderacion/Historial");
    			add_location(a2, file$F, 12, 12, 664);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a0, anchor);
    			mount_component(button0, a0, null);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, a1, anchor);
    			mount_component(button1, a1, null);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, a2, anchor);
    			mount_component(button2, a2, null);
    			current = true;
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button0.$$.fragment, local);
    			transition_in(button1.$$.fragment, local);
    			transition_in(button2.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button0.$$.fragment, local);
    			transition_out(button1.$$.fragment, local);
    			transition_out(button2.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a0);
    			destroy_component(button0);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(a1);
    			destroy_component(button1);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(a2);
    			destroy_component(button2);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$u.name,
    		type: "if",
    		source: "(10:8) {#if $globalStore.usuario.esMod}",
    		ctx
    	});

    	return block;
    }

    // (11:50) <Button outlined>
    function create_default_slot_3$f(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Usuarios y baneos");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_3$f.name,
    		type: "slot",
    		source: "(11:50) <Button outlined>",
    		ctx
    	});

    	return block;
    }

    // (12:58) <Button outlined>
    function create_default_slot_2$i(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Eliminados y desactivados");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_2$i.name,
    		type: "slot",
    		source: "(12:58) <Button outlined>",
    		ctx
    	});

    	return block;
    }

    // (13:44) <Button outlined>
    function create_default_slot_1$j(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Historial");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$j.name,
    		type: "slot",
    		source: "(13:44) <Button outlined>",
    		ctx
    	});

    	return block;
    }

    // (7:4) <ButtonGroup  color="var(--color7)" >
    function create_default_slot$o(ctx) {
    	let a0;
    	let button0;
    	let t0;
    	let a1;
    	let button1;
    	let t1;
    	let if_block_anchor;
    	let current;

    	button0 = new ye({
    			props: {
    				outlined: true,
    				$$slots: { default: [create_default_slot_5$6] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button1 = new ye({
    			props: {
    				outlined: true,
    				$$slots: { default: [create_default_slot_4$9] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	let if_block = /*$globalStore*/ ctx[0].usuario.esMod && create_if_block$u(ctx);

    	const block = {
    		c: function create() {
    			a0 = element("a");
    			create_component(button0.$$.fragment);
    			t0 = space();
    			a1 = element("a");
    			create_component(button1.$$.fragment);
    			t1 = space();
    			if (if_block) if_block.c();
    			if_block_anchor = empty();
    			attr_dev(a0, "href", "/Moderacion");
    			add_location(a0, file$F, 7, 8, 237);
    			attr_dev(a1, "href", "/Moderacion/Media");
    			add_location(a1, file$F, 8, 8, 316);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a0, anchor);
    			mount_component(button0, a0, null);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, a1, anchor);
    			mount_component(button1, a1, null);
    			insert_dev(target, t1, anchor);
    			if (if_block) if_block.m(target, anchor);
    			insert_dev(target, if_block_anchor, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button0_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				button0_changes.$$scope = { dirty, ctx };
    			}

    			button0.$set(button0_changes);
    			const button1_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				button1_changes.$$scope = { dirty, ctx };
    			}

    			button1.$set(button1_changes);

    			if (/*$globalStore*/ ctx[0].usuario.esMod) {
    				if (if_block) {
    					if (dirty & /*$globalStore*/ 1) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$u(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(if_block_anchor.parentNode, if_block_anchor);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button0.$$.fragment, local);
    			transition_in(button1.$$.fragment, local);
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button0.$$.fragment, local);
    			transition_out(button1.$$.fragment, local);
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a0);
    			destroy_component(button0);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(a1);
    			destroy_component(button1);
    			if (detaching) detach_dev(t1);
    			if (if_block) if_block.d(detaching);
    			if (detaching) detach_dev(if_block_anchor);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$o.name,
    		type: "slot",
    		source: "(7:4) <ButtonGroup  color=\\\"var(--color7)\\\" >",
    		ctx
    	});

    	return block;
    }

    function create_fragment$F(ctx) {
    	let nav;
    	let buttongroup;
    	let current;

    	buttongroup = new $e({
    			props: {
    				color: "var(--color7)",
    				$$slots: { default: [create_default_slot$o] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			nav = element("nav");
    			create_component(buttongroup.$$.fragment);
    			attr_dev(nav, "class", "moderacion-nav svelte-ebkvgx");
    			set_style(nav, "width", "100%");
    			set_style(nav, "margin", "0 auto");
    			add_location(nav, file$F, 5, 0, 122);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, nav, anchor);
    			mount_component(buttongroup, nav, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const buttongroup_changes = {};

    			if (dirty & /*$$scope, $globalStore*/ 3) {
    				buttongroup_changes.$$scope = { dirty, ctx };
    			}

    			buttongroup.$set(buttongroup_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(buttongroup.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(buttongroup.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(nav);
    			destroy_component(buttongroup);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$F.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$F($$self, $$props, $$invalidate) {
    	let $globalStore;
    	validate_store(globalStore, "globalStore");
    	component_subscribe($$self, globalStore, $$value => $$invalidate(0, $globalStore = $$value));
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("BarraModeracion", slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<BarraModeracion> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		ButtonGroup: $e,
    		Button: ye,
    		globalStore,
    		$globalStore
    	});

    	return [$globalStore];
    }

    class BarraModeracion extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$F, create_fragment$F, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "BarraModeracion",
    			options,
    			id: create_fragment$F.name
    		});
    	}
    }

    /* src\components\Moderacion\ComentarioMod.svelte generated by Svelte v3.29.0 */
    const file$G = "src\\components\\Moderacion\\ComentarioMod.svelte";

    function create_fragment$G(ctx) {
    	let div;
    	let comentario_1;
    	let current;

    	comentario_1 = new Comentario({
    			props: {
    				hilo: { id: /*comentario*/ ctx[0].hiloId },
    				comentario: /*comentario*/ ctx[0]
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(comentario_1.$$.fragment);
    			toggle_class(div, "eliminado", /*comentario*/ ctx[0].estado == ComentarioEstado.eliminado);
    			add_location(div, file$G, 6, 4, 168);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(comentario_1, div, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const comentario_1_changes = {};
    			if (dirty & /*comentario*/ 1) comentario_1_changes.hilo = { id: /*comentario*/ ctx[0].hiloId };
    			if (dirty & /*comentario*/ 1) comentario_1_changes.comentario = /*comentario*/ ctx[0];
    			comentario_1.$set(comentario_1_changes);

    			if (dirty & /*comentario, ComentarioEstado*/ 1) {
    				toggle_class(div, "eliminado", /*comentario*/ ctx[0].estado == ComentarioEstado.eliminado);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(comentario_1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(comentario_1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(comentario_1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$G.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$G($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("ComentarioMod", slots, []);
    	let { comentario } = $$props;
    	const writable_props = ["comentario"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ComentarioMod> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("comentario" in $$props) $$invalidate(0, comentario = $$props.comentario);
    	};

    	$$self.$capture_state = () => ({ ComentarioEstado, Comentario, comentario });

    	$$self.$inject_state = $$props => {
    		if ("comentario" in $$props) $$invalidate(0, comentario = $$props.comentario);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [comentario];
    }

    class ComentarioMod extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$G, create_fragment$G, safe_not_equal, { comentario: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ComentarioMod",
    			options,
    			id: create_fragment$G.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*comentario*/ ctx[0] === undefined && !("comentario" in props)) {
    			console.warn("<ComentarioMod> was created without expected prop 'comentario'");
    		}
    	}

    	get comentario() {
    		throw new Error("<ComentarioMod>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set comentario(value) {
    		throw new Error("<ComentarioMod>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\components\Paginas\Moderacion.svelte generated by Svelte v3.29.0 */
    const file$H = "src\\components\\Paginas\\Moderacion.svelte";

    function get_each_context$i(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[4] = list[i];
    	return child_ctx;
    }

    function get_each_context_1$4(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[7] = list[i];
    	return child_ctx;
    }

    function get_each_context_2$3(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[10] = list[i];
    	return child_ctx;
    }

    function get_each_context_3$2(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[4] = list[i];
    	return child_ctx;
    }

    // (38:12) {#each comentariosMedia as c}
    function create_each_block_3$2(ctx) {
    	let li;
    	let a;
    	let img;
    	let img_src_value;
    	let a_href_value;
    	let t;

    	const block = {
    		c: function create() {
    			li = element("li");
    			a = element("a");
    			img = element("img");
    			t = space();
    			if (img.src !== (img_src_value = /*c*/ ctx[4].media.vistaPreviaCuadrado)) attr_dev(img, "src", img_src_value);
    			attr_dev(img, "alt", "");
    			attr_dev(img, "class", "svelte-ih139p");
    			add_location(img, file$H, 40, 24, 1350);
    			attr_dev(a, "href", a_href_value = "/Hilo/" + /*c*/ ctx[4].hiloId + "#" + /*c*/ ctx[4].id);
    			add_location(a, file$H, 39, 20, 1290);
    			add_location(li, file$H, 38, 16, 1264);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			append_dev(li, a);
    			append_dev(a, img);
    			append_dev(li, t);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_3$2.name,
    		type: "each",
    		source: "(38:12) {#each comentariosMedia as c}",
    		ctx
    	});

    	return block;
    }

    // (50:12) {#each denuncias as d}
    function create_each_block_2$3(ctx) {
    	let denuncia;
    	let current;

    	denuncia = new Denuncia({
    			props: { denuncia: /*d*/ ctx[10] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(denuncia.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(denuncia, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(denuncia.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(denuncia.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(denuncia, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_2$3.name,
    		type: "each",
    		source: "(50:12) {#each denuncias as d}",
    		ctx
    	});

    	return block;
    }

    // (56:12) {#each hilos as h (h.id)}
    function create_each_block_1$4(key_1, ctx) {
    	let first;
    	let hilopreviewmod;
    	let current;

    	hilopreviewmod = new HiloPreviewMod({
    			props: { hilo: /*h*/ ctx[7] },
    			$$inline: true
    		});

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			first = empty();
    			create_component(hilopreviewmod.$$.fragment);
    			this.first = first;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, first, anchor);
    			mount_component(hilopreviewmod, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const hilopreviewmod_changes = {};
    			if (dirty & /*hilos*/ 1) hilopreviewmod_changes.hilo = /*h*/ ctx[7];
    			hilopreviewmod.$set(hilopreviewmod_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(hilopreviewmod.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(hilopreviewmod.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(first);
    			destroy_component(hilopreviewmod, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$4.name,
    		type: "each",
    		source: "(56:12) {#each hilos as h (h.id)}",
    		ctx
    	});

    	return block;
    }

    // (62:12) {#each comentarios as c}
    function create_each_block$i(ctx) {
    	let li;
    	let comentariomod;
    	let t;
    	let li_transition;
    	let current;

    	comentariomod = new ComentarioMod({
    			props: { comentario: /*c*/ ctx[4] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			li = element("li");
    			create_component(comentariomod.$$.fragment);
    			t = space();
    			add_location(li, file$H, 62, 16, 2118);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			mount_component(comentariomod, li, null);
    			append_dev(li, t);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const comentariomod_changes = {};
    			if (dirty & /*comentarios*/ 2) comentariomod_changes.comentario = /*c*/ ctx[4];
    			comentariomod.$set(comentariomod_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(comentariomod.$$.fragment, local);

    			if (local) {
    				add_render_callback(() => {
    					if (!li_transition) li_transition = create_bidirectional_transition(li, fly, { y: -50, duration: 250 }, true);
    					li_transition.run(1);
    				});
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(comentariomod.$$.fragment, local);

    			if (local) {
    				if (!li_transition) li_transition = create_bidirectional_transition(li, fly, { y: -50, duration: 250 }, false);
    				li_transition.run(0);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			destroy_component(comentariomod);
    			if (detaching && li_transition) li_transition.end();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$i.name,
    		type: "each",
    		source: "(62:12) {#each comentarios as c}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$H(ctx) {
    	let main;
    	let barramoderacion;
    	let t0;
    	let div0;
    	let ul0;
    	let t1;
    	let div1;
    	let ul1;
    	let h30;
    	let t3;
    	let t4;
    	let ul2;
    	let h31;
    	let t6;
    	let each_blocks_1 = [];
    	let each2_lookup = new Map();
    	let t7;
    	let ul3;
    	let h32;
    	let t9;
    	let current;
    	barramoderacion = new BarraModeracion({ $$inline: true });
    	let each_value_3 = /*comentariosMedia*/ ctx[3];
    	validate_each_argument(each_value_3);
    	let each_blocks_3 = [];

    	for (let i = 0; i < each_value_3.length; i += 1) {
    		each_blocks_3[i] = create_each_block_3$2(get_each_context_3$2(ctx, each_value_3, i));
    	}

    	let each_value_2 = /*denuncias*/ ctx[2];
    	validate_each_argument(each_value_2);
    	let each_blocks_2 = [];

    	for (let i = 0; i < each_value_2.length; i += 1) {
    		each_blocks_2[i] = create_each_block_2$3(get_each_context_2$3(ctx, each_value_2, i));
    	}

    	const out = i => transition_out(each_blocks_2[i], 1, 1, () => {
    		each_blocks_2[i] = null;
    	});

    	let each_value_1 = /*hilos*/ ctx[0];
    	validate_each_argument(each_value_1);
    	const get_key = ctx => /*h*/ ctx[7].id;
    	validate_each_keys(ctx, each_value_1, get_each_context_1$4, get_key);

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		let child_ctx = get_each_context_1$4(ctx, each_value_1, i);
    		let key = get_key(child_ctx);
    		each2_lookup.set(key, each_blocks_1[i] = create_each_block_1$4(key, child_ctx));
    	}

    	let each_value = /*comentarios*/ ctx[1];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$i(get_each_context$i(ctx, each_value, i));
    	}

    	const out_1 = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			main = element("main");
    			create_component(barramoderacion.$$.fragment);
    			t0 = space();
    			div0 = element("div");
    			ul0 = element("ul");

    			for (let i = 0; i < each_blocks_3.length; i += 1) {
    				each_blocks_3[i].c();
    			}

    			t1 = space();
    			div1 = element("div");
    			ul1 = element("ul");
    			h30 = element("h3");
    			h30.textContent = "Ultimas denuncias";
    			t3 = space();

    			for (let i = 0; i < each_blocks_2.length; i += 1) {
    				each_blocks_2[i].c();
    			}

    			t4 = space();
    			ul2 = element("ul");
    			h31 = element("h3");
    			h31.textContent = "Ultimos hilos";
    			t6 = space();

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].c();
    			}

    			t7 = space();
    			ul3 = element("ul");
    			h32 = element("h3");
    			h32.textContent = "Ultimos comentarios";
    			t9 = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(ul0, "class", "svelte-ih139p");
    			add_location(ul0, file$H, 36, 8, 1199);
    			attr_dev(div0, "class", "ultimos-medias svelte-ih139p");
    			add_location(div0, file$H, 35, 4, 1161);
    			set_style(h30, "height", "40px");
    			add_location(h30, file$H, 48, 12, 1619);
    			set_style(ul1, "width", "33%");
    			set_style(ul1, "background", "#711c08");
    			set_style(ul1, "font-size", "0.7em");
    			attr_dev(ul1, "class", "svelte-ih139p");
    			add_location(ul1, file$H, 47, 8, 1533);
    			set_style(h31, "height", "40px");
    			add_location(h31, file$H, 54, 12, 1825);
    			set_style(ul2, "width", "33%");
    			attr_dev(ul2, "class", "svelte-ih139p");
    			add_location(ul2, file$H, 53, 8, 1789);
    			set_style(h32, "height", "40px");
    			add_location(h32, file$H, 60, 12, 2014);
    			attr_dev(ul3, "class", "svelte-ih139p");
    			add_location(ul3, file$H, 59, 8, 1996);
    			attr_dev(div1, "class", "seccion2 svelte-ih139p");
    			add_location(div1, file$H, 46, 4, 1501);
    			attr_dev(main, "class", "svelte-ih139p");
    			add_location(main, file$H, 33, 0, 1125);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			mount_component(barramoderacion, main, null);
    			append_dev(main, t0);
    			append_dev(main, div0);
    			append_dev(div0, ul0);

    			for (let i = 0; i < each_blocks_3.length; i += 1) {
    				each_blocks_3[i].m(ul0, null);
    			}

    			append_dev(main, t1);
    			append_dev(main, div1);
    			append_dev(div1, ul1);
    			append_dev(ul1, h30);
    			append_dev(ul1, t3);

    			for (let i = 0; i < each_blocks_2.length; i += 1) {
    				each_blocks_2[i].m(ul1, null);
    			}

    			append_dev(div1, t4);
    			append_dev(div1, ul2);
    			append_dev(ul2, h31);
    			append_dev(ul2, t6);

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].m(ul2, null);
    			}

    			append_dev(div1, t7);
    			append_dev(div1, ul3);
    			append_dev(ul3, h32);
    			append_dev(ul3, t9);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(ul3, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*comentariosMedia*/ 8) {
    				each_value_3 = /*comentariosMedia*/ ctx[3];
    				validate_each_argument(each_value_3);
    				let i;

    				for (i = 0; i < each_value_3.length; i += 1) {
    					const child_ctx = get_each_context_3$2(ctx, each_value_3, i);

    					if (each_blocks_3[i]) {
    						each_blocks_3[i].p(child_ctx, dirty);
    					} else {
    						each_blocks_3[i] = create_each_block_3$2(child_ctx);
    						each_blocks_3[i].c();
    						each_blocks_3[i].m(ul0, null);
    					}
    				}

    				for (; i < each_blocks_3.length; i += 1) {
    					each_blocks_3[i].d(1);
    				}

    				each_blocks_3.length = each_value_3.length;
    			}

    			if (dirty & /*denuncias*/ 4) {
    				each_value_2 = /*denuncias*/ ctx[2];
    				validate_each_argument(each_value_2);
    				let i;

    				for (i = 0; i < each_value_2.length; i += 1) {
    					const child_ctx = get_each_context_2$3(ctx, each_value_2, i);

    					if (each_blocks_2[i]) {
    						each_blocks_2[i].p(child_ctx, dirty);
    						transition_in(each_blocks_2[i], 1);
    					} else {
    						each_blocks_2[i] = create_each_block_2$3(child_ctx);
    						each_blocks_2[i].c();
    						transition_in(each_blocks_2[i], 1);
    						each_blocks_2[i].m(ul1, null);
    					}
    				}

    				group_outros();

    				for (i = each_value_2.length; i < each_blocks_2.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}

    			if (dirty & /*hilos*/ 1) {
    				const each_value_1 = /*hilos*/ ctx[0];
    				validate_each_argument(each_value_1);
    				group_outros();
    				validate_each_keys(ctx, each_value_1, get_each_context_1$4, get_key);
    				each_blocks_1 = update_keyed_each(each_blocks_1, dirty, get_key, 1, ctx, each_value_1, each2_lookup, ul2, outro_and_destroy_block, create_each_block_1$4, null, get_each_context_1$4);
    				check_outros();
    			}

    			if (dirty & /*comentarios*/ 2) {
    				each_value = /*comentarios*/ ctx[1];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$i(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$i(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(ul3, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out_1(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(barramoderacion.$$.fragment, local);

    			for (let i = 0; i < each_value_2.length; i += 1) {
    				transition_in(each_blocks_2[i]);
    			}

    			for (let i = 0; i < each_value_1.length; i += 1) {
    				transition_in(each_blocks_1[i]);
    			}

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(barramoderacion.$$.fragment, local);
    			each_blocks_2 = each_blocks_2.filter(Boolean);

    			for (let i = 0; i < each_blocks_2.length; i += 1) {
    				transition_out(each_blocks_2[i]);
    			}

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				transition_out(each_blocks_1[i]);
    			}

    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    			destroy_component(barramoderacion);
    			destroy_each(each_blocks_3, detaching);
    			destroy_each(each_blocks_2, detaching);

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].d();
    			}

    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$H.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$H($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Moderacion", slots, []);
    	let hilos = window.model.hilos;
    	let comentarios = window.model.comentarios;
    	let denuncias = window.model.denuncias;
    	let comentariosMedia = window.model.medias;

    	comentarios = comentarios.map(c => {
    		c.respuestas = [];
    		return c;
    	});

    	Signal.subscribirAModeracion();

    	Signal.coneccion.on("NuevoComentarioMod", comentario => {
    		comentario.respuestas = [];
    		comentarios.unshift(comentario);
    		comentarios.pop();
    		$$invalidate(1, comentarios);
    	});

    	Signal.coneccion.on("HiloCreadoMod", hilo => {
    		hilos.pop();
    		$$invalidate(0, hilos = [hilo, ...hilos]);
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Moderacion> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		Comentario,
    		fly,
    		Denuncia,
    		HiloPreview,
    		BarraModeracion,
    		ComentarioMod,
    		HiloPreviewMod,
    		Sigal: Signal,
    		hilos,
    		comentarios,
    		denuncias,
    		comentariosMedia
    	});

    	$$self.$inject_state = $$props => {
    		if ("hilos" in $$props) $$invalidate(0, hilos = $$props.hilos);
    		if ("comentarios" in $$props) $$invalidate(1, comentarios = $$props.comentarios);
    		if ("denuncias" in $$props) $$invalidate(2, denuncias = $$props.denuncias);
    		if ("comentariosMedia" in $$props) $$invalidate(3, comentariosMedia = $$props.comentariosMedia);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [hilos, comentarios, denuncias, comentariosMedia];
    }

    class Moderacion extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$H, create_fragment$H, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Moderacion",
    			options,
    			id: create_fragment$H.name
    		});
    	}
    }

    /* src\components\Paginas\Login.svelte generated by Svelte v3.29.0 */

    const { console: console_1$d } = globals;
    const file$I = "src\\components\\Paginas\\Login.svelte";

    // (52:12) <Checkbox bind:checked={usarToken}>
    function create_default_slot_1$k(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Usar Token");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$k.name,
    		type: "slot",
    		source: "(52:12) <Checkbox bind:checked={usarToken}>",
    		ctx
    	});

    	return block;
    }

    // (70:16) {:else}
    function create_else_block$9(ctx) {
    	let textfield;
    	let updating_value;
    	let current;

    	function textfield_value_binding(value) {
    		/*textfield_value_binding*/ ctx[9].call(null, value);
    	}

    	let textfield_props = {
    		autocomplete: "off",
    		label: "Token de sesion"
    	};

    	if (/*token*/ ctx[4] !== void 0) {
    		textfield_props.value = /*token*/ ctx[4];
    	}

    	textfield = new Ve({ props: textfield_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield, "value", textfield_value_binding));

    	const block = {
    		c: function create() {
    			create_component(textfield.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(textfield, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const textfield_changes = {};

    			if (!updating_value && dirty & /*token*/ 16) {
    				updating_value = true;
    				textfield_changes.value = /*token*/ ctx[4];
    				add_flush_callback(() => updating_value = false);
    			}

    			textfield.$set(textfield_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(textfield.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(textfield.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(textfield, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$9.name,
    		type: "else",
    		source: "(70:16) {:else}",
    		ctx
    	});

    	return block;
    }

    // (53:12) {#if !usarToken}
    function create_if_block$v(ctx) {
    	let errorvalidacion;
    	let t0;
    	let textfield0;
    	let updating_value;
    	let t1;
    	let textfield1;
    	let updating_value_1;
    	let current;

    	errorvalidacion = new ErrorValidacion({
    			props: { error: /*error*/ ctx[2] },
    			$$inline: true
    		});

    	function textfield0_value_binding(value) {
    		/*textfield0_value_binding*/ ctx[7].call(null, value);
    	}

    	let textfield0_props = {
    		autocomplete: "off",
    		label: "Nombre de usuario",
    		required: true,
    		message: "kikefoster4000"
    	};

    	if (/*username*/ ctx[0] !== void 0) {
    		textfield0_props.value = /*username*/ ctx[0];
    	}

    	textfield0 = new Ve({ props: textfield0_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield0, "value", textfield0_value_binding));

    	function textfield1_value_binding(value) {
    		/*textfield1_value_binding*/ ctx[8].call(null, value);
    	}

    	let textfield1_props = {
    		autocomplete: "off",
    		label: "Contraseña",
    		type: "password",
    		required: true,
    		message: "aynose1234"
    	};

    	if (/*password*/ ctx[1] !== void 0) {
    		textfield1_props.value = /*password*/ ctx[1];
    	}

    	textfield1 = new Ve({ props: textfield1_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield1, "value", textfield1_value_binding));

    	const block = {
    		c: function create() {
    			create_component(errorvalidacion.$$.fragment);
    			t0 = space();
    			create_component(textfield0.$$.fragment);
    			t1 = space();
    			create_component(textfield1.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(errorvalidacion, target, anchor);
    			insert_dev(target, t0, anchor);
    			mount_component(textfield0, target, anchor);
    			insert_dev(target, t1, anchor);
    			mount_component(textfield1, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const errorvalidacion_changes = {};
    			if (dirty & /*error*/ 4) errorvalidacion_changes.error = /*error*/ ctx[2];
    			errorvalidacion.$set(errorvalidacion_changes);
    			const textfield0_changes = {};

    			if (!updating_value && dirty & /*username*/ 1) {
    				updating_value = true;
    				textfield0_changes.value = /*username*/ ctx[0];
    				add_flush_callback(() => updating_value = false);
    			}

    			textfield0.$set(textfield0_changes);
    			const textfield1_changes = {};

    			if (!updating_value_1 && dirty & /*password*/ 2) {
    				updating_value_1 = true;
    				textfield1_changes.value = /*password*/ ctx[1];
    				add_flush_callback(() => updating_value_1 = false);
    			}

    			textfield1.$set(textfield1_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(errorvalidacion.$$.fragment, local);
    			transition_in(textfield0.$$.fragment, local);
    			transition_in(textfield1.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(errorvalidacion.$$.fragment, local);
    			transition_out(textfield0.$$.fragment, local);
    			transition_out(textfield1.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(errorvalidacion, detaching);
    			if (detaching) detach_dev(t0);
    			destroy_component(textfield0, detaching);
    			if (detaching) detach_dev(t1);
    			destroy_component(textfield1, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$v.name,
    		type: "if",
    		source: "(53:12) {#if !usarToken}",
    		ctx
    	});

    	return block;
    }

    // (79:20) <Button >
    function create_default_slot$p(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Entrar");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$p.name,
    		type: "slot",
    		source: "(79:20) <Button >",
    		ctx
    	});

    	return block;
    }

    function create_fragment$I(ctx) {
    	let div0;
    	let t0;
    	let main;
    	let section;
    	let errorvalidacion;
    	let t1;
    	let h1;
    	let t3;
    	let h2;
    	let t5;
    	let h3;
    	let t6;
    	let a0;
    	let t8;
    	let a1;
    	let t10;
    	let form;
    	let checkbox;
    	let updating_checked;
    	let t11;
    	let current_block_type_index;
    	let if_block;
    	let t12;
    	let div1;
    	let button;
    	let current;
    	let mounted;
    	let dispose;

    	errorvalidacion = new ErrorValidacion({
    			props: { error: /*error*/ ctx[2] },
    			$$inline: true
    		});

    	function checkbox_checked_binding(value) {
    		/*checkbox_checked_binding*/ ctx[6].call(null, value);
    	}

    	let checkbox_props = {
    		$$slots: { default: [create_default_slot_1$k] },
    		$$scope: { ctx }
    	};

    	if (/*usarToken*/ ctx[3] !== void 0) {
    		checkbox_props.checked = /*usarToken*/ ctx[3];
    	}

    	checkbox = new Ne({ props: checkbox_props, $$inline: true });
    	binding_callbacks.push(() => bind(checkbox, "checked", checkbox_checked_binding));
    	const if_block_creators = [create_if_block$v, create_else_block$9];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (!/*usarToken*/ ctx[3]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	button = new ye({
    			props: {
    				$$slots: { default: [create_default_slot$p] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div0 = element("div");
    			t0 = space();
    			main = element("main");
    			section = element("section");
    			create_component(errorvalidacion.$$.fragment);
    			t1 = space();
    			h1 = element("h1");
    			h1.textContent = "Hola anon!";
    			t3 = space();
    			h2 = element("h2");
    			h2.textContent = "Para crear y responder rozes en Rozed debes iniciar una sesion";
    			t5 = space();
    			h3 = element("h3");
    			t6 = text("No tenes un token o una cuenta? Enfermo!,  podes ");
    			a0 = element("a");
    			a0.textContent = "Iniciar Sesion";
    			t8 = text(" o ");
    			a1 = element("a");
    			a1.textContent = "registrate";
    			t10 = space();
    			form = element("form");
    			create_component(checkbox.$$.fragment);
    			t11 = space();
    			if_block.c();
    			t12 = space();
    			div1 = element("div");
    			create_component(button.$$.fragment);
    			attr_dev(div0, "class", "fondo svelte-t1g0rt");
    			add_location(div0, file$I, 38, 0, 1080);
    			add_location(h1, file$I, 45, 8, 1273);
    			add_location(h2, file$I, 46, 8, 1302);
    			attr_dev(a0, "href", "/Inicio");
    			set_style(a0, "color", "var(--color5) ");
    			add_location(a0, file$I, 47, 61, 1436);
    			attr_dev(a1, "href", "/Registro");
    			set_style(a1, "color", "var(--color5) ");
    			add_location(a1, file$I, 47, 128, 1503);
    			add_location(h3, file$I, 47, 8, 1383);
    			set_style(div1, "display", "flex");
    			set_style(div1, "justify-content", "center");
    			add_location(div1, file$I, 77, 16, 2536);
    			attr_dev(form, "class", "svelte-t1g0rt");
    			add_location(form, file$I, 50, 8, 1593);
    			attr_dev(section, "class", "svelte-t1g0rt");
    			add_location(section, file$I, 43, 4, 1216);
    			attr_dev(main, "class", "svelte-t1g0rt");
    			add_location(main, file$I, 40, 0, 1109);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div0, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, main, anchor);
    			append_dev(main, section);
    			mount_component(errorvalidacion, section, null);
    			append_dev(section, t1);
    			append_dev(section, h1);
    			append_dev(section, t3);
    			append_dev(section, h2);
    			append_dev(section, t5);
    			append_dev(section, h3);
    			append_dev(h3, t6);
    			append_dev(h3, a0);
    			append_dev(h3, t8);
    			append_dev(h3, a1);
    			append_dev(section, t10);
    			append_dev(section, form);
    			mount_component(checkbox, form, null);
    			append_dev(form, t11);
    			if_blocks[current_block_type_index].m(form, null);
    			append_dev(form, t12);
    			append_dev(form, div1);
    			mount_component(button, div1, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(form, "submit", prevent_default(/*accion*/ ctx[5]), false, true, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			const errorvalidacion_changes = {};
    			if (dirty & /*error*/ 4) errorvalidacion_changes.error = /*error*/ ctx[2];
    			errorvalidacion.$set(errorvalidacion_changes);
    			const checkbox_changes = {};

    			if (dirty & /*$$scope*/ 2048) {
    				checkbox_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_checked && dirty & /*usarToken*/ 8) {
    				updating_checked = true;
    				checkbox_changes.checked = /*usarToken*/ ctx[3];
    				add_flush_callback(() => updating_checked = false);
    			}

    			checkbox.$set(checkbox_changes);
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				}

    				transition_in(if_block, 1);
    				if_block.m(form, t12);
    			}

    			const button_changes = {};

    			if (dirty & /*$$scope*/ 2048) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(errorvalidacion.$$.fragment, local);
    			transition_in(checkbox.$$.fragment, local);
    			transition_in(if_block);
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(errorvalidacion.$$.fragment, local);
    			transition_out(checkbox.$$.fragment, local);
    			transition_out(if_block);
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div0);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(main);
    			destroy_component(errorvalidacion);
    			destroy_component(checkbox);
    			if_blocks[current_block_type_index].d();
    			destroy_component(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$I.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$I($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Login", slots, []);
    	let username = "";
    	let password = "";
    	let captcha = "";
    	let error = null;
    	let usarToken = false;
    	let token = "";

    	async function accion(e) {
    		console.log(captcha);

    		try {
    			let res = null;

    			if (!usarToken) {
    				res = await RChanClient.logearse(username, password);
    			} else {
    				res = await RChanClient.restaurarSesion(token);
    			}
    		} catch(e) {
    			console.log(e); // if(res.data.redirect) {
    			$$invalidate(2, error = e.response.data);
    			return;
    		}

    		console.log("chan");
    		window.location = "/";
    	} // location.reload();

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$d.warn(`<Login> was created with unknown prop '${key}'`);
    	});

    	function checkbox_checked_binding(value) {
    		usarToken = value;
    		$$invalidate(3, usarToken);
    	}

    	function textfield0_value_binding(value) {
    		username = value;
    		$$invalidate(0, username);
    	}

    	function textfield1_value_binding(value) {
    		password = value;
    		$$invalidate(1, password);
    	}

    	function textfield_value_binding(value) {
    		token = value;
    		$$invalidate(4, token);
    	}

    	$$self.$capture_state = () => ({
    		Textfield: Ve,
    		Button: ye,
    		Ripple: he,
    		Checkbox: Ne,
    		RChanClient,
    		Captcha,
    		ErrorValidacion,
    		config,
    		username,
    		password,
    		captcha,
    		error,
    		usarToken,
    		token,
    		accion
    	});

    	$$self.$inject_state = $$props => {
    		if ("username" in $$props) $$invalidate(0, username = $$props.username);
    		if ("password" in $$props) $$invalidate(1, password = $$props.password);
    		if ("captcha" in $$props) captcha = $$props.captcha;
    		if ("error" in $$props) $$invalidate(2, error = $$props.error);
    		if ("usarToken" in $$props) $$invalidate(3, usarToken = $$props.usarToken);
    		if ("token" in $$props) $$invalidate(4, token = $$props.token);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		username,
    		password,
    		error,
    		usarToken,
    		token,
    		accion,
    		checkbox_checked_binding,
    		textfield0_value_binding,
    		textfield1_value_binding,
    		textfield_value_binding
    	];
    }

    class Login extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$I, create_fragment$I, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Login",
    			options,
    			id: create_fragment$I.name
    		});
    	}
    }

    /* src\components\Paginas\Registro.svelte generated by Svelte v3.29.0 */

    const { console: console_1$e } = globals;
    const file$J = "src\\components\\Paginas\\Registro.svelte";

    // (67:8) {:else}
    function create_else_block$a(ctx) {
    	let h2;

    	const block = {
    		c: function create() {
    			h2 = element("h2");
    			h2.textContent = "Lo siento anon, el registro esta temporalmente deshabilitado";
    			add_location(h2, file$J, 67, 12, 2464);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h2, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h2);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$a.name,
    		type: "else",
    		source: "(67:8) {:else}",
    		ctx
    	});

    	return block;
    }

    // (38:8) {#if config.general.registroAbierto || codigo}
    function create_if_block$w(ctx) {
    	let h2;
    	let t1;
    	let h4;
    	let t3;
    	let errorvalidacion;
    	let t4;
    	let form;
    	let textfield0;
    	let updating_value;
    	let t5;
    	let textfield1;
    	let updating_value_1;
    	let t6;
    	let a;
    	let t8;
    	let checkbox;
    	let updating_checked;
    	let t9;
    	let captcha_1;
    	let updating_token;
    	let t10;
    	let div;
    	let button;
    	let current;
    	let mounted;
    	let dispose;

    	errorvalidacion = new ErrorValidacion({
    			props: { error: /*error*/ ctx[4] },
    			$$inline: true
    		});

    	function textfield0_value_binding(value) {
    		/*textfield0_value_binding*/ ctx[7].call(null, value);
    	}

    	let textfield0_props = {
    		autocomplete: "off",
    		label: "Nombre de usuario",
    		required: true,
    		message: "kikefoster4000"
    	};

    	if (/*username*/ ctx[0] !== void 0) {
    		textfield0_props.value = /*username*/ ctx[0];
    	}

    	textfield0 = new Ve({ props: textfield0_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield0, "value", textfield0_value_binding));

    	function textfield1_value_binding(value) {
    		/*textfield1_value_binding*/ ctx[8].call(null, value);
    	}

    	let textfield1_props = {
    		autocomplete: "off",
    		label: "Contraseña",
    		type: "password",
    		required: true,
    		message: "Si te la olvidas, domado"
    	};

    	if (/*password*/ ctx[1] !== void 0) {
    		textfield1_props.value = /*password*/ ctx[1];
    	}

    	textfield1 = new Ve({ props: textfield1_props, $$inline: true });
    	binding_callbacks.push(() => bind(textfield1, "value", textfield1_value_binding));

    	function checkbox_checked_binding(value) {
    		/*checkbox_checked_binding*/ ctx[9].call(null, value);
    	}

    	let checkbox_props = {
    		right: true,
    		$$slots: { default: [create_default_slot_1$l] },
    		$$scope: { ctx }
    	};

    	if (/*terminos*/ ctx[2] !== void 0) {
    		checkbox_props.checked = /*terminos*/ ctx[2];
    	}

    	checkbox = new Ne({ props: checkbox_props, $$inline: true });
    	binding_callbacks.push(() => bind(checkbox, "checked", checkbox_checked_binding));

    	function captcha_1_token_binding(value) {
    		/*captcha_1_token_binding*/ ctx[10].call(null, value);
    	}

    	let captcha_1_props = { visible: config.general.captchaRegistro };

    	if (/*captcha*/ ctx[3] !== void 0) {
    		captcha_1_props.token = /*captcha*/ ctx[3];
    	}

    	captcha_1 = new Captcha({ props: captcha_1_props, $$inline: true });
    	binding_callbacks.push(() => bind(captcha_1, "token", captcha_1_token_binding));

    	button = new ye({
    			props: {
    				disabled: !/*terminos*/ ctx[2],
    				$$slots: { default: [create_default_slot$q] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			h2 = element("h2");
    			h2.textContent = "Registrate con cofianza";
    			t1 = space();
    			h4 = element("h4");
    			h4.textContent = "Tu ip esta a salvo, desde ya que si";
    			t3 = space();
    			create_component(errorvalidacion.$$.fragment);
    			t4 = space();
    			form = element("form");
    			create_component(textfield0.$$.fragment);
    			t5 = space();
    			create_component(textfield1.$$.fragment);
    			t6 = space();
    			a = element("a");
    			a.textContent = "Ver reglas";
    			t8 = space();
    			create_component(checkbox.$$.fragment);
    			t9 = space();
    			create_component(captcha_1.$$.fragment);
    			t10 = space();
    			div = element("div");
    			create_component(button.$$.fragment);
    			add_location(h2, file$J, 38, 12, 1108);
    			add_location(h4, file$J, 39, 12, 1154);
    			set_style(a, "color", "var(--color5)");
    			set_style(a, "text-align", "center");
    			set_style(a, "display", "block");
    			attr_dev(a, "target", "_blanck");
    			attr_dev(a, "href", "/reglas.html");
    			add_location(a, file$J, 57, 16, 1838);
    			set_style(div, "display", "flex");
    			set_style(div, "justify-content", "center");
    			set_style(div, "margin-top", "8px");
    			add_location(div, file$J, 61, 16, 2247);
    			attr_dev(form, "class", "svelte-15jfbxr");
    			add_location(form, file$J, 41, 12, 1252);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h2, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, h4, anchor);
    			insert_dev(target, t3, anchor);
    			mount_component(errorvalidacion, target, anchor);
    			insert_dev(target, t4, anchor);
    			insert_dev(target, form, anchor);
    			mount_component(textfield0, form, null);
    			append_dev(form, t5);
    			mount_component(textfield1, form, null);
    			append_dev(form, t6);
    			append_dev(form, a);
    			append_dev(form, t8);
    			mount_component(checkbox, form, null);
    			append_dev(form, t9);
    			mount_component(captcha_1, form, null);
    			append_dev(form, t10);
    			append_dev(form, div);
    			mount_component(button, div, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(form, "submit", prevent_default(/*accion*/ ctx[6]), false, true, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			const errorvalidacion_changes = {};
    			if (dirty & /*error*/ 16) errorvalidacion_changes.error = /*error*/ ctx[4];
    			errorvalidacion.$set(errorvalidacion_changes);
    			const textfield0_changes = {};

    			if (!updating_value && dirty & /*username*/ 1) {
    				updating_value = true;
    				textfield0_changes.value = /*username*/ ctx[0];
    				add_flush_callback(() => updating_value = false);
    			}

    			textfield0.$set(textfield0_changes);
    			const textfield1_changes = {};

    			if (!updating_value_1 && dirty & /*password*/ 2) {
    				updating_value_1 = true;
    				textfield1_changes.value = /*password*/ ctx[1];
    				add_flush_callback(() => updating_value_1 = false);
    			}

    			textfield1.$set(textfield1_changes);
    			const checkbox_changes = {};

    			if (dirty & /*$$scope*/ 2048) {
    				checkbox_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_checked && dirty & /*terminos*/ 4) {
    				updating_checked = true;
    				checkbox_changes.checked = /*terminos*/ ctx[2];
    				add_flush_callback(() => updating_checked = false);
    			}

    			checkbox.$set(checkbox_changes);
    			const captcha_1_changes = {};

    			if (!updating_token && dirty & /*captcha*/ 8) {
    				updating_token = true;
    				captcha_1_changes.token = /*captcha*/ ctx[3];
    				add_flush_callback(() => updating_token = false);
    			}

    			captcha_1.$set(captcha_1_changes);
    			const button_changes = {};
    			if (dirty & /*terminos*/ 4) button_changes.disabled = !/*terminos*/ ctx[2];

    			if (dirty & /*$$scope*/ 2048) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(errorvalidacion.$$.fragment, local);
    			transition_in(textfield0.$$.fragment, local);
    			transition_in(textfield1.$$.fragment, local);
    			transition_in(checkbox.$$.fragment, local);
    			transition_in(captcha_1.$$.fragment, local);
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(errorvalidacion.$$.fragment, local);
    			transition_out(textfield0.$$.fragment, local);
    			transition_out(textfield1.$$.fragment, local);
    			transition_out(checkbox.$$.fragment, local);
    			transition_out(captcha_1.$$.fragment, local);
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h2);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(h4);
    			if (detaching) detach_dev(t3);
    			destroy_component(errorvalidacion, detaching);
    			if (detaching) detach_dev(t4);
    			if (detaching) detach_dev(form);
    			destroy_component(textfield0);
    			destroy_component(textfield1);
    			destroy_component(checkbox);
    			destroy_component(captcha_1);
    			destroy_component(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$w.name,
    		type: "if",
    		source: "(38:8) {#if config.general.registroAbierto || codigo}",
    		ctx
    	});

    	return block;
    }

    // (59:16) <Checkbox right bind:checked={terminos}>
    function create_default_slot_1$l(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			div.textContent = "Yo Anon juro solemnemente seguir las reglas de Rozed";
    			set_style(div, "white-space", "normal");
    			set_style(div, "text-align", "center");
    			add_location(div, file$J, 58, 56, 2012);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$l.name,
    		type: "slot",
    		source: "(59:16) <Checkbox right bind:checked={terminos}>",
    		ctx
    	});

    	return block;
    }

    // (63:20) <Button disabled={!terminos}>
    function create_default_slot$q(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Registrarse");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$q.name,
    		type: "slot",
    		source: "(63:20) <Button disabled={!terminos}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$J(ctx) {
    	let div;
    	let t;
    	let main;
    	let section;
    	let current_block_type_index;
    	let if_block;
    	let current;
    	const if_block_creators = [create_if_block$w, create_else_block$a];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (config.general.registroAbierto || /*codigo*/ ctx[5]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = space();
    			main = element("main");
    			section = element("section");
    			if_block.c();
    			attr_dev(div, "class", "fondo svelte-15jfbxr");
    			add_location(div, file$J, 32, 0, 894);
    			attr_dev(section, "class", "svelte-15jfbxr");
    			add_location(section, file$J, 36, 4, 1028);
    			attr_dev(main, "class", "svelte-15jfbxr");
    			add_location(main, file$J, 33, 0, 921);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			insert_dev(target, t, anchor);
    			insert_dev(target, main, anchor);
    			append_dev(main, section);
    			if_blocks[current_block_type_index].m(section, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				}

    				transition_in(if_block, 1);
    				if_block.m(section, null);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (detaching) detach_dev(t);
    			if (detaching) detach_dev(main);
    			if_blocks[current_block_type_index].d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$J.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$J($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Registro", slots, []);
    	let username = "";
    	let password = "";
    	let terminos = false;
    	let captcha = "";
    	let error = null;
    	let codigo = "";

    	if (window.model && window.model.codigoDeInvitacion) {
    		codigo = window.model.codigoDeInvitacion;
    	}

    	async function accion(e) {
    		console.log(captcha);

    		try {
    			await RChanClient.registrase(username, password, captcha, codigo);
    		} catch(e) {
    			console.log(e);
    			$$invalidate(4, error = e.response.data);
    			return;
    		}

    		window.location = "/";
    	} // location.reload();

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$e.warn(`<Registro> was created with unknown prop '${key}'`);
    	});

    	function textfield0_value_binding(value) {
    		username = value;
    		$$invalidate(0, username);
    	}

    	function textfield1_value_binding(value) {
    		password = value;
    		$$invalidate(1, password);
    	}

    	function checkbox_checked_binding(value) {
    		terminos = value;
    		$$invalidate(2, terminos);
    	}

    	function captcha_1_token_binding(value) {
    		captcha = value;
    		$$invalidate(3, captcha);
    	}

    	$$self.$capture_state = () => ({
    		Textfield: Ve,
    		Button: ye,
    		Ripple: he,
    		Checkbox: Ne,
    		RChanClient,
    		Captcha,
    		ErrorValidacion,
    		config,
    		username,
    		password,
    		terminos,
    		captcha,
    		error,
    		codigo,
    		accion
    	});

    	$$self.$inject_state = $$props => {
    		if ("username" in $$props) $$invalidate(0, username = $$props.username);
    		if ("password" in $$props) $$invalidate(1, password = $$props.password);
    		if ("terminos" in $$props) $$invalidate(2, terminos = $$props.terminos);
    		if ("captcha" in $$props) $$invalidate(3, captcha = $$props.captcha);
    		if ("error" in $$props) $$invalidate(4, error = $$props.error);
    		if ("codigo" in $$props) $$invalidate(5, codigo = $$props.codigo);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		username,
    		password,
    		terminos,
    		captcha,
    		error,
    		codigo,
    		accion,
    		textfield0_value_binding,
    		textfield1_value_binding,
    		checkbox_checked_binding,
    		captcha_1_token_binding
    	];
    }

    class Registro extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$J, create_fragment$J, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Registro",
    			options,
    			id: create_fragment$J.name
    		});
    	}
    }

    /* src\components\Paginas\Inicio.svelte generated by Svelte v3.29.0 */

    const { console: console_1$f } = globals;
    const file$K = "src\\components\\Paginas\\Inicio.svelte";

    // (53:8) {:else}
    function create_else_block$b(ctx) {
    	let h2;

    	const block = {
    		c: function create() {
    			h2 = element("h2");
    			h2.textContent = "Lo siento anon, el inicio de sesiones esta temporalmente deshabilitado";
    			add_location(h2, file$K, 53, 12, 2051);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h2, anchor);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h2);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_else_block$b.name,
    		type: "else",
    		source: "(53:8) {:else}",
    		ctx
    	});

    	return block;
    }

    // (37:8) {#if config.general.registroAbierto || codigo}
    function create_if_block$x(ctx) {
    	let h2;
    	let t1;
    	let h40;
    	let t3;
    	let h41;
    	let t4;
    	let a0;
    	let t6;
    	let errorvalidacion;
    	let t7;
    	let form;
    	let a1;
    	let t9;
    	let checkbox;
    	let updating_checked;
    	let t10;
    	let captcha_1;
    	let updating_token;
    	let t11;
    	let div;
    	let button;
    	let current;
    	let mounted;
    	let dispose;

    	errorvalidacion = new ErrorValidacion({
    			props: { error: /*error*/ ctx[2] },
    			$$inline: true
    		});

    	function checkbox_checked_binding(value) {
    		/*checkbox_checked_binding*/ ctx[5].call(null, value);
    	}

    	let checkbox_props = {
    		right: true,
    		$$slots: { default: [create_default_slot_1$m] },
    		$$scope: { ctx }
    	};

    	if (/*terminos*/ ctx[0] !== void 0) {
    		checkbox_props.checked = /*terminos*/ ctx[0];
    	}

    	checkbox = new Ne({ props: checkbox_props, $$inline: true });
    	binding_callbacks.push(() => bind(checkbox, "checked", checkbox_checked_binding));

    	function captcha_1_token_binding(value) {
    		/*captcha_1_token_binding*/ ctx[6].call(null, value);
    	}

    	let captcha_1_props = { visible: config.general.captchaRegistro };

    	if (/*captcha*/ ctx[1] !== void 0) {
    		captcha_1_props.token = /*captcha*/ ctx[1];
    	}

    	captcha_1 = new Captcha({ props: captcha_1_props, $$inline: true });
    	binding_callbacks.push(() => bind(captcha_1, "token", captcha_1_token_binding));

    	button = new ye({
    			props: {
    				disabled: !/*terminos*/ ctx[0],
    				$$slots: { default: [create_default_slot$r] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			h2 = element("h2");
    			h2.textContent = "Para usar Rozed debes leer y aceptar las reglas";
    			t1 = space();
    			h40 = element("h4");
    			h40.textContent = "Tu ip esta a salvo, desde ya que si";
    			t3 = space();
    			h41 = element("h4");
    			t4 = text("Preferis crear una sesion con usuario y contraseña?   ");
    			a0 = element("a");
    			a0.textContent = "Registro";
    			t6 = space();
    			create_component(errorvalidacion.$$.fragment);
    			t7 = space();
    			form = element("form");
    			a1 = element("a");
    			a1.textContent = "Ver reglas";
    			t9 = space();
    			create_component(checkbox.$$.fragment);
    			t10 = space();
    			create_component(captcha_1.$$.fragment);
    			t11 = space();
    			div = element("div");
    			create_component(button.$$.fragment);
    			add_location(h2, file$K, 37, 12, 1047);
    			add_location(h40, file$K, 38, 12, 1117);
    			set_style(a0, "color", "var(--color5)");
    			set_style(a0, "text-align", "center");
    			attr_dev(a0, "href", "/Registro");
    			add_location(a0, file$K, 39, 70, 1233);
    			add_location(h41, file$K, 39, 12, 1175);
    			set_style(a1, "color", "var(--color5)");
    			set_style(a1, "text-align", "center");
    			set_style(a1, "display", "block");
    			attr_dev(a1, "target", "_blank");
    			attr_dev(a1, "href", "/reglas.html");
    			add_location(a1, file$K, 43, 12, 1441);
    			set_style(div, "display", "flex");
    			set_style(div, "justify-content", "center");
    			set_style(div, "margin-top", "8px");
    			add_location(div, file$K, 47, 12, 1837);
    			attr_dev(form, "class", "svelte-15jfbxr");
    			add_location(form, file$K, 41, 12, 1373);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h2, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, h40, anchor);
    			insert_dev(target, t3, anchor);
    			insert_dev(target, h41, anchor);
    			append_dev(h41, t4);
    			append_dev(h41, a0);
    			insert_dev(target, t6, anchor);
    			mount_component(errorvalidacion, target, anchor);
    			insert_dev(target, t7, anchor);
    			insert_dev(target, form, anchor);
    			append_dev(form, a1);
    			append_dev(form, t9);
    			mount_component(checkbox, form, null);
    			append_dev(form, t10);
    			mount_component(captcha_1, form, null);
    			append_dev(form, t11);
    			append_dev(form, div);
    			mount_component(button, div, null);
    			current = true;

    			if (!mounted) {
    				dispose = listen_dev(form, "submit", prevent_default(/*accion*/ ctx[4]), false, true, false);
    				mounted = true;
    			}
    		},
    		p: function update(ctx, dirty) {
    			const errorvalidacion_changes = {};
    			if (dirty & /*error*/ 4) errorvalidacion_changes.error = /*error*/ ctx[2];
    			errorvalidacion.$set(errorvalidacion_changes);
    			const checkbox_changes = {};

    			if (dirty & /*$$scope*/ 128) {
    				checkbox_changes.$$scope = { dirty, ctx };
    			}

    			if (!updating_checked && dirty & /*terminos*/ 1) {
    				updating_checked = true;
    				checkbox_changes.checked = /*terminos*/ ctx[0];
    				add_flush_callback(() => updating_checked = false);
    			}

    			checkbox.$set(checkbox_changes);
    			const captcha_1_changes = {};

    			if (!updating_token && dirty & /*captcha*/ 2) {
    				updating_token = true;
    				captcha_1_changes.token = /*captcha*/ ctx[1];
    				add_flush_callback(() => updating_token = false);
    			}

    			captcha_1.$set(captcha_1_changes);
    			const button_changes = {};
    			if (dirty & /*terminos*/ 1) button_changes.disabled = !/*terminos*/ ctx[0];

    			if (dirty & /*$$scope*/ 128) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(errorvalidacion.$$.fragment, local);
    			transition_in(checkbox.$$.fragment, local);
    			transition_in(captcha_1.$$.fragment, local);
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(errorvalidacion.$$.fragment, local);
    			transition_out(checkbox.$$.fragment, local);
    			transition_out(captcha_1.$$.fragment, local);
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h2);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(h40);
    			if (detaching) detach_dev(t3);
    			if (detaching) detach_dev(h41);
    			if (detaching) detach_dev(t6);
    			destroy_component(errorvalidacion, detaching);
    			if (detaching) detach_dev(t7);
    			if (detaching) detach_dev(form);
    			destroy_component(checkbox);
    			destroy_component(captcha_1);
    			destroy_component(button);
    			mounted = false;
    			dispose();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$x.name,
    		type: "if",
    		source: "(37:8) {#if config.general.registroAbierto || codigo}",
    		ctx
    	});

    	return block;
    }

    // (45:12) <Checkbox right bind:checked={terminos}>
    function create_default_slot_1$m(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			div.textContent = "Yo Anon juro solemnemente seguir las reglas de Rozed";
    			set_style(div, "white-space", "normal");
    			set_style(div, "text-align", "center");
    			add_location(div, file$K, 44, 52, 1610);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$m.name,
    		type: "slot",
    		source: "(45:12) <Checkbox right bind:checked={terminos}>",
    		ctx
    	});

    	return block;
    }

    // (49:16) <Button disabled={!terminos}>
    function create_default_slot$r(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Empezar a rozear");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$r.name,
    		type: "slot",
    		source: "(49:16) <Button disabled={!terminos}>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$K(ctx) {
    	let div;
    	let t;
    	let main;
    	let section;
    	let current_block_type_index;
    	let if_block;
    	let current;
    	const if_block_creators = [create_if_block$x, create_else_block$b];
    	const if_blocks = [];

    	function select_block_type(ctx, dirty) {
    		if (config.general.registroAbierto || /*codigo*/ ctx[3]) return 0;
    		return 1;
    	}

    	current_block_type_index = select_block_type(ctx);
    	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			t = space();
    			main = element("main");
    			section = element("section");
    			if_block.c();
    			attr_dev(div, "class", "fondo svelte-15jfbxr");
    			add_location(div, file$K, 31, 0, 833);
    			attr_dev(section, "class", "svelte-15jfbxr");
    			add_location(section, file$K, 35, 4, 967);
    			attr_dev(main, "class", "svelte-15jfbxr");
    			add_location(main, file$K, 32, 0, 860);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			insert_dev(target, t, anchor);
    			insert_dev(target, main, anchor);
    			append_dev(main, section);
    			if_blocks[current_block_type_index].m(section, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			let previous_block_index = current_block_type_index;
    			current_block_type_index = select_block_type(ctx);

    			if (current_block_type_index === previous_block_index) {
    				if_blocks[current_block_type_index].p(ctx, dirty);
    			} else {
    				group_outros();

    				transition_out(if_blocks[previous_block_index], 1, 1, () => {
    					if_blocks[previous_block_index] = null;
    				});

    				check_outros();
    				if_block = if_blocks[current_block_type_index];

    				if (!if_block) {
    					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
    					if_block.c();
    				}

    				transition_in(if_block, 1);
    				if_block.m(section, null);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (detaching) detach_dev(t);
    			if (detaching) detach_dev(main);
    			if_blocks[current_block_type_index].d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$K.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$K($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Inicio", slots, []);
    	let terminos = false;
    	let captcha = "";
    	let error = null;
    	let codigo = "";

    	if (window.model && window.model.codigoDeInvitacion) {
    		codigo = window.model.codigoDeInvitacion;
    	}

    	async function accion(e) {
    		console.log(captcha);

    		try {
    			await RChanClient.inicio(captcha, codigo);
    		} catch(e) {
    			console.log(e);
    			$$invalidate(2, error = e.response.data);
    			return;
    		}
    	} // window.location = "/"
    	// location.reload();

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$f.warn(`<Inicio> was created with unknown prop '${key}'`);
    	});

    	function checkbox_checked_binding(value) {
    		terminos = value;
    		$$invalidate(0, terminos);
    	}

    	function captcha_1_token_binding(value) {
    		captcha = value;
    		$$invalidate(1, captcha);
    	}

    	$$self.$capture_state = () => ({
    		Textfield: Ve,
    		Button: ye,
    		Ripple: he,
    		Checkbox: Ne,
    		RChanClient,
    		Captcha,
    		ErrorValidacion,
    		config,
    		terminos,
    		captcha,
    		error,
    		codigo,
    		accion
    	});

    	$$self.$inject_state = $$props => {
    		if ("terminos" in $$props) $$invalidate(0, terminos = $$props.terminos);
    		if ("captcha" in $$props) $$invalidate(1, captcha = $$props.captcha);
    		if ("error" in $$props) $$invalidate(2, error = $$props.error);
    		if ("codigo" in $$props) $$invalidate(3, codigo = $$props.codigo);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		terminos,
    		captcha,
    		error,
    		codigo,
    		accion,
    		checkbox_checked_binding,
    		captcha_1_token_binding
    	];
    }

    class Inicio extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$K, create_fragment$K, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Inicio",
    			options,
    			id: create_fragment$K.name
    		});
    	}
    }

    /* src\components\Paginas\Token.svelte generated by Svelte v3.29.0 */
    const file$L = "src\\components\\Paginas\\Token.svelte";

    function create_fragment$L(ctx) {
    	let div;
    	let t0;
    	let main;
    	let section;
    	let h2;
    	let t2;
    	let p0;
    	let t4;
    	let h4;
    	let t6;
    	let p1;
    	let t7;
    	let a;
    	let t9;

    	const block = {
    		c: function create() {
    			div = element("div");
    			t0 = space();
    			main = element("main");
    			section = element("section");
    			h2 = element("h2");
    			h2.textContent = "Este es tu token de sesion";
    			t2 = space();
    			p0 = element("p");
    			p0.textContent = `${/*token*/ ctx[0]}`;
    			t4 = space();
    			h4 = element("h4");
    			h4.textContent = "Sirve para poder usar la misma sesion en diferentes navegadores y dispositivos";
    			t6 = space();
    			p1 = element("p");
    			t7 = text("Para utilizarlo tenes que dirigirte al ");
    			a = element("a");
    			a.textContent = "login";
    			t9 = text(" y cliquear la opcion usar token");
    			attr_dev(div, "class", "fondo svelte-1dkqzt0");
    			add_location(div, file$L, 11, 0, 328);
    			add_location(h2, file$L, 16, 8, 512);
    			add_location(p0, file$L, 17, 8, 557);
    			add_location(h4, file$L, 18, 8, 581);
    			attr_dev(a, "href", "/Login");
    			add_location(a, file$L, 19, 50, 720);
    			add_location(p1, file$L, 19, 8, 678);
    			set_style(section, "word-break", "break-all");
    			attr_dev(section, "class", "svelte-1dkqzt0");
    			add_location(section, file$L, 15, 4, 462);
    			attr_dev(main, "class", "svelte-1dkqzt0");
    			add_location(main, file$L, 12, 0, 355);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, main, anchor);
    			append_dev(main, section);
    			append_dev(section, h2);
    			append_dev(section, t2);
    			append_dev(section, p0);
    			append_dev(section, t4);
    			append_dev(section, h4);
    			append_dev(section, t6);
    			append_dev(section, p1);
    			append_dev(p1, t7);
    			append_dev(p1, a);
    			append_dev(p1, t9);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(main);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$L.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$L($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Token", slots, []);
    	let token = window.model.token;
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Token> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		Textfield: Ve,
    		Button: ye,
    		Ripple: he,
    		Checkbox: Ne,
    		RChanClient,
    		Captcha,
    		ErrorValidacion,
    		config,
    		token
    	});

    	$$self.$inject_state = $$props => {
    		if ("token" in $$props) $$invalidate(0, token = $$props.token);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [token];
    }

    class Token extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$L, create_fragment$L, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Token",
    			options,
    			id: create_fragment$L.name
    		});
    	}
    }

    function formatearTiempo(tiempo) {
        return new Date(Date.parse(tiempo)).toLocaleString()
    }

    function formatearTimeSpan(timespan)
    {
        // 69444.10:39:00.0000010
        //"00:05:00.0000010",
        let minutos = Array.from(timespan.matchAll(/(\d\d):/g))[1][1];
        let horas = Array.from(timespan.matchAll(/(\d\d):/g))[0][1];
        let dias = timespan.split(".")[0];

        minutos = minutos[0] == "0" ?minutos[1] : minutos;
        horas = horas[0] == "0" ?horas[1] : horas;
        
        let ret = "";
        if(dias > 0) ret += `${dias}D `;
        if(horas > 0) ret += `${horas}H `;
        if(minutos > 0) ret += `${minutos}M `;
        return ret
    }

    /* src\components\Moderacion\BanPreview.svelte generated by Svelte v3.29.0 */
    const file$M = "src\\components\\Moderacion\\BanPreview.svelte";

    // (17:4) {#if ban.comentario}
    function create_if_block_1$l(ctx) {
    	let comentario;
    	let current;

    	comentario = new Comentario({
    			props: { comentario: /*ban*/ ctx[0].comentario },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(comentario.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(comentario, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const comentario_changes = {};
    			if (dirty & /*ban*/ 1) comentario_changes.comentario = /*ban*/ ctx[0].comentario;
    			comentario.$set(comentario_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(comentario.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(comentario.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(comentario, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$l.name,
    		type: "if",
    		source: "(17:4) {#if ban.comentario}",
    		ctx
    	});

    	return block;
    }

    // (20:4) {#if ban.hilo}
    function create_if_block$y(ctx) {
    	let hilopreviewmod;
    	let current;

    	hilopreviewmod = new HiloPreviewMod({
    			props: { hilo: /*ban*/ ctx[0].hilo },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(hilopreviewmod.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(hilopreviewmod, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const hilopreviewmod_changes = {};
    			if (dirty & /*ban*/ 1) hilopreviewmod_changes.hilo = /*ban*/ ctx[0].hilo;
    			hilopreviewmod.$set(hilopreviewmod_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(hilopreviewmod.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(hilopreviewmod.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(hilopreviewmod, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$y.name,
    		type: "if",
    		source: "(20:4) {#if ban.hilo}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$M(ctx) {
    	let div;
    	let p0;
    	let t0;
    	let t1_value = (/*ban*/ ctx[0].aclaracion || " ") + "";
    	let t1;
    	let t2;
    	let p1;
    	let t3;
    	let t4_value = MotivoDenuncia.aString(/*ban*/ ctx[0].motivo) + "";
    	let t4;
    	let t5;
    	let p2;
    	let t6;
    	let t7_value = formatearTiempo(/*ban*/ ctx[0].creacion) + "";
    	let t7;
    	let t8;
    	let p3;
    	let t9;
    	let t10_value = formatearTimeSpan(/*ban*/ ctx[0].duracion) + "";
    	let t10;
    	let t11;
    	let p4;
    	let t12;
    	let t13_value = /*ban*/ ctx[0].id + "";
    	let t13;
    	let t14;
    	let t15;
    	let current;
    	let if_block0 = /*ban*/ ctx[0].comentario && create_if_block_1$l(ctx);
    	let if_block1 = /*ban*/ ctx[0].hilo && create_if_block$y(ctx);

    	const block = {
    		c: function create() {
    			div = element("div");
    			p0 = element("p");
    			t0 = text("Aclaracion: ");
    			t1 = text(t1_value);
    			t2 = space();
    			p1 = element("p");
    			t3 = text("Motivo: ");
    			t4 = text(t4_value);
    			t5 = space();
    			p2 = element("p");
    			t6 = text("Fecha: ");
    			t7 = text(t7_value);
    			t8 = space();
    			p3 = element("p");
    			t9 = text("Duracion: ");
    			t10 = text(t10_value);
    			t11 = space();
    			p4 = element("p");
    			t12 = text("Id del ban: ");
    			t13 = text(t13_value);
    			t14 = space();
    			if (if_block0) if_block0.c();
    			t15 = space();
    			if (if_block1) if_block1.c();
    			attr_dev(p0, "class", "svelte-1o1jpaz");
    			add_location(p0, file$M, 10, 4, 324);
    			attr_dev(p1, "class", "svelte-1o1jpaz");
    			add_location(p1, file$M, 11, 4, 371);
    			attr_dev(p2, "class", "svelte-1o1jpaz");
    			add_location(p2, file$M, 12, 4, 429);
    			attr_dev(p3, "class", "svelte-1o1jpaz");
    			add_location(p3, file$M, 13, 4, 480);
    			attr_dev(p4, "class", "svelte-1o1jpaz");
    			add_location(p4, file$M, 14, 4, 536);
    			attr_dev(div, "class", "ban svelte-1o1jpaz");
    			add_location(div, file$M, 9, 0, 301);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			append_dev(div, p0);
    			append_dev(p0, t0);
    			append_dev(p0, t1);
    			append_dev(div, t2);
    			append_dev(div, p1);
    			append_dev(p1, t3);
    			append_dev(p1, t4);
    			append_dev(div, t5);
    			append_dev(div, p2);
    			append_dev(p2, t6);
    			append_dev(p2, t7);
    			append_dev(div, t8);
    			append_dev(div, p3);
    			append_dev(p3, t9);
    			append_dev(p3, t10);
    			append_dev(div, t11);
    			append_dev(div, p4);
    			append_dev(p4, t12);
    			append_dev(p4, t13);
    			append_dev(div, t14);
    			if (if_block0) if_block0.m(div, null);
    			append_dev(div, t15);
    			if (if_block1) if_block1.m(div, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if ((!current || dirty & /*ban*/ 1) && t1_value !== (t1_value = (/*ban*/ ctx[0].aclaracion || " ") + "")) set_data_dev(t1, t1_value);
    			if ((!current || dirty & /*ban*/ 1) && t4_value !== (t4_value = MotivoDenuncia.aString(/*ban*/ ctx[0].motivo) + "")) set_data_dev(t4, t4_value);
    			if ((!current || dirty & /*ban*/ 1) && t7_value !== (t7_value = formatearTiempo(/*ban*/ ctx[0].creacion) + "")) set_data_dev(t7, t7_value);
    			if ((!current || dirty & /*ban*/ 1) && t10_value !== (t10_value = formatearTimeSpan(/*ban*/ ctx[0].duracion) + "")) set_data_dev(t10, t10_value);
    			if ((!current || dirty & /*ban*/ 1) && t13_value !== (t13_value = /*ban*/ ctx[0].id + "")) set_data_dev(t13, t13_value);

    			if (/*ban*/ ctx[0].comentario) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);

    					if (dirty & /*ban*/ 1) {
    						transition_in(if_block0, 1);
    					}
    				} else {
    					if_block0 = create_if_block_1$l(ctx);
    					if_block0.c();
    					transition_in(if_block0, 1);
    					if_block0.m(div, t15);
    				}
    			} else if (if_block0) {
    				group_outros();

    				transition_out(if_block0, 1, 1, () => {
    					if_block0 = null;
    				});

    				check_outros();
    			}

    			if (/*ban*/ ctx[0].hilo) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty & /*ban*/ 1) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block$y(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(div, null);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(if_block0);
    			transition_in(if_block1);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(if_block0);
    			transition_out(if_block1);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$M.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$M($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("BanPreview", slots, []);
    	let { ban } = $$props;
    	const writable_props = ["ban"];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<BanPreview> was created with unknown prop '${key}'`);
    	});

    	$$self.$$set = $$props => {
    		if ("ban" in $$props) $$invalidate(0, ban = $$props.ban);
    	};

    	$$self.$capture_state = () => ({
    		MotivoDenuncia,
    		formatearTiempo,
    		formatearTimeSpan,
    		Comentario,
    		HiloPreviewMod,
    		ban
    	});

    	$$self.$inject_state = $$props => {
    		if ("ban" in $$props) $$invalidate(0, ban = $$props.ban);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [ban];
    }

    class BanPreview extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$M, create_fragment$M, safe_not_equal, { ban: 0 });

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "BanPreview",
    			options,
    			id: create_fragment$M.name
    		});

    		const { ctx } = this.$$;
    		const props = options.props || {};

    		if (/*ban*/ ctx[0] === undefined && !("ban" in props)) {
    			console.warn("<BanPreview> was created without expected prop 'ban'");
    		}
    	}

    	get ban() {
    		throw new Error("<BanPreview>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}

    	set ban(value) {
    		throw new Error("<BanPreview>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
    	}
    }

    /* src\components\Paginas\HistorialUsuario.svelte generated by Svelte v3.29.0 */

    const { Object: Object_1$7 } = globals;
    const file$N = "src\\components\\Paginas\\HistorialUsuario.svelte";

    function get_each_context$j(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[5] = list[i];
    	return child_ctx;
    }

    function get_each_context_1$5(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[8] = list[i];
    	return child_ctx;
    }

    function get_each_context_2$4(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[11] = list[i];
    	return child_ctx;
    }

    // (39:12) {#each hilos as h}
    function create_each_block_2$4(ctx) {
    	let hilopreviewmod;
    	let current;

    	hilopreviewmod = new HiloPreviewMod({
    			props: { hilo: /*h*/ ctx[11] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(hilopreviewmod.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(hilopreviewmod, target, anchor);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(hilopreviewmod.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(hilopreviewmod.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(hilopreviewmod, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_2$4.name,
    		type: "each",
    		source: "(39:12) {#each hilos as h}",
    		ctx
    	});

    	return block;
    }

    // (45:12) {#each comentarios as c}
    function create_each_block_1$5(ctx) {
    	let comentariomod;
    	let current;

    	comentariomod = new ComentarioMod({
    			props: { comentario: /*c*/ ctx[8] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(comentariomod.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(comentariomod, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const comentariomod_changes = {};
    			if (dirty & /*comentarios*/ 1) comentariomod_changes.comentario = /*c*/ ctx[8];
    			comentariomod.$set(comentariomod_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(comentariomod.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(comentariomod.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(comentariomod, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$5.name,
    		type: "each",
    		source: "(45:12) {#each comentarios as c}",
    		ctx
    	});

    	return block;
    }

    // (51:12) {#each baneos as ban}
    function create_each_block$j(ctx) {
    	let li;
    	let banpreview;
    	let t;
    	let current;

    	banpreview = new BanPreview({
    			props: { ban: /*ban*/ ctx[5] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			li = element("li");
    			create_component(banpreview.$$.fragment);
    			t = space();
    			set_style(li, "margin-bottom", "4px");
    			add_location(li, file$N, 51, 16, 1753);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			mount_component(banpreview, li, null);
    			append_dev(li, t);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(banpreview.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(banpreview.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			destroy_component(banpreview);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$j.name,
    		type: "each",
    		source: "(51:12) {#each baneos as ban}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$N(ctx) {
    	let barramoderacion;
    	let t0;
    	let main;
    	let div0;
    	let h1;
    	let t2;
    	let div1;
    	let p0;
    	let t5;
    	let p1;
    	let t8;
    	let p2;
    	let t11;
    	let p3;
    	let t14;
    	let div2;
    	let ul0;
    	let h30;
    	let t16;
    	let t17;
    	let ul1;
    	let h31;
    	let t19;
    	let t20;
    	let ul2;
    	let h32;
    	let t22;
    	let current;
    	barramoderacion = new BarraModeracion({ $$inline: true });
    	let each_value_2 = /*hilos*/ ctx[1];
    	validate_each_argument(each_value_2);
    	let each_blocks_2 = [];

    	for (let i = 0; i < each_value_2.length; i += 1) {
    		each_blocks_2[i] = create_each_block_2$4(get_each_context_2$4(ctx, each_value_2, i));
    	}

    	const out = i => transition_out(each_blocks_2[i], 1, 1, () => {
    		each_blocks_2[i] = null;
    	});

    	let each_value_1 = /*comentarios*/ ctx[0];
    	validate_each_argument(each_value_1);
    	let each_blocks_1 = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks_1[i] = create_each_block_1$5(get_each_context_1$5(ctx, each_value_1, i));
    	}

    	const out_1 = i => transition_out(each_blocks_1[i], 1, 1, () => {
    		each_blocks_1[i] = null;
    	});

    	let each_value = /*baneos*/ ctx[3];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$j(get_each_context$j(ctx, each_value, i));
    	}

    	const out_2 = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			create_component(barramoderacion.$$.fragment);
    			t0 = space();
    			main = element("main");
    			div0 = element("div");
    			h1 = element("h1");
    			h1.textContent = `${/*usuario*/ ctx[2].userName}`;
    			t2 = space();
    			div1 = element("div");
    			p0 = element("p");
    			p0.textContent = `Id: ${/*usuario*/ ctx[2].id}`;
    			t5 = space();
    			p1 = element("p");
    			p1.textContent = `Registro: ${/*usuario*/ ctx[2].creacion}`;
    			t8 = space();
    			p2 = element("p");
    			p2.textContent = `Numero de rozs(en db): ${/*usuario*/ ctx[2].rozs}`;
    			t11 = space();
    			p3 = element("p");
    			p3.textContent = `Numero de comentarios(en db): ${/*usuario*/ ctx[2].comentarios}`;
    			t14 = space();
    			div2 = element("div");
    			ul0 = element("ul");
    			h30 = element("h3");
    			h30.textContent = "Ultimos hilos";
    			t16 = space();

    			for (let i = 0; i < each_blocks_2.length; i += 1) {
    				each_blocks_2[i].c();
    			}

    			t17 = space();
    			ul1 = element("ul");
    			h31 = element("h3");
    			h31.textContent = "Ultimos comentarios";
    			t19 = space();

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].c();
    			}

    			t20 = space();
    			ul2 = element("ul");
    			h32 = element("h3");
    			h32.textContent = "Baneos";
    			t22 = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(h1, "class", "svelte-l013ux");
    			add_location(h1, file$N, 26, 8, 915);
    			attr_dev(div0, "class", "panel svelte-l013ux");
    			set_style(div0, "background", "var(--color6)", 1);
    			set_style(div0, "color", "black");
    			set_style(div0, "padding", "8px 16px");
    			add_location(div0, file$N, 25, 4, 811);
    			add_location(p0, file$N, 29, 8, 995);
    			add_location(p1, file$N, 30, 8, 1028);
    			add_location(p2, file$N, 31, 8, 1073);
    			add_location(p3, file$N, 32, 8, 1127);
    			attr_dev(div1, "class", "panel svelte-l013ux");
    			add_location(div1, file$N, 28, 4, 966);
    			set_style(h30, "height", "40px");
    			add_location(h30, file$N, 37, 12, 1284);
    			set_style(ul0, "min-width", "300px");
    			attr_dev(ul0, "class", "svelte-l013ux");
    			add_location(ul0, file$N, 36, 8, 1242);
    			set_style(h31, "height", "40px");
    			add_location(h31, file$N, 43, 12, 1466);
    			attr_dev(ul1, "class", "svelte-l013ux");
    			add_location(ul1, file$N, 42, 8, 1448);
    			set_style(h32, "height", "40px");
    			add_location(h32, file$N, 49, 12, 1665);
    			attr_dev(ul2, "class", "svelte-l013ux");
    			add_location(ul2, file$N, 48, 8, 1647);
    			attr_dev(div2, "class", "historial svelte-l013ux");
    			add_location(div2, file$N, 35, 4, 1209);
    			attr_dev(main, "class", "svelte-l013ux");
    			add_location(main, file$N, 24, 0, 799);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(barramoderacion, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, main, anchor);
    			append_dev(main, div0);
    			append_dev(div0, h1);
    			append_dev(main, t2);
    			append_dev(main, div1);
    			append_dev(div1, p0);
    			append_dev(div1, t5);
    			append_dev(div1, p1);
    			append_dev(div1, t8);
    			append_dev(div1, p2);
    			append_dev(div1, t11);
    			append_dev(div1, p3);
    			append_dev(main, t14);
    			append_dev(main, div2);
    			append_dev(div2, ul0);
    			append_dev(ul0, h30);
    			append_dev(ul0, t16);

    			for (let i = 0; i < each_blocks_2.length; i += 1) {
    				each_blocks_2[i].m(ul0, null);
    			}

    			append_dev(div2, t17);
    			append_dev(div2, ul1);
    			append_dev(ul1, h31);
    			append_dev(ul1, t19);

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].m(ul1, null);
    			}

    			append_dev(div2, t20);
    			append_dev(div2, ul2);
    			append_dev(ul2, h32);
    			append_dev(ul2, t22);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(ul2, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*hilos*/ 2) {
    				each_value_2 = /*hilos*/ ctx[1];
    				validate_each_argument(each_value_2);
    				let i;

    				for (i = 0; i < each_value_2.length; i += 1) {
    					const child_ctx = get_each_context_2$4(ctx, each_value_2, i);

    					if (each_blocks_2[i]) {
    						each_blocks_2[i].p(child_ctx, dirty);
    						transition_in(each_blocks_2[i], 1);
    					} else {
    						each_blocks_2[i] = create_each_block_2$4(child_ctx);
    						each_blocks_2[i].c();
    						transition_in(each_blocks_2[i], 1);
    						each_blocks_2[i].m(ul0, null);
    					}
    				}

    				group_outros();

    				for (i = each_value_2.length; i < each_blocks_2.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}

    			if (dirty & /*comentarios*/ 1) {
    				each_value_1 = /*comentarios*/ ctx[0];
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$5(ctx, each_value_1, i);

    					if (each_blocks_1[i]) {
    						each_blocks_1[i].p(child_ctx, dirty);
    						transition_in(each_blocks_1[i], 1);
    					} else {
    						each_blocks_1[i] = create_each_block_1$5(child_ctx);
    						each_blocks_1[i].c();
    						transition_in(each_blocks_1[i], 1);
    						each_blocks_1[i].m(ul1, null);
    					}
    				}

    				group_outros();

    				for (i = each_value_1.length; i < each_blocks_1.length; i += 1) {
    					out_1(i);
    				}

    				check_outros();
    			}

    			if (dirty & /*baneos*/ 8) {
    				each_value = /*baneos*/ ctx[3];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$j(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$j(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(ul2, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out_2(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(barramoderacion.$$.fragment, local);

    			for (let i = 0; i < each_value_2.length; i += 1) {
    				transition_in(each_blocks_2[i]);
    			}

    			for (let i = 0; i < each_value_1.length; i += 1) {
    				transition_in(each_blocks_1[i]);
    			}

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(barramoderacion.$$.fragment, local);
    			each_blocks_2 = each_blocks_2.filter(Boolean);

    			for (let i = 0; i < each_blocks_2.length; i += 1) {
    				transition_out(each_blocks_2[i]);
    			}

    			each_blocks_1 = each_blocks_1.filter(Boolean);

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				transition_out(each_blocks_1[i]);
    			}

    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(barramoderacion, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(main);
    			destroy_each(each_blocks_2, detaching);
    			destroy_each(each_blocks_1, detaching);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$N.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$N($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("HistorialUsuario", slots, []);
    	let hilos = window.model.hilos;
    	let comentarios = window.model.comentarios;
    	let usuario = window.model.usuario;
    	let baneos = window.model.baneos;

    	// let denuncias = window.model.denuncias
    	const motivo = Object.keys(MotivoDenuncia);

    	comentarios = comentarios.map(c => {
    		c.respuestas = [];
    		return c;
    	});

    	const writable_props = [];

    	Object_1$7.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<HistorialUsuario> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		BarraModeracion,
    		ComentarioMod,
    		HiloPreviewMod,
    		MotivoDenuncia,
    		formatearTiempo,
    		formatearTimeSpan,
    		BanPreview,
    		hilos,
    		comentarios,
    		usuario,
    		baneos,
    		motivo
    	});

    	$$self.$inject_state = $$props => {
    		if ("hilos" in $$props) $$invalidate(1, hilos = $$props.hilos);
    		if ("comentarios" in $$props) $$invalidate(0, comentarios = $$props.comentarios);
    		if ("usuario" in $$props) $$invalidate(2, usuario = $$props.usuario);
    		if ("baneos" in $$props) $$invalidate(3, baneos = $$props.baneos);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [comentarios, hilos, usuario, baneos];
    }

    class HistorialUsuario extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$N, create_fragment$N, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "HistorialUsuario",
    			options,
    			id: create_fragment$N.name
    		});
    	}
    }

    /* src\components\Paginas\Domado.svelte generated by Svelte v3.29.0 */
    const file$O = "src\\components\\Paginas\\Domado.svelte";

    // (19:12) <Button>
    function create_default_slot$s(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Aceptar");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$s.name,
    		type: "slot",
    		source: "(19:12) <Button>",
    		ctx
    	});

    	return block;
    }

    function create_fragment$O(ctx) {
    	let div1;
    	let div0;
    	let h1;
    	let t1;
    	let h2;
    	let t4;
    	let h3;
    	let t5;
    	let strong;
    	let t7;
    	let p0;
    	let t10;
    	let p1;
    	let t13;
    	let p2;
    	let t16;
    	let p3;
    	let t19;
    	let p4;
    	let t22;
    	let a;
    	let button;
    	let current;

    	button = new ye({
    			props: {
    				$$slots: { default: [create_default_slot$s] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			div1 = element("div");
    			div0 = element("div");
    			h1 = element("h1");
    			h1.textContent = "Has sido domado!";
    			t1 = space();
    			h2 = element("h2");

    			h2.textContent = `Fuiste baneado por romper las reglas de Rozed ${/*ban*/ ctx[0].tipo == 0
			? `en el roz "${/*ban*/ ctx[0].hilo}"`
			: `en un comentario en el roz "${/*ban*/ ctx[0].hilo}"`}`;

    			t4 = space();
    			h3 = element("h3");
    			t5 = text("Aclaracion: ");
    			strong = element("strong");
    			strong.textContent = `${/*ban*/ ctx[0].aclaracion || " "}`;
    			t7 = space();
    			p0 = element("p");
    			p0.textContent = `Motivo: ${/*ban*/ ctx[0].motivo}`;
    			t10 = space();
    			p1 = element("p");
    			p1.textContent = `Fecha: ${formatearTiempo(/*ban*/ ctx[0].creacion)}`;
    			t13 = space();
    			p2 = element("p");
    			p2.textContent = `Duracion: ${formatearTimeSpan(/*ban*/ ctx[0].duracion)}`;
    			t16 = space();
    			p3 = element("p");
    			p3.textContent = `Expira el: ${formatearTiempo(/*ban*/ ctx[0].expiracion)}`;
    			t19 = space();
    			p4 = element("p");
    			p4.textContent = `Id del ban: ${/*ban*/ ctx[0].id}`;
    			t22 = space();
    			a = element("a");
    			create_component(button.$$.fragment);
    			add_location(h1, file$O, 8, 8, 217);
    			set_style(h2, "margin-bottom", "10px");
    			add_location(h2, file$O, 9, 8, 252);
    			add_location(strong, file$O, 10, 24, 444);
    			add_location(h3, file$O, 10, 8, 428);
    			add_location(p0, file$O, 11, 8, 499);
    			add_location(p1, file$O, 12, 8, 536);
    			add_location(p2, file$O, 13, 8, 591);
    			add_location(p3, file$O, 14, 8, 651);
    			add_location(p4, file$O, 15, 8, 712);
    			attr_dev(a, "href", "/");
    			add_location(a, file$O, 17, 8, 759);
    			attr_dev(div0, "class", "ban svelte-8qqoee");
    			add_location(div0, file$O, 7, 4, 190);
    			attr_dev(div1, "class", "fondo svelte-8qqoee");
    			add_location(div1, file$O, 6, 0, 165);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div1, anchor);
    			append_dev(div1, div0);
    			append_dev(div0, h1);
    			append_dev(div0, t1);
    			append_dev(div0, h2);
    			append_dev(div0, t4);
    			append_dev(div0, h3);
    			append_dev(h3, t5);
    			append_dev(h3, strong);
    			append_dev(div0, t7);
    			append_dev(div0, p0);
    			append_dev(div0, t10);
    			append_dev(div0, p1);
    			append_dev(div0, t13);
    			append_dev(div0, p2);
    			append_dev(div0, t16);
    			append_dev(div0, p3);
    			append_dev(div0, t19);
    			append_dev(div0, p4);
    			append_dev(div0, t22);
    			append_dev(div0, a);
    			mount_component(button, a, null);
    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			const button_changes = {};

    			if (dirty & /*$$scope*/ 2) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div1);
    			destroy_component(button);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$O.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$O($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Domado", slots, []);
    	const ban = window.model.ban;
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Domado> was created with unknown prop '${key}'`);
    	});

    	$$self.$capture_state = () => ({
    		Button: ye,
    		formatearTiempo,
    		formatearTimeSpan,
    		ban
    	});

    	return [ban];
    }

    class Domado extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$O, create_fragment$O, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Domado",
    			options,
    			id: create_fragment$O.name
    		});
    	}
    }

    /* src\components\Paginas\ListaDeUsuarios.svelte generated by Svelte v3.29.0 */
    const file$P = "src\\components\\Paginas\\ListaDeUsuarios.svelte";

    function get_each_context$k(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[4] = list[i];
    	return child_ctx;
    }

    function get_each_context_1$6(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[7] = list[i];
    	return child_ctx;
    }

    // (28:24) <div slot="body">
    function create_body_slot$5(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			div.textContent = "Remover ban?";
    			attr_dev(div, "slot", "body");
    			add_location(div, file$P, 27, 24, 1274);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_body_slot$5.name,
    		type: "slot",
    		source: "(28:24) <div slot=\\\"body\\\">",
    		ctx
    	});

    	return block;
    }

    // (17:12) {#each ultimosBaneos as b}
    function create_each_block_1$6(ctx) {
    	let li;
    	let a0;
    	let t0_value = /*b*/ ctx[7].usuario.userName + "";
    	let t0;
    	let a0_href_value;
    	let t1;
    	let tiempo;
    	let t2;
    	let br0;
    	let t3;
    	let a1;
    	let t4;
    	let a1_href_value;
    	let t5;
    	let t6_value = formatearTimeSpan(/*b*/ ctx[7].duracion) + "";
    	let t6;
    	let t7;
    	let br1;
    	let t8;
    	let dialogo;
    	let t9;
    	let current;

    	tiempo = new Tiempo({
    			props: { date: /*b*/ ctx[7].creacion },
    			$$inline: true
    		});

    	function func(...args) {
    		return /*func*/ ctx[3](/*b*/ ctx[7], ...args);
    	}

    	dialogo = new Dialogo({
    			props: {
    				textoActivador: "Desbanear",
    				titulo: "Desbanear gordo",
    				accion: func,
    				$$slots: { body: [create_body_slot$5] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			li = element("li");
    			a0 = element("a");
    			t0 = text(t0_value);
    			t1 = text("\r\n                    fue baneado hace ");
    			create_component(tiempo.$$.fragment);
    			t2 = space();
    			br0 = element("br");
    			t3 = space();
    			a1 = element("a");
    			t4 = text("roz/comentario del baneo");
    			t5 = text("\r\n                    Duracion: ");
    			t6 = text(t6_value);
    			t7 = space();
    			br1 = element("br");
    			t8 = space();
    			create_component(dialogo.$$.fragment);
    			t9 = space();
    			set_style(a0, "color", "var(--color6)");
    			attr_dev(a0, "href", a0_href_value = "/Moderacion/HistorialDeUsuario/" + /*b*/ ctx[7].usuario.id);
    			add_location(a0, file$P, 18, 16, 667);
    			add_location(br0, file$P, 22, 65, 904);
    			set_style(a1, "color", "var(--color6)");
    			attr_dev(a1, "href", a1_href_value = "/Hilo/" + /*b*/ ctx[7].hiloId + "#" + /*b*/ ctx[7].comentarioId);
    			add_location(a1, file$P, 23, 20, 930);
    			add_location(br1, file$P, 25, 20, 1115);
    			attr_dev(li, "class", "ban svelte-m85ysw");
    			add_location(li, file$P, 17, 12, 632);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			append_dev(li, a0);
    			append_dev(a0, t0);
    			append_dev(li, t1);
    			mount_component(tiempo, li, null);
    			append_dev(li, t2);
    			append_dev(li, br0);
    			append_dev(li, t3);
    			append_dev(li, a1);
    			append_dev(a1, t4);
    			append_dev(li, t5);
    			append_dev(li, t6);
    			append_dev(li, t7);
    			append_dev(li, br1);
    			append_dev(li, t8);
    			mount_component(dialogo, li, null);
    			append_dev(li, t9);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const dialogo_changes = {};

    			if (dirty & /*$$scope*/ 1024) {
    				dialogo_changes.$$scope = { dirty, ctx };
    			}

    			dialogo.$set(dialogo_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(tiempo.$$.fragment, local);
    			transition_in(dialogo.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(tiempo.$$.fragment, local);
    			transition_out(dialogo.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			destroy_component(tiempo);
    			destroy_component(dialogo);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$6.name,
    		type: "each",
    		source: "(17:12) {#each ultimosBaneos as b}",
    		ctx
    	});

    	return block;
    }

    // (41:12) {#each ultimosRegistros as u}
    function create_each_block$k(ctx) {
    	let li;
    	let t0;
    	let a;
    	let t1_value = /*u*/ ctx[4].userName + "";
    	let t1;
    	let a_href_value;
    	let t2;
    	let tiempo;
    	let t3;
    	let current;

    	tiempo = new Tiempo({
    			props: { date: /*u*/ ctx[4].creacion },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			li = element("li");
    			t0 = text("Se registro \r\n                    ");
    			a = element("a");
    			t1 = text(t1_value);
    			t2 = text("  \r\n                    hace ");
    			create_component(tiempo.$$.fragment);
    			t3 = space();
    			set_style(a, "color", "var(--color6)");
    			attr_dev(a, "href", a_href_value = "/Moderacion/HistorialDeUsuario/" + /*u*/ ctx[4].id);
    			add_location(a, file$P, 42, 20, 1802);
    			set_style(li, "padding", "4px 8px");
    			add_location(li, file$P, 41, 16, 1740);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			append_dev(li, t0);
    			append_dev(li, a);
    			append_dev(a, t1);
    			append_dev(li, t2);
    			mount_component(tiempo, li, null);
    			append_dev(li, t3);
    			current = true;
    		},
    		p: noop,
    		i: function intro(local) {
    			if (current) return;
    			transition_in(tiempo.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(tiempo.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			destroy_component(tiempo);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$k.name,
    		type: "each",
    		source: "(41:12) {#each ultimosRegistros as u}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$P(ctx) {
    	let barramoderacion;
    	let t0;
    	let section;
    	let div0;
    	let h20;
    	let t2;
    	let ul0;
    	let t3;
    	let div1;
    	let h21;
    	let t5;
    	let h4;
    	let t9;
    	let br;
    	let t10;
    	let ul1;
    	let current;
    	barramoderacion = new BarraModeracion({ $$inline: true });
    	let each_value_1 = /*ultimosBaneos*/ ctx[1];
    	validate_each_argument(each_value_1);
    	let each_blocks_1 = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks_1[i] = create_each_block_1$6(get_each_context_1$6(ctx, each_value_1, i));
    	}

    	const out = i => transition_out(each_blocks_1[i], 1, 1, () => {
    		each_blocks_1[i] = null;
    	});

    	let each_value = /*ultimosRegistros*/ ctx[0];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$k(get_each_context$k(ctx, each_value, i));
    	}

    	const out_1 = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			create_component(barramoderacion.$$.fragment);
    			t0 = space();
    			section = element("section");
    			div0 = element("div");
    			h20 = element("h2");
    			h20.textContent = "Baneos activos";
    			t2 = space();
    			ul0 = element("ul");

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].c();
    			}

    			t3 = space();
    			div1 = element("div");
    			h21 = element("h2");
    			h21.textContent = "Ultimos 100 usuarios registrados";
    			t5 = space();
    			h4 = element("h4");
    			h4.textContent = `Hay un total de ${/*cantidadDeUsuarios*/ ctx[2]} usuarios registrados`;
    			t9 = space();
    			br = element("br");
    			t10 = space();
    			ul1 = element("ul");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			add_location(h20, file$P, 14, 8, 537);
    			add_location(ul0, file$P, 15, 8, 570);
    			attr_dev(div0, "class", "lista-baneos panel svelte-m85ysw");
    			add_location(div0, file$P, 13, 4, 495);
    			add_location(h21, file$P, 36, 8, 1530);
    			add_location(h4, file$P, 37, 8, 1581);
    			add_location(br, file$P, 38, 8, 1657);
    			add_location(ul1, file$P, 39, 8, 1671);
    			attr_dev(div1, "class", "lista-usuarios panel svelte-m85ysw");
    			add_location(div1, file$P, 35, 4, 1486);
    			attr_dev(section, "class", "svelte-m85ysw");
    			add_location(section, file$P, 12, 0, 480);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(barramoderacion, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, section, anchor);
    			append_dev(section, div0);
    			append_dev(div0, h20);
    			append_dev(div0, t2);
    			append_dev(div0, ul0);

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].m(ul0, null);
    			}

    			append_dev(section, t3);
    			append_dev(section, div1);
    			append_dev(div1, h21);
    			append_dev(div1, t5);
    			append_dev(div1, h4);
    			append_dev(div1, t9);
    			append_dev(div1, br);
    			append_dev(div1, t10);
    			append_dev(div1, ul1);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(ul1, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*RChanClient, ultimosBaneos, formatearTimeSpan*/ 2) {
    				each_value_1 = /*ultimosBaneos*/ ctx[1];
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$6(ctx, each_value_1, i);

    					if (each_blocks_1[i]) {
    						each_blocks_1[i].p(child_ctx, dirty);
    						transition_in(each_blocks_1[i], 1);
    					} else {
    						each_blocks_1[i] = create_each_block_1$6(child_ctx);
    						each_blocks_1[i].c();
    						transition_in(each_blocks_1[i], 1);
    						each_blocks_1[i].m(ul0, null);
    					}
    				}

    				group_outros();

    				for (i = each_value_1.length; i < each_blocks_1.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}

    			if (dirty & /*ultimosRegistros*/ 1) {
    				each_value = /*ultimosRegistros*/ ctx[0];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$k(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$k(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(ul1, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out_1(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(barramoderacion.$$.fragment, local);

    			for (let i = 0; i < each_value_1.length; i += 1) {
    				transition_in(each_blocks_1[i]);
    			}

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(barramoderacion.$$.fragment, local);
    			each_blocks_1 = each_blocks_1.filter(Boolean);

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				transition_out(each_blocks_1[i]);
    			}

    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(barramoderacion, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(section);
    			destroy_each(each_blocks_1, detaching);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$P.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$P($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("ListaDeUsuarios", slots, []);
    	let ultimosRegistros = window.model.ultimosRegistros;
    	let ultimosBaneos = window.model.ultimosBaneos;
    	let cantidadDeUsuarios = window.model.cantidadDeUsuarios;
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ListaDeUsuarios> was created with unknown prop '${key}'`);
    	});

    	const func = b => RChanClient.removerBan(b.id);

    	$$self.$capture_state = () => ({
    		formatearTimeSpan,
    		Tiempo,
    		Dialogo,
    		RChanClient,
    		BarraModeracion,
    		ultimosRegistros,
    		ultimosBaneos,
    		cantidadDeUsuarios
    	});

    	$$self.$inject_state = $$props => {
    		if ("ultimosRegistros" in $$props) $$invalidate(0, ultimosRegistros = $$props.ultimosRegistros);
    		if ("ultimosBaneos" in $$props) $$invalidate(1, ultimosBaneos = $$props.ultimosBaneos);
    		if ("cantidadDeUsuarios" in $$props) $$invalidate(2, cantidadDeUsuarios = $$props.cantidadDeUsuarios);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [ultimosRegistros, ultimosBaneos, cantidadDeUsuarios, func];
    }

    class ListaDeUsuarios extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$P, create_fragment$P, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "ListaDeUsuarios",
    			options,
    			id: create_fragment$P.name
    		});
    	}
    }

    /* src\components\Paginas\Busqueda.svelte generated by Svelte v3.29.0 */

    const { console: console_1$g } = globals;
    const file$Q = "src\\components\\Paginas\\Busqueda.svelte";

    // (42:16) <Button on:click={buscar} raised color="var(--color5)">
    function create_default_slot_1$n(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Buscar");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot_1$n.name,
    		type: "slot",
    		source: "(42:16) <Button on:click={buscar} raised color=\\\"var(--color5)\\\">",
    		ctx
    	});

    	return block;
    }

    // (41:12) <Spinner {cargando}>
    function create_default_slot$t(ctx) {
    	let button;
    	let current;

    	button = new ye({
    			props: {
    				raised: true,
    				color: "var(--color5)",
    				$$slots: { default: [create_default_slot_1$n] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button.$on("click", /*buscar*/ ctx[4]);

    	const block = {
    		c: function create() {
    			create_component(button.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(button, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button_changes = {};

    			if (dirty & /*$$scope*/ 128) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(button, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$t.name,
    		type: "slot",
    		source: "(41:12) <Spinner {cargando}>",
    		ctx
    	});

    	return block;
    }

    // (47:4) {#if sinResultados}
    function create_if_block$z(ctx) {
    	let h3;

    	const block = {
    		c: function create() {
    			h3 = element("h3");
    			h3.textContent = "No se encontraron rozs";
    			set_style(h3, "text-align", "center");
    			add_location(h3, file$Q, 47, 8, 1313);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, h3, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(h3);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$z.name,
    		type: "if",
    		source: "(47:4) {#if sinResultados}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$Q(ctx) {
    	let main;
    	let h3;
    	let t1;
    	let section;
    	let form;
    	let input;
    	let t2;
    	let spinner;
    	let t3;
    	let t4;
    	let hilolist;
    	let updating_hiloList;
    	let current;
    	let mounted;
    	let dispose;

    	spinner = new Spinner({
    			props: {
    				cargando: /*cargando*/ ctx[3],
    				$$slots: { default: [create_default_slot$t] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	let if_block = /*sinResultados*/ ctx[2] && create_if_block$z(ctx);

    	function hilolist_hiloList_binding(value) {
    		/*hilolist_hiloList_binding*/ ctx[6].call(null, value);
    	}

    	let hilolist_props = {};

    	if (/*hiloList*/ ctx[1] !== void 0) {
    		hilolist_props.hiloList = /*hiloList*/ ctx[1];
    	}

    	hilolist = new HiloList({ props: hilolist_props, $$inline: true });
    	binding_callbacks.push(() => bind(hilolist, "hiloList", hilolist_hiloList_binding));

    	const block = {
    		c: function create() {
    			main = element("main");
    			h3 = element("h3");
    			h3.textContent = "Buscar Roz";
    			t1 = space();
    			section = element("section");
    			form = element("form");
    			input = element("input");
    			t2 = space();
    			create_component(spinner.$$.fragment);
    			t3 = space();
    			if (if_block) if_block.c();
    			t4 = space();
    			create_component(hilolist.$$.fragment);
    			set_style(h3, "text-align", "center");
    			set_style(h3, "margin", "16px 10px");
    			add_location(h3, file$Q, 31, 4, 744);
    			attr_dev(input, "autocomplete", "off");
    			attr_dev(input, "placeholder", "Alguna palabra en el titulo del roz");
    			add_location(input, file$Q, 35, 12, 921);
    			attr_dev(form, "class", "panel input-busqueda svelte-1cuxuj6");
    			add_location(form, file$Q, 34, 8, 838);
    			attr_dev(section, "class", "svelte-1cuxuj6");
    			add_location(section, file$Q, 33, 4, 819);
    			attr_dev(main, "class", "svelte-1cuxuj6");
    			add_location(main, file$Q, 30, 0, 732);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			append_dev(main, h3);
    			append_dev(main, t1);
    			append_dev(main, section);
    			append_dev(section, form);
    			append_dev(form, input);
    			set_input_value(input, /*cadenaDeBusqueda*/ ctx[0]);
    			append_dev(form, t2);
    			mount_component(spinner, form, null);
    			append_dev(main, t3);
    			if (if_block) if_block.m(main, null);
    			append_dev(main, t4);
    			mount_component(hilolist, main, null);
    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(input, "input", /*input_input_handler*/ ctx[5]),
    					listen_dev(form, "submit", prevent_default(/*buscar*/ ctx[4]), false, true, false)
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*cadenaDeBusqueda*/ 1 && input.value !== /*cadenaDeBusqueda*/ ctx[0]) {
    				set_input_value(input, /*cadenaDeBusqueda*/ ctx[0]);
    			}

    			const spinner_changes = {};

    			if (dirty & /*$$scope*/ 128) {
    				spinner_changes.$$scope = { dirty, ctx };
    			}

    			spinner.$set(spinner_changes);

    			if (/*sinResultados*/ ctx[2]) {
    				if (if_block) ; else {
    					if_block = create_if_block$z(ctx);
    					if_block.c();
    					if_block.m(main, t4);
    				}
    			} else if (if_block) {
    				if_block.d(1);
    				if_block = null;
    			}

    			const hilolist_changes = {};

    			if (!updating_hiloList && dirty & /*hiloList*/ 2) {
    				updating_hiloList = true;
    				hilolist_changes.hiloList = /*hiloList*/ ctx[1];
    				add_flush_callback(() => updating_hiloList = false);
    			}

    			hilolist.$set(hilolist_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(spinner.$$.fragment, local);
    			transition_in(hilolist.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(spinner.$$.fragment, local);
    			transition_out(hilolist.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    			destroy_component(spinner);
    			if (if_block) if_block.d();
    			destroy_component(hilolist);
    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$Q.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$Q($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Busqueda", slots, []);
    	let cadenaDeBusqueda = "";
    	let hiloList = { hilos: [] };
    	let cargando = false;
    	let sinResultados = false;

    	async function buscar() {
    		try {
    			$$invalidate(2, sinResultados = false);
    			let cargando = true;
    			let res = await RChanClient.buscar(cadenaDeBusqueda);
    			$$invalidate(2, sinResultados = res.data.length == 0);
    			$$invalidate(1, hiloList.hilos = res.data, hiloList);
    		} catch(e) {
    			console.log(e);
    		}
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$g.warn(`<Busqueda> was created with unknown prop '${key}'`);
    	});

    	function input_input_handler() {
    		cadenaDeBusqueda = this.value;
    		$$invalidate(0, cadenaDeBusqueda);
    	}

    	function hilolist_hiloList_binding(value) {
    		hiloList = value;
    		$$invalidate(1, hiloList);
    	}

    	$$self.$capture_state = () => ({
    		Button: ye,
    		HiloList,
    		RChanClient,
    		Spinner,
    		cadenaDeBusqueda,
    		hiloList,
    		cargando,
    		sinResultados,
    		buscar
    	});

    	$$self.$inject_state = $$props => {
    		if ("cadenaDeBusqueda" in $$props) $$invalidate(0, cadenaDeBusqueda = $$props.cadenaDeBusqueda);
    		if ("hiloList" in $$props) $$invalidate(1, hiloList = $$props.hiloList);
    		if ("cargando" in $$props) $$invalidate(3, cargando = $$props.cargando);
    		if ("sinResultados" in $$props) $$invalidate(2, sinResultados = $$props.sinResultados);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [
    		cadenaDeBusqueda,
    		hiloList,
    		sinResultados,
    		cargando,
    		buscar,
    		input_input_handler,
    		hilolist_hiloList_binding
    	];
    }

    class Busqueda extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$Q, create_fragment$Q, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Busqueda",
    			options,
    			id: create_fragment$Q.name
    		});
    	}
    }

    /* src\components\Paginas\EliminadosYDesactivados.svelte generated by Svelte v3.29.0 */
    const file$R = "src\\components\\Paginas\\EliminadosYDesactivados.svelte";

    function get_each_context$l(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[3] = list[i];
    	return child_ctx;
    }

    function get_each_context_1$7(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[6] = list[i];
    	return child_ctx;
    }

    // (21:36) <Button on:click={() => abrir.restaurarHilo(h.id)}>
    function create_default_slot$u(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = text("Restaurar");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$u.name,
    		type: "slot",
    		source: "(21:36) <Button on:click={() => abrir.restaurarHilo(h.id)}>",
    		ctx
    	});

    	return block;
    }

    // (20:8) {#each hilos as h}
    function create_each_block_1$7(ctx) {
    	let hilopreview;
    	let t;
    	let button;
    	let current;

    	hilopreview = new HiloPreview({
    			props: { hilo: /*h*/ ctx[6] },
    			$$inline: true
    		});

    	function click_handler(...args) {
    		return /*click_handler*/ ctx[2](/*h*/ ctx[6], ...args);
    	}

    	button = new ye({
    			props: {
    				$$slots: { default: [create_default_slot$u] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button.$on("click", click_handler);

    	const block = {
    		c: function create() {
    			create_component(hilopreview.$$.fragment);
    			t = space();
    			create_component(button.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(hilopreview, target, anchor);
    			insert_dev(target, t, anchor);
    			mount_component(button, target, anchor);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const button_changes = {};

    			if (dirty & /*$$scope*/ 512) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(hilopreview.$$.fragment, local);
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(hilopreview.$$.fragment, local);
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(hilopreview, detaching);
    			if (detaching) detach_dev(t);
    			destroy_component(button, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$7.name,
    		type: "each",
    		source: "(20:8) {#each hilos as h}",
    		ctx
    	});

    	return block;
    }

    // (26:8) {#each comentarios as c}
    function create_each_block$l(ctx) {
    	let comentariomod;
    	let current;

    	comentariomod = new ComentarioMod({
    			props: { comentario: /*c*/ ctx[3] },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			create_component(comentariomod.$$.fragment);
    		},
    		m: function mount(target, anchor) {
    			mount_component(comentariomod, target, anchor);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const comentariomod_changes = {};
    			if (dirty & /*comentarios*/ 1) comentariomod_changes.comentario = /*c*/ ctx[3];
    			comentariomod.$set(comentariomod_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(comentariomod.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(comentariomod.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(comentariomod, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$l.name,
    		type: "each",
    		source: "(26:8) {#each comentarios as c}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$R(ctx) {
    	let barramoderacion;
    	let t0;
    	let main;
    	let ul0;
    	let h30;
    	let t2;
    	let t3;
    	let ul1;
    	let h31;
    	let t5;
    	let current;
    	barramoderacion = new BarraModeracion({ $$inline: true });
    	let each_value_1 = /*hilos*/ ctx[1];
    	validate_each_argument(each_value_1);
    	let each_blocks_1 = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks_1[i] = create_each_block_1$7(get_each_context_1$7(ctx, each_value_1, i));
    	}

    	const out = i => transition_out(each_blocks_1[i], 1, 1, () => {
    		each_blocks_1[i] = null;
    	});

    	let each_value = /*comentarios*/ ctx[0];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$l(get_each_context$l(ctx, each_value, i));
    	}

    	const out_1 = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			create_component(barramoderacion.$$.fragment);
    			t0 = space();
    			main = element("main");
    			ul0 = element("ul");
    			h30 = element("h3");
    			h30.textContent = "Rozs eliminados";
    			t2 = space();

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].c();
    			}

    			t3 = space();
    			ul1 = element("ul");
    			h31 = element("h3");
    			h31.textContent = "Comentarios eliminados";
    			t5 = space();

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			set_style(h30, "height", "40px");
    			add_location(h30, file$R, 18, 8, 563);
    			set_style(ul0, "width", "33%");
    			attr_dev(ul0, "class", "svelte-wvcmr6");
    			add_location(ul0, file$R, 17, 4, 531);
    			set_style(h31, "height", "40px");
    			add_location(h31, file$R, 24, 8, 790);
    			attr_dev(ul1, "class", "svelte-wvcmr6");
    			add_location(ul1, file$R, 23, 4, 776);
    			attr_dev(main, "class", "svelte-wvcmr6");
    			add_location(main, file$R, 16, 0, 519);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(barramoderacion, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, main, anchor);
    			append_dev(main, ul0);
    			append_dev(ul0, h30);
    			append_dev(ul0, t2);

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].m(ul0, null);
    			}

    			append_dev(main, t3);
    			append_dev(main, ul1);
    			append_dev(ul1, h31);
    			append_dev(ul1, t5);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(ul1, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*abrir, hilos*/ 2) {
    				each_value_1 = /*hilos*/ ctx[1];
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$7(ctx, each_value_1, i);

    					if (each_blocks_1[i]) {
    						each_blocks_1[i].p(child_ctx, dirty);
    						transition_in(each_blocks_1[i], 1);
    					} else {
    						each_blocks_1[i] = create_each_block_1$7(child_ctx);
    						each_blocks_1[i].c();
    						transition_in(each_blocks_1[i], 1);
    						each_blocks_1[i].m(ul0, null);
    					}
    				}

    				group_outros();

    				for (i = each_value_1.length; i < each_blocks_1.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}

    			if (dirty & /*comentarios*/ 1) {
    				each_value = /*comentarios*/ ctx[0];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$l(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$l(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(ul1, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out_1(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(barramoderacion.$$.fragment, local);

    			for (let i = 0; i < each_value_1.length; i += 1) {
    				transition_in(each_blocks_1[i]);
    			}

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(barramoderacion.$$.fragment, local);
    			each_blocks_1 = each_blocks_1.filter(Boolean);

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				transition_out(each_blocks_1[i]);
    			}

    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(barramoderacion, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(main);
    			destroy_each(each_blocks_1, detaching);
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$R.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$R($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("EliminadosYDesactivados", slots, []);
    	let hilos = window.model.hilos;
    	let comentarios = window.model.comentarios;

    	comentarios = comentarios.map(c => {
    		c.respuestas = [];
    		return c;
    	});

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<EliminadosYDesactivados> was created with unknown prop '${key}'`);
    	});

    	const click_handler = h => abrir.restaurarHilo(h.id);

    	$$self.$capture_state = () => ({
    		ComentarioMod,
    		HiloPreview,
    		abrir,
    		Button: ye,
    		BarraModeracion,
    		hilos,
    		comentarios
    	});

    	$$self.$inject_state = $$props => {
    		if ("hilos" in $$props) $$invalidate(1, hilos = $$props.hilos);
    		if ("comentarios" in $$props) $$invalidate(0, comentarios = $$props.comentarios);
    	};

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	return [comentarios, hilos, click_handler];
    }

    class EliminadosYDesactivados extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$R, create_fragment$R, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "EliminadosYDesactivados",
    			options,
    			id: create_fragment$R.name
    		});
    	}
    }

    /* src\components\Paginas\MediaHome.svelte generated by Svelte v3.29.0 */
    const file$S = "src\\components\\Paginas\\MediaHome.svelte";

    function get_each_context$m(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[5] = list[i];
    	child_ctx[6] = list;
    	child_ctx[7] = i;
    	return child_ctx;
    }

    // (36:4) {#if selecionados.length > 0}
    function create_if_block$A(ctx) {
    	let div;
    	let button;
    	let current;

    	button = new ye({
    			props: {
    				color: "var(--color5)",
    				disabled: /*eliminando*/ ctx[1],
    				raised: true,
    				$$slots: { default: [create_default_slot$v] },
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	button.$on("click", /*eliminarMedias*/ ctx[3]);

    	const block = {
    		c: function create() {
    			div = element("div");
    			create_component(button.$$.fragment);
    			set_style(div, "justify-content", "center");
    			set_style(div, "display", "flex");
    			set_style(div, "margin", "8px");
    			add_location(div, file$S, 36, 8, 1044);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    			mount_component(button, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const button_changes = {};
    			if (dirty & /*eliminando*/ 2) button_changes.disabled = /*eliminando*/ ctx[1];

    			if (dirty & /*$$scope, selecionados*/ 260) {
    				button_changes.$$scope = { dirty, ctx };
    			}

    			button.$set(button_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(button.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(button.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    			destroy_component(button);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$A.name,
    		type: "if",
    		source: "(36:4) {#if selecionados.length > 0}",
    		ctx
    	});

    	return block;
    }

    // (38:12) <Button on:click={eliminarMedias}                   color="var(--color5)"                  disabled = {eliminando}                  raised>
    function create_default_slot$v(ctx) {
    	let t0;
    	let t1_value = /*selecionados*/ ctx[2].length + "";
    	let t1;
    	let t2;

    	const block = {
    		c: function create() {
    			t0 = text("Eliminar ");
    			t1 = text(t1_value);
    			t2 = text(" archivos");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t0, anchor);
    			insert_dev(target, t1, anchor);
    			insert_dev(target, t2, anchor);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*selecionados*/ 4 && t1_value !== (t1_value = /*selecionados*/ ctx[2].length + "")) set_data_dev(t1, t1_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(t1);
    			if (detaching) detach_dev(t2);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$v.name,
    		type: "slot",
    		source: "(38:12) <Button on:click={eliminarMedias}                   color=\\\"var(--color5)\\\"                  disabled = {eliminando}                  raised>",
    		ctx
    	});

    	return block;
    }

    // (45:8) {#each medias as m}
    function create_each_block$m(ctx) {
    	let li;
    	let media;
    	let t0;
    	let div;
    	let checkbox;
    	let updating_checked;
    	let t1;
    	let current;

    	media = new Media({
    			props: { media: /*m*/ ctx[5], modoCuadrado: true },
    			$$inline: true
    		});

    	function checkbox_checked_binding(value) {
    		/*checkbox_checked_binding*/ ctx[4].call(null, value, /*m*/ ctx[5]);
    	}

    	let checkbox_props = {};

    	if (/*m*/ ctx[5].seleccionado !== void 0) {
    		checkbox_props.checked = /*m*/ ctx[5].seleccionado;
    	}

    	checkbox = new Ne({ props: checkbox_props, $$inline: true });
    	binding_callbacks.push(() => bind(checkbox, "checked", checkbox_checked_binding));

    	const block = {
    		c: function create() {
    			li = element("li");
    			create_component(media.$$.fragment);
    			t0 = space();
    			div = element("div");
    			create_component(checkbox.$$.fragment);
    			t1 = space();
    			attr_dev(div, "class", "check svelte-yl7va1");
    			add_location(div, file$S, 48, 16, 1612);
    			attr_dev(li, "class", "svelte-yl7va1");
    			add_location(li, file$S, 45, 12, 1388);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			mount_component(media, li, null);
    			append_dev(li, t0);
    			append_dev(li, div);
    			mount_component(checkbox, div, null);
    			append_dev(li, t1);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const media_changes = {};
    			if (dirty & /*medias*/ 1) media_changes.media = /*m*/ ctx[5];
    			media.$set(media_changes);
    			const checkbox_changes = {};

    			if (!updating_checked && dirty & /*medias*/ 1) {
    				updating_checked = true;
    				checkbox_changes.checked = /*m*/ ctx[5].seleccionado;
    				add_flush_callback(() => updating_checked = false);
    			}

    			checkbox.$set(checkbox_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(media.$$.fragment, local);
    			transition_in(checkbox.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(media.$$.fragment, local);
    			transition_out(checkbox.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			destroy_component(media);
    			destroy_component(checkbox);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$m.name,
    		type: "each",
    		source: "(45:8) {#each medias as m}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$S(ctx) {
    	let barramoderacion;
    	let t0;
    	let section;
    	let t1;
    	let ul;
    	let current;
    	barramoderacion = new BarraModeracion({ $$inline: true });
    	let if_block = /*selecionados*/ ctx[2].length > 0 && create_if_block$A(ctx);
    	let each_value = /*medias*/ ctx[0];
    	validate_each_argument(each_value);
    	let each_blocks = [];

    	for (let i = 0; i < each_value.length; i += 1) {
    		each_blocks[i] = create_each_block$m(get_each_context$m(ctx, each_value, i));
    	}

    	const out = i => transition_out(each_blocks[i], 1, 1, () => {
    		each_blocks[i] = null;
    	});

    	const block = {
    		c: function create() {
    			create_component(barramoderacion.$$.fragment);
    			t0 = space();
    			section = element("section");
    			if (if_block) if_block.c();
    			t1 = space();
    			ul = element("ul");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			attr_dev(ul, "class", "svelte-yl7va1");
    			add_location(ul, file$S, 43, 4, 1341);
    			attr_dev(section, "class", "media-home svelte-yl7va1");
    			add_location(section, file$S, 33, 0, 965);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			mount_component(barramoderacion, target, anchor);
    			insert_dev(target, t0, anchor);
    			insert_dev(target, section, anchor);
    			if (if_block) if_block.m(section, null);
    			append_dev(section, t1);
    			append_dev(section, ul);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(ul, null);
    			}

    			current = true;
    		},
    		p: function update(ctx, [dirty]) {
    			if (/*selecionados*/ ctx[2].length > 0) {
    				if (if_block) {
    					if_block.p(ctx, dirty);

    					if (dirty & /*selecionados*/ 4) {
    						transition_in(if_block, 1);
    					}
    				} else {
    					if_block = create_if_block$A(ctx);
    					if_block.c();
    					transition_in(if_block, 1);
    					if_block.m(section, t1);
    				}
    			} else if (if_block) {
    				group_outros();

    				transition_out(if_block, 1, 1, () => {
    					if_block = null;
    				});

    				check_outros();
    			}

    			if (dirty & /*medias*/ 1) {
    				each_value = /*medias*/ ctx[0];
    				validate_each_argument(each_value);
    				let i;

    				for (i = 0; i < each_value.length; i += 1) {
    					const child_ctx = get_each_context$m(ctx, each_value, i);

    					if (each_blocks[i]) {
    						each_blocks[i].p(child_ctx, dirty);
    						transition_in(each_blocks[i], 1);
    					} else {
    						each_blocks[i] = create_each_block$m(child_ctx);
    						each_blocks[i].c();
    						transition_in(each_blocks[i], 1);
    						each_blocks[i].m(ul, null);
    					}
    				}

    				group_outros();

    				for (i = each_value.length; i < each_blocks.length; i += 1) {
    					out(i);
    				}

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(barramoderacion.$$.fragment, local);
    			transition_in(if_block);

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(barramoderacion.$$.fragment, local);
    			transition_out(if_block);
    			each_blocks = each_blocks.filter(Boolean);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			destroy_component(barramoderacion, detaching);
    			if (detaching) detach_dev(t0);
    			if (detaching) detach_dev(section);
    			if (if_block) if_block.d();
    			destroy_each(each_blocks, detaching);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$S.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$S($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("MediaHome", slots, []);
    	let medias = window.model.medias;

    	// let comentarios = window.model.comentarios
    	medias.forEach(m => m.seleccionado = false);

    	medias = medias;
    	let eliminando = false;

    	async function eliminarMedias() {
    		try {
    			$$invalidate(1, eliminando = true);
    			await RChanClient.eliminarMedias(selecionados.map(s => s.id));
    			$$invalidate(0, medias = medias.filter(m => !selecionados.map(s => s.id).includes(m.id)));
    			$$invalidate(2, selecionados = []);
    		} catch(error) {
    			
    		}

    		$$invalidate(1, eliminando = false);
    	}

    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<MediaHome> was created with unknown prop '${key}'`);
    	});

    	function checkbox_checked_binding(value, m) {
    		m.seleccionado = value;
    		$$invalidate(0, medias);
    	}

    	$$self.$capture_state = () => ({
    		abrir,
    		Button: ye,
    		Checkbox: Ne,
    		BarraModeracion,
    		Media,
    		RChanClient,
    		medias,
    		eliminando,
    		eliminarMedias,
    		selecionados
    	});

    	$$self.$inject_state = $$props => {
    		if ("medias" in $$props) $$invalidate(0, medias = $$props.medias);
    		if ("eliminando" in $$props) $$invalidate(1, eliminando = $$props.eliminando);
    		if ("selecionados" in $$props) $$invalidate(2, selecionados = $$props.selecionados);
    	};

    	let selecionados;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*medias*/ 1) {
    			 $$invalidate(2, selecionados = medias.filter(m => m.seleccionado));
    		}
    	};

    	return [medias, eliminando, selecionados, eliminarMedias, checkbox_checked_binding];
    }

    class MediaHome extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$S, create_fragment$S, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "MediaHome",
    			options,
    			id: create_fragment$S.name
    		});
    	}
    }

    /* src\components\Paginas\Historial.svelte generated by Svelte v3.29.0 */

    const { Object: Object_1$8 } = globals;
    const file$T = "src\\components\\Paginas\\Historial.svelte";

    function get_each_context$n(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[8] = list[i];
    	return child_ctx;
    }

    function get_each_context_1$8(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[8] = list[i];
    	return child_ctx;
    }

    function get_each_context_2$5(ctx, list, i) {
    	const child_ctx = ctx.slice();
    	child_ctx[13] = list[i];
    	return child_ctx;
    }

    // (38:12) {#each mods as m}
    function create_each_block_2$5(ctx) {
    	let option;
    	let t_value = /*m*/ ctx[13] + "";
    	let t;
    	let option_value_value;

    	const block = {
    		c: function create() {
    			option = element("option");
    			t = text(t_value);
    			option.__value = option_value_value = /*m*/ ctx[13];
    			option.value = option.__value;
    			add_location(option, file$T, 38, 16, 1545);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, option, anchor);
    			append_dev(option, t);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(option);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_2$5.name,
    		type: "each",
    		source: "(38:12) {#each mods as m}",
    		ctx
    	});

    	return block;
    }

    // (45:12) {#each Object.keys(TipoAccion) as a}
    function create_each_block_1$8(ctx) {
    	let option;
    	let t_value = /*a*/ ctx[8] + "";
    	let t;
    	let option_value_value;

    	const block = {
    		c: function create() {
    			option = element("option");
    			t = text(t_value);
    			option.__value = option_value_value = TipoAccion[/*a*/ ctx[8]];
    			option.value = option.__value;
    			add_location(option, file$T, 45, 16, 1786);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, option, anchor);
    			append_dev(option, t);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(option);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block_1$8.name,
    		type: "each",
    		source: "(45:12) {#each Object.keys(TipoAccion) as a}",
    		ctx
    	});

    	return block;
    }

    // (58:16) {#if a.tipo == TipoAccion.CategoriaCambiada}
    function create_if_block_4$7(ctx) {
    	let span;
    	let t_value = /*a*/ ctx[8].nota + "";
    	let t;

    	const block = {
    		c: function create() {
    			span = element("span");
    			t = text(t_value);
    			attr_dev(span, "class", "svelte-2q5elb");
    			add_location(span, file$T, 58, 20, 2367);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    			append_dev(span, t);
    		},
    		p: function update(ctx, dirty) {
    			if (dirty & /*accionesFiltradas*/ 2 && t_value !== (t_value = /*a*/ ctx[8].nota + "")) set_data_dev(t, t_value);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_4$7.name,
    		type: "if",
    		source: "(58:16) {#if a.tipo == TipoAccion.CategoriaCambiada}",
    		ctx
    	});

    	return block;
    }

    // (61:16) {#if a.hilo}
    function create_if_block_3$b(ctx) {
    	let a;
    	let t;
    	let div;
    	let hilopreviewmod;
    	let a_href_value;
    	let current;

    	hilopreviewmod = new HiloPreviewMod({
    			props: { hilo: /*a*/ ctx[8].hilo },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			a = element("a");
    			t = text("Roz\r\n                        ");
    			div = element("div");
    			create_component(hilopreviewmod.$$.fragment);
    			attr_dev(div, "class", "desplegable roz svelte-2q5elb");
    			add_location(div, file$T, 62, 24, 2520);
    			attr_dev(a, "href", a_href_value = "/Hilo/" + /*a*/ ctx[8].hilo.id);
    			attr_dev(a, "class", "svelte-2q5elb");
    			add_location(a, file$T, 61, 20, 2463);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);
    			append_dev(a, t);
    			append_dev(a, div);
    			mount_component(hilopreviewmod, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const hilopreviewmod_changes = {};
    			if (dirty & /*accionesFiltradas*/ 2) hilopreviewmod_changes.hilo = /*a*/ ctx[8].hilo;
    			hilopreviewmod.$set(hilopreviewmod_changes);

    			if (!current || dirty & /*accionesFiltradas*/ 2 && a_href_value !== (a_href_value = "/Hilo/" + /*a*/ ctx[8].hilo.id)) {
    				attr_dev(a, "href", a_href_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(hilopreviewmod.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(hilopreviewmod.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    			destroy_component(hilopreviewmod);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_3$b.name,
    		type: "if",
    		source: "(61:16) {#if a.hilo}",
    		ctx
    	});

    	return block;
    }

    // (68:16) {#if a.comentario}
    function create_if_block_2$j(ctx) {
    	let a;
    	let t;
    	let div;
    	let comentario;
    	let a_href_value;
    	let current;

    	comentario = new Comentario({
    			props: { comentario: /*a*/ ctx[8].comentario },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			a = element("a");
    			t = text("Comentario\r\n                        ");
    			div = element("div");
    			create_component(comentario.$$.fragment);
    			attr_dev(div, "class", "desplegable svelte-2q5elb");
    			add_location(div, file$T, 70, 24, 2867);
    			attr_dev(a, "href", a_href_value = "/Hilo/" + /*a*/ ctx[8].comentario.hiloId + "#" + /*a*/ ctx[8].comentario.id);
    			attr_dev(a, "class", "svelte-2q5elb");
    			add_location(a, file$T, 68, 20, 2749);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);
    			append_dev(a, t);
    			append_dev(a, div);
    			mount_component(comentario, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const comentario_changes = {};
    			if (dirty & /*accionesFiltradas*/ 2) comentario_changes.comentario = /*a*/ ctx[8].comentario;
    			comentario.$set(comentario_changes);

    			if (!current || dirty & /*accionesFiltradas*/ 2 && a_href_value !== (a_href_value = "/Hilo/" + /*a*/ ctx[8].comentario.hiloId + "#" + /*a*/ ctx[8].comentario.id)) {
    				attr_dev(a, "href", a_href_value);
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(comentario.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(comentario.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    			destroy_component(comentario);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_2$j.name,
    		type: "if",
    		source: "(68:16) {#if a.comentario}",
    		ctx
    	});

    	return block;
    }

    // (76:16) {#if a.denuncia}
    function create_if_block_1$m(ctx) {
    	let a;
    	let t;
    	let div;
    	let denuncia;
    	let current;

    	denuncia = new Denuncia({
    			props: { denuncia: /*a*/ ctx[8].denuncia },
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			a = element("a");
    			t = text("Denuncia\r\n                        ");
    			div = element("div");
    			create_component(denuncia.$$.fragment);
    			attr_dev(div, "class", "desplegable svelte-2q5elb");
    			add_location(div, file$T, 78, 24, 3170);
    			attr_dev(a, "href", "#");
    			attr_dev(a, "class", "svelte-2q5elb");
    			add_location(a, file$T, 76, 20, 3098);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);
    			append_dev(a, t);
    			append_dev(a, div);
    			mount_component(denuncia, div, null);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const denuncia_changes = {};
    			if (dirty & /*accionesFiltradas*/ 2) denuncia_changes.denuncia = /*a*/ ctx[8].denuncia;
    			denuncia.$set(denuncia_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(denuncia.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(denuncia.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    			destroy_component(denuncia);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block_1$m.name,
    		type: "if",
    		source: "(76:16) {#if a.denuncia}",
    		ctx
    	});

    	return block;
    }

    // (84:16) {#if a.ban}
    function create_if_block$B(ctx) {
    	let a;
    	let t0;
    	let div;
    	let banpreview;
    	let t1;
    	let dialogo;
    	let current;

    	banpreview = new BanPreview({
    			props: { ban: /*a*/ ctx[8].ban },
    			$$inline: true
    		});

    	function func(...args) {
    		return /*func*/ ctx[5](/*a*/ ctx[8], ...args);
    	}

    	dialogo = new Dialogo({
    			props: {
    				textoActivador: "Desbanear",
    				titulo: "Desbanear gordo",
    				accion: func,
    				$$slots: {
    					default: [create_default_slot$w],
    					body: [create_body_slot$6],
    					activador: [create_activador_slot$5]
    				},
    				$$scope: { ctx }
    			},
    			$$inline: true
    		});

    	const block = {
    		c: function create() {
    			a = element("a");
    			t0 = text("Ban\r\n                        ");
    			div = element("div");
    			create_component(banpreview.$$.fragment);
    			t1 = space();
    			create_component(dialogo.$$.fragment);
    			attr_dev(div, "class", "desplegable svelte-2q5elb");
    			add_location(div, file$T, 86, 24, 3504);
    			attr_dev(a, "href", "#");
    			set_style(a, "background", "var(--color5)");
    			attr_dev(a, "class", "svelte-2q5elb");
    			add_location(a, file$T, 84, 20, 3402);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, a, anchor);
    			append_dev(a, t0);
    			append_dev(a, div);
    			mount_component(banpreview, div, null);
    			append_dev(a, t1);
    			mount_component(dialogo, a, null);
    			current = true;
    		},
    		p: function update(new_ctx, dirty) {
    			ctx = new_ctx;
    			const banpreview_changes = {};
    			if (dirty & /*accionesFiltradas*/ 2) banpreview_changes.ban = /*a*/ ctx[8].ban;
    			banpreview.$set(banpreview_changes);
    			const dialogo_changes = {};
    			if (dirty & /*accionesFiltradas*/ 2) dialogo_changes.accion = func;

    			if (dirty & /*$$scope*/ 65536) {
    				dialogo_changes.$$scope = { dirty, ctx };
    			}

    			dialogo.$set(dialogo_changes);
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(banpreview.$$.fragment, local);
    			transition_in(dialogo.$$.fragment, local);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(banpreview.$$.fragment, local);
    			transition_out(dialogo.$$.fragment, local);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(a);
    			destroy_component(banpreview);
    			destroy_component(dialogo);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_if_block$B.name,
    		type: "if",
    		source: "(84:16) {#if a.ban}",
    		ctx
    	});

    	return block;
    }

    // (91:28) <span slot="activador">
    function create_activador_slot$5(ctx) {
    	let span;

    	const block = {
    		c: function create() {
    			span = element("span");
    			span.textContent = "desbanear";
    			attr_dev(span, "slot", "activador");
    			add_location(span, file$T, 90, 28, 3783);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, span, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(span);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_activador_slot$5.name,
    		type: "slot",
    		source: "(91:28) <span slot=\\\"activador\\\">",
    		ctx
    	});

    	return block;
    }

    // (92:28) <div slot="body">
    function create_body_slot$6(ctx) {
    	let div;

    	const block = {
    		c: function create() {
    			div = element("div");
    			div.textContent = "Remover ban?";
    			attr_dev(div, "slot", "body");
    			add_location(div, file$T, 91, 28, 3852);
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, div, anchor);
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(div);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_body_slot$6.name,
    		type: "slot",
    		source: "(92:28) <div slot=\\\"body\\\">",
    		ctx
    	});

    	return block;
    }

    // (90:24) <Dialogo textoActivador="Desbanear" titulo="Desbanear gordo" accion = {() => RChanClient.removerBan(a.ban.id)}>
    function create_default_slot$w(ctx) {
    	let t;

    	const block = {
    		c: function create() {
    			t = space();
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, t, anchor);
    		},
    		p: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(t);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_default_slot$w.name,
    		type: "slot",
    		source: "(90:24) <Dialogo textoActivador=\\\"Desbanear\\\" titulo=\\\"Desbanear gordo\\\" accion = {() => RChanClient.removerBan(a.ban.id)}>",
    		ctx
    	});

    	return block;
    }

    // (51:8) {#each accionesFiltradas as a (a.id)}
    function create_each_block$n(key_1, ctx) {
    	let li;
    	let span0;
    	let tiempo;
    	let t0;
    	let span1;
    	let t1_value = /*a*/ ctx[8].usuario.userName + "";
    	let t1;
    	let t2;
    	let span2;
    	let t3_value = TipoAccion.aString(/*a*/ ctx[8].tipo) + "";
    	let t3;
    	let t4;
    	let t5;
    	let t6;
    	let t7;
    	let t8;
    	let t9;
    	let current;

    	tiempo = new Tiempo({
    			props: { date: /*a*/ ctx[8].creacion },
    			$$inline: true
    		});

    	let if_block0 = /*a*/ ctx[8].tipo == TipoAccion.CategoriaCambiada && create_if_block_4$7(ctx);
    	let if_block1 = /*a*/ ctx[8].hilo && create_if_block_3$b(ctx);
    	let if_block2 = /*a*/ ctx[8].comentario && create_if_block_2$j(ctx);
    	let if_block3 = /*a*/ ctx[8].denuncia && create_if_block_1$m(ctx);
    	let if_block4 = /*a*/ ctx[8].ban && create_if_block$B(ctx);

    	const block = {
    		key: key_1,
    		first: null,
    		c: function create() {
    			li = element("li");
    			span0 = element("span");
    			create_component(tiempo.$$.fragment);
    			t0 = space();
    			span1 = element("span");
    			t1 = text(t1_value);
    			t2 = space();
    			span2 = element("span");
    			t3 = text(t3_value);
    			t4 = space();
    			if (if_block0) if_block0.c();
    			t5 = space();
    			if (if_block1) if_block1.c();
    			t6 = space();
    			if (if_block2) if_block2.c();
    			t7 = space();
    			if (if_block3) if_block3.c();
    			t8 = space();
    			if (if_block4) if_block4.c();
    			t9 = space();
    			set_style(span0, "background", "var(--color3)");
    			attr_dev(span0, "class", "svelte-2q5elb");
    			add_location(span0, file$T, 52, 16, 1988);
    			set_style(span1, "background", "var(--color6)");
    			attr_dev(span1, "class", "svelte-2q5elb");
    			add_location(span1, file$T, 55, 16, 2121);
    			set_style(span2, "background", "var(--color5)");
    			attr_dev(span2, "class", "svelte-2q5elb");
    			add_location(span2, file$T, 56, 16, 2207);
    			attr_dev(li, "class", "accion svelte-2q5elb");
    			add_location(li, file$T, 51, 12, 1951);
    			this.first = li;
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, li, anchor);
    			append_dev(li, span0);
    			mount_component(tiempo, span0, null);
    			append_dev(li, t0);
    			append_dev(li, span1);
    			append_dev(span1, t1);
    			append_dev(li, t2);
    			append_dev(li, span2);
    			append_dev(span2, t3);
    			append_dev(li, t4);
    			if (if_block0) if_block0.m(li, null);
    			append_dev(li, t5);
    			if (if_block1) if_block1.m(li, null);
    			append_dev(li, t6);
    			if (if_block2) if_block2.m(li, null);
    			append_dev(li, t7);
    			if (if_block3) if_block3.m(li, null);
    			append_dev(li, t8);
    			if (if_block4) if_block4.m(li, null);
    			append_dev(li, t9);
    			current = true;
    		},
    		p: function update(ctx, dirty) {
    			const tiempo_changes = {};
    			if (dirty & /*accionesFiltradas*/ 2) tiempo_changes.date = /*a*/ ctx[8].creacion;
    			tiempo.$set(tiempo_changes);
    			if ((!current || dirty & /*accionesFiltradas*/ 2) && t1_value !== (t1_value = /*a*/ ctx[8].usuario.userName + "")) set_data_dev(t1, t1_value);
    			if ((!current || dirty & /*accionesFiltradas*/ 2) && t3_value !== (t3_value = TipoAccion.aString(/*a*/ ctx[8].tipo) + "")) set_data_dev(t3, t3_value);

    			if (/*a*/ ctx[8].tipo == TipoAccion.CategoriaCambiada) {
    				if (if_block0) {
    					if_block0.p(ctx, dirty);
    				} else {
    					if_block0 = create_if_block_4$7(ctx);
    					if_block0.c();
    					if_block0.m(li, t5);
    				}
    			} else if (if_block0) {
    				if_block0.d(1);
    				if_block0 = null;
    			}

    			if (/*a*/ ctx[8].hilo) {
    				if (if_block1) {
    					if_block1.p(ctx, dirty);

    					if (dirty & /*accionesFiltradas*/ 2) {
    						transition_in(if_block1, 1);
    					}
    				} else {
    					if_block1 = create_if_block_3$b(ctx);
    					if_block1.c();
    					transition_in(if_block1, 1);
    					if_block1.m(li, t6);
    				}
    			} else if (if_block1) {
    				group_outros();

    				transition_out(if_block1, 1, 1, () => {
    					if_block1 = null;
    				});

    				check_outros();
    			}

    			if (/*a*/ ctx[8].comentario) {
    				if (if_block2) {
    					if_block2.p(ctx, dirty);

    					if (dirty & /*accionesFiltradas*/ 2) {
    						transition_in(if_block2, 1);
    					}
    				} else {
    					if_block2 = create_if_block_2$j(ctx);
    					if_block2.c();
    					transition_in(if_block2, 1);
    					if_block2.m(li, t7);
    				}
    			} else if (if_block2) {
    				group_outros();

    				transition_out(if_block2, 1, 1, () => {
    					if_block2 = null;
    				});

    				check_outros();
    			}

    			if (/*a*/ ctx[8].denuncia) {
    				if (if_block3) {
    					if_block3.p(ctx, dirty);

    					if (dirty & /*accionesFiltradas*/ 2) {
    						transition_in(if_block3, 1);
    					}
    				} else {
    					if_block3 = create_if_block_1$m(ctx);
    					if_block3.c();
    					transition_in(if_block3, 1);
    					if_block3.m(li, t8);
    				}
    			} else if (if_block3) {
    				group_outros();

    				transition_out(if_block3, 1, 1, () => {
    					if_block3 = null;
    				});

    				check_outros();
    			}

    			if (/*a*/ ctx[8].ban) {
    				if (if_block4) {
    					if_block4.p(ctx, dirty);

    					if (dirty & /*accionesFiltradas*/ 2) {
    						transition_in(if_block4, 1);
    					}
    				} else {
    					if_block4 = create_if_block$B(ctx);
    					if_block4.c();
    					transition_in(if_block4, 1);
    					if_block4.m(li, t9);
    				}
    			} else if (if_block4) {
    				group_outros();

    				transition_out(if_block4, 1, 1, () => {
    					if_block4 = null;
    				});

    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(tiempo.$$.fragment, local);
    			transition_in(if_block1);
    			transition_in(if_block2);
    			transition_in(if_block3);
    			transition_in(if_block4);
    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(tiempo.$$.fragment, local);
    			transition_out(if_block1);
    			transition_out(if_block2);
    			transition_out(if_block3);
    			transition_out(if_block4);
    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(li);
    			destroy_component(tiempo);
    			if (if_block0) if_block0.d();
    			if (if_block1) if_block1.d();
    			if (if_block2) if_block2.d();
    			if (if_block3) if_block3.d();
    			if (if_block4) if_block4.d();
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_each_block$n.name,
    		type: "each",
    		source: "(51:8) {#each accionesFiltradas as a (a.id)}",
    		ctx
    	});

    	return block;
    }

    function create_fragment$T(ctx) {
    	let main;
    	let barramoderacion;
    	let t0;
    	let h3;
    	let t2;
    	let div;
    	let span;
    	let t4;
    	let select0;
    	let option0;
    	let option0_value_value;
    	let t6;
    	let select1;
    	let option1;
    	let option1_value_value;
    	let t8;
    	let ul;
    	let each_blocks = [];
    	let each2_lookup = new Map();
    	let current;
    	let mounted;
    	let dispose;
    	barramoderacion = new BarraModeracion({ $$inline: true });
    	let each_value_2 = /*mods*/ ctx[2];
    	validate_each_argument(each_value_2);
    	let each_blocks_2 = [];

    	for (let i = 0; i < each_value_2.length; i += 1) {
    		each_blocks_2[i] = create_each_block_2$5(get_each_context_2$5(ctx, each_value_2, i));
    	}

    	let each_value_1 = Object.keys(TipoAccion);
    	validate_each_argument(each_value_1);
    	let each_blocks_1 = [];

    	for (let i = 0; i < each_value_1.length; i += 1) {
    		each_blocks_1[i] = create_each_block_1$8(get_each_context_1$8(ctx, each_value_1, i));
    	}

    	let each_value = /*accionesFiltradas*/ ctx[1];
    	validate_each_argument(each_value);
    	const get_key = ctx => /*a*/ ctx[8].id;
    	validate_each_keys(ctx, each_value, get_each_context$n, get_key);

    	for (let i = 0; i < each_value.length; i += 1) {
    		let child_ctx = get_each_context$n(ctx, each_value, i);
    		let key = get_key(child_ctx);
    		each2_lookup.set(key, each_blocks[i] = create_each_block$n(key, child_ctx));
    	}

    	const block = {
    		c: function create() {
    			main = element("main");
    			create_component(barramoderacion.$$.fragment);
    			t0 = space();
    			h3 = element("h3");
    			h3.textContent = "Ultimas acciones";
    			t2 = space();
    			div = element("div");
    			span = element("span");
    			span.textContent = "Filtrar:";
    			t4 = space();
    			select0 = element("select");
    			option0 = element("option");
    			option0.textContent = "Usuario";

    			for (let i = 0; i < each_blocks_2.length; i += 1) {
    				each_blocks_2[i].c();
    			}

    			t6 = space();
    			select1 = element("select");
    			option1 = element("option");
    			option1.textContent = "Accion";

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].c();
    			}

    			t8 = space();
    			ul = element("ul");

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].c();
    			}

    			set_style(h3, "text-align", "center");
    			set_style(h3, "margin-bottom", "10px");
    			add_location(h3, file$T, 32, 4, 1191);
    			add_location(span, file$T, 34, 8, 1379);
    			option0.__value = option0_value_value = "";
    			option0.value = option0.__value;
    			add_location(option0, file$T, 36, 12, 1461);
    			if (/*filtro*/ ctx[0].usuario === void 0) add_render_callback(() => /*select0_change_handler*/ ctx[3].call(select0));
    			add_location(select0, file$T, 35, 8, 1411);
    			option1.__value = option1_value_value = "";
    			option1.value = option1.__value;
    			add_location(option1, file$T, 43, 12, 1684);
    			if (/*filtro*/ ctx[0].accion === void 0) add_render_callback(() => /*select1_change_handler*/ ctx[4].call(select1));
    			add_location(select1, file$T, 42, 8, 1635);
    			attr_dev(div, "class", "filtros");
    			set_style(div, "display", "flex");
    			set_style(div, "width", "fit-content");
    			set_style(div, "margin", "0 auto");
    			set_style(div, "align-items", "baseline");
    			add_location(div, file$T, 33, 4, 1269);
    			attr_dev(ul, "class", "svelte-2q5elb");
    			add_location(ul, file$T, 49, 4, 1886);
    			add_location(main, file$T, 30, 0, 1155);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, main, anchor);
    			mount_component(barramoderacion, main, null);
    			append_dev(main, t0);
    			append_dev(main, h3);
    			append_dev(main, t2);
    			append_dev(main, div);
    			append_dev(div, span);
    			append_dev(div, t4);
    			append_dev(div, select0);
    			append_dev(select0, option0);

    			for (let i = 0; i < each_blocks_2.length; i += 1) {
    				each_blocks_2[i].m(select0, null);
    			}

    			select_option(select0, /*filtro*/ ctx[0].usuario);
    			append_dev(div, t6);
    			append_dev(div, select1);
    			append_dev(select1, option1);

    			for (let i = 0; i < each_blocks_1.length; i += 1) {
    				each_blocks_1[i].m(select1, null);
    			}

    			select_option(select1, /*filtro*/ ctx[0].accion);
    			append_dev(main, t8);
    			append_dev(main, ul);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].m(ul, null);
    			}

    			current = true;

    			if (!mounted) {
    				dispose = [
    					listen_dev(select0, "change", /*select0_change_handler*/ ctx[3]),
    					listen_dev(select1, "change", /*select1_change_handler*/ ctx[4])
    				];

    				mounted = true;
    			}
    		},
    		p: function update(ctx, [dirty]) {
    			if (dirty & /*mods*/ 4) {
    				each_value_2 = /*mods*/ ctx[2];
    				validate_each_argument(each_value_2);
    				let i;

    				for (i = 0; i < each_value_2.length; i += 1) {
    					const child_ctx = get_each_context_2$5(ctx, each_value_2, i);

    					if (each_blocks_2[i]) {
    						each_blocks_2[i].p(child_ctx, dirty);
    					} else {
    						each_blocks_2[i] = create_each_block_2$5(child_ctx);
    						each_blocks_2[i].c();
    						each_blocks_2[i].m(select0, null);
    					}
    				}

    				for (; i < each_blocks_2.length; i += 1) {
    					each_blocks_2[i].d(1);
    				}

    				each_blocks_2.length = each_value_2.length;
    			}

    			if (dirty & /*filtro, mods*/ 5) {
    				select_option(select0, /*filtro*/ ctx[0].usuario);
    			}

    			if (dirty & /*TipoAccion, Object*/ 0) {
    				each_value_1 = Object.keys(TipoAccion);
    				validate_each_argument(each_value_1);
    				let i;

    				for (i = 0; i < each_value_1.length; i += 1) {
    					const child_ctx = get_each_context_1$8(ctx, each_value_1, i);

    					if (each_blocks_1[i]) {
    						each_blocks_1[i].p(child_ctx, dirty);
    					} else {
    						each_blocks_1[i] = create_each_block_1$8(child_ctx);
    						each_blocks_1[i].c();
    						each_blocks_1[i].m(select1, null);
    					}
    				}

    				for (; i < each_blocks_1.length; i += 1) {
    					each_blocks_1[i].d(1);
    				}

    				each_blocks_1.length = each_value_1.length;
    			}

    			if (dirty & /*filtro, mods*/ 5) {
    				select_option(select1, /*filtro*/ ctx[0].accion);
    			}

    			if (dirty & /*RChanClient, accionesFiltradas, TipoAccion*/ 2) {
    				const each_value = /*accionesFiltradas*/ ctx[1];
    				validate_each_argument(each_value);
    				group_outros();
    				validate_each_keys(ctx, each_value, get_each_context$n, get_key);
    				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each2_lookup, ul, outro_and_destroy_block, create_each_block$n, null, get_each_context$n);
    				check_outros();
    			}
    		},
    		i: function intro(local) {
    			if (current) return;
    			transition_in(barramoderacion.$$.fragment, local);

    			for (let i = 0; i < each_value.length; i += 1) {
    				transition_in(each_blocks[i]);
    			}

    			current = true;
    		},
    		o: function outro(local) {
    			transition_out(barramoderacion.$$.fragment, local);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				transition_out(each_blocks[i]);
    			}

    			current = false;
    		},
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(main);
    			destroy_component(barramoderacion);
    			destroy_each(each_blocks_2, detaching);
    			destroy_each(each_blocks_1, detaching);

    			for (let i = 0; i < each_blocks.length; i += 1) {
    				each_blocks[i].d();
    			}

    			mounted = false;
    			run_all(dispose);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$T.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$T($$self, $$props, $$invalidate) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Historial", slots, []);
    	const historial = window.model.acciones;
    	let dialogoDesban = false;
    	let filtro = { usuario: "", accion: "" };
    	let mods = Array.from(new Set(historial.map(a => a.usuario.userName)));
    	const writable_props = [];

    	Object_1$8.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Historial> was created with unknown prop '${key}'`);
    	});

    	function select0_change_handler() {
    		filtro.usuario = select_value(this);
    		$$invalidate(0, filtro);
    		$$invalidate(2, mods);
    	}

    	function select1_change_handler() {
    		filtro.accion = select_value(this);
    		$$invalidate(0, filtro);
    		$$invalidate(2, mods);
    	}

    	const func = a => RChanClient.removerBan(a.ban.id);

    	$$self.$capture_state = () => ({
    		TipoAccion,
    		MotivoDenuncia,
    		Button: ye,
    		Comentario,
    		HiloPreviewMod,
    		Denuncia,
    		formatearTiempo,
    		formatearTimeSpan,
    		Dialogo,
    		RChanClient,
    		Tiempo,
    		BarraModeracion,
    		BanPreview,
    		historial,
    		dialogoDesban,
    		filtro,
    		mods,
    		accionesFiltradas
    	});

    	$$self.$inject_state = $$props => {
    		if ("dialogoDesban" in $$props) dialogoDesban = $$props.dialogoDesban;
    		if ("filtro" in $$props) $$invalidate(0, filtro = $$props.filtro);
    		if ("mods" in $$props) $$invalidate(2, mods = $$props.mods);
    		if ("accionesFiltradas" in $$props) $$invalidate(1, accionesFiltradas = $$props.accionesFiltradas);
    	};

    	let accionesFiltradas;

    	if ($$props && "$$inject" in $$props) {
    		$$self.$inject_state($$props.$$inject);
    	}

    	$$self.$$.update = () => {
    		if ($$self.$$.dirty & /*filtro*/ 1) {
    			 $$invalidate(1, accionesFiltradas = historial.filter(a => {
    				let fUsuario = !filtro.usuario || a.usuario.userName == filtro.usuario;
    				let fAccion = filtro.accion === "" || a.tipo === filtro.accion;
    				return fUsuario && fAccion;
    			}) || filtro);
    		}
    	};

    	return [
    		filtro,
    		accionesFiltradas,
    		mods,
    		select0_change_handler,
    		select1_change_handler,
    		func
    	];
    }

    class Historial extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$T, create_fragment$T, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Historial",
    			options,
    			id: create_fragment$T.name
    		});
    	}
    }

    // const app = new App({
    // 	target: document.body,
    // 	props: {
    // 		name: 'world'
    // 	}
    // });

    let componentes = [
    	["#svelte", App, {}],
    	["#svelte-navbar", Navbar, {}],
    	["#svelte-index", HiloList, {hiloList: window.hiloList}],
    	["#svelte-administracion", Administracion, {}],
    	["#svelte-moderacion", Moderacion, {}],
    	["#svelte-token", Token, {}],
    	["#svelte-login", Login, {}],
    	["#svelte-historialDeUsuario", HistorialUsuario, {}],
    	["#svelte-registro", Registro],
    	["#svelte-inicio", Inicio],
    	["#svelte-domado", Domado, {}],
    	["#svelte-listaDeUsuarios", ListaDeUsuarios, {}],
    	["#svelte-eliminadosYDesactivados", EliminadosYDesactivados, {}],
    	["#svelte-media-home", MediaHome, {}],
    	["#svelte-busqueda", Busqueda, {}],
    	["#svelte-historial", Historial, {}],
    ];

    for (const c of componentes) {
    	if(document.querySelector(c[0]))
    	{	
    		new c[1]({
    			target: document.querySelector(c[0]),
    			props: c[2]
    		});
    	}
    	
    }

}());
//# sourceMappingURL=bundle.js.map
