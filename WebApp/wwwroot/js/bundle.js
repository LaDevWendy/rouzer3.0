
(function(l, r) { if (l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (window.location.host || 'localhost').split(':')[0] + ':6000/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(window.document);
(function () {
    'use strict';

    function noop() {}

    const identity = x => x;

    function assign(tar, src) {
      // @ts-ignore
      for (const k in src) tar[k] = src[k];

      return tar;
    }

    function add_location(element, file, line, column, char) {
      element.__svelte_meta = {
        loc: {
          file,
          line,
          column,
          char
        }
      };
    }

    function run(fn) {
      return fn();
    }

    function blank_object() {
      return Object.create(null);
    }

    function run_all(fns) {
      fns.forEach(run);
    }

    function is_function(thing) {
      return typeof thing === 'function';
    }

    function safe_not_equal(a, b) {
      return a != a ? b == b : a !== b || a && typeof a === 'object' || typeof a === 'function';
    }

    function is_empty(obj) {
      return Object.keys(obj).length === 0;
    }

    function validate_store(store, name) {
      if (store != null && typeof store.subscribe !== 'function') {
        throw new Error(`'${name}' is not a store with a 'subscribe' method`);
      }
    }

    function subscribe(store, ...callbacks) {
      if (store == null) {
        return noop;
      }

      const unsub = store.subscribe(...callbacks);
      return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
    }

    function component_subscribe(component, store, callback) {
      component.$$.on_destroy.push(subscribe(store, callback));
    }

    function create_slot(definition, ctx, $$scope, fn) {
      if (definition) {
        const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
        return definition[0](slot_ctx);
      }
    }

    function get_slot_context(definition, ctx, $$scope, fn) {
      return definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;
    }

    function get_slot_changes(definition, $$scope, dirty, fn) {
      if (definition[2] && fn) {
        const lets = definition[2](fn(dirty));

        if ($$scope.dirty === undefined) {
          return lets;
        }

        if (typeof lets === 'object') {
          const merged = [];
          const len = Math.max($$scope.dirty.length, lets.length);

          for (let i = 0; i < len; i += 1) {
            merged[i] = $$scope.dirty[i] | lets[i];
          }

          return merged;
        }

        return $$scope.dirty | lets;
      }

      return $$scope.dirty;
    }

    function update_slot(slot, slot_definition, ctx, $$scope, dirty, get_slot_changes_fn, get_slot_context_fn) {
      const slot_changes = get_slot_changes(slot_definition, $$scope, dirty, get_slot_changes_fn);

      if (slot_changes) {
        const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
        slot.p(slot_context, slot_changes);
      }
    }

    function exclude_internal_props(props) {
      const result = {};

      for (const k in props) if (k[0] !== '$') result[k] = props[k];

      return result;
    }

    function null_to_empty(value) {
      return value == null ? '' : value;
    }

    function set_store_value(store, ret, value = ret) {
      store.set(value);
      return ret;
    }

    function action_destroyer(action_result) {
      return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;
    }

    const is_client = typeof window !== 'undefined';
    let now = is_client ? () => window.performance.now() : () => Date.now();
    let raf = is_client ? cb => requestAnimationFrame(cb) : noop; // used internally for testing

    const tasks = new Set();

    function run_tasks(now) {
      tasks.forEach(task => {
        if (!task.c(now)) {
          tasks.delete(task);
          task.f();
        }
      });
      if (tasks.size !== 0) raf(run_tasks);
    }
    /**
     * Creates a new task that runs on each raf frame
     * until it returns a falsy value or is aborted
     */


    function loop(callback) {
      let task;
      if (tasks.size === 0) raf(run_tasks);
      return {
        promise: new Promise(fulfill => {
          tasks.add(task = {
            c: callback,
            f: fulfill
          });
        }),

        abort() {
          tasks.delete(task);
        }

      };
    }

    function append(target, node) {
      target.appendChild(node);
    }

    function insert(target, node, anchor) {
      target.insertBefore(node, anchor || null);
    }

    function detach(node) {
      node.parentNode.removeChild(node);
    }

    function destroy_each(iterations, detaching) {
      for (let i = 0; i < iterations.length; i += 1) {
        if (iterations[i]) iterations[i].d(detaching);
      }
    }

    function element(name) {
      return document.createElement(name);
    }

    function svg_element(name) {
      return document.createElementNS('http://www.w3.org/2000/svg', name);
    }

    function text(data) {
      return document.createTextNode(data);
    }

    function space() {
      return text(' ');
    }

    function empty() {
      return text('');
    }

    function listen(node, event, handler, options) {
      node.addEventListener(event, handler, options);
      return () => node.removeEventListener(event, handler, options);
    }

    function prevent_default(fn) {
      return function (event) {
        event.preventDefault(); // @ts-ignore

        return fn.call(this, event);
      };
    }

    function stop_propagation(fn) {
      return function (event) {
        event.stopPropagation(); // @ts-ignore

        return fn.call(this, event);
      };
    }

    function attr(node, attribute, value) {
      if (value == null) node.removeAttribute(attribute);else if (node.getAttribute(attribute) !== value) node.setAttribute(attribute, value);
    }

    function set_attributes(node, attributes) {
      // @ts-ignore
      const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);

      for (const key in attributes) {
        if (attributes[key] == null) {
          node.removeAttribute(key);
        } else if (key === 'style') {
          node.style.cssText = attributes[key];
        } else if (key === '__value') {
          node.value = node[key] = attributes[key];
        } else if (descriptors[key] && descriptors[key].set) {
          node[key] = attributes[key];
        } else {
          attr(node, key, attributes[key]);
        }
      }
    }

    function to_number(value) {
      return value === '' ? null : +value;
    }

    function children(element) {
      return Array.from(element.childNodes);
    }

    function set_data(text, data) {
      data = '' + data;
      if (text.wholeText !== data) text.data = data;
    }

    function set_input_value(input, value) {
      input.value = value == null ? '' : value;
    }

    function set_style(node, key, value, important) {
      node.style.setProperty(key, value, important ? 'important' : '');
    }

    function select_option(select, value) {
      for (let i = 0; i < select.options.length; i += 1) {
        const option = select.options[i];

        if (option.__value === value) {
          option.selected = true;
          return;
        }
      }
    }

    function select_value(select) {
      const selected_option = select.querySelector(':checked') || select.options[0];
      return selected_option && selected_option.__value;
    }
    // so we cache the result instead


    let crossorigin;

    function is_crossorigin() {
      if (crossorigin === undefined) {
        crossorigin = false;

        try {
          if (typeof window !== 'undefined' && window.parent) {
            void window.parent.document;
          }
        } catch (error) {
          crossorigin = true;
        }
      }

      return crossorigin;
    }

    function add_resize_listener(node, fn) {
      const computed_style = getComputedStyle(node);
      const z_index = (parseInt(computed_style.zIndex) || 0) - 1;

      if (computed_style.position === 'static') {
        node.style.position = 'relative';
      }

      const iframe = element('iframe');
      iframe.setAttribute('style', `display: block; position: absolute; top: 0; left: 0; width: 100%; height: 100%; ` + `overflow: hidden; border: 0; opacity: 0; pointer-events: none; z-index: ${z_index};`);
      iframe.setAttribute('aria-hidden', 'true');
      iframe.tabIndex = -1;
      const crossorigin = is_crossorigin();
      let unsubscribe;

      if (crossorigin) {
        iframe.src = `data:text/html,<script>onresize=function(){parent.postMessage(0,'*')}</script>`;
        unsubscribe = listen(window, 'message', event => {
          if (event.source === iframe.contentWindow) fn();
        });
      } else {
        iframe.src = 'about:blank';

        iframe.onload = () => {
          unsubscribe = listen(iframe.contentWindow, 'resize', fn);
        };
      }

      append(node, iframe);
      return () => {
        if (crossorigin) {
          unsubscribe();
        } else if (unsubscribe && iframe.contentWindow) {
          unsubscribe();
        }

        detach(iframe);
      };
    }

    function toggle_class(element, name, toggle) {
      element.classList[toggle ? 'add' : 'remove'](name);
    }

    function custom_event(type, detail) {
      const e = document.createEvent('CustomEvent');
      e.initCustomEvent(type, false, false, detail);
      return e;
    }

    const active_docs = new Set();
    let active = 0; // https://github.com/darkskyapp/string-hash/blob/master/index.js

    function hash(str) {
      let hash = 5381;
      let i = str.length;

      while (i--) hash = (hash << 5) - hash ^ str.charCodeAt(i);

      return hash >>> 0;
    }

    function create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {
      const step = 16.666 / duration;
      let keyframes = '{\n';

      for (let p = 0; p <= 1; p += step) {
        const t = a + (b - a) * ease(p);
        keyframes += p * 100 + `%{${fn(t, 1 - t)}}\n`;
      }

      const rule = keyframes + `100% {${fn(b, 1 - b)}}\n}`;
      const name = `__svelte_${hash(rule)}_${uid}`;
      const doc = node.ownerDocument;
      active_docs.add(doc);
      const stylesheet = doc.__svelte_stylesheet || (doc.__svelte_stylesheet = doc.head.appendChild(element('style')).sheet);
      const current_rules = doc.__svelte_rules || (doc.__svelte_rules = {});

      if (!current_rules[name]) {
        current_rules[name] = true;
        stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);
      }

      const animation = node.style.animation || '';
      node.style.animation = `${animation ? `${animation}, ` : ``}${name} ${duration}ms linear ${delay}ms 1 both`;
      active += 1;
      return name;
    }

    function delete_rule(node, name) {
      const previous = (node.style.animation || '').split(', ');
      const next = previous.filter(name ? anim => anim.indexOf(name) < 0 // remove specific animation
      : anim => anim.indexOf('__svelte') === -1 // remove all Svelte animations
      );
      const deleted = previous.length - next.length;

      if (deleted) {
        node.style.animation = next.join(', ');
        active -= deleted;
        if (!active) clear_rules();
      }
    }

    function clear_rules() {
      raf(() => {
        if (active) return;
        active_docs.forEach(doc => {
          const stylesheet = doc.__svelte_stylesheet;
          let i = stylesheet.cssRules.length;

          while (i--) stylesheet.deleteRule(i);

          doc.__svelte_rules = {};
        });
        active_docs.clear();
      });
    }

    let current_component;

    function set_current_component(component) {
      current_component = component;
    }

    function get_current_component() {
      if (!current_component) throw new Error(`Function called outside component initialization`);
      return current_component;
    }

    function beforeUpdate(fn) {
      get_current_component().$$.before_update.push(fn);
    }

    function onMount(fn) {
      get_current_component().$$.on_mount.push(fn);
    }

    function onDestroy(fn) {
      get_current_component().$$.on_destroy.push(fn);
    }

    function createEventDispatcher() {
      const component = get_current_component();
      return (type, detail) => {
        const callbacks = component.$$.callbacks[type];

        if (callbacks) {
          // TODO are there situations where events could be dispatched
          // in a server (non-DOM) environment?
          const event = custom_event(type, detail);
          callbacks.slice().forEach(fn => {
            fn.call(component, event);
          });
        }
      };
    }
    // shorthand events, or if we want to implement
    // a real bubbling mechanism


    function bubble(component, event) {
      const callbacks = component.$$.callbacks[event.type];

      if (callbacks) {
        callbacks.slice().forEach(fn => fn(event));
      }
    }

    const dirty_components = [];
    const binding_callbacks = [];
    const render_callbacks = [];
    const flush_callbacks = [];
    const resolved_promise = Promise.resolve();
    let update_scheduled = false;

    function schedule_update() {
      if (!update_scheduled) {
        update_scheduled = true;
        resolved_promise.then(flush);
      }
    }

    function tick() {
      schedule_update();
      return resolved_promise;
    }

    function add_render_callback(fn) {
      render_callbacks.push(fn);
    }

    function add_flush_callback(fn) {
      flush_callbacks.push(fn);
    }

    let flushing = false;
    const seen_callbacks = new Set();

    function flush() {
      if (flushing) return;
      flushing = true;

      do {
        // first, call beforeUpdate functions
        // and update components
        for (let i = 0; i < dirty_components.length; i += 1) {
          const component = dirty_components[i];
          set_current_component(component);
          update(component.$$);
        }

        set_current_component(null);
        dirty_components.length = 0;

        while (binding_callbacks.length) binding_callbacks.pop()(); // then, once components are updated, call
        // afterUpdate functions. This may cause
        // subsequent updates...


        for (let i = 0; i < render_callbacks.length; i += 1) {
          const callback = render_callbacks[i];

          if (!seen_callbacks.has(callback)) {
            // ...so guard against infinite loops
            seen_callbacks.add(callback);
            callback();
          }
        }

        render_callbacks.length = 0;
      } while (dirty_components.length);

      while (flush_callbacks.length) {
        flush_callbacks.pop()();
      }

      update_scheduled = false;
      flushing = false;
      seen_callbacks.clear();
    }

    function update($$) {
      if ($$.fragment !== null) {
        $$.update();
        run_all($$.before_update);
        const dirty = $$.dirty;
        $$.dirty = [-1];
        $$.fragment && $$.fragment.p($$.ctx, dirty);
        $$.after_update.forEach(add_render_callback);
      }
    }

    let promise;

    function wait() {
      if (!promise) {
        promise = Promise.resolve();
        promise.then(() => {
          promise = null;
        });
      }

      return promise;
    }

    function dispatch(node, direction, kind) {
      node.dispatchEvent(custom_event(`${direction ? 'intro' : 'outro'}${kind}`));
    }

    const outroing = new Set();
    let outros;

    function group_outros() {
      outros = {
        r: 0,
        c: [],
        p: outros // parent group

      };
    }

    function check_outros() {
      if (!outros.r) {
        run_all(outros.c);
      }

      outros = outros.p;
    }

    function transition_in(block, local) {
      if (block && block.i) {
        outroing.delete(block);
        block.i(local);
      }
    }

    function transition_out(block, local, detach, callback) {
      if (block && block.o) {
        if (outroing.has(block)) return;
        outroing.add(block);
        outros.c.push(() => {
          outroing.delete(block);

          if (callback) {
            if (detach) block.d(1);
            callback();
          }
        });
        block.o(local);
      }
    }

    const null_transition = {
      duration: 0
    };

    function create_in_transition(node, fn, params) {
      let config = fn(node, params);
      let running = false;
      let animation_name;
      let task;
      let uid = 0;

      function cleanup() {
        if (animation_name) delete_rule(node, animation_name);
      }

      function go() {
        const {
          delay = 0,
          duration = 300,
          easing = identity,
          tick = noop,
          css
        } = config || null_transition;
        if (css) animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);
        tick(0, 1);
        const start_time = now() + delay;
        const end_time = start_time + duration;
        if (task) task.abort();
        running = true;
        add_render_callback(() => dispatch(node, true, 'start'));
        task = loop(now => {
          if (running) {
            if (now >= end_time) {
              tick(1, 0);
              dispatch(node, true, 'end');
              cleanup();
              return running = false;
            }

            if (now >= start_time) {
              const t = easing((now - start_time) / duration);
              tick(t, 1 - t);
            }
          }

          return running;
        });
      }

      let started = false;
      return {
        start() {
          if (started) return;
          delete_rule(node);

          if (is_function(config)) {
            config = config();
            wait().then(go);
          } else {
            go();
          }
        },

        invalidate() {
          started = false;
        },

        end() {
          if (running) {
            cleanup();
            running = false;
          }
        }

      };
    }

    function create_out_transition(node, fn, params) {
      let config = fn(node, params);
      let running = true;
      let animation_name;
      const group = outros;
      group.r += 1;

      function go() {
        const {
          delay = 0,
          duration = 300,
          easing = identity,
          tick = noop,
          css
        } = config || null_transition;
        if (css) animation_name = create_rule(node, 1, 0, duration, delay, easing, css);
        const start_time = now() + delay;
        const end_time = start_time + duration;
        add_render_callback(() => dispatch(node, false, 'start'));
        loop(now => {
          if (running) {
            if (now >= end_time) {
              tick(0, 1);
              dispatch(node, false, 'end');

              if (! --group.r) {
                // this will result in `end()` being called,
                // so we don't need to clean up here
                run_all(group.c);
              }

              return false;
            }

            if (now >= start_time) {
              const t = easing((now - start_time) / duration);
              tick(1 - t, t);
            }
          }

          return running;
        });
      }

      if (is_function(config)) {
        wait().then(() => {
          // @ts-ignore
          config = config();
          go();
        });
      } else {
        go();
      }

      return {
        end(reset) {
          if (reset && config.tick) {
            config.tick(1, 0);
          }

          if (running) {
            if (animation_name) delete_rule(node, animation_name);
            running = false;
          }
        }

      };
    }

    function create_bidirectional_transition(node, fn, params, intro) {
      let config = fn(node, params);
      let t = intro ? 0 : 1;
      let running_program = null;
      let pending_program = null;
      let animation_name = null;

      function clear_animation() {
        if (animation_name) delete_rule(node, animation_name);
      }

      function init(program, duration) {
        const d = program.b - t;
        duration *= Math.abs(d);
        return {
          a: t,
          b: program.b,
          d,
          duration,
          start: program.start,
          end: program.start + duration,
          group: program.group
        };
      }

      function go(b) {
        const {
          delay = 0,
          duration = 300,
          easing = identity,
          tick = noop,
          css
        } = config || null_transition;
        const program = {
          start: now() + delay,
          b
        };

        if (!b) {
          // @ts-ignore todo: improve typings
          program.group = outros;
          outros.r += 1;
        }

        if (running_program || pending_program) {
          pending_program = program;
        } else {
          // if this is an intro, and there's a delay, we need to do
          // an initial tick and/or apply CSS animation immediately
          if (css) {
            clear_animation();
            animation_name = create_rule(node, t, b, duration, delay, easing, css);
          }

          if (b) tick(0, 1);
          running_program = init(program, duration);
          add_render_callback(() => dispatch(node, b, 'start'));
          loop(now => {
            if (pending_program && now > pending_program.start) {
              running_program = init(pending_program, duration);
              pending_program = null;
              dispatch(node, running_program.b, 'start');

              if (css) {
                clear_animation();
                animation_name = create_rule(node, t, running_program.b, running_program.duration, 0, easing, config.css);
              }
            }

            if (running_program) {
              if (now >= running_program.end) {
                tick(t = running_program.b, 1 - t);
                dispatch(node, running_program.b, 'end');

                if (!pending_program) {
                  // we're done
                  if (running_program.b) {
                    // intro — we can tidy up immediately
                    clear_animation();
                  } else {
                    // outro — needs to be coordinated
                    if (! --running_program.group.r) run_all(running_program.group.c);
                  }
                }

                running_program = null;
              } else if (now >= running_program.start) {
                const p = now - running_program.start;
                t = running_program.a + running_program.d * easing(p / running_program.duration);
                tick(t, 1 - t);
              }
            }

            return !!(running_program || pending_program);
          });
        }
      }

      return {
        run(b) {
          if (is_function(config)) {
            wait().then(() => {
              // @ts-ignore
              config = config();
              go(b);
            });
          } else {
            go(b);
          }
        },

        end() {
          clear_animation();
          running_program = pending_program = null;
        }

      };
    }

    const globals = typeof window !== 'undefined' ? window : typeof globalThis !== 'undefined' ? globalThis : global;

    function destroy_block(block, lookup) {
      block.d(1);
      lookup.delete(block.key);
    }

    function outro_and_destroy_block(block, lookup) {
      transition_out(block, 1, 1, () => {
        lookup.delete(block.key);
      });
    }

    function update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block, next, get_context) {
      let o = old_blocks.length;
      let n = list.length;
      let i = o;
      const old_indexes = {};

      while (i--) old_indexes[old_blocks[i].key] = i;

      const new_blocks = [];
      const new_lookup = new Map();
      const deltas = new Map();
      i = n;

      while (i--) {
        const child_ctx = get_context(ctx, list, i);
        const key = get_key(child_ctx);
        let block = lookup.get(key);

        if (!block) {
          block = create_each_block(key, child_ctx);
          block.c();
        } else if (dynamic) {
          block.p(child_ctx, dirty);
        }

        new_lookup.set(key, new_blocks[i] = block);
        if (key in old_indexes) deltas.set(key, Math.abs(i - old_indexes[key]));
      }

      const will_move = new Set();
      const did_move = new Set();

      function insert(block) {
        transition_in(block, 1);
        block.m(node, next);
        lookup.set(block.key, block);
        next = block.first;
        n--;
      }

      while (o && n) {
        const new_block = new_blocks[n - 1];
        const old_block = old_blocks[o - 1];
        const new_key = new_block.key;
        const old_key = old_block.key;

        if (new_block === old_block) {
          // do nothing
          next = new_block.first;
          o--;
          n--;
        } else if (!new_lookup.has(old_key)) {
          // remove old block
          destroy(old_block, lookup);
          o--;
        } else if (!lookup.has(new_key) || will_move.has(new_key)) {
          insert(new_block);
        } else if (did_move.has(old_key)) {
          o--;
        } else if (deltas.get(new_key) > deltas.get(old_key)) {
          did_move.add(new_key);
          insert(new_block);
        } else {
          will_move.add(old_key);
          o--;
        }
      }

      while (o--) {
        const old_block = old_blocks[o];
        if (!new_lookup.has(old_block.key)) destroy(old_block, lookup);
      }

      while (n) insert(new_blocks[n - 1]);

      return new_blocks;
    }

    function validate_each_keys(ctx, list, get_context, get_key) {
      const keys = new Set();

      for (let i = 0; i < list.length; i++) {
        const key = get_key(get_context(ctx, list, i));

        if (keys.has(key)) {
          throw new Error(`Cannot have duplicate keys in a keyed each`);
        }

        keys.add(key);
      }
    }

    function get_spread_update(levels, updates) {
      const update = {};
      const to_null_out = {};
      const accounted_for = {
        $$scope: 1
      };
      let i = levels.length;

      while (i--) {
        const o = levels[i];
        const n = updates[i];

        if (n) {
          for (const key in o) {
            if (!(key in n)) to_null_out[key] = 1;
          }

          for (const key in n) {
            if (!accounted_for[key]) {
              update[key] = n[key];
              accounted_for[key] = 1;
            }
          }

          levels[i] = n;
        } else {
          for (const key in o) {
            accounted_for[key] = 1;
          }
        }
      }

      for (const key in to_null_out) {
        if (!(key in update)) update[key] = undefined;
      }

      return update;
    }

    function bind(component, name, callback) {
      const index = component.$$.props[name];

      if (index !== undefined) {
        component.$$.bound[index] = callback;
        callback(component.$$.ctx[index]);
      }
    }

    function create_component(block) {
      block && block.c();
    }

    function mount_component(component, target, anchor) {
      const {
        fragment,
        on_mount,
        on_destroy,
        after_update
      } = component.$$;
      fragment && fragment.m(target, anchor); // onMount happens before the initial afterUpdate

      add_render_callback(() => {
        const new_on_destroy = on_mount.map(run).filter(is_function);

        if (on_destroy) {
          on_destroy.push(...new_on_destroy);
        } else {
          // Edge case - component was destroyed immediately,
          // most likely as a result of a binding initialising
          run_all(new_on_destroy);
        }

        component.$$.on_mount = [];
      });
      after_update.forEach(add_render_callback);
    }

    function destroy_component(component, detaching) {
      const $$ = component.$$;

      if ($$.fragment !== null) {
        run_all($$.on_destroy);
        $$.fragment && $$.fragment.d(detaching); // TODO null out other refs, including component.$$ (but need to
        // preserve final state?)

        $$.on_destroy = $$.fragment = null;
        $$.ctx = [];
      }
    }

    function make_dirty(component, i) {
      if (component.$$.dirty[0] === -1) {
        dirty_components.push(component);
        schedule_update();
        component.$$.dirty.fill(0);
      }

      component.$$.dirty[i / 31 | 0] |= 1 << i % 31;
    }

    function init(component, options, instance, create_fragment, not_equal, props, dirty = [-1]) {
      const parent_component = current_component;
      set_current_component(component);
      const prop_values = options.props || {};
      const $$ = component.$$ = {
        fragment: null,
        ctx: null,
        // state
        props,
        update: noop,
        not_equal,
        bound: blank_object(),
        // lifecycle
        on_mount: [],
        on_destroy: [],
        before_update: [],
        after_update: [],
        context: new Map(parent_component ? parent_component.$$.context : []),
        // everything else
        callbacks: blank_object(),
        dirty,
        skip_bound: false
      };
      let ready = false;
      $$.ctx = instance ? instance(component, prop_values, (i, ret, ...rest) => {
        const value = rest.length ? rest[0] : ret;

        if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
          if (!$$.skip_bound && $$.bound[i]) $$.bound[i](value);
          if (ready) make_dirty(component, i);
        }

        return ret;
      }) : [];
      $$.update();
      ready = true;
      run_all($$.before_update); // `false` as a special case of no DOM component

      $$.fragment = create_fragment ? create_fragment($$.ctx) : false;

      if (options.target) {
        if (options.hydrate) {
          const nodes = children(options.target); // eslint-disable-next-line @typescript-eslint/no-non-null-assertion

          $$.fragment && $$.fragment.l(nodes);
          nodes.forEach(detach);
        } else {
          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
          $$.fragment && $$.fragment.c();
        }

        if (options.intro) transition_in(component.$$.fragment);
        mount_component(component, options.target, options.anchor);
        flush();
      }

      set_current_component(parent_component);
    }

    class SvelteComponent {
      $destroy() {
        destroy_component(this, 1);
        this.$destroy = noop;
      }

      $on(type, callback) {
        const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
        callbacks.push(callback);
        return () => {
          const index = callbacks.indexOf(callback);
          if (index !== -1) callbacks.splice(index, 1);
        };
      }

      $set($$props) {
        if (this.$$set && !is_empty($$props)) {
          this.$$.skip_bound = true;
          this.$$set($$props);
          this.$$.skip_bound = false;
        }
      }

    }

    function dispatch_dev(type, detail) {
      document.dispatchEvent(custom_event(type, Object.assign({
        version: '3.29.0'
      }, detail)));
    }

    function append_dev(target, node) {
      dispatch_dev("SvelteDOMInsert", {
        target,
        node
      });
      append(target, node);
    }

    function insert_dev(target, node, anchor) {
      dispatch_dev("SvelteDOMInsert", {
        target,
        node,
        anchor
      });
      insert(target, node, anchor);
    }

    function detach_dev(node) {
      dispatch_dev("SvelteDOMRemove", {
        node
      });
      detach(node);
    }

    function listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation) {
      const modifiers = options === true ? ["capture"] : options ? Array.from(Object.keys(options)) : [];
      if (has_prevent_default) modifiers.push('preventDefault');
      if (has_stop_propagation) modifiers.push('stopPropagation');
      dispatch_dev("SvelteDOMAddEventListener", {
        node,
        event,
        handler,
        modifiers
      });
      const dispose = listen(node, event, handler, options);
      return () => {
        dispatch_dev("SvelteDOMRemoveEventListener", {
          node,
          event,
          handler,
          modifiers
        });
        dispose();
      };
    }

    function attr_dev(node, attribute, value) {
      attr(node, attribute, value);
      if (value == null) dispatch_dev("SvelteDOMRemoveAttribute", {
        node,
        attribute
      });else dispatch_dev("SvelteDOMSetAttribute", {
        node,
        attribute,
        value
      });
    }

    function prop_dev(node, property, value) {
      node[property] = value;
      dispatch_dev("SvelteDOMSetProperty", {
        node,
        property,
        value
      });
    }

    function set_data_dev(text, data) {
      data = '' + data;
      if (text.wholeText === data) return;
      dispatch_dev("SvelteDOMSetData", {
        node: text,
        data
      });
      text.data = data;
    }

    function validate_each_argument(arg) {
      if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg)) {
        let msg = '{#each} only iterates over array-like objects.';

        if (typeof Symbol === 'function' && arg && Symbol.iterator in arg) {
          msg += ' You can use a spread to convert this iterable into an array.';
        }

        throw new Error(msg);
      }
    }

    function validate_slots(name, slot, keys) {
      for (const slot_key of Object.keys(slot)) {
        if (!~keys.indexOf(slot_key)) {
          console.warn(`<${name}> received an unexpected slot "${slot_key}".`);
        }
      }
    }

    class SvelteComponentDev extends SvelteComponent {
      constructor(options) {
        if (!options || !options.target && !options.$$inline) {
          throw new Error(`'target' is a required option`);
        }

        super();
      }

      $destroy() {
        super.$destroy();

        this.$destroy = () => {
          console.warn(`Component was already destroyed`); // eslint-disable-line no-console
        };
      }

      $capture_state() {}

      $inject_state() {}

    }

    function cubicInOut(t) {
      return t < 0.5 ? 4.0 * t * t * t : 0.5 * Math.pow(2.0 * t - 2.0, 3.0) + 1.0;
    }

    function cubicOut(t) {
      const f = t - 1.0;
      return f * f * f + 1.0;
    }

    function quintOut(t) {
      return --t * t * t * t * t + 1;
    }

    function blur(node, {
      delay = 0,
      duration = 400,
      easing = cubicInOut,
      amount = 5,
      opacity = 0
    }) {
      const style = getComputedStyle(node);
      const target_opacity = +style.opacity;
      const f = style.filter === 'none' ? '' : style.filter;
      const od = target_opacity * (1 - opacity);
      return {
        delay,
        duration,
        easing,
        css: (_t, u) => `opacity: ${target_opacity - od * u}; filter: ${f} blur(${u * amount}px);`
      };
    }

    function fade(node, {
      delay = 0,
      duration = 400,
      easing = identity
    }) {
      const o = +getComputedStyle(node).opacity;
      return {
        delay,
        duration,
        easing,
        css: t => `opacity: ${t * o}`
      };
    }

    function fly(node, {
      delay = 0,
      duration = 400,
      easing = cubicOut,
      x = 0,
      y = 0,
      opacity = 0
    }) {
      const style = getComputedStyle(node);
      const target_opacity = +style.opacity;
      const transform = style.transform === 'none' ? '' : style.transform;
      const od = target_opacity * (1 - opacity);
      return {
        delay,
        duration,
        easing,
        css: (t, u) => `
			transform: ${transform} translate(${(1 - t) * x}px, ${(1 - t) * y}px);
			opacity: ${target_opacity - od * u}`
      };
    }

    function slide(node, {
      delay = 0,
      duration = 400,
      easing = cubicOut
    }) {
      const style = getComputedStyle(node);
      const opacity = +style.opacity;
      const height = parseFloat(style.height);
      const padding_top = parseFloat(style.paddingTop);
      const padding_bottom = parseFloat(style.paddingBottom);
      const margin_top = parseFloat(style.marginTop);
      const margin_bottom = parseFloat(style.marginBottom);
      const border_top_width = parseFloat(style.borderTopWidth);
      const border_bottom_width = parseFloat(style.borderBottomWidth);
      return {
        delay,
        duration,
        easing,
        css: t => `overflow: hidden;` + `opacity: ${Math.min(t * 20, 1) * opacity};` + `height: ${t * height}px;` + `padding-top: ${t * padding_top}px;` + `padding-bottom: ${t * padding_bottom}px;` + `margin-top: ${t * margin_top}px;` + `margin-bottom: ${t * margin_bottom}px;` + `border-top-width: ${t * border_top_width}px;` + `border-bottom-width: ${t * border_bottom_width}px;`
      };
    }

    function scale(node, {
      delay = 0,
      duration = 400,
      easing = cubicOut,
      start = 0,
      opacity = 0
    }) {
      const style = getComputedStyle(node);
      const target_opacity = +style.opacity;
      const transform = style.transform === 'none' ? '' : style.transform;
      const sd = 1 - start;
      const od = target_opacity * (1 - opacity);
      return {
        delay,
        duration,
        easing,
        css: (_t, u) => `
			transform: ${transform} scale(${1 - sd * u});
			opacity: ${target_opacity - od * u}
		`
      };
    }

    function oe(n) {
      return l => {
        const o = Object.keys(n.$$.callbacks),
              i = [];
        return o.forEach(o => i.push(listen(l, o, e => bubble(n, e)))), {
          destroy: () => {
            i.forEach(e => e());
          }
        };
      };
    }

    function ie() {
      return "undefined" != typeof window && !(window.CSS && window.CSS.supports && window.CSS.supports("(--foo: red)"));
    }

    function se(e) {
      var t;
      return "r" === e.charAt(0) ? e = (t = (t = e).match(/^rgba?[\s+]?\([\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?,[\s+]?(\d+)[\s+]?/i)) && 4 === t.length ? "#" + ("0" + parseInt(t[1], 10).toString(16)).slice(-2) + ("0" + parseInt(t[2], 10).toString(16)).slice(-2) + ("0" + parseInt(t[3], 10).toString(16)).slice(-2) : "" : "transparent" === e.toLowerCase() && (e = "#00000000"), e;
    }

    const {
      document: re
    } = globals;

    function ae(e) {
      let t;
      return {
        c() {
          t = element("div"), attr(t, "class", "ripple svelte-po4fcb");
        },

        m(n, l) {
          insert(n, t, l), e[5](t);
        },

        p: noop,
        i: noop,
        o: noop,

        d(n) {
          n && detach(t), e[5](null);
        }

      };
    }

    function ce(e, t) {
      e.style.transform = t, e.style.webkitTransform = t;
    }

    function de(e, t) {
      e.style.opacity = t.toString();
    }

    const ue = function (e, t) {
      const n = ["touchcancel", "mouseleave", "dragstart"];
      let l = t.currentTarget || t.target;
      if (l && !l.classList.contains("ripple") && (l = l.querySelector(".ripple")), !l) return;
      const o = l.dataset.event;
      if (o && o !== e) return;
      l.dataset.event = e;

      const i = document.createElement("span"),
            {
        radius: s,
        scale: r,
        x: a,
        y: c,
        centerX: d,
        centerY: u
      } = ((e, t) => {
        const n = t.getBoundingClientRect(),
              l = function (e) {
          return "TouchEvent" === e.constructor.name;
        }(e) ? e.touches[e.touches.length - 1] : e,
              o = l.clientX - n.left,
              i = l.clientY - n.top;
        let s = 0,
            r = .3;
        const a = t.dataset.center;
        t.dataset.circle ? (r = .15, s = t.clientWidth / 2, s = a ? s : s + Math.sqrt((o - s) ** 2 + (i - s) ** 2) / 4) : s = Math.sqrt(t.clientWidth ** 2 + t.clientHeight ** 2) / 2;
        const c = (t.clientWidth - 2 * s) / 2 + "px",
              d = (t.clientHeight - 2 * s) / 2 + "px";
        return {
          radius: s,
          scale: r,
          x: a ? c : o - s + "px",
          y: a ? d : i - s + "px",
          centerX: c,
          centerY: d
        };
      })(t, l),
            p = l.dataset.color,
            f = 2 * s + "px";

      i.className = "animation", i.style.width = f, i.style.height = f, i.style.background = p, i.classList.add("animation--enter"), i.classList.add("animation--visible"), ce(i, `translate(${a}, ${c}) scale3d(${r},${r},${r})`), de(i, 0), i.dataset.activated = String(performance.now()), l.appendChild(i), setTimeout(() => {
        i.classList.remove("animation--enter"), i.classList.add("animation--in"), ce(i, `translate(${d}, ${u}) scale3d(1,1,1)`), de(i, .25);
      }, 0);

      const v = "mousedown" === e ? "mouseup" : "touchend",
            h = function () {
        document.removeEventListener(v, h), n.forEach(e => {
          document.removeEventListener(e, h);
        });
        const e = performance.now() - Number(i.dataset.activated),
              t = Math.max(250 - e, 0);
        setTimeout(() => {
          i.classList.remove("animation--in"), i.classList.add("animation--out"), de(i, 0), setTimeout(() => {
            i && l.removeChild(i), 0 === l.children.length && delete l.dataset.event;
          }, 300);
        }, t);
      };

      document.addEventListener(v, h), n.forEach(e => {
        document.addEventListener(e, h, {
          passive: !0
        });
      });
    },
          pe = function (e) {
      0 === e.button && ue(e.type, e);
    },
          fe = function (e) {
      if (e.changedTouches) for (let t = 0; t < e.changedTouches.length; ++t) ue(e.type, e.changedTouches[t]);
    };

    function ve(e, t, n) {
      let l,
          o,
          {
        center: i = !1
      } = t,
          {
        circle: s = !1
      } = t,
          {
        color: r = "currentColor"
      } = t;
      return onMount(async () => {
        await tick();

        try {
          i && n(0, l.dataset.center = "true", l), s && n(0, l.dataset.circle = "true", l), n(0, l.dataset.color = r, l), o = l.parentElement;
        } catch (e) {}

        if (!o) return void console.error("Ripple: Trigger element not found.");
        let e = window.getComputedStyle(o);
        0 !== e.position.length && "static" !== e.position || (o.style.position = "relative"), o.addEventListener("touchstart", fe, {
          passive: !0
        }), o.addEventListener("mousedown", pe, {
          passive: !0
        });
      }), onDestroy(() => {
        o && (o.removeEventListener("mousedown", pe), o.removeEventListener("touchstart", fe));
      }), e.$set = e => {
        "center" in e && n(1, i = e.center), "circle" in e && n(2, s = e.circle), "color" in e && n(3, r = e.color);
      }, [l, i, s, r, o, function (e) {
        binding_callbacks[e ? "unshift" : "push"](() => {
          n(0, l = e);
        });
      }];
    }

    class he extends SvelteComponent {
      constructor(e) {
        var t;
        super(), re.getElementById("svelte-po4fcb-style") || ((t = element("style")).id = "svelte-po4fcb-style", t.textContent = ".ripple.svelte-po4fcb{display:block;position:absolute;top:0;left:0;right:0;bottom:0;overflow:hidden;border-radius:inherit;color:inherit;pointer-events:none;z-index:0;contain:strict}.ripple.svelte-po4fcb .animation{color:inherit;position:absolute;top:0;left:0;border-radius:50%;opacity:0;pointer-events:none;overflow:hidden;will-change:transform, opacity}.ripple.svelte-po4fcb .animation--enter{transition:none}.ripple.svelte-po4fcb .animation--in{transition:opacity 0.1s cubic-bezier(0.4, 0, 0.2, 1);transition:transform 0.25s cubic-bezier(0.4, 0, 0.2, 1),\n\t\t\topacity 0.1s cubic-bezier(0.4, 0, 0.2, 1)}.ripple.svelte-po4fcb .animation--out{transition:opacity 0.3s cubic-bezier(0.4, 0, 0.2, 1)}", append(re.head, t)), init(this, e, ve, ae, safe_not_equal, {
          center: 1,
          circle: 2,
          color: 3
        });
      }

    }

    function ge(e) {
      let t;
      const n = new he({
        props: {
          center: e[3],
          circle: e[3]
        }
      });
      return {
        c() {
          create_component(n.$$.fragment);
        },

        m(e, l) {
          mount_component(n, e, l), t = !0;
        },

        p(e, t) {
          const l = {};
          8 & t && (l.center = e[3]), 8 & t && (l.circle = e[3]), n.$set(l);
        },

        i(e) {
          t || (transition_in(n.$$.fragment, e), t = !0);
        },

        o(e) {
          transition_out(n.$$.fragment, e), t = !1;
        },

        d(e) {
          destroy_component(n, e);
        }

      };
    }

    function me(t) {
      let n, l, o, i, a, d;
      const p = t[22].default,
            v = create_slot(p, t, t[21], null);
      let h = t[10] && ge(t),
          b = [{
        class: t[1]
      }, {
        style: t[2]
      }, t[14]],
          E = {};

      for (let e = 0; e < b.length; e += 1) E = assign(E, b[e]);

      return {
        c() {
          n = element("button"), v && v.c(), l = space(), h && h.c(), set_attributes(n, E), toggle_class(n, "raised", t[6]), toggle_class(n, "outlined", t[8] && !(t[6] || t[7])), toggle_class(n, "shaped", t[9] && !t[3]), toggle_class(n, "dense", t[5]), toggle_class(n, "fab", t[4] && t[3]), toggle_class(n, "icon-button", t[3]), toggle_class(n, "toggle", t[11]), toggle_class(n, "active", t[11] && t[0]), toggle_class(n, "full-width", t[12] && !t[3]), toggle_class(n, "svelte-6bcb3a", !0);
        },

        m(s, u) {
          insert(s, n, u), v && v.m(n, null), append(n, l), h && h.m(n, null), t[23](n), i = !0, a || (d = [listen(n, "click", t[16]), action_destroyer(o = t[15].call(null, n))], a = !0);
        },

        p(e, [t]) {
          v && v.p && 2097152 & t && update_slot(v, p, e, e[21], t, null, null), e[10] ? h ? (h.p(e, t), 1024 & t && transition_in(h, 1)) : (h = ge(e), h.c(), transition_in(h, 1), h.m(n, null)) : h && (group_outros(), transition_out(h, 1, 1, () => {
            h = null;
          }), check_outros()), set_attributes(n, E = get_spread_update(b, [2 & t && {
            class: e[1]
          }, 4 & t && {
            style: e[2]
          }, 16384 & t && e[14]])), toggle_class(n, "raised", e[6]), toggle_class(n, "outlined", e[8] && !(e[6] || e[7])), toggle_class(n, "shaped", e[9] && !e[3]), toggle_class(n, "dense", e[5]), toggle_class(n, "fab", e[4] && e[3]), toggle_class(n, "icon-button", e[3]), toggle_class(n, "toggle", e[11]), toggle_class(n, "active", e[11] && e[0]), toggle_class(n, "full-width", e[12] && !e[3]), toggle_class(n, "svelte-6bcb3a", !0);
        },

        i(e) {
          i || (transition_in(v, e), transition_in(h), i = !0);
        },

        o(e) {
          transition_out(v, e), transition_out(h), i = !1;
        },

        d(e) {
          e && detach(n), v && v.d(e), h && h.d(), t[23](null), a = !1, run_all(d);
        }

      };
    }

    function be(e, t, n) {
      const l = createEventDispatcher(),
            o = oe(current_component);
      let i,
          {
        class: s = ""
      } = t,
          {
        style: r = null
      } = t,
          {
        icon: a = !1
      } = t,
          {
        fab: c = !1
      } = t,
          {
        dense: d = !1
      } = t,
          {
        raised: u = !1
      } = t,
          {
        unelevated: f = !1
      } = t,
          {
        outlined: v = !1
      } = t,
          {
        shaped: h = !1
      } = t,
          {
        color: g = null
      } = t,
          {
        ripple: m = !0
      } = t,
          {
        toggle: b = !1
      } = t,
          {
        active: x = !1
      } = t,
          {
        fullWidth: w = !1
      } = t,
          $ = {};
      beforeUpdate(() => {
        if (!i) return;
        let e = i.getElementsByTagName("svg"),
            t = e.length;

        for (let n = 0; n < t; n++) e[n].setAttribute("width", z + (b && !a ? 2 : 0)), e[n].setAttribute("height", z + (b && !a ? 2 : 0));

        n(13, i.style.backgroundColor = u || f ? g : "transparent", i);
        let l = getComputedStyle(i).getPropertyValue("background-color");
        n(13, i.style.color = u || f ? function (e = "#ffffff") {
          let t, n, l, o, i, s;
          if (0 === e.length && (e = "#ffffff"), e = se(e), e = String(e).replace(/[^0-9a-f]/gi, ""), !new RegExp(/^(?:[0-9a-f]{3}){1,2}$/i).test(e)) throw new Error("Invalid HEX color!");
          e.length < 6 && (e = e[0] + e[0] + e[1] + e[1] + e[2] + e[2]);
          const r = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(e);
          return t = parseInt(r[1], 16) / 255, n = parseInt(r[2], 16) / 255, l = parseInt(r[3], 16) / 255, o = t <= .03928 ? t / 12.92 : Math.pow((t + .055) / 1.055, 2.4), i = n <= .03928 ? n / 12.92 : Math.pow((n + .055) / 1.055, 2.4), s = l <= .03928 ? l / 12.92 : Math.pow((l + .055) / 1.055, 2.4), .2126 * o + .7152 * i + .0722 * s;
        }(l) > .5 ? "#000" : "#fff" : g, i);
      });
      let z,
          {
        $$slots: k = {},
        $$scope: D
      } = t;
      return e.$set = e => {
        n(20, t = assign(assign({}, t), exclude_internal_props(e))), "class" in e && n(1, s = e.class), "style" in e && n(2, r = e.style), "icon" in e && n(3, a = e.icon), "fab" in e && n(4, c = e.fab), "dense" in e && n(5, d = e.dense), "raised" in e && n(6, u = e.raised), "unelevated" in e && n(7, f = e.unelevated), "outlined" in e && n(8, v = e.outlined), "shaped" in e && n(9, h = e.shaped), "color" in e && n(17, g = e.color), "ripple" in e && n(10, m = e.ripple), "toggle" in e && n(11, b = e.toggle), "active" in e && n(0, x = e.active), "fullWidth" in e && n(12, w = e.fullWidth), "$$scope" in e && n(21, D = e.$$scope);
      }, e.$$.update = () => {
        {
          const {
            style: e,
            icon: l,
            fab: o,
            dense: i,
            raised: s,
            unelevated: r,
            outlined: a,
            shaped: c,
            color: d,
            ripple: u,
            toggle: p,
            active: f,
            fullWidth: v,
            ...h
          } = t;
          !h.disabled && delete h.disabled, delete h.class, n(14, $ = h);
        }
        56 & e.$$.dirty && (z = a ? c ? 24 : d ? 20 : 24 : d ? 16 : 18), 139264 & e.$$.dirty && ("primary" === g ? n(17, g = ie() ? "#1976d2" : "var(--primary, #1976d2)") : "accent" == g ? n(17, g = ie() ? "#f50057" : "var(--accent, #f50057)") : !g && i && n(17, g = i.style.color || i.parentElement.style.color || (ie() ? "#333" : "var(--color, #333)")));
      }, t = exclude_internal_props(t), [x, s, r, a, c, d, u, f, v, h, m, b, w, i, $, o, function (e) {
        b && (n(0, x = !x), l("change", x));
      }, g, z, l, t, D, k, function (e) {
        binding_callbacks[e ? "unshift" : "push"](() => {
          n(13, i = e);
        });
      }];
    }

    class ye extends SvelteComponent {
      constructor(e) {
        var t;
        super(), document.getElementById("svelte-6bcb3a-style") || ((t = element("style")).id = "svelte-6bcb3a-style", t.textContent = "button.svelte-6bcb3a:disabled{cursor:default}button.svelte-6bcb3a{cursor:pointer;font-family:Roboto, Helvetica, sans-serif;font-family:var(--button-font-family, Roboto, Helvetica, sans-serif);font-size:0.875rem;font-weight:500;letter-spacing:0.75px;text-decoration:none;text-transform:uppercase;will-change:transform, opacity;margin:0;padding:0 16px;display:-ms-inline-flexbox;display:inline-flex;position:relative;align-items:center;justify-content:center;box-sizing:border-box;height:36px;border:none;outline:none;line-height:inherit;user-select:none;overflow:hidden;vertical-align:middle;border-radius:4px}button.svelte-6bcb3a::-moz-focus-inner{border:0}button.svelte-6bcb3a:-moz-focusring{outline:none}button.svelte-6bcb3a:before{box-sizing:inherit;border-radius:inherit;color:inherit;bottom:0;content:'';left:0;opacity:0;pointer-events:none;position:absolute;right:0;top:0;transition:0.2s cubic-bezier(0.25, 0.8, 0.5, 1);will-change:background-color, opacity}.toggle.svelte-6bcb3a:before{box-sizing:content-box}.active.svelte-6bcb3a:before{background-color:currentColor;opacity:0.3}.raised.svelte-6bcb3a{box-shadow:0 3px 1px -2px rgba(0, 0, 0, 0.2), 0 2px 2px 0 rgba(0, 0, 0, 0.14),\n\t\t\t0 1px 5px 0 rgba(0, 0, 0, 0.12)}.outlined.svelte-6bcb3a{padding:0 14px;border-style:solid;border-width:2px}.shaped.svelte-6bcb3a{border-radius:18px}.dense.svelte-6bcb3a{height:32px}.icon-button.svelte-6bcb3a{line-height:0.5;border-radius:50%;padding:8px;width:40px;height:40px;vertical-align:middle}.icon-button.outlined.svelte-6bcb3a{padding:6px}.icon-button.fab.svelte-6bcb3a{border:none;width:56px;height:56px;box-shadow:0 3px 5px -1px rgba(0, 0, 0, 0.2), 0 6px 10px 0 rgba(0, 0, 0, 0.14),\n\t\t\t0 1px 18px 0 rgba(0, 0, 0, 0.12)}.icon-button.dense.svelte-6bcb3a{width:36px;height:36px}.icon-button.fab.dense.svelte-6bcb3a{width:40px;height:40px}.outlined.svelte-6bcb3a:not(.shaped) .ripple{border-radius:0 !important}.full-width.svelte-6bcb3a{width:100%}@media(hover: hover){button.svelte-6bcb3a:hover:not(.toggle):not([disabled]):not(.disabled):before{background-color:currentColor;opacity:0.15}button.focus-visible.svelte-6bcb3a:focus:not(.toggle):not([disabled]):not(.disabled):before{background-color:currentColor;opacity:0.3}button.focus-visible.toggle.svelte-6bcb3a:focus:not(.active):not([disabled]):not(.disabled):before{background-color:currentColor;opacity:0.15}}", append(document.head, t)), init(this, e, be, me, safe_not_equal, {
          class: 1,
          style: 2,
          icon: 3,
          fab: 4,
          dense: 5,
          raised: 6,
          unelevated: 7,
          outlined: 8,
          shaped: 9,
          color: 17,
          ripple: 10,
          toggle: 11,
          active: 0,
          fullWidth: 12
        });
      }

    }

    function xe(e) {
      let t, n, l;
      const o = e[3].default,
            i = create_slot(o, e, e[2], null);
      return {
        c() {
          t = element("div"), i && i.c(), attr(t, "class", "button-group svelte-x6hf3e"), attr(t, "style", n = e[0] ? `color: ${e[0]};` : "" + e[1]);
        },

        m(e, n) {
          insert(e, t, n), i && i.m(t, null), l = !0;
        },

        p(e, [s]) {
          i && i.p && 4 & s && update_slot(i, o, e, e[2], s, null, null), (!l || 3 & s && n !== (n = e[0] ? `color: ${e[0]};` : "" + e[1])) && attr(t, "style", n);
        },

        i(e) {
          l || (transition_in(i, e), l = !0);
        },

        o(e) {
          transition_out(i, e), l = !1;
        },

        d(e) {
          e && detach(t), i && i.d(e);
        }

      };
    }

    function we(e, t, n) {
      let {
        color: l = ""
      } = t,
          {
        style: o = ""
      } = t,
          {
        $$slots: i = {},
        $$scope: s
      } = t;
      return e.$set = e => {
        "color" in e && n(0, l = e.color), "style" in e && n(1, o = e.style), "$$scope" in e && n(2, s = e.$$scope);
      }, e.$$.update = () => {
        1 & e.$$.dirty && ("primary" === l ? n(0, l = ie() ? "#1976d2" : "var(--primary, #1976d2)") : "accent" == l && n(0, l = ie() ? "#f50057" : "var(--accent, #f50057)"));
      }, [l, o, s, i];
    }

    class $e extends SvelteComponent {
      constructor(e) {
        var t;
        super(), document.getElementById("svelte-x6hf3e-style") || ((t = element("style")).id = "svelte-x6hf3e-style", t.textContent = ".button-group.svelte-x6hf3e{display:inline-flex;flex-wrap:wrap}.button-group.svelte-x6hf3e button{padding:0 8px}.button-group.svelte-x6hf3e button:first-child{border-top-right-radius:0;border-bottom-right-radius:0}.button-group.svelte-x6hf3e button:last-child{border-top-left-radius:0;border-bottom-left-radius:0}.button-group.svelte-x6hf3e .shaped:first-child{padding-left:12px}.button-group.svelte-x6hf3e .shaped:last-child{padding-right:12px}.button-group.svelte-x6hf3e button:not(:first-child):not(:last-child){border-radius:0}.button-group.svelte-x6hf3e button:not(:first-child){border-left:none}.button-group.svelte-x6hf3e .outlined{border-width:1px}", append(document.head, t)), init(this, e, we, xe, safe_not_equal, {
          color: 0,
          style: 1
        });
      }

    }

    function ze(e) {
      let t;
      const n = e[13].default,
            l = create_slot(n, e, e[12], null);
      return {
        c() {
          l && l.c();
        },

        m(e, n) {
          l && l.m(e, n), t = !0;
        },

        p(e, t) {
          l && l.p && 4096 & t && update_slot(l, n, e, e[12], t, null, null);
        },

        i(e) {
          t || (transition_in(l, e), t = !0);
        },

        o(e) {
          transition_out(l, e), t = !1;
        },

        d(e) {
          l && l.d(e);
        }

      };
    }

    function ke(e) {
      let t, n;
      return {
        c() {
          t = svg_element("svg"), n = svg_element("path"), attr(n, "d", e[1]), attr(t, "xmlns", "http://www.w3.org/2000/svg"), attr(t, "viewBox", e[2]), attr(t, "class", "svelte-h2unzw");
        },

        m(e, l) {
          insert(e, t, l), append(t, n);
        },

        p(e, l) {
          2 & l && attr(n, "d", e[1]), 4 & l && attr(t, "viewBox", e[2]);
        },

        i: noop,
        o: noop,

        d(e) {
          e && detach(t);
        }

      };
    }

    function De(e) {
      let t, n, l, o, i, r, a;
      const d = [ke, ze],
            p = [];

      function f(e, t) {
        return "string" == typeof e[1] ? 0 : 1;
      }

      n = f(e), l = p[n] = d[n](e);
      let v = [{
        class: "icon " + e[0]
      }, e[7]],
          h = {};

      for (let e = 0; e < v.length; e += 1) h = assign(h, v[e]);

      return {
        c() {
          t = element("i"), l.c(), set_attributes(t, h), toggle_class(t, "flip", e[3] && "boolean" == typeof e[3]), toggle_class(t, "flip-h", "h" === e[3]), toggle_class(t, "flip-v", "v" === e[3]), toggle_class(t, "spin", e[4]), toggle_class(t, "pulse", e[5] && !e[4]), toggle_class(t, "svelte-h2unzw", !0);
        },

        m(l, s) {
          insert(l, t, s), p[n].m(t, null), e[14](t), i = !0, r || (a = action_destroyer(o = e[8].call(null, t)), r = !0);
        },

        p(e, [o]) {
          let i = n;
          n = f(e), n === i ? p[n].p(e, o) : (group_outros(), transition_out(p[i], 1, 1, () => {
            p[i] = null;
          }), check_outros(), l = p[n], l || (l = p[n] = d[n](e), l.c()), transition_in(l, 1), l.m(t, null)), set_attributes(t, h = get_spread_update(v, [1 & o && {
            class: "icon " + e[0]
          }, 128 & o && e[7]])), toggle_class(t, "flip", e[3] && "boolean" == typeof e[3]), toggle_class(t, "flip-h", "h" === e[3]), toggle_class(t, "flip-v", "v" === e[3]), toggle_class(t, "spin", e[4]), toggle_class(t, "pulse", e[5] && !e[4]), toggle_class(t, "svelte-h2unzw", !0);
        },

        i(e) {
          i || (transition_in(l), i = !0);
        },

        o(e) {
          transition_out(l), i = !1;
        },

        d(l) {
          l && detach(t), p[n].d(), e[14](null), r = !1, a();
        }

      };
    }

    function Ce(e, t, n) {
      const l = oe(current_component);
      let o,
          {
        class: i = ""
      } = t,
          {
        path: s = null
      } = t,
          {
        size: r = 24
      } = t,
          {
        viewBox: a = "0 0 24 24"
      } = t,
          {
        color: c = "currentColor"
      } = t,
          {
        flip: d = !1
      } = t,
          {
        spin: u = !1
      } = t,
          {
        pulse: f = !1
      } = t,
          v = {},
          {
        $$slots: h = {},
        $$scope: g
      } = t;
      return e.$set = e => {
        n(11, t = assign(assign({}, t), exclude_internal_props(e))), "class" in e && n(0, i = e.class), "path" in e && n(1, s = e.path), "size" in e && n(9, r = e.size), "viewBox" in e && n(2, a = e.viewBox), "color" in e && n(10, c = e.color), "flip" in e && n(3, d = e.flip), "spin" in e && n(4, u = e.spin), "pulse" in e && n(5, f = e.pulse), "$$scope" in e && n(12, g = e.$$scope);
      }, e.$$.update = () => {
        {
          const {
            path: e,
            size: l,
            viewBox: o,
            color: i,
            flip: s,
            spin: r,
            pulse: a,
            ...c
          } = t;
          delete c.class, n(7, v = c);
        }
        1600 & e.$$.dirty && o && (o.firstChild.setAttribute("width", r), o.firstChild.setAttribute("height", r), c && o.firstChild.setAttribute("fill", c));
      }, t = exclude_internal_props(t), [i, s, a, d, u, f, o, v, l, r, c, t, g, h, function (e) {
        binding_callbacks[e ? "unshift" : "push"](() => {
          n(6, o = e);
        });
      }];
    }

    class Me extends SvelteComponent {
      constructor(e) {
        var t;
        super(), document.getElementById("svelte-h2unzw-style") || ((t = element("style")).id = "svelte-h2unzw-style", t.textContent = ".icon.svelte-h2unzw.svelte-h2unzw{display:inline-block;position:relative;vertical-align:middle;line-height:0.5}.icon.svelte-h2unzw>svg.svelte-h2unzw{display:inline-block}.flip.svelte-h2unzw.svelte-h2unzw{transform:scale(-1, -1)}.flip-h.svelte-h2unzw.svelte-h2unzw{transform:scale(-1, 1)}.flip-v.svelte-h2unzw.svelte-h2unzw{transform:scale(1, -1)}.spin.svelte-h2unzw.svelte-h2unzw{animation:svelte-h2unzw-spin 1s 0s infinite linear}.pulse.svelte-h2unzw.svelte-h2unzw{animation:svelte-h2unzw-spin 1s infinite steps(8)}@keyframes svelte-h2unzw-spin{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}", append(document.head, t)), init(this, e, Ce, De, safe_not_equal, {
          class: 0,
          path: 1,
          size: 9,
          viewBox: 2,
          color: 10,
          flip: 3,
          spin: 4,
          pulse: 5
        });
      }

    }

    function Le(e) {
      let t;
      const n = new he({
        props: {
          center: !0,
          circle: !0
        }
      });
      return {
        c() {
          create_component(n.$$.fragment);
        },

        m(e, l) {
          mount_component(n, e, l), t = !0;
        },

        i(e) {
          t || (transition_in(n.$$.fragment, e), t = !0);
        },

        o(e) {
          transition_out(n.$$.fragment, e), t = !1;
        },

        d(e) {
          destroy_component(n, e);
        }

      };
    }

    function Ee(t) {
      let n,
          l,
          o,
          i,
          d,
          p,
          E,
          Y,
          j,
          N,
          B,
          I,
          F,
          S = [{
        type: "checkbox"
      }, {
        __value: t[9]
      }, t[10]],
          q = {};

      for (let e = 0; e < S.length; e += 1) q = assign(q, S[e]);

      const _ = new Me({
        props: {
          path: t[2] ? Ae : t[0] ? Ye : je
        }
      });

      let H = t[7] && Le();
      const O = t[17].default,
            P = create_slot(O, t, t[16], null);
      return {
        c() {
          n = element("label"), l = element("input"), i = space(), d = element("div"), create_component(_.$$.fragment), p = space(), H && H.c(), Y = space(), j = element("div"), P && P.c(), set_attributes(l, q), void 0 !== t[0] && void 0 !== t[2] || add_render_callback(() => t[18].call(l)), toggle_class(l, "svelte-1idh7xl", !0), attr(d, "class", "mark svelte-1idh7xl"), attr(d, "style", E = "color: " + (t[2] || t[0] ? t[1] : "#9a9a9a")), attr(j, "class", "label-text svelte-1idh7xl"), attr(n, "class", N = null_to_empty(t[3]) + " svelte-1idh7xl"), attr(n, "style", t[4]), attr(n, "title", t[8]), toggle_class(n, "right", t[6]), toggle_class(n, "disabled", t[5]);
        },

        m(s, a) {
          insert(s, n, a), append(n, l), l.checked = t[0], l.indeterminate = t[2], append(n, i), append(n, d), mount_component(_, d, null), append(d, p), H && H.m(d, null), append(n, Y), append(n, j), P && P.m(j, null), B = !0, I || (F = [listen(l, "change", t[18]), listen(l, "change", t[12]), action_destroyer(o = t[11].call(null, l))], I = !0);
        },

        p(e, [t]) {
          set_attributes(l, q = get_spread_update(S, [{
            type: "checkbox"
          }, 512 & t && {
            __value: e[9]
          }, 1024 & t && e[10]])), 1 & t && (l.checked = e[0]), 4 & t && (l.indeterminate = e[2]), toggle_class(l, "svelte-1idh7xl", !0);
          const o = {};
          5 & t && (o.path = e[2] ? Ae : e[0] ? Ye : je), _.$set(o), e[7] ? H ? 128 & t && transition_in(H, 1) : (H = Le(), H.c(), transition_in(H, 1), H.m(d, null)) : H && (group_outros(), transition_out(H, 1, 1, () => {
            H = null;
          }), check_outros()), (!B || 7 & t && E !== (E = "color: " + (e[2] || e[0] ? e[1] : "#9a9a9a"))) && attr(d, "style", E), P && P.p && 65536 & t && update_slot(P, O, e, e[16], t, null, null), (!B || 8 & t && N !== (N = null_to_empty(e[3]) + " svelte-1idh7xl")) && attr(n, "class", N), (!B || 16 & t) && attr(n, "style", e[4]), (!B || 256 & t) && attr(n, "title", e[8]), 72 & t && toggle_class(n, "right", e[6]), 40 & t && toggle_class(n, "disabled", e[5]);
        },

        i(e) {
          B || (transition_in(_.$$.fragment, e), transition_in(H), transition_in(P, e), B = !0);
        },

        o(e) {
          transition_out(_.$$.fragment, e), transition_out(H), transition_out(P, e), B = !1;
        },

        d(e) {
          e && detach(n), destroy_component(_), H && H.d(), P && P.d(e), I = !1, run_all(F);
        }

      };
    }

    let Ye = "M19 3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.11 0 2-.9 2-2V5c0-1.1-.89-2-2-2zm-9 14l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z",
        je = "M19 5v14H5V5h14m0-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2z",
        Ae = "M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-2 10H7v-2h10v2z";

    function Te(e, t, n) {
      const l = oe(current_component);
      let {
        checked: o = !1
      } = t,
          {
        class: i = ""
      } = t,
          {
        style: s = null
      } = t,
          {
        color: r = "primary"
      } = t,
          {
        disabled: a = !1
      } = t,
          {
        group: c = null
      } = t,
          {
        indeterminate: d = !1
      } = t,
          {
        right: u = !1
      } = t,
          {
        ripple: p = !0
      } = t,
          {
        title: f = null
      } = t,
          {
        value: v = "on"
      } = t,
          h = {};

      function g() {
        setTimeout(() => {
          n(0, o = c.indexOf(v) >= 0);
        }, 0);
      }

      let {
        $$slots: m = {},
        $$scope: b
      } = t;
      return e.$set = e => {
        n(15, t = assign(assign({}, t), exclude_internal_props(e))), "checked" in e && n(0, o = e.checked), "class" in e && n(3, i = e.class), "style" in e && n(4, s = e.style), "color" in e && n(1, r = e.color), "disabled" in e && n(5, a = e.disabled), "group" in e && n(13, c = e.group), "indeterminate" in e && n(2, d = e.indeterminate), "right" in e && n(6, u = e.right), "ripple" in e && n(7, p = e.ripple), "title" in e && n(8, f = e.title), "value" in e && n(9, v = e.value), "$$scope" in e && n(16, b = e.$$scope);
      }, e.$$.update = () => {
        {
          const {
            checked: e,
            style: l,
            color: o,
            group: i,
            indeterminate: s,
            right: r,
            ripple: a,
            title: c,
            value: d,
            ...u
          } = t;
          !u.disabled && delete u.disabled, delete u.class, n(10, h = u);
        }
        8192 & e.$$.dirty && null !== c && g(), 2 & e.$$.dirty && ("primary" !== r && r ? "accent" === r && n(1, r = ie() ? "#f50057" : "var(--accent, #f50057)") : n(1, r = ie() ? "#1976d2" : "var(--primary, #1976d2)"));
      }, t = exclude_internal_props(t), [o, r, d, i, s, a, u, p, f, v, h, l, function () {
        if (null !== c) {
          let e = c.indexOf(v);
          o ? e < 0 && c.push(v) : e >= 0 && c.splice(e, 1), n(13, c);
        }
      }, c, g, t, b, m, function () {
        o = this.checked, d = this.indeterminate, n(0, o), n(2, d);
      }];
    }

    class Ne extends SvelteComponent {
      constructor(e) {
        var t;
        super(), document.getElementById("svelte-1idh7xl-style") || ((t = element("style")).id = "svelte-1idh7xl-style", t.textContent = "label.svelte-1idh7xl.svelte-1idh7xl{width:100%;align-items:center;display:flex;margin:0;position:relative;cursor:pointer;line-height:40px;user-select:none}input.svelte-1idh7xl.svelte-1idh7xl{cursor:inherit;width:100%;height:100%;position:absolute;top:0;left:0;margin:0;padding:0;opacity:0 !important}.mark.svelte-1idh7xl.svelte-1idh7xl{display:flex;position:relative;justify-content:center;align-items:center;border-radius:50%;width:40px;height:40px}.mark.svelte-1idh7xl.svelte-1idh7xl:before{background-color:currentColor;border-radius:inherit;bottom:0;color:inherit;content:'';left:0;opacity:0;pointer-events:none;position:absolute;right:0;top:0;transition:0.3s cubic-bezier(0.25, 0.8, 0.5, 1)}@media not all and (min-resolution: 0.001dpcm){@supports (-webkit-appearance: none) and (stroke-color: transparent){.mark.svelte-1idh7xl.svelte-1idh7xl:before{transition:none}}}.label-text.svelte-1idh7xl.svelte-1idh7xl{margin-left:4px;white-space:nowrap;overflow:hidden}.right.svelte-1idh7xl .label-text.svelte-1idh7xl{margin-left:0;margin-right:auto;order:-1}@media(hover: hover){label.svelte-1idh7xl:hover:not([disabled]):not(.disabled) .mark.svelte-1idh7xl:before{opacity:0.15}.focus-visible:focus:not([disabled]):not(.disabled)~.mark.svelte-1idh7xl.svelte-1idh7xl:before{opacity:0.3}}", append(document.head, t)), init(this, e, Te, Ee, safe_not_equal, {
          checked: 0,
          class: 3,
          style: 4,
          color: 1,
          disabled: 5,
          group: 13,
          indeterminate: 2,
          right: 6,
          ripple: 7,
          title: 8,
          value: 9
        });
      }

    }

    function He(e) {
      let t;
      return {
        c() {
          t = element("span"), t.textContent = "*", attr(t, "class", "required svelte-1dzu4e7");
        },

        m(e, n) {
          insert(e, t, n);
        },

        d(e) {
          e && detach(t);
        }

      };
    }

    function Oe(e) {
      let t, n, l;
      return {
        c() {
          t = element("div"), n = space(), l = element("div"), attr(t, "class", "input-line svelte-1dzu4e7"), attr(l, "class", "focus-line svelte-1dzu4e7");
        },

        m(e, o) {
          insert(e, t, o), insert(e, n, o), insert(e, l, o);
        },

        d(e) {
          e && detach(t), e && detach(n), e && detach(l);
        }

      };
    }

    function Pe(e) {
      let t,
          n,
          l,
          o = (e[11] || e[10]) + "";
      return {
        c() {
          t = element("div"), n = element("div"), l = text(o), attr(n, "class", "message"), attr(t, "class", "help svelte-1dzu4e7"), toggle_class(t, "persist", e[9]), toggle_class(t, "error", e[11]);
        },

        m(e, o) {
          insert(e, t, o), append(t, n), append(n, l);
        },

        p(e, n) {
          3072 & n && o !== (o = (e[11] || e[10]) + "") && set_data(l, o), 512 & n && toggle_class(t, "persist", e[9]), 2048 & n && toggle_class(t, "error", e[11]);
        },

        d(e) {
          e && detach(t);
        }

      };
    }

    function We(t) {
      let n,
          l,
          o,
          i,
          p,
          f,
          v,
          h,
          g,
          m,
          b,
          k,
          D,
          C,
          E = [{
        class: "input"
      }, t[12]],
          Y = {};

      for (let e = 0; e < E.length; e += 1) Y = assign(Y, E[e]);

      let j = t[2] && !t[0].length && He(),
          A = (!t[7] || t[8]) && Oe(),
          F = (!!t[10] || !!t[11]) && Pe(t);
      return {
        c() {
          n = element("div"), l = element("input"), i = space(), p = element("div"), f = space(), v = element("div"), h = text(t[6]), g = space(), j && j.c(), m = space(), A && A.c(), b = space(), F && F.c(), set_attributes(l, Y), toggle_class(l, "svelte-1dzu4e7", !0), attr(p, "class", "focus-ring svelte-1dzu4e7"), attr(v, "class", "label svelte-1dzu4e7"), attr(n, "class", k = null_to_empty(`text-field ${t[7] && !t[8] ? "outlined" : "baseline"} ${t[3]}`) + " svelte-1dzu4e7"), attr(n, "style", t[4]), attr(n, "title", t[5]), toggle_class(n, "filled", t[8]), toggle_class(n, "dirty", t[13]), toggle_class(n, "disabled", t[1]);
        },

        m(s, a) {
          insert(s, n, a), append(n, l), set_input_value(l, t[0]), append(n, i), append(n, p), append(n, f), append(n, v), append(v, h), append(v, g), j && j.m(v, null), append(n, m), A && A.m(n, null), append(n, b), F && F.m(n, null), D || (C = [listen(l, "input", t[19]), action_destroyer(o = t[14].call(null, l))], D = !0);
        },

        p(e, [t]) {
          set_attributes(l, Y = get_spread_update(E, [{
            class: "input"
          }, 4096 & t && e[12]])), 1 & t && l.value !== e[0] && set_input_value(l, e[0]), toggle_class(l, "svelte-1dzu4e7", !0), 64 & t && set_data(h, e[6]), e[2] && !e[0].length ? j || (j = He(), j.c(), j.m(v, null)) : j && (j.d(1), j = null), !e[7] || e[8] ? A || (A = Oe(), A.c(), A.m(n, b)) : A && (A.d(1), A = null), e[10] || e[11] ? F ? F.p(e, t) : (F = Pe(e), F.c(), F.m(n, null)) : F && (F.d(1), F = null), 392 & t && k !== (k = null_to_empty(`text-field ${e[7] && !e[8] ? "outlined" : "baseline"} ${e[3]}`) + " svelte-1dzu4e7") && attr(n, "class", k), 16 & t && attr(n, "style", e[4]), 32 & t && attr(n, "title", e[5]), 392 & t && toggle_class(n, "filled", e[8]), 8584 & t && toggle_class(n, "dirty", e[13]), 394 & t && toggle_class(n, "disabled", e[1]);
        },

        i: noop,
        o: noop,

        d(e) {
          e && detach(n), j && j.d(), A && A.d(), F && F.d(), D = !1, run_all(C);
        }

      };
    }

    function Xe(e, t, n) {
      const l = oe(current_component);
      let o,
          {
        value: i = ""
      } = t,
          {
        disabled: s = !1
      } = t,
          {
        required: r = !1
      } = t,
          {
        class: a = ""
      } = t,
          {
        style: c = null
      } = t,
          {
        title: d = null
      } = t,
          {
        label: u = ""
      } = t,
          {
        outlined: p = !1
      } = t,
          {
        filled: f = !1
      } = t,
          {
        messagePersist: v = !1
      } = t,
          {
        message: h = ""
      } = t,
          {
        error: g = ""
      } = t,
          m = {};
      const b = ["date", "datetime-local", "email", "month", "number", "password", "search", "tel", "text", "time", "url", "week"],
            x = ["date", "datetime-local", "month", "time", "week"];
      let w;
      return e.$set = e => {
        n(18, t = assign(assign({}, t), exclude_internal_props(e))), "value" in e && n(0, i = e.value), "disabled" in e && n(1, s = e.disabled), "required" in e && n(2, r = e.required), "class" in e && n(3, a = e.class), "style" in e && n(4, c = e.style), "title" in e && n(5, d = e.title), "label" in e && n(6, u = e.label), "outlined" in e && n(7, p = e.outlined), "filled" in e && n(8, f = e.filled), "messagePersist" in e && n(9, v = e.messagePersist), "message" in e && n(10, h = e.message), "error" in e && n(11, g = e.error);
      }, e.$$.update = () => {
        {
          const {
            value: e,
            style: l,
            title: i,
            label: s,
            outlined: r,
            filled: a,
            messagePersist: c,
            message: d,
            error: u,
            ...p
          } = t;
          !p.readonly && delete p.readonly, !p.disabled && delete p.disabled, delete p.class, p.type = b.indexOf(p.type) < 0 ? "text" : p.type, n(15, o = p.placeholder), n(12, m = p);
        }
        36865 & e.$$.dirty && n(13, w = "string" == typeof i && i.length > 0 || "number" == typeof i || o || x.indexOf(m.type) >= 0);
      }, t = exclude_internal_props(t), [i, s, r, a, c, d, u, p, f, v, h, g, m, w, l, o, b, x, t, function () {
        i = this.value, n(0, i);
      }];
    }

    class Ve extends SvelteComponent {
      constructor(e) {
        var t;
        super(), document.getElementById("svelte-1dzu4e7-style") || ((t = element("style")).id = "svelte-1dzu4e7-style", t.textContent = ".text-field.svelte-1dzu4e7.svelte-1dzu4e7{font-family:Roboto, 'Segoe UI', sans-serif;font-weight:400;font-size:inherit;text-decoration:inherit;text-transform:inherit;box-sizing:border-box;margin:0 0 20px;position:relative;width:100%;background-color:inherit;will-change:opacity, transform, color}.outlined.svelte-1dzu4e7.svelte-1dzu4e7{margin-top:12px}.required.svelte-1dzu4e7.svelte-1dzu4e7{position:relative;top:0.175em;left:0.125em;color:#ff5252}.input.svelte-1dzu4e7.svelte-1dzu4e7{box-sizing:border-box;font:inherit;width:100%;min-height:32px;background:none;text-align:left;color:#333;color:var(--color, #333);caret-color:#1976d2;caret-color:var(--primary, #1976d2);border:none;margin:0;padding:2px 0 0;outline:none}.input.svelte-1dzu4e7.svelte-1dzu4e7::placeholder{color:rgba(0, 0, 0, 0.3755);color:var(--label, rgba(0, 0, 0, 0.3755));font-weight:100}.input.svelte-1dzu4e7.svelte-1dzu4e7::-moz-focus-inner{padding:0;border:0}.input.svelte-1dzu4e7.svelte-1dzu4e7:-moz-focusring{outline:none}.input.svelte-1dzu4e7.svelte-1dzu4e7:required{box-shadow:none}.input.svelte-1dzu4e7.svelte-1dzu4e7:invalid{box-shadow:none}.input.svelte-1dzu4e7.svelte-1dzu4e7:active{outline:none}.input:hover~.input-line.svelte-1dzu4e7.svelte-1dzu4e7{background:#333;background:var(--color, #333)}.label.svelte-1dzu4e7.svelte-1dzu4e7{font:inherit;display:inline-flex;position:absolute;left:0;top:28px;padding-right:0.2em;color:rgba(0, 0, 0, 0.3755);color:var(--label, rgba(0, 0, 0, 0.3755));background-color:inherit;pointer-events:none;-webkit-backface-visibility:hidden;backface-visibility:hidden;overflow:hidden;max-width:90%;white-space:nowrap;transform-origin:left top;transition:0.18s cubic-bezier(0.25, 0.8, 0.5, 1)}.focus-ring.svelte-1dzu4e7.svelte-1dzu4e7{pointer-events:none;margin:0;padding:0;border:2px solid transparent;border-radius:4px;position:absolute;left:0;top:0;right:0;bottom:0}.input-line.svelte-1dzu4e7.svelte-1dzu4e7{position:absolute;left:0;right:0;bottom:0;margin:0;height:1px;background:rgba(0, 0, 0, 0.3755);background:var(--label, rgba(0, 0, 0, 0.3755))}.focus-line.svelte-1dzu4e7.svelte-1dzu4e7{position:absolute;bottom:0;left:0;right:0;height:2px;-webkit-transform:scaleX(0);transform:scaleX(0);transition:transform 0.18s cubic-bezier(0.4, 0, 0.2, 1),\n\t\t\topacity 0.18s cubic-bezier(0.4, 0, 0.2, 1),\n\t\t\t-webkit-transform 0.18s cubic-bezier(0.4, 0, 0.2, 1);transition:transform 0.18s cubic-bezier(0.4, 0, 0.2, 1),\n\t\t\topacity 0.18s cubic-bezier(0.4, 0, 0.2, 1);opacity:0;z-index:2;background:#1976d2;background:var(--primary, #1976d2)}.help.svelte-1dzu4e7.svelte-1dzu4e7{position:absolute;left:0;right:0;bottom:-18px;display:flex;justify-content:space-between;font-size:12px;line-height:normal;letter-spacing:0.4px;color:rgba(0, 0, 0, 0.3755);color:var(--label, rgba(0, 0, 0, 0.3755));opacity:0;overflow:hidden;max-width:90%;white-space:nowrap}.persist.svelte-1dzu4e7.svelte-1dzu4e7,.error.svelte-1dzu4e7.svelte-1dzu4e7,.input:focus~.help.svelte-1dzu4e7.svelte-1dzu4e7{opacity:1}.error.svelte-1dzu4e7.svelte-1dzu4e7{color:#ff5252}.baseline.dirty.svelte-1dzu4e7 .label.svelte-1dzu4e7{letter-spacing:0.4px;top:6px;bottom:unset;font-size:13px}.baseline .input:focus~.label.svelte-1dzu4e7.svelte-1dzu4e7{letter-spacing:0.4px;top:6px;bottom:unset;font-size:13px;color:#1976d2;color:var(--primary, #1976d2)}.baseline .input:focus~.focus-line.svelte-1dzu4e7.svelte-1dzu4e7{transform:scaleX(1);opacity:1}.baseline.svelte-1dzu4e7 .input.svelte-1dzu4e7{height:52px;padding-top:22px}.baseline.filled.svelte-1dzu4e7.svelte-1dzu4e7{background:rgba(0, 0, 0, 0.0555);background:var(--bg-input-filled, rgba(0, 0, 0, 0.0555));border-radius:4px 4px 0 0}.baseline.filled.svelte-1dzu4e7 .label.svelte-1dzu4e7{background:none}.baseline.filled.svelte-1dzu4e7 .input.svelte-1dzu4e7,.baseline.filled.svelte-1dzu4e7 .label.svelte-1dzu4e7{padding-left:8px;padding-right:8px}.baseline.filled .input:focus~.label.svelte-1dzu4e7.svelte-1dzu4e7{top:6px}.baseline.filled.svelte-1dzu4e7 .help.svelte-1dzu4e7{padding-left:8px}.filled.svelte-1dzu4e7 .input.svelte-1dzu4e7:hover,.filled.svelte-1dzu4e7 .input.svelte-1dzu4e7:focus{background:rgba(0, 0, 0, 0.0555);background:var(--bg-input-filled, rgba(0, 0, 0, 0.0555))}.outlined.svelte-1dzu4e7 .help.svelte-1dzu4e7{left:18px}.outlined.svelte-1dzu4e7 .input.svelte-1dzu4e7{padding:11px 16px 9px;border-radius:4px;border:1px solid;border-color:rgba(0, 0, 0, 0.3755);border-color:var(--label, rgba(0, 0, 0, 0.3755))}.outlined.svelte-1dzu4e7 .label.svelte-1dzu4e7{top:12px;bottom:unset;left:17px}.outlined.dirty.svelte-1dzu4e7 .label.svelte-1dzu4e7{top:-6px;bottom:unset;font-size:12px;letter-spacing:0.4px;padding:0 4px;left:13px}.outlined.svelte-1dzu4e7 .input.svelte-1dzu4e7:hover{border-color:#333;border-color:var(--color, #333)}.outlined .input:focus~.label.svelte-1dzu4e7.svelte-1dzu4e7{top:-6px;bottom:unset;font-size:12px;letter-spacing:0.4px;padding:0 4px;left:13px;color:#1976d2;color:var(--primary, #1976d2)}.outlined .input:focus~.focus-ring.svelte-1dzu4e7.svelte-1dzu4e7,.outlined .input.focus-visible~.focus-ring.svelte-1dzu4e7.svelte-1dzu4e7{border-color:#1976d2;border-color:var(--primary, #1976d2)}", append(document.head, t)), init(this, e, Xe, We, safe_not_equal, {
          value: 0,
          disabled: 1,
          required: 2,
          class: 3,
          style: 4,
          title: 5,
          label: 6,
          outlined: 7,
          filled: 8,
          messagePersist: 9,
          message: 10,
          error: 11
        });
      }

    }

    function Re(e, t) {
      if ("Tab" !== e.key && 9 !== e.keyCode) return;

      let n = function (e = document) {
        return Array.prototype.slice.call(e.querySelectorAll('button, [href], select, textarea, input:not([type="hidden"]), [tabindex]:not([tabindex="-1"])')).filter(function (e) {
          const t = window.getComputedStyle(e);
          return !e.disabled && !e.getAttribute("disabled") && !e.classList.contains("disabled") && "none" !== t.display && "hidden" !== t.visibility && t.opacity > 0;
        });
      }(t);

      if (0 === n.length) return void e.preventDefault();
      let l = document.activeElement,
          o = n.indexOf(l);
      e.shiftKey ? o <= 0 && (n[n.length - 1].focus(), e.preventDefault()) : o >= n.length - 1 && (n[0].focus(), e.preventDefault());
    }

    const {
      window: Ze
    } = globals;

    function Ue(t) {
      let n, l, o, i, r, d, p, v;
      const h = t[23].default,
            b = create_slot(h, t, t[22], null);
      return {
        c() {
          n = element("div"), b && b.c(), attr(n, "class", l = null_to_empty("popover " + t[1]) + " svelte-5k22n0"), attr(n, "style", t[2]), attr(n, "tabindex", "-1");
        },

        m(l, i) {
          insert(l, n, i), b && b.m(n, null), t[26](n), d = !0, p || (v = [listen(n, "introstart", t[24]), listen(n, "introend", t[25]), action_destroyer(o = t[4].call(null, n))], p = !0);
        },

        p(e, t) {
          b && b.p && 4194304 & t && update_slot(b, h, e, e[22], t, null, null), (!d || 2 & t && l !== (l = null_to_empty("popover " + e[1]) + " svelte-5k22n0")) && attr(n, "class", l), (!d || 4 & t) && attr(n, "style", e[2]);
        },

        i(e) {
          d || (transition_in(b, e), add_render_callback(() => {
            r && r.end(1), i || (i = create_in_transition(n, t[5], {})), i.start();
          }), d = !0);
        },

        o(e) {
          transition_out(b, e), i && i.invalidate(), r = create_out_transition(n, t[6], {}), d = !1;
        },

        d(e) {
          e && detach(n), b && b.d(e), t[26](null), e && r && r.end(), p = !1, run_all(v);
        }

      };
    }

    function Ge(t) {
      let n,
          l,
          o,
          i,
          s = t[0] && Ue(t);
      return {
        c() {
          s && s.c(), n = empty();
        },

        m(r, a) {
          s && s.m(r, a), insert(r, n, a), l = !0, o || (i = [listen(Ze, "scroll", t[8], {
            passive: !0
          }), listen(Ze, "resize", t[9], {
            passive: !0
          }), listen(Ze, "keydown", t[10], !0), listen(Ze, "click", t[11], !0)], o = !0);
        },

        p(e, [t]) {
          e[0] ? s ? (s.p(e, t), 1 & t && transition_in(s, 1)) : (s = Ue(e), s.c(), transition_in(s, 1), s.m(n.parentNode, n)) : s && (group_outros(), transition_out(s, 1, 1, () => {
            s = null;
          }), check_outros());
        },

        i(e) {
          l || (transition_in(s), l = !0);
        },

        o(e) {
          transition_out(s), l = !1;
        },

        d(e) {
          s && s.d(e), e && detach(n), o = !1, run_all(i);
        }

      };
    }

    function Ke(e, t, n) {
      const l = oe(current_component),
            o = createEventDispatcher();
      let i,
          s,
          {
        class: r = ""
      } = t,
          {
        style: a = null
      } = t,
          {
        origin: c = "top left"
      } = t,
          {
        dx: d = 0
      } = t,
          {
        dy: u = 0
      } = t,
          {
        visible: f = !1
      } = t,
          {
        duration: v = 300
      } = t;

      async function h({
        target: e
      }) {
        setTimeout(() => {
          e.style.transitionDuration = v + "ms", e.style.transitionProperty = "opacity, transform", e.style.transform = "scale(1)", e.style.opacity = null;
        }, 0);
      }

      function g(e, t) {
        let l = 0;
        n(12, d = +d);
        const o = window.innerWidth - 8 - e;
        return l = l = c.indexOf("left") >= 0 ? t.left + d : t.left + t.width - e - d, l = Math.min(o, l), l = Math.max(8, l), l;
      }

      function m(e, t) {
        let l = 0;
        n(13, u = +u);
        const o = window.innerHeight - 8 - e;
        return l = l = c.indexOf("top") >= 0 ? t.top + u : t.top + t.height - e - u, l = Math.min(o, l), l = Math.max(8, l), l;
      }

      function b() {
        if (!f || !i || !s) return;
        const e = s.getBoundingClientRect();
        e.top < -e.height || e.top > window.innerHeight ? y("overflow") : (n(3, i.style.top = m(i.offsetHeight, e) + "px", i), n(3, i.style.left = g(i.offsetWidth, e) + "px", i));
      }

      function y(e) {
        o("close", e), n(0, f = !1);
      }

      beforeUpdate(() => {
        s = i ? i.parentElement : null, s && b();
      });
      let {
        $$slots: x = {},
        $$scope: w
      } = t;
      return e.$set = e => {
        "class" in e && n(1, r = e.class), "style" in e && n(2, a = e.style), "origin" in e && n(14, c = e.origin), "dx" in e && n(12, d = e.dx), "dy" in e && n(13, u = e.dy), "visible" in e && n(0, f = e.visible), "duration" in e && n(15, v = e.duration), "$$scope" in e && n(22, w = e.$$scope);
      }, [f, r, a, i, l, function (e) {
        return e.style.transformOrigin = c, e.style.transform = "scale(0.6)", e.style.opacity = "0", {
          duration: +v
        };
      }, function (e) {
        return e.style.transformOrigin = c, e.style.transitionDuration = v + "ms", e.style.transitionProperty = "opacity, transform", e.style.transform = "scale(0.6)", e.style.opacity = "0", {
          duration: +v
        };
      }, h, function () {
        b();
      }, function () {
        b();
      }, function (e) {
        f && (27 === e.keyCode && (e.stopPropagation(), y("escape")), Re(e, i));
      }, function (e) {
        f && s && !s.contains(e.target) && (e.stopPropagation(), y("clickOutside"));
      }, d, u, c, v, s, o, g, m, b, y, w, x, e => h(e), e => function ({
        target: e
      }) {
        e.style.transformOrigin = null, e.style.transitionDuration = null, e.style.transitionProperty = null, e.style.transform = null, e.focus();
      }(e), function (e) {
        binding_callbacks[e ? "unshift" : "push"](() => {
          n(3, i = e);
        });
      }];
    }

    class Je extends SvelteComponent {
      constructor(e) {
        var t;
        super(), document.getElementById("svelte-5k22n0-style") || ((t = element("style")).id = "svelte-5k22n0-style", t.textContent = ".popover.svelte-5k22n0{color:#333;color:var(--color, #333);background:#fff;background:var(--bg-popover, #fff);backface-visibility:hidden;position:fixed;border-radius:2px;max-height:100%;max-width:80%;overflow:auto;outline:none;box-shadow:0 3px 3px -2px rgba(0, 0, 0, 0.2), 0 3px 4px 0 rgba(0, 0, 0, 0.14),\n\t\t\t0 1px 8px 0 rgba(0, 0, 0, 0.12);z-index:50}", append(document.head, t)), init(this, e, Ke, Ge, safe_not_equal, {
          class: 1,
          style: 2,
          origin: 14,
          dx: 12,
          dy: 13,
          visible: 0,
          duration: 15
        });
      }

    }

    function tn(e) {
      let t = "hidden" === document.body.style.overflow;

      if (e && t) {
        let e = Math.abs(parseInt(document.body.style.top));
        document.body.style.cssText = null, document.body.removeAttribute("style"), window.scrollTo(0, e);
      } else e || t || (document.body.style.top = "-" + Math.max(document.body.scrollTop, document.documentElement && document.documentElement.scrollTop || 0) + "px", document.body.style.position = "fixed", document.body.style.width = "100%", document.body.style.overflow = "hidden");
    }

    const nn = e => ({}),
          ln = e => ({}),
          on = e => ({}),
          sn = e => ({}),
          rn = e => ({}),
          an = e => ({});

    function cn(t) {
      let n, l, o, i, d, p, v, h, b, D, C, E, Y;

      const j = t[19].title,
            T = create_slot(j, t, t[18], an),
            N = t[19].default,
            B = create_slot(N, t, t[18], null),
            I = t[19].actions,
            S = create_slot(I, t, t[18], sn),
            q = t[19].footer,
            _ = create_slot(q, t, t[18], ln);

      let H = [{
        class: "dialog " + t[1]
      }, {
        style: `width: ${t[3]}px;${t[2]}`
      }, {
        tabindex: "-1"
      }, t[6]],
          O = {};

      for (let e = 0; e < H.length; e += 1) O = assign(O, H[e]);

      return {
        c() {
          n = element("div"), l = element("div"), o = element("div"), T && T.c(), i = space(), d = element("div"), B && B.c(), p = space(), S && S.c(), v = space(), _ && _.c(), attr(o, "class", "title svelte-1pkw9hl"), attr(d, "class", "content svelte-1pkw9hl"), set_attributes(l, O), toggle_class(l, "svelte-1pkw9hl", !0), attr(n, "class", "overlay svelte-1pkw9hl");
        },

        m(s, a) {
          insert(s, n, a), append(n, l), append(l, o), T && T.m(o, null), append(l, i), append(l, d), B && B.m(d, null), append(l, p), S && S.m(l, null), append(l, v), _ && _.m(l, null), t[21](l), C = !0, E || (Y = [action_destroyer(h = t[8].call(null, l)), listen(l, "mousedown", stop_propagation(t[20])), listen(l, "mouseenter", t[22]), listen(n, "mousedown", t[23]), listen(n, "mouseup", t[24])], E = !0);
        },

        p(e, t) {
          T && T.p && 262144 & t && update_slot(T, j, e, e[18], t, rn, an), B && B.p && 262144 & t && update_slot(B, N, e, e[18], t, null, null), S && S.p && 262144 & t && update_slot(S, I, e, e[18], t, on, sn), _ && _.p && 262144 & t && update_slot(_, q, e, e[18], t, nn, ln), set_attributes(l, O = get_spread_update(H, [2 & t && {
            class: "dialog " + e[1]
          }, 12 & t && {
            style: `width: ${e[3]}px;${e[2]}`
          }, {
            tabindex: "-1"
          }, 64 & t && e[6]])), toggle_class(l, "svelte-1pkw9hl", !0);
        },

        i(e) {
          C || (transition_in(T, e), transition_in(B, e), transition_in(S, e), transition_in(_, e), b || add_render_callback(() => {
            b = create_in_transition(l, scale, {
              duration: 180,
              opacity: .5,
              start: .75,
              easing: quintOut
            }), b.start();
          }), add_render_callback(() => {
            D || (D = create_bidirectional_transition(n, fade, {
              duration: 180
            }, !0)), D.run(1);
          }), C = !0);
        },

        o(e) {
          transition_out(T, e), transition_out(B, e), transition_out(S, e), transition_out(_, e), D || (D = create_bidirectional_transition(n, fade, {
            duration: 180
          }, !1)), D.run(0), C = !1;
        },

        d(e) {
          e && detach(n), T && T.d(e), B && B.d(e), S && S.d(e), _ && _.d(e), t[21](null), e && D && D.end(), E = !1, run_all(Y);
        }

      };
    }

    function dn(t) {
      let n,
          l,
          o,
          i,
          s = t[0] && cn(t);
      return {
        c() {
          s && s.c(), n = empty();
        },

        m(r, a) {
          s && s.m(r, a), insert(r, n, a), l = !0, o || (i = [listen(window, "keydown", t[10]), listen(window, "popstate", t[11])], o = !0);
        },

        p(e, [t]) {
          e[0] ? s ? (s.p(e, t), 1 & t && transition_in(s, 1)) : (s = cn(e), s.c(), transition_in(s, 1), s.m(n.parentNode, n)) : s && (group_outros(), transition_out(s, 1, 1, () => {
            s = null;
          }), check_outros());
        },

        i(e) {
          l || (transition_in(s), l = !0);
        },

        o(e) {
          transition_out(s), l = !1;
        },

        d(e) {
          s && s.d(e), e && detach(n), o = !1, run_all(i);
        }

      };
    }

    function un(e, n, l) {
      const o = createEventDispatcher(),
            i = oe(current_component);
      let s,
          {
        class: r = ""
      } = n,
          {
        style: a = ""
      } = n,
          {
        visible: c = !1
      } = n,
          {
        width: d = 320
      } = n,
          {
        modal: u = !1
      } = n,
          {
        closeByEsc: f = !0
      } = n,
          {
        beforeClose: v = () => !0
      } = n,
          h = !1,
          g = {},
          m = !1;

      function b(e) {
        v() && (o("close", e), l(0, c = !1));
      }

      async function x() {
        if (!s) return;
        await tick();
        let e = s.querySelectorAll('input:not([type="hidden"])'),
            t = e.length,
            n = 0;

        for (; n < t && !e[n].getAttribute("autofocus"); n++);

        n < t ? e[n].focus() : t > 0 ? e[0].focus() : s.focus(), o("open");
      }

      onMount(async () => {
        await tick(), l(14, m = !0);
      }), onDestroy(() => {
        m && tn(!0);
      });
      let {
        $$slots: w = {},
        $$scope: $
      } = n;
      return e.$set = e => {
        l(17, n = assign(assign({}, n), exclude_internal_props(e))), "class" in e && l(1, r = e.class), "style" in e && l(2, a = e.style), "visible" in e && l(0, c = e.visible), "width" in e && l(3, d = e.width), "modal" in e && l(4, u = e.modal), "closeByEsc" in e && l(12, f = e.closeByEsc), "beforeClose" in e && l(13, v = e.beforeClose), "$$scope" in e && l(18, $ = e.$$scope);
      }, e.$$.update = () => {
        {
          const {
            style: e,
            visible: t,
            width: o,
            modal: i,
            closeByEsc: s,
            beforeClose: r,
            ...a
          } = n;
          l(6, g = a);
        }
        16385 & e.$$.dirty && (c ? (m && tn(!1), x()) : (l(5, h = !1), m && tn(!0)));
      }, n = exclude_internal_props(n), [c, r, a, d, u, h, g, s, i, b, function (e) {
        const t = "Escape";
        27 !== e.keyCode && e.key !== t && e.code !== t || f && b(t), c && Re(e, s);
      }, function () {
        l(0, c = !1);
      }, f, v, m, o, x, n, $, w, function (n) {
        bubble(e, n);
      }, function (e) {
        binding_callbacks[e ? "unshift" : "push"](() => {
          l(7, s = e);
        });
      }, () => {
        l(5, h = !1);
      }, () => {
        l(5, h = !0);
      }, () => {
        h && !u && b("clickOutside");
      }];
    }

    class pn extends SvelteComponent {
      constructor(e) {
        var t;
        super(), document.getElementById("svelte-1pkw9hl-style") || ((t = element("style")).id = "svelte-1pkw9hl-style", t.textContent = ".overlay.svelte-1pkw9hl{background-color:rgba(0, 0, 0, 0.5);cursor:pointer;position:fixed;left:0;top:0;right:0;bottom:0;z-index:30;display:flex;justify-content:center;align-items:center}.dialog.svelte-1pkw9hl{position:relative;font-size:1rem;background:#eee;background:var(--bg-panel, #eee);border-radius:4px;cursor:auto;box-shadow:0 11px 15px -7px rgba(0, 0, 0, 0.2), 0 24px 38px 3px rgba(0, 0, 0, 0.14),\n\t\t\t0 9px 46px 8px rgba(0, 0, 0, 0.12);z-index:40;max-height:80%;overflow-x:hidden;overflow-y:auto}.dialog.svelte-1pkw9hl:focus{outline:none}.dialog.svelte-1pkw9hl::-moz-focus-inner{border:0}.dialog.svelte-1pkw9hl:-moz-focusring{outline:none}div.svelte-1pkw9hl .actions{min-height:48px;padding:8px;display:flex;align-items:center}div.svelte-1pkw9hl .center{justify-content:center}div.svelte-1pkw9hl .left{justify-content:flex-start}div.svelte-1pkw9hl .right{justify-content:flex-end}.title.svelte-1pkw9hl{padding:16px 16px 12px;font-size:24px;line-height:36px;background:rgba(0, 0, 0, 0.1);background:var(--divider, rgba(0, 0, 0, 0.1))}.content.svelte-1pkw9hl{margin:16px}", append(document.head, t)), init(this, e, un, dn, safe_not_equal, {
          class: 1,
          style: 2,
          visible: 0,
          width: 3,
          modal: 4,
          closeByEsc: 12,
          beforeClose: 13
        });
      }

    }

    const fn = e => ({}),
          vn = e => ({});

    function hn(e) {
      let t, n, l;
      const o = e[14].default,
            i = create_slot(o, e, e[13], null);
      return {
        c() {
          t = element("div"), i && i.c(), attr(t, "class", "content svelte-duf4ie");
        },

        m(e, n) {
          insert(e, t, n), i && i.m(t, null), l = !0;
        },

        p(e, t) {
          i && i.p && 8192 & t && update_slot(i, o, e, e[13], t, null, null);
        },

        i(e) {
          l || (transition_in(i, e), e && add_render_callback(() => {
            n || (n = create_bidirectional_transition(t, slide, {
              duration: 250
            }, !0)), n.run(1);
          }), l = !0);
        },

        o(e) {
          transition_out(i, e), e && (n || (n = create_bidirectional_transition(t, slide, {
            duration: 250
          }, !1)), n.run(0)), l = !1;
        },

        d(e) {
          e && detach(t), i && i.d(e), e && n && n.end();
        }

      };
    }

    function gn(t) {
      let n, l, o, i, d, p, v, h, b, E;

      const Y = t[14].icon,
            j = create_slot(Y, t, t[13], vn),
            A = j || function (e) {
        let t;
        return {
          c() {
            t = element("i"), t.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24" fill="currentColor"><path d="M16.59 8.59L12 13.17 7.41 8.59 6 10l6 6 6-6z"></path></svg>', attr(t, "class", "icon svelte-duf4ie");
          },

          m(e, n) {
            insert(e, t, n);
          },

          d(e) {
            e && detach(t);
          }

        };
      }();

      let T = t[6] && hn(t),
          I = [{
        class: "panel " + t[0]
      }, t[5]],
          F = {};

      for (let e = 0; e < I.length; e += 1) F = assign(F, I[e]);

      return {
        c() {
          n = element("div"), l = element("button"), o = element("span"), i = text(t[1]), d = space(), A && A.c(), p = space(), T && T.c(), attr(o, "class", "svelte-duf4ie"), attr(l, "class", "header svelte-duf4ie"), l.disabled = t[4], toggle_class(l, "rotate", t[3]), set_attributes(n, F), toggle_class(n, "dense", t[2]), toggle_class(n, "active", t[6]), toggle_class(n, "svelte-duf4ie", !0);
        },

        m(s, a) {
          insert(s, n, a), append(n, l), append(l, o), append(o, i), append(l, d), A && A.m(l, null), append(n, p), T && T.m(n, null), h = !0, b || (E = [listen(l, "click", t[8]), action_destroyer(v = t[7].call(null, n))], b = !0);
        },

        p(e, [t]) {
          (!h || 2 & t) && set_data(i, e[1]), j && j.p && 8192 & t && update_slot(j, Y, e, e[13], t, fn, vn), (!h || 16 & t) && (l.disabled = e[4]), 8 & t && toggle_class(l, "rotate", e[3]), e[6] ? T ? (T.p(e, t), 64 & t && transition_in(T, 1)) : (T = hn(e), T.c(), transition_in(T, 1), T.m(n, null)) : T && (group_outros(), transition_out(T, 1, 1, () => {
            T = null;
          }), check_outros()), set_attributes(n, F = get_spread_update(I, [1 & t && {
            class: "panel " + e[0]
          }, 32 & t && e[5]])), toggle_class(n, "dense", e[2]), toggle_class(n, "active", e[6]), toggle_class(n, "svelte-duf4ie", !0);
        },

        i(e) {
          h || (transition_in(A, e), transition_in(T), h = !0);
        },

        o(e) {
          transition_out(A, e), transition_out(T), h = !1;
        },

        d(e) {
          e && detach(n), A && A.d(e), T && T.d(), b = !1, run_all(E);
        }

      };
    }

    function mn(e, t, n) {
      const l = oe(current_component),
            o = createEventDispatcher();
      let {
        class: i = ""
      } = t,
          {
        name: s = "?"
      } = t,
          {
        group: r = ""
      } = t,
          {
        dense: a = !1
      } = t,
          {
        rotate: c = !0
      } = t,
          {
        expand: d = !1
      } = t,
          {
        disabled: u = !1
      } = t,
          p = {};
      let f,
          {
        $$slots: v = {},
        $$scope: h
      } = t;
      return e.$set = e => {
        n(12, t = assign(assign({}, t), exclude_internal_props(e))), "class" in e && n(0, i = e.class), "name" in e && n(1, s = e.name), "group" in e && n(9, r = e.group), "dense" in e && n(2, a = e.dense), "rotate" in e && n(3, c = e.rotate), "expand" in e && n(10, d = e.expand), "disabled" in e && n(4, u = e.disabled), "$$scope" in e && n(13, h = e.$$scope);
      }, e.$$.update = () => {
        {
          const {
            name: e,
            group: l,
            dense: o,
            rotate: i,
            expand: s,
            disabled: r,
            ...a
          } = t;
          delete a.class, n(5, p = a);
        }
        1026 & e.$$.dirty && d && n(9, r = s), 514 & e.$$.dirty && n(6, f = r === s), 66 & e.$$.dirty && o("change", {
          expanded: f,
          name: s
        });
      }, t = exclude_internal_props(t), [i, s, a, c, u, p, f, l, function (e) {
        n(9, r = r === s ? "" : s), e.target.classList.remove("focus-visible");
      }, r, d, o, t, h, v];
    }

    class bn extends SvelteComponent {
      constructor(e) {
        var t;
        super(), document.getElementById("svelte-duf4ie-style") || ((t = element("style")).id = "svelte-duf4ie-style", t.textContent = ".panel.svelte-duf4ie.svelte-duf4ie{position:relative;box-sizing:border-box;background:var(--bg-color, #fbfbfb);box-shadow:0px 2px 1px -1px rgba(0, 0, 0, 0.2), 0px 1px 1px 0px rgba(0, 0, 0, 0.14),\n\t\t\t0px 1px 3px 0px var(--border, #dfdfdf);transition:margin 0.25s}.panel.svelte-duf4ie.svelte-duf4ie::before{position:absolute;top:-1px;left:0;right:0;height:1px;content:'';background-color:var(--divider, rgba(0, 0, 0, 0.1))}.panel.svelte-duf4ie.svelte-duf4ie:first-child{border-top:none;border-top-left-radius:inherit;border-top-right-radius:inherit}.panel.svelte-duf4ie.svelte-duf4ie:last-child{border-bottom-left-radius:inherit;border-bottom-right-radius:inherit}.panel.svelte-duf4ie.svelte-duf4ie:first-child::before{display:none}.panel.active.svelte-duf4ie.svelte-duf4ie:not(:first-child):not(.dense),.panel.active:not(.dense)+.panel.svelte-duf4ie.svelte-duf4ie{margin-top:16px}.panel.active.svelte-duf4ie.svelte-duf4ie:not(.dense)::before{display:none}.panel.active:not(.dense)+.panel.svelte-duf4ie.svelte-duf4ie:before{display:none}.header.svelte-duf4ie.svelte-duf4ie{display:flex;align-items:flex-start;width:100%;min-height:48px;cursor:pointer;background:none;color:inherit;font-size:16px;line-height:1;border:2px solid transparent;outline:none;margin:0;padding:10px 22px;text-align:left;outline:none;transition:min-height 0.25s}.header.svelte-duf4ie.svelte-duf4ie:active{background:none}.header.svelte-duf4ie span.svelte-duf4ie{flex:1;line-height:24px}.icon.svelte-duf4ie.svelte-duf4ie{display:inline-block;line-height:0.5}.panel.svelte-duf4ie.svelte-duf4ie .icon{transition:0.25s linear}.active.svelte-duf4ie .header.svelte-duf4ie{min-height:64px}.active.svelte-duf4ie .rotate.svelte-duf4ie .icon{transform:rotate(-180deg)}.content.svelte-duf4ie.svelte-duf4ie{overflow:auto;margin:0;padding:0 24px 16px}@media(hover: hover){.header.focus-visible.svelte-duf4ie.svelte-duf4ie:focus:not([disabled]):not(.disabled){outline:none;border:2px solid var(--focus-color, rgba(25, 118, 210, 0.5))}}", append(document.head, t)), init(this, e, mn, gn, safe_not_equal, {
          class: 0,
          name: 1,
          group: 9,
          dense: 2,
          rotate: 3,
          expand: 10,
          disabled: 4
        });
      }

    }

    const yn = e => ({}),
          xn = e => ({});

    function wn(e) {
      let t, n, l;
      const o = e[11].default,
            i = create_slot(o, e, e[14], null);
      return {
        c() {
          t = element("ul"), i && i.c(), attr(t, "style", n = `min-width: ${e[5]}px`), attr(t, "class", "svelte-1vc5q8h");
        },

        m(e, n) {
          insert(e, t, n), i && i.m(t, null), l = !0;
        },

        p(e, s) {
          i && i.p && 16384 & s && update_slot(i, o, e, e[14], s, null, null), (!l || 32 & s && n !== (n = `min-width: ${e[5]}px`)) && attr(t, "style", n);
        },

        i(e) {
          l || (transition_in(i, e), l = !0);
        },

        o(e) {
          transition_out(i, e), l = !1;
        },

        d(e) {
          e && detach(t), i && i.d(e);
        }

      };
    }

    function $n(t) {
      let n, l, o, i, d, y, w;

      const $ = t[11].activator,
            D = create_slot($, t, t[14], xn),
            C = D || function (e) {
        let t;
        return {
          c() {
            t = element("span");
          },

          m(e, n) {
            insert(e, t, n);
          },

          d(e) {
            e && detach(t);
          }

        };
      }();

      function M(e) {
        t[12].call(null, e);
      }

      let E = {
        class: t[0],
        style: t[1],
        origin: t[4],
        dx: t[2],
        dy: t[3],
        $$slots: {
          default: [wn]
        },
        $$scope: {
          ctx: t
        }
      };
      void 0 !== t[6] && (E.visible = t[6]);
      const Y = new Je({
        props: E
      });
      return binding_callbacks.push(() => bind(Y, "visible", M)), Y.$on("click", t[10]), {
        c() {
          n = element("div"), C && C.c(), l = space(), create_component(Y.$$.fragment), attr(n, "class", "menu svelte-1vc5q8h");
        },

        m(o, s) {
          insert(o, n, s), C && C.m(n, null), append(n, l), mount_component(Y, n, null), t[13](n), d = !0, y || (w = [listen(n, "click", t[9]), action_destroyer(i = t[8].call(null, n))], y = !0);
        },

        p(e, [t]) {
          D && D.p && 16384 & t && update_slot(D, $, e, e[14], t, yn, xn);
          const n = {};
          1 & t && (n.class = e[0]), 2 & t && (n.style = e[1]), 16 & t && (n.origin = e[4]), 4 & t && (n.dx = e[2]), 8 & t && (n.dy = e[3]), 16416 & t && (n.$$scope = {
            dirty: t,
            ctx: e
          }), !o && 64 & t && (o = !0, n.visible = e[6], add_flush_callback(() => o = !1)), Y.$set(n);
        },

        i(e) {
          d || (transition_in(C, e), transition_in(Y.$$.fragment, e), d = !0);
        },

        o(e) {
          transition_out(C, e), transition_out(Y.$$.fragment, e), d = !1;
        },

        d(e) {
          e && detach(n), C && C.d(e), destroy_component(Y), t[13](null), y = !1, run_all(w);
        }

      };
    }

    function zn(e, t, n) {
      const l = oe(current_component);
      let o,
          {
        class: i = ""
      } = t,
          {
        style: s = null
      } = t,
          {
        dx: r = 0
      } = t,
          {
        dy: a = 0
      } = t,
          {
        origin: c = "top left"
      } = t,
          {
        width: d = 112
      } = t,
          u = !1;
      let {
        $$slots: f = {},
        $$scope: v
      } = t;
      return e.$set = e => {
        "class" in e && n(0, i = e.class), "style" in e && n(1, s = e.style), "dx" in e && n(2, r = e.dx), "dy" in e && n(3, a = e.dy), "origin" in e && n(4, c = e.origin), "width" in e && n(5, d = e.width), "$$scope" in e && n(14, v = e.$$scope);
      }, [i, s, r, a, c, d, u, o, l, function (e) {
        try {
          o.childNodes[0].contains(e.target) ? n(6, u = !u) : e.target === o && n(6, u = !1);
        } catch (e) {
          console.error(e);
        }
      }, function (e) {
        e.target.classList.contains("menu-item") && n(6, u = !1);
      }, f, function (e) {
        u = e, n(6, u);
      }, function (e) {
        binding_callbacks[e ? "unshift" : "push"](() => {
          n(7, o = e);
        });
      }, v];
    }

    class kn extends SvelteComponent {
      constructor(e) {
        var t;
        super(), document.getElementById("svelte-1vc5q8h-style") || ((t = element("style")).id = "svelte-1vc5q8h-style", t.textContent = "@supports (-webkit-overflow-scrolling: touch){html{cursor:pointer}}.menu.svelte-1vc5q8h{position:relative;display:inline-block;vertical-align:middle}ul.svelte-1vc5q8h{margin:0;padding:8px 0;width:100%;position:relative;overflow-x:hidden;overflow-y:visible}", append(document.head, t)), init(this, e, zn, $n, safe_not_equal, {
          class: 0,
          style: 1,
          dx: 2,
          dy: 3,
          origin: 4,
          width: 5
        });
      }

    }

    function Dn(t) {
      let n, l, o, i, a, d;
      const p = t[10].default,
            v = create_slot(p, t, t[9], null);
      let h = t[1] && Mn(),
          b = [{
        class: "menu-item " + t[0]
      }, {
        tabindex: t[2] ? "-1" : "0"
      }, t[4]],
          E = {};

      for (let e = 0; e < b.length; e += 1) E = assign(E, b[e]);

      return {
        c() {
          n = element("li"), v && v.c(), l = space(), h && h.c(), set_attributes(n, E), toggle_class(n, "svelte-mmrniu", !0);
        },

        m(s, u) {
          insert(s, n, u), v && v.m(n, null), append(n, l), h && h.m(n, null), t[12](n), i = !0, a || (d = [listen(n, "keydown", t[7]), action_destroyer(o = t[6].call(null, n))], a = !0);
        },

        p(e, t) {
          v && v.p && 512 & t && update_slot(v, p, e, e[9], t, null, null), e[1] ? h ? 2 & t && transition_in(h, 1) : (h = Mn(), h.c(), transition_in(h, 1), h.m(n, null)) : h && (group_outros(), transition_out(h, 1, 1, () => {
            h = null;
          }), check_outros()), set_attributes(n, E = get_spread_update(b, [1 & t && {
            class: "menu-item " + e[0]
          }, 4 & t && {
            tabindex: e[2] ? "-1" : "0"
          }, 16 & t && e[4]])), toggle_class(n, "svelte-mmrniu", !0);
        },

        i(e) {
          i || (transition_in(v, e), transition_in(h), i = !0);
        },

        o(e) {
          transition_out(v, e), transition_out(h), i = !1;
        },

        d(e) {
          e && detach(n), v && v.d(e), h && h.d(), t[12](null), a = !1, run_all(d);
        }

      };
    }

    function Cn(t) {
      let n, l, o, i, d, p, v;
      const h = t[10].default,
            b = create_slot(h, t, t[9], null);
      let E = t[1] && Ln(),
          Y = [{
        class: "menu-item " + t[0]
      }, {
        href: t[3]
      }, {
        tabindex: t[2] ? "-1" : "0"
      }, t[4]],
          j = {};

      for (let e = 0; e < Y.length; e += 1) j = assign(j, Y[e]);

      return {
        c() {
          n = element("li"), l = element("a"), b && b.c(), o = space(), E && E.c(), set_attributes(l, j), toggle_class(l, "svelte-mmrniu", !0), attr(n, "class", "svelte-mmrniu");
        },

        m(s, a) {
          insert(s, n, a), append(n, l), b && b.m(l, null), append(l, o), E && E.m(l, null), t[11](l), d = !0, p || (v = [listen(l, "keydown", t[7]), action_destroyer(i = t[6].call(null, l))], p = !0);
        },

        p(e, t) {
          b && b.p && 512 & t && update_slot(b, h, e, e[9], t, null, null), e[1] ? E ? 2 & t && transition_in(E, 1) : (E = Ln(), E.c(), transition_in(E, 1), E.m(l, null)) : E && (group_outros(), transition_out(E, 1, 1, () => {
            E = null;
          }), check_outros()), set_attributes(l, j = get_spread_update(Y, [1 & t && {
            class: "menu-item " + e[0]
          }, 8 & t && {
            href: e[3]
          }, 4 & t && {
            tabindex: e[2] ? "-1" : "0"
          }, 16 & t && e[4]])), toggle_class(l, "svelte-mmrniu", !0);
        },

        i(e) {
          d || (transition_in(b, e), transition_in(E), d = !0);
        },

        o(e) {
          transition_out(b, e), transition_out(E), d = !1;
        },

        d(e) {
          e && detach(n), b && b.d(e), E && E.d(), t[11](null), p = !1, run_all(v);
        }

      };
    }

    function Mn(e) {
      let t;
      const n = new he({});
      return {
        c() {
          create_component(n.$$.fragment);
        },

        m(e, l) {
          mount_component(n, e, l), t = !0;
        },

        i(e) {
          t || (transition_in(n.$$.fragment, e), t = !0);
        },

        o(e) {
          transition_out(n.$$.fragment, e), t = !1;
        },

        d(e) {
          destroy_component(n, e);
        }

      };
    }

    function Ln(e) {
      let t;
      const n = new he({});
      return {
        c() {
          create_component(n.$$.fragment);
        },

        m(e, l) {
          mount_component(n, e, l), t = !0;
        },

        i(e) {
          t || (transition_in(n.$$.fragment, e), t = !0);
        },

        o(e) {
          transition_out(n.$$.fragment, e), t = !1;
        },

        d(e) {
          destroy_component(n, e);
        }

      };
    }

    function En(e) {
      let t, n, l, o;
      const i = [Cn, Dn],
            s = [];

      function r(e, t) {
        return e[3] ? 0 : 1;
      }

      return t = r(e), n = s[t] = i[t](e), {
        c() {
          n.c(), l = empty();
        },

        m(e, n) {
          s[t].m(e, n), insert(e, l, n), o = !0;
        },

        p(e, [o]) {
          let a = t;
          t = r(e), t === a ? s[t].p(e, o) : (group_outros(), transition_out(s[a], 1, 1, () => {
            s[a] = null;
          }), check_outros(), n = s[t], n || (n = s[t] = i[t](e), n.c()), transition_in(n, 1), n.m(l.parentNode, l));
        },

        i(e) {
          o || (transition_in(n), o = !0);
        },

        o(e) {
          transition_out(n), o = !1;
        },

        d(e) {
          s[t].d(e), e && detach(l);
        }

      };
    }

    function Yn(e, t, n) {
      const l = oe(current_component);
      let o,
          {
        class: i = ""
      } = t,
          {
        ripple: s = !0
      } = t,
          r = !1,
          a = null,
          c = {};
      let {
        $$slots: d = {},
        $$scope: u
      } = t;
      return e.$set = e => {
        n(8, t = assign(assign({}, t), exclude_internal_props(e))), "class" in e && n(0, i = e.class), "ripple" in e && n(1, s = e.ripple), "$$scope" in e && n(9, u = e.$$scope);
      }, e.$$.update = () => {
        {
          const {
            href: e,
            ripple: l,
            ...o
          } = t;
          delete o.class, !1 === o.disabled && delete o.disabled, n(2, r = !!o.disabled), n(3, a = e && !r ? e : null), n(4, c = o);
        }
      }, t = exclude_internal_props(t), [i, s, r, a, c, o, l, function (e) {
        if (13 === e.keyCode || 32 === e.keyCode) {
          e.stopPropagation(), e.preventDefault();
          const t = new MouseEvent("click", {
            bubbles: !0,
            cancelable: !0
          });
          o.dispatchEvent(t), o.blur();
        }
      }, t, u, d, function (e) {
        binding_callbacks[e ? "unshift" : "push"](() => {
          n(5, o = e);
        });
      }, function (e) {
        binding_callbacks[e ? "unshift" : "push"](() => {
          n(5, o = e);
        });
      }];
    }

    class jn extends SvelteComponent {
      constructor(e) {
        var t;
        super(), document.getElementById("svelte-mmrniu-style") || ((t = element("style")).id = "svelte-mmrniu-style", t.textContent = "li.svelte-mmrniu{display:block}a.svelte-mmrniu,a.svelte-mmrniu:hover{text-decoration:none}.menu-item.svelte-mmrniu{position:relative;color:inherit;cursor:pointer;height:44px;user-select:none;display:flex;align-items:center;padding:0 16px;white-space:nowrap}.menu-item.svelte-mmrniu:focus{outline:none}.menu-item.svelte-mmrniu::-moz-focus-inner{border:0}.menu-item.svelte-mmrniu:-moz-focusring{outline:none}.menu-item.svelte-mmrniu:before{background-color:currentColor;color:inherit;bottom:0;content:'';left:0;opacity:0;pointer-events:none;position:absolute;right:0;top:0;transition:0.3s cubic-bezier(0.25, 0.8, 0.5, 1)}@media(hover: hover){.menu-item.svelte-mmrniu:hover:not([disabled]):not(.disabled):before{opacity:0.15}.focus-visible.menu-item:focus:not([disabled]):not(.disabled):before{opacity:0.3}}", append(document.head, t)), init(this, e, Yn, En, safe_not_equal, {
          class: 0,
          ripple: 1
        });
      }

    }

    function An(e) {
      let t;
      const n = new he({
        props: {
          center: !0,
          circle: !0
        }
      });
      return {
        c() {
          create_component(n.$$.fragment);
        },

        m(e, l) {
          mount_component(n, e, l), t = !0;
        },

        i(e) {
          t || (transition_in(n.$$.fragment, e), t = !0);
        },

        o(e) {
          transition_out(n.$$.fragment, e), t = !1;
        },

        d(e) {
          destroy_component(n, e);
        }

      };
    }

    function Tn(t) {
      let n, l, o, i, d, p, y, w, M, E, Y, j, A;
      const N = new Me({
        props: {
          path: t[0] === t[2] ? Nn : Bn
        }
      });
      let B = t[7] && An();
      const I = t[14].default,
            F = create_slot(I, t, t[13], null);
      return {
        c() {
          n = element("label"), l = element("input"), i = space(), d = element("div"), create_component(N.$$.fragment), p = space(), B && B.c(), w = space(), M = element("div"), F && F.c(), attr(l, "type", "radio"), l.disabled = t[5], l.__value = t[2], l.value = l.__value, attr(l, "class", "svelte-j29u99"), t[16][0].push(l), attr(d, "class", "mark svelte-j29u99"), attr(d, "style", y = "color: " + (t[2] === t[0] ? t[1] : "#9a9a9a")), attr(M, "class", "label-text svelte-j29u99"), attr(n, "class", E = null_to_empty(t[3]) + " svelte-j29u99"), attr(n, "style", t[4]), attr(n, "title", t[8]), toggle_class(n, "right", t[6]), toggle_class(n, "disabled", t[5]);
        },

        m(s, a) {
          insert(s, n, a), append(n, l), l.checked = l.__value === t[0], t[17](l), append(n, i), append(n, d), mount_component(N, d, null), append(d, p), B && B.m(d, null), append(n, w), append(n, M), F && F.m(M, null), Y = !0, j || (A = [listen(l, "change", t[15]), action_destroyer(o = t[10].call(null, l))], j = !0);
        },

        p(e, [t]) {
          (!Y || 32 & t) && (l.disabled = e[5]), (!Y || 4 & t) && (l.__value = e[2]), l.value = l.__value, 1 & t && (l.checked = l.__value === e[0]);
          const o = {};
          5 & t && (o.path = e[0] === e[2] ? Nn : Bn), N.$set(o), e[7] ? B ? 128 & t && transition_in(B, 1) : (B = An(), B.c(), transition_in(B, 1), B.m(d, null)) : B && (group_outros(), transition_out(B, 1, 1, () => {
            B = null;
          }), check_outros()), (!Y || 7 & t && y !== (y = "color: " + (e[2] === e[0] ? e[1] : "#9a9a9a"))) && attr(d, "style", y), F && F.p && 8192 & t && update_slot(F, I, e, e[13], t, null, null), (!Y || 8 & t && E !== (E = null_to_empty(e[3]) + " svelte-j29u99")) && attr(n, "class", E), (!Y || 16 & t) && attr(n, "style", e[4]), (!Y || 256 & t) && attr(n, "title", e[8]), 72 & t && toggle_class(n, "right", e[6]), 40 & t && toggle_class(n, "disabled", e[5]);
        },

        i(e) {
          Y || (transition_in(N.$$.fragment, e), transition_in(B), transition_in(F, e), Y = !0);
        },

        o(e) {
          transition_out(N.$$.fragment, e), transition_out(B), transition_out(F, e), Y = !1;
        },

        d(e) {
          e && detach(n), t[16][0].splice(t[16][0].indexOf(l), 1), t[17](null), destroy_component(N), B && B.d(), F && F.d(e), j = !1, run_all(A);
        }

      };
    }

    let Nn = "M12 7c-2.76 0-5 2.24-5 5s2.24 5 5 5 5-2.24 5-5-2.24-5-5-5zm0-5C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z",
        Bn = "M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z";

    function In(e, t, n) {
      const l = oe(current_component);
      let o,
          {
        group: i = null
      } = t,
          {
        value: s = "on"
      } = t,
          {
        class: r = ""
      } = t,
          {
        style: a = null
      } = t,
          {
        color: c = "primary"
      } = t,
          {
        disabled: d = !1
      } = t,
          {
        right: u = !1
      } = t,
          {
        ripple: f = !0
      } = t,
          {
        title: v = null
      } = t,
          h = {};
      onMount(async () => {
        if (await tick(), o) for (let e in h) o.setAttribute(e, h[e]);
      });
      let {
        $$slots: g = {},
        $$scope: m
      } = t;
      return e.$set = e => {
        n(12, t = assign(assign({}, t), exclude_internal_props(e))), "group" in e && n(0, i = e.group), "value" in e && n(2, s = e.value), "class" in e && n(3, r = e.class), "style" in e && n(4, a = e.style), "color" in e && n(1, c = e.color), "disabled" in e && n(5, d = e.disabled), "right" in e && n(6, u = e.right), "ripple" in e && n(7, f = e.ripple), "title" in e && n(8, v = e.title), "$$scope" in e && n(13, m = e.$$scope);
      }, e.$$.update = () => {
        {
          const {
            group: e,
            value: n,
            style: l,
            color: o,
            disabled: i,
            right: s,
            ripple: r,
            title: a,
            ...c
          } = t;
          delete c.class, h = c;
        }
        2 & e.$$.dirty && ("primary" !== c && c ? "accent" === c && n(1, c = ie() ? "#f50057" : "var(--accent, #f50057)") : n(1, c = ie() ? "#1976d2" : "var(--primary, #1976d2)"));
      }, t = exclude_internal_props(t), [i, c, s, r, a, d, u, f, v, o, l, h, t, m, g, function () {
        i = this.__value, n(0, i);
      }, [[]], function (e) {
        binding_callbacks[e ? "unshift" : "push"](() => {
          n(9, o = e);
        });
      }];
    }

    class Fn extends SvelteComponent {
      constructor(e) {
        var t;
        super(), document.getElementById("svelte-j29u99-style") || ((t = element("style")).id = "svelte-j29u99-style", t.textContent = "label.svelte-j29u99.svelte-j29u99{cursor:pointer;width:100%;align-items:center;display:flex;margin:0;position:relative;line-height:40px;user-select:none}input.svelte-j29u99.svelte-j29u99{cursor:inherit;width:100%;height:100%;position:absolute;top:0;left:0;margin:0;padding:0;opacity:0 !important}.mark.svelte-j29u99.svelte-j29u99{display:flex;position:relative;justify-content:center;align-items:center;border-radius:50%;width:40px;height:40px}.mark.svelte-j29u99.svelte-j29u99:before{background:currentColor;border-radius:inherit;bottom:0;color:inherit;content:'';left:0;opacity:0;pointer-events:none;position:absolute;right:0;top:0;transition:0.3s cubic-bezier(0.25, 0.8, 0.5, 1)}@media not all and (min-resolution: 0.001dpcm){@supports (-webkit-appearance: none) and (stroke-color: transparent){.mark.svelte-j29u99.svelte-j29u99:before{transition:none}}}.label-text.svelte-j29u99.svelte-j29u99{margin-left:4px;white-space:nowrap;overflow:hidden}.right.svelte-j29u99 .label-text.svelte-j29u99{margin-left:0;margin-right:auto;order:-1}@media(hover: hover){label.svelte-j29u99:hover:not([disabled]):not(.disabled) .mark.svelte-j29u99:before{opacity:0.15}.focus-visible:focus:not([disabled]):not(.disabled)~.mark.svelte-j29u99.svelte-j29u99:before{opacity:0.3}}", append(document.head, t)), init(this, e, In, Tn, safe_not_equal, {
          group: 0,
          value: 2,
          class: 3,
          style: 4,
          color: 1,
          disabled: 5,
          right: 6,
          ripple: 7,
          title: 8
        });
      }

    }

    const {
      window: Sn
    } = globals;

    function qn(t) {
      let n, l, o, i, r;
      return {
        c() {
          n = element("div"), attr(n, "class", "overlay svelte-1o2jp7l");
        },

        m(l, s) {
          insert(l, n, s), o = !0, i || (r = listen(n, "click", t[4]), i = !0);
        },

        p: noop,

        i(e) {
          o || (add_render_callback(() => {
            l || (l = create_bidirectional_transition(n, fade, {
              duration: 300
            }, !0)), l.run(1);
          }), o = !0);
        },

        o(e) {
          l || (l = create_bidirectional_transition(n, fade, {
            duration: 300
          }, !1)), l.run(0), o = !1;
        },

        d(e) {
          e && detach(n), e && l && l.end(), i = !1, r();
        }

      };
    }

    function _n(t) {
      let n,
          l,
          o,
          i,
          r,
          d,
          p,
          v = t[0] && qn(t);
      const h = t[14].default,
            b = create_slot(h, t, t[13], null);
      return {
        c() {
          n = space(), v && v.c(), l = space(), o = element("aside"), b && b.c(), attr(o, "class", "side-panel svelte-1o2jp7l"), attr(o, "tabindex", "-1"), toggle_class(o, "left", !t[1]), toggle_class(o, "right", t[1]), toggle_class(o, "visible", t[0]);
        },

        m(s, a) {
          insert(s, n, a), v && v.m(s, a), insert(s, l, a), insert(s, o, a), b && b.m(o, null), t[15](o), r = !0, d || (p = [listen(Sn, "keydown", t[8]), listen(document.body, "touchstart", t[6]), listen(document.body, "touchend", t[7]), listen(o, "transitionend", t[5]), action_destroyer(i = t[3].call(null, o))], d = !0);
        },

        p(e, [t]) {
          e[0] ? v ? (v.p(e, t), 1 & t && transition_in(v, 1)) : (v = qn(e), v.c(), transition_in(v, 1), v.m(l.parentNode, l)) : v && (group_outros(), transition_out(v, 1, 1, () => {
            v = null;
          }), check_outros()), b && b.p && 8192 & t && update_slot(b, h, e, e[13], t, null, null), 2 & t && toggle_class(o, "left", !e[1]), 2 & t && toggle_class(o, "right", e[1]), 1 & t && toggle_class(o, "visible", e[0]);
        },

        i(e) {
          r || (transition_in(v), transition_in(b, e), r = !0);
        },

        o(e) {
          transition_out(v), transition_out(b, e), r = !1;
        },

        d(e) {
          e && detach(n), v && v.d(e), e && detach(l), e && detach(o), b && b.d(e), t[15](null), d = !1, run_all(p);
        }

      };
    }

    let Hn = !1;

    function On(e, t, n) {
      const l = oe(current_component);
      let o,
          {
        right: i = !1
      } = t,
          {
        visible: s = !1
      } = t,
          {
        disableScroll: r = !1
      } = t,
          a = {
        x: null,
        y: null
      },
          c = !1;

      function d() {
        n(0, s = !1), setTimeout(() => {
          Hn = !1;
        }, 20);
      }

      function u() {
        n(0, s = !0);
      }

      onMount(async () => {
        await tick(), n(11, c = !0);
      });
      let {
        $$slots: f = {},
        $$scope: v
      } = t;
      return e.$set = e => {
        "right" in e && n(1, i = e.right), "visible" in e && n(0, s = e.visible), "disableScroll" in e && n(9, r = e.disableScroll), "$$scope" in e && n(13, v = e.$$scope);
      }, e.$$.update = () => {
        2561 & e.$$.dirty && (s ? (Hn = !0, c && r && tn(!1)) : (c && tn(!0), d()));
      }, [s, i, o, l, d, function (e) {
        s && "visibility" === e.propertyName && o.focus();
      }, function (e) {
        a.x = e.changedTouches[0].clientX, a.y = e.changedTouches[0].clientY;
      }, function (e) {
        const t = e.changedTouches[0].clientX - a.x,
              n = e.changedTouches[0].clientY - a.y;

        if (Math.abs(t) > 50) {
          if (Math.abs(n) < 100) if (s) (t > 0 && i || t < 0 && !i) && d();else {
            if (Hn) return;
            t > 0 && a.x <= 20 ? i || u() : a.x >= window.innerWidth - 20 && i && u();
          }
        }
      }, function (e) {
        s && (27 !== e.keyCode && "Escape" !== e.key && "Escape" !== e.code || d(), s && Re(e, o));
      }, r, a, c, u, v, f, function (e) {
        binding_callbacks[e ? "unshift" : "push"](() => {
          n(2, o = e);
        });
      }];
    }

    class Pn extends SvelteComponent {
      constructor(e) {
        var t;
        super(), document.getElementById("svelte-1o2jp7l-style") || ((t = element("style")).id = "svelte-1o2jp7l-style", t.textContent = ".side-panel.svelte-1o2jp7l{background:#fbfbfb;background:var(--bg-color, #fbfbfb);position:fixed;visibility:hidden;width:256px;top:0;height:100%;box-shadow:0 0 10px rgba(0, 0, 0, 0.2);z-index:40;overflow-x:hidden;overflow-y:auto;transform-style:preserve-3d;will-change:transform, visibility;transition-duration:0.2s;transition-timing-function:cubic-bezier(0.4, 0, 0.2, 1);transition-property:transform, visibility}.side-panel.svelte-1o2jp7l:focus{outline:none}.side-panel.svelte-1o2jp7l::-moz-focus-inner{border:0}.side-panel.svelte-1o2jp7l:-moz-focusring{outline:none}.left.svelte-1o2jp7l{left:0;transform:translateX(-256px)}.right.svelte-1o2jp7l{left:auto;right:0;transform:translateX(256px)}.visible.svelte-1o2jp7l{visibility:visible;transform:translateX(0)}.overlay.svelte-1o2jp7l{background-color:rgba(0, 0, 0, 0.5);cursor:pointer;position:fixed;left:0;top:0;right:0;bottom:0;z-index:30}", append(document.head, t)), init(this, e, On, _n, safe_not_equal, {
          right: 1,
          visible: 0,
          disableScroll: 9
        });
      }

    }

    /* src\components\Menu.svelte generated by Svelte v3.29.0 */
    const file = "src\\components\\Menu.svelte";

    const get_activador_slot_changes = dirty => ({});

    const get_activador_slot_context = ctx => ({}); // (13:0) {#if mostrarMenu}


    function create_if_block(ctx) {
      let ul;
      let ul_intro;
      let ul_outro;
      let current;
      let mounted;
      let dispose;
      const default_slot_template =
      /*#slots*/
      ctx[3].default;
      const default_slot = create_slot(default_slot_template, ctx,
      /*$$scope*/
      ctx[2], null);
      const block = {
        c: function create() {
          ul = element("ul");
          if (default_slot) default_slot.c();
          attr_dev(ul, "class", "menu svelte-134df7t");
          attr_dev(ul, "style",
          /*stylish*/
          ctx[1]);
          add_location(ul, file, 13, 4, 319);
        },
        m: function mount(target, anchor) {
          insert_dev(target, ul, anchor);

          if (default_slot) {
            default_slot.m(ul, null);
          }

          current = true;

          if (!mounted) {
            dispose = listen_dev(ul, "mouseleave",
            /*mouseleave_handler*/
            ctx[5], false, false, false);
            mounted = true;
          }
        },
        p: function update(ctx, dirty) {
          if (default_slot) {
            if (default_slot.p && dirty &
            /*$$scope*/
            4) {
              update_slot(default_slot, default_slot_template, ctx,
              /*$$scope*/
              ctx[2], dirty, null, null);
            }
          }
        },
        i: function intro(local) {
          if (current) return;
          transition_in(default_slot, local);

          if (local) {
            add_render_callback(() => {
              if (ul_outro) ul_outro.end(1);
              if (!ul_intro) ul_intro = create_in_transition(ul, fly, {
                x: -100
              });
              ul_intro.start();
            });
          }

          current = true;
        },
        o: function outro(local) {
          transition_out(default_slot, local);
          if (ul_intro) ul_intro.invalidate();

          if (local) {
            ul_outro = create_out_transition(ul, fly, {
              x: 100
            });
          }

          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(ul);
          if (default_slot) default_slot.d(detaching);
          if (detaching && ul_outro) ul_outro.end();
          mounted = false;
          dispose();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block.name,
        type: "if",
        source: "(13:0) {#if mostrarMenu}",
        ctx
      });
      return block;
    }

    function create_fragment(ctx) {
      let span;
      let t;
      let if_block_anchor;
      let current;
      let mounted;
      let dispose;
      const activador_slot_template =
      /*#slots*/
      ctx[3].activador;
      const activador_slot = create_slot(activador_slot_template, ctx,
      /*$$scope*/
      ctx[2], get_activador_slot_context);
      let if_block =
      /*mostrarMenu*/
      ctx[0] && create_if_block(ctx);
      const block = {
        c: function create() {
          span = element("span");
          if (activador_slot) activador_slot.c();
          t = space();
          if (if_block) if_block.c();
          if_block_anchor = empty();
          add_location(span, file, 9, 0, 199);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, span, anchor);

          if (activador_slot) {
            activador_slot.m(span, null);
          }

          insert_dev(target, t, anchor);
          if (if_block) if_block.m(target, anchor);
          insert_dev(target, if_block_anchor, anchor);
          current = true;

          if (!mounted) {
            dispose = listen_dev(span, "click",
            /*click_handler*/
            ctx[4], false, false, false);
            mounted = true;
          }
        },
        p: function update(ctx, [dirty]) {
          if (activador_slot) {
            if (activador_slot.p && dirty &
            /*$$scope*/
            4) {
              update_slot(activador_slot, activador_slot_template, ctx,
              /*$$scope*/
              ctx[2], dirty, get_activador_slot_changes, get_activador_slot_context);
            }
          }

          if (
          /*mostrarMenu*/
          ctx[0]) {
            if (if_block) {
              if_block.p(ctx, dirty);

              if (dirty &
              /*mostrarMenu*/
              1) {
                transition_in(if_block, 1);
              }
            } else {
              if_block = create_if_block(ctx);
              if_block.c();
              transition_in(if_block, 1);
              if_block.m(if_block_anchor.parentNode, if_block_anchor);
            }
          } else if (if_block) {
            group_outros();
            transition_out(if_block, 1, 1, () => {
              if_block = null;
            });
            check_outros();
          }
        },
        i: function intro(local) {
          if (current) return;
          transition_in(activador_slot, local);
          transition_in(if_block);
          current = true;
        },
        o: function outro(local) {
          transition_out(activador_slot, local);
          transition_out(if_block);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(span);
          if (activador_slot) activador_slot.d(detaching);
          if (detaching) detach_dev(t);
          if (if_block) if_block.d(detaching);
          if (detaching) detach_dev(if_block_anchor);
          mounted = false;
          dispose();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }

    function instance($$self, $$props, $$invalidate) {
      let {
        $$slots: slots = {},
        $$scope
      } = $$props;
      validate_slots("Menu", slots, ['activador', 'default']);
      let {
        mostrarMenu = false
      } = $$props;
      let stylish = $$props.style;

      const click_handler = () => $$invalidate(0, mostrarMenu = !mostrarMenu);

      const mouseleave_handler = () => $$invalidate(0, mostrarMenu = false);

      $$self.$$set = $$new_props => {
        $$invalidate(6, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
        if ("mostrarMenu" in $$new_props) $$invalidate(0, mostrarMenu = $$new_props.mostrarMenu);
        if ("$$scope" in $$new_props) $$invalidate(2, $$scope = $$new_props.$$scope);
      };

      $$self.$capture_state = () => ({
        Menu: kn,
        Ripple: he,
        Button: ye,
        Icon: Me,
        fly,
        mostrarMenu,
        stylish
      });

      $$self.$inject_state = $$new_props => {
        $$invalidate(6, $$props = assign(assign({}, $$props), $$new_props));
        if ("mostrarMenu" in $$props) $$invalidate(0, mostrarMenu = $$new_props.mostrarMenu);
        if ("stylish" in $$props) $$invalidate(1, stylish = $$new_props.stylish);
      };

      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }

      $$props = exclude_internal_props($$props);
      return [mostrarMenu, stylish, $$scope, slots, click_handler, mouseleave_handler];
    }

    class Menu_1 extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance, create_fragment, safe_not_equal, {
          mostrarMenu: 0
        });
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "Menu_1",
          options,
          id: create_fragment.name
        });
      }

      get mostrarMenu() {
        throw new Error("<Menu>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set mostrarMenu(value) {
        throw new Error("<Menu>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

    }

    const subscriber_queue = [];
    /**
     * Create a `Writable` store that allows both updating and reading by subscription.
     * @param {*=}value initial value
     * @param {StartStopNotifier=}start start and stop notifications for subscriptions
     */


    function writable(value, start = noop) {
      let stop;
      const subscribers = [];

      function set(new_value) {
        if (safe_not_equal(value, new_value)) {
          value = new_value;

          if (stop) {
            // store is ready
            const run_queue = !subscriber_queue.length;

            for (let i = 0; i < subscribers.length; i += 1) {
              const s = subscribers[i];
              s[1]();
              subscriber_queue.push(s, value);
            }

            if (run_queue) {
              for (let i = 0; i < subscriber_queue.length; i += 2) {
                subscriber_queue[i][0](subscriber_queue[i + 1]);
              }

              subscriber_queue.length = 0;
            }
          }
        }
      }

      function update(fn) {
        set(fn(value));
      }

      function subscribe(run, invalidate = noop) {
        const subscriber = [run, invalidate];
        subscribers.push(subscriber);

        if (subscribers.length === 1) {
          stop = start(set) || noop;
        }

        run(value);
        return () => {
          const index = subscribers.indexOf(subscriber);

          if (index !== -1) {
            subscribers.splice(index, 1);
          }

          if (subscribers.length === 0) {
            stop();
            stop = null;
          }
        };
      }

      return {
        set,
        update,
        subscribe
      };
    }

    var comentarioStore = writable('');

    const localStore = (key, initial) => {
      // receives the key of the local storage and an initial value
      const toString = value => JSON.stringify(value, null, 2); // helper function


      const toObj = JSON.parse; // helper function

      if (localStorage.getItem(key) === null || localStorage.getItem(key) === "") {
        // item not present in local storage
        localStorage.setItem(key, toString(initial)); // initialize local storage with initial value
      }

      const saved = toObj(localStorage.getItem(key)); // convert to object

      const {
        subscribe,
        set,
        update
      } = writable(saved); // create the underlying writable store

      return {
        initial,
        subscribe,
        set: value => {
          // console.log(value)
          localStorage.setItem(key, toString(Object.assign(initial, value))); // save also to local storage as a string

          return set(value);
        },
        update
      };
    };

    let configInicial = {
      fondoAburrido: false,
      colorFondo: "#101923",
      usarImagen: false,
      imagen: "/imagenes/rosed.png",
      modoCover: true,
      scrollAncho: false,
      tagClasico: false,
      palabrasHideadas: "",
      usarColorPersonalizado: false,
      colorPersonalizado: 'blue'
    }; // Cargo configuracion gudardada

    var ajustesConfigStore = localStore('ajustes_config', configInicial);

    /* src\components\Tiempo.svelte generated by Svelte v3.29.0 */
    const file$1 = "src\\components\\Tiempo.svelte";

    function create_fragment$1(ctx) {
      let span;
      let t_value =
      /*tiempoRelativo*/
      ctx[1].short + "";
      let t;
      let span_title_value;
      const block = {
        c: function create() {
          span = element("span");
          t = text(t_value);
          attr_dev(span, "title", span_title_value =
          /*tiempoRelativo*/
          ctx[1].long + "\n" + new Date(
          /*date*/
          ctx[0]));
          add_location(span, file$1, 61, 0, 2178);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, span, anchor);
          append_dev(span, t);
        },
        p: function update(ctx, [dirty]) {
          if (dirty &
          /*tiempoRelativo*/
          2 && t_value !== (t_value =
          /*tiempoRelativo*/
          ctx[1].short + "")) set_data_dev(t, t_value);

          if (dirty &
          /*tiempoRelativo, date*/
          3 && span_title_value !== (span_title_value =
          /*tiempoRelativo*/
          ctx[1].long + "\n" + new Date(
          /*date*/
          ctx[0]))) {
            attr_dev(span, "title", span_title_value);
          }
        },
        i: noop,
        o: noop,
        d: function destroy(detaching) {
          if (detaching) detach_dev(span);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$1.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }

    function relativeTime(date, horaActual) {
      if (horaActual == undefined) horaActual = new Date();
      if (typeof date === "string") date = Date.parse(date);
      let current = horaActual.getTime();
      let previous = date;
      const msPerMinute = 60 * 1000;
      const msPerHour = msPerMinute * 60;
      const msPerDay = msPerHour * 24;
      const msPerMonth = msPerDay * 30;
      const msPerYear = msPerDay * 365;
      let elapsed = current - previous;

      if (elapsed < msPerMinute) {
        return {
          short: Math.round(elapsed / 1000) + " s",
          long: Math.round(elapsed / 1000) + " segundos",
          diferencia: elapsed
        };
      } else if (elapsed < msPerHour) {
        return {
          short: Math.round(elapsed / msPerMinute) + " m",
          long: Math.round(elapsed / msPerMinute) + " minutos",
          diferencia: elapsed
        };
      } else if (elapsed < msPerDay) {
        return {
          short: Math.round(elapsed / msPerHour) + " h",
          long: Math.round(elapsed / msPerHour) + " horas",
          diferencia: elapsed
        };
      } else if (elapsed < msPerMonth) {
        return {
          short: Math.round(elapsed / msPerDay) + " d",
          long: Math.round(elapsed / msPerDay) + " dias",
          diferencia: elapsed
        };
      } else if (elapsed < msPerYear) {
        return {
          short: Math.round(elapsed / msPerMonth) + " M",
          long: Math.round(elapsed / msPerMonth) + " meses",
          diferencia: elapsed
        };
      } else {
        return {
          short: Math.round(elapsed / msPerYear) + " a",
          long: Math.round(elapsed / msPerYear) + " años",
          diferencia: elapsed
        };
      }
    }

    function instance$1($$self, $$props, $$invalidate) {
      let {
        $$slots: slots = {},
        $$scope
      } = $$props;
      validate_slots("Tiempo", slots, []);
      let {
        date
      } = $$props;
      let horaActual = new Date();
      setInterval(() => $$invalidate(2, horaActual = new Date()), relativeTime(date, horaActual).diferencia < 60000 ? 1000 : 6000);
      const writable_props = ["date"];
      Object.keys($$props).forEach(key => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Tiempo> was created with unknown prop '${key}'`);
      });

      $$self.$$set = $$props => {
        if ("date" in $$props) $$invalidate(0, date = $$props.date);
      };

      $$self.$capture_state = () => ({
        date,
        horaActual,
        relativeTime,
        tiempoRelativo
      });

      $$self.$inject_state = $$props => {
        if ("date" in $$props) $$invalidate(0, date = $$props.date);
        if ("horaActual" in $$props) $$invalidate(2, horaActual = $$props.horaActual);
        if ("tiempoRelativo" in $$props) $$invalidate(1, tiempoRelativo = $$props.tiempoRelativo);
      };

      let tiempoRelativo;

      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }

      $$self.$$.update = () => {
        if ($$self.$$.dirty &
        /*date, horaActual*/
        5) {
           $$invalidate(1, tiempoRelativo = relativeTime(date, horaActual));
        }
      };

      return [date, tiempoRelativo];
    }

    class Tiempo extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$1, create_fragment$1, safe_not_equal, {
          date: 0
        });
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "Tiempo",
          options,
          id: create_fragment$1.name
        });
        const {
          ctx
        } = this.$$;
        const props = options.props || {};

        if (
        /*date*/
        ctx[0] === undefined && !("date" in props)) {
          console.warn("<Tiempo> was created without expected prop 'date'");
        }
      }

      get date() {
        throw new Error("<Tiempo>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set date(value) {
        throw new Error("<Tiempo>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

    }

    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }

      return obj;
    }

    // Copyright (c) .NET Foundation. All rights reserved.
    // Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.
    var __extends = undefined && undefined.__extends || function () {
      var extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
      };

      return function (d, b) {
        extendStatics(d, b);

        function __() {
          this.constructor = d;
        }

        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    /** Error thrown when an HTTP request fails. */


    var HttpError =
    /** @class */
    function (_super) {
      __extends(HttpError, _super);
      /** Constructs a new instance of {@link @microsoft/signalr.HttpError}.
       *
       * @param {string} errorMessage A descriptive error message.
       * @param {number} statusCode The HTTP status code represented by this error.
       */


      function HttpError(errorMessage, statusCode) {
        var _newTarget = this.constructor;

        var _this = this;

        var trueProto = _newTarget.prototype;
        _this = _super.call(this, errorMessage) || this;
        _this.statusCode = statusCode; // Workaround issue in Typescript compiler
        // https://github.com/Microsoft/TypeScript/issues/13965#issuecomment-278570200

        _this.__proto__ = trueProto;
        return _this;
      }

      return HttpError;
    }(Error);
    /** Error thrown when a timeout elapses. */

    var TimeoutError =
    /** @class */
    function (_super) {
      __extends(TimeoutError, _super);
      /** Constructs a new instance of {@link @microsoft/signalr.TimeoutError}.
       *
       * @param {string} errorMessage A descriptive error message.
       */


      function TimeoutError(errorMessage) {
        var _newTarget = this.constructor;

        if (errorMessage === void 0) {
          errorMessage = "A timeout occurred.";
        }

        var _this = this;

        var trueProto = _newTarget.prototype;
        _this = _super.call(this, errorMessage) || this; // Workaround issue in Typescript compiler
        // https://github.com/Microsoft/TypeScript/issues/13965#issuecomment-278570200

        _this.__proto__ = trueProto;
        return _this;
      }

      return TimeoutError;
    }(Error);
    /** Error thrown when an action is aborted. */

    var AbortError =
    /** @class */
    function (_super) {
      __extends(AbortError, _super);
      /** Constructs a new instance of {@link AbortError}.
       *
       * @param {string} errorMessage A descriptive error message.
       */


      function AbortError(errorMessage) {
        var _newTarget = this.constructor;

        if (errorMessage === void 0) {
          errorMessage = "An abort occurred.";
        }

        var _this = this;

        var trueProto = _newTarget.prototype;
        _this = _super.call(this, errorMessage) || this; // Workaround issue in Typescript compiler
        // https://github.com/Microsoft/TypeScript/issues/13965#issuecomment-278570200

        _this.__proto__ = trueProto;
        return _this;
      }

      return AbortError;
    }(Error);

    // Copyright (c) .NET Foundation. All rights reserved.
    // Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.
    var __assign = undefined && undefined.__assign || Object.assign || function (t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];

        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
      }

      return t;
    };
    /** Represents an HTTP response. */


    var HttpResponse =
    /** @class */
    function () {
      function HttpResponse(statusCode, statusText, content) {
        this.statusCode = statusCode;
        this.statusText = statusText;
        this.content = content;
      }

      return HttpResponse;
    }();
    /** Abstraction over an HTTP client.
     *
     * This class provides an abstraction over an HTTP client so that a different implementation can be provided on different platforms.
     */

    var HttpClient =
    /** @class */
    function () {
      function HttpClient() {}

      HttpClient.prototype.get = function (url, options) {
        return this.send(__assign({}, options, {
          method: "GET",
          url: url
        }));
      };

      HttpClient.prototype.post = function (url, options) {
        return this.send(__assign({}, options, {
          method: "POST",
          url: url
        }));
      };

      HttpClient.prototype.delete = function (url, options) {
        return this.send(__assign({}, options, {
          method: "DELETE",
          url: url
        }));
      };
      /** Gets all cookies that apply to the specified URL.
       *
       * @param url The URL that the cookies are valid for.
       * @returns {string} A string containing all the key-value cookie pairs for the specified URL.
       */
      // @ts-ignore


      HttpClient.prototype.getCookieString = function (url) {
        return "";
      };

      return HttpClient;
    }();

    // Copyright (c) .NET Foundation. All rights reserved.
    // Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.
    // These values are designed to match the ASP.NET Log Levels since that's the pattern we're emulating here.

    /** Indicates the severity of a log message.
     *
     * Log Levels are ordered in increasing severity. So `Debug` is more severe than `Trace`, etc.
     */
    var LogLevel;

    (function (LogLevel) {
      /** Log level for very low severity diagnostic messages. */
      LogLevel[LogLevel["Trace"] = 0] = "Trace";
      /** Log level for low severity diagnostic messages. */

      LogLevel[LogLevel["Debug"] = 1] = "Debug";
      /** Log level for informational diagnostic messages. */

      LogLevel[LogLevel["Information"] = 2] = "Information";
      /** Log level for diagnostic messages that indicate a non-fatal problem. */

      LogLevel[LogLevel["Warning"] = 3] = "Warning";
      /** Log level for diagnostic messages that indicate a failure in the current operation. */

      LogLevel[LogLevel["Error"] = 4] = "Error";
      /** Log level for diagnostic messages that indicate a failure that will terminate the entire application. */

      LogLevel[LogLevel["Critical"] = 5] = "Critical";
      /** The highest possible log level. Used when configuring logging to indicate that no log messages should be emitted. */

      LogLevel[LogLevel["None"] = 6] = "None";
    })(LogLevel || (LogLevel = {}));

    // Copyright (c) .NET Foundation. All rights reserved.
    // Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.

    /** A logger that does nothing when log messages are sent to it. */
    var NullLogger =
    /** @class */
    function () {
      function NullLogger() {}
      /** @inheritDoc */
      // tslint:disable-next-line


      NullLogger.prototype.log = function (_logLevel, _message) {};
      /** The singleton instance of the {@link @microsoft/signalr.NullLogger}. */


      NullLogger.instance = new NullLogger();
      return NullLogger;
    }();

    // Copyright (c) .NET Foundation. All rights reserved.
    // Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.
    var __awaiter = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
      return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }

        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }

        function step(result) {
          result.done ? resolve(result.value) : new P(function (resolve) {
            resolve(result.value);
          }).then(fulfilled, rejected);
        }

        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };

    var __generator = undefined && undefined.__generator || function (thisArg, body) {
      var _ = {
        label: 0,
        sent: function () {
          if (t[0] & 1) throw t[1];
          return t[1];
        },
        trys: [],
        ops: []
      },
          f,
          y,
          t,
          g;
      return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
      }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
        return this;
      }), g;

      function verb(n) {
        return function (v) {
          return step([n, v]);
        };
      }

      function step(op) {
        if (f) throw new TypeError("Generator is already executing.");

        while (_) try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];

          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;

            case 4:
              _.label++;
              return {
                value: op[1],
                done: false
              };

            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;

            case 7:
              op = _.ops.pop();

              _.trys.pop();

              continue;

            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }

              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }

              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }

              if (t && _.label < t[2]) {
                _.label = t[2];

                _.ops.push(op);

                break;
              }

              if (t[2]) _.ops.pop();

              _.trys.pop();

              continue;
          }

          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }

        if (op[0] & 5) throw op[1];
        return {
          value: op[0] ? op[1] : void 0,
          done: true
        };
      }
    };
    /** @private */

    var Arg =
    /** @class */
    function () {
      function Arg() {}

      Arg.isRequired = function (val, name) {
        if (val === null || val === undefined) {
          throw new Error("The '" + name + "' argument is required.");
        }
      };

      Arg.isIn = function (val, values, name) {
        // TypeScript enums have keys for **both** the name and the value of each enum member on the type itself.
        if (!(val in values)) {
          throw new Error("Unknown " + name + " value: " + val + ".");
        }
      };

      return Arg;
    }();
    /** @private */

    var Platform =
    /** @class */
    function () {
      function Platform() {}

      Object.defineProperty(Platform, "isBrowser", {
        get: function () {
          return typeof window === "object";
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(Platform, "isWebWorker", {
        get: function () {
          return typeof self === "object" && "importScripts" in self;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(Platform, "isNode", {
        get: function () {
          return !this.isBrowser && !this.isWebWorker;
        },
        enumerable: true,
        configurable: true
      });
      return Platform;
    }();
    /** @private */

    function getDataDetail(data, includeContent) {
      var detail = "";

      if (isArrayBuffer(data)) {
        detail = "Binary data of length " + data.byteLength;

        if (includeContent) {
          detail += ". Content: '" + formatArrayBuffer(data) + "'";
        }
      } else if (typeof data === "string") {
        detail = "String data of length " + data.length;

        if (includeContent) {
          detail += ". Content: '" + data + "'";
        }
      }

      return detail;
    }
    /** @private */

    function formatArrayBuffer(data) {
      var view = new Uint8Array(data); // Uint8Array.map only supports returning another Uint8Array?

      var str = "";
      view.forEach(function (num) {
        var pad = num < 16 ? "0" : "";
        str += "0x" + pad + num.toString(16) + " ";
      }); // Trim of trailing space.

      return str.substr(0, str.length - 1);
    } // Also in signalr-protocol-msgpack/Utils.ts

    /** @private */

    function isArrayBuffer(val) {
      return val && typeof ArrayBuffer !== "undefined" && (val instanceof ArrayBuffer || // Sometimes we get an ArrayBuffer that doesn't satisfy instanceof
      val.constructor && val.constructor.name === "ArrayBuffer");
    }
    /** @private */

    function sendMessage(logger, transportName, httpClient, url, accessTokenFactory, content, logMessageContent) {
      return __awaiter(this, void 0, void 0, function () {
        var _a, headers, token, responseType, response;

        return __generator(this, function (_b) {
          switch (_b.label) {
            case 0:
              if (!accessTokenFactory) return [3
              /*break*/
              , 2];
              return [4
              /*yield*/
              , accessTokenFactory()];

            case 1:
              token = _b.sent();

              if (token) {
                headers = (_a = {}, _a["Authorization"] = "Bearer " + token, _a);
              }

              _b.label = 2;

            case 2:
              logger.log(LogLevel.Trace, "(" + transportName + " transport) sending data. " + getDataDetail(content, logMessageContent) + ".");
              responseType = isArrayBuffer(content) ? "arraybuffer" : "text";
              return [4
              /*yield*/
              , httpClient.post(url, {
                content: content,
                headers: headers,
                responseType: responseType
              })];

            case 3:
              response = _b.sent();
              logger.log(LogLevel.Trace, "(" + transportName + " transport) request complete. Response status: " + response.statusCode + ".");
              return [2
              /*return*/
              ];
          }
        });
      });
    }
    /** @private */

    function createLogger(logger) {
      if (logger === undefined) {
        return new ConsoleLogger(LogLevel.Information);
      }

      if (logger === null) {
        return NullLogger.instance;
      }

      if (logger.log) {
        return logger;
      }

      return new ConsoleLogger(logger);
    }
    /** @private */

    var SubjectSubscription =
    /** @class */
    function () {
      function SubjectSubscription(subject, observer) {
        this.subject = subject;
        this.observer = observer;
      }

      SubjectSubscription.prototype.dispose = function () {
        var index = this.subject.observers.indexOf(this.observer);

        if (index > -1) {
          this.subject.observers.splice(index, 1);
        }

        if (this.subject.observers.length === 0 && this.subject.cancelCallback) {
          this.subject.cancelCallback().catch(function (_) {});
        }
      };

      return SubjectSubscription;
    }();
    /** @private */

    var ConsoleLogger =
    /** @class */
    function () {
      function ConsoleLogger(minimumLogLevel) {
        this.minimumLogLevel = minimumLogLevel;
        this.outputConsole = console;
      }

      ConsoleLogger.prototype.log = function (logLevel, message) {
        if (logLevel >= this.minimumLogLevel) {
          switch (logLevel) {
            case LogLevel.Critical:
            case LogLevel.Error:
              this.outputConsole.error("[" + new Date().toISOString() + "] " + LogLevel[logLevel] + ": " + message);
              break;

            case LogLevel.Warning:
              this.outputConsole.warn("[" + new Date().toISOString() + "] " + LogLevel[logLevel] + ": " + message);
              break;

            case LogLevel.Information:
              this.outputConsole.info("[" + new Date().toISOString() + "] " + LogLevel[logLevel] + ": " + message);
              break;

            default:
              // console.debug only goes to attached debuggers in Node, so we use console.log for Trace and Debug
              this.outputConsole.log("[" + new Date().toISOString() + "] " + LogLevel[logLevel] + ": " + message);
              break;
          }
        }
      };

      return ConsoleLogger;
    }();

    // Copyright (c) .NET Foundation. All rights reserved.
    // Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.
    var __extends$1 = undefined && undefined.__extends || function () {
      var extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
      };

      return function (d, b) {
        extendStatics(d, b);

        function __() {
          this.constructor = d;
        }

        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();

    var __assign$1 = undefined && undefined.__assign || Object.assign || function (t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];

        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
      }

      return t;
    };
    var requestModule;

    if (typeof XMLHttpRequest === "undefined") {
      // In order to ignore the dynamic require in webpack builds we need to do this magic
      // @ts-ignore: TS doesn't know about these names
      var requireFunc = typeof __webpack_require__ === "function" ? __non_webpack_require__ : require;
      requestModule = requireFunc("request");
    }
    /** @private */


    var NodeHttpClient =
    /** @class */
    function (_super) {
      __extends$1(NodeHttpClient, _super);

      function NodeHttpClient(logger) {
        var _this = _super.call(this) || this;

        if (typeof requestModule === "undefined") {
          throw new Error("The 'request' module could not be loaded.");
        }

        _this.logger = logger;
        _this.cookieJar = requestModule.jar();
        _this.request = requestModule.defaults({
          jar: _this.cookieJar
        });
        return _this;
      }

      NodeHttpClient.prototype.send = function (httpRequest) {
        var _this = this; // Check that abort was not signaled before calling send


        if (httpRequest.abortSignal) {
          if (httpRequest.abortSignal.aborted) {
            return Promise.reject(new AbortError());
          }
        }

        return new Promise(function (resolve, reject) {
          var requestBody;

          if (isArrayBuffer(httpRequest.content)) {
            requestBody = Buffer.from(httpRequest.content);
          } else {
            requestBody = httpRequest.content || "";
          }

          var currentRequest = _this.request(httpRequest.url, {
            body: requestBody,
            // If binary is expected 'null' should be used, otherwise for text 'utf8'
            encoding: httpRequest.responseType === "arraybuffer" ? null : "utf8",
            headers: __assign$1({
              // Tell auth middleware to 401 instead of redirecting
              "X-Requested-With": "XMLHttpRequest"
            }, httpRequest.headers),
            method: httpRequest.method,
            timeout: httpRequest.timeout
          }, function (error, response, body) {
            if (httpRequest.abortSignal) {
              httpRequest.abortSignal.onabort = null;
            }

            if (error) {
              if (error.code === "ETIMEDOUT") {
                _this.logger.log(LogLevel.Warning, "Timeout from HTTP request.");

                reject(new TimeoutError());
              }

              _this.logger.log(LogLevel.Warning, "Error from HTTP request. " + error);

              reject(error);
              return;
            }

            if (response.statusCode >= 200 && response.statusCode < 300) {
              resolve(new HttpResponse(response.statusCode, response.statusMessage || "", body));
            } else {
              reject(new HttpError(response.statusMessage || "", response.statusCode || 0));
            }
          });

          if (httpRequest.abortSignal) {
            httpRequest.abortSignal.onabort = function () {
              currentRequest.abort();
              reject(new AbortError());
            };
          }
        });
      };

      NodeHttpClient.prototype.getCookieString = function (url) {
        return this.cookieJar.getCookieString(url);
      };

      return NodeHttpClient;
    }(HttpClient);

    // Copyright (c) .NET Foundation. All rights reserved.
    // Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.
    var __extends$2 = undefined && undefined.__extends || function () {
      var extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
      };

      return function (d, b) {
        extendStatics(d, b);

        function __() {
          this.constructor = d;
        }

        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();

    var XhrHttpClient =
    /** @class */
    function (_super) {
      __extends$2(XhrHttpClient, _super);

      function XhrHttpClient(logger) {
        var _this = _super.call(this) || this;

        _this.logger = logger;
        return _this;
      }
      /** @inheritDoc */


      XhrHttpClient.prototype.send = function (request) {
        var _this = this; // Check that abort was not signaled before calling send


        if (request.abortSignal && request.abortSignal.aborted) {
          return Promise.reject(new AbortError());
        }

        if (!request.method) {
          return Promise.reject(new Error("No method defined."));
        }

        if (!request.url) {
          return Promise.reject(new Error("No url defined."));
        }

        return new Promise(function (resolve, reject) {
          var xhr = new XMLHttpRequest();
          xhr.open(request.method, request.url, true);
          xhr.withCredentials = true;
          xhr.setRequestHeader("X-Requested-With", "XMLHttpRequest"); // Explicitly setting the Content-Type header for React Native on Android platform.

          xhr.setRequestHeader("Content-Type", "text/plain;charset=UTF-8");
          var headers = request.headers;

          if (headers) {
            Object.keys(headers).forEach(function (header) {
              xhr.setRequestHeader(header, headers[header]);
            });
          }

          if (request.responseType) {
            xhr.responseType = request.responseType;
          }

          if (request.abortSignal) {
            request.abortSignal.onabort = function () {
              xhr.abort();
              reject(new AbortError());
            };
          }

          if (request.timeout) {
            xhr.timeout = request.timeout;
          }

          xhr.onload = function () {
            if (request.abortSignal) {
              request.abortSignal.onabort = null;
            }

            if (xhr.status >= 200 && xhr.status < 300) {
              resolve(new HttpResponse(xhr.status, xhr.statusText, xhr.response || xhr.responseText));
            } else {
              reject(new HttpError(xhr.statusText, xhr.status));
            }
          };

          xhr.onerror = function () {
            _this.logger.log(LogLevel.Warning, "Error from HTTP request. " + xhr.status + ": " + xhr.statusText + ".");

            reject(new HttpError(xhr.statusText, xhr.status));
          };

          xhr.ontimeout = function () {
            _this.logger.log(LogLevel.Warning, "Timeout from HTTP request.");

            reject(new TimeoutError());
          };

          xhr.send(request.content || "");
        });
      };

      return XhrHttpClient;
    }(HttpClient);

    // Copyright (c) .NET Foundation. All rights reserved.
    // Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.
    var __extends$3 = undefined && undefined.__extends || function () {
      var extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
      };

      return function (d, b) {
        extendStatics(d, b);

        function __() {
          this.constructor = d;
        }

        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    /** Default implementation of {@link @microsoft/signalr.HttpClient}. */

    var DefaultHttpClient =
    /** @class */
    function (_super) {
      __extends$3(DefaultHttpClient, _super);
      /** Creates a new instance of the {@link @microsoft/signalr.DefaultHttpClient}, using the provided {@link @microsoft/signalr.ILogger} to log messages. */


      function DefaultHttpClient(logger) {
        var _this = _super.call(this) || this;

        if (typeof XMLHttpRequest !== "undefined") {
          _this.httpClient = new XhrHttpClient(logger);
        } else {
          _this.httpClient = new NodeHttpClient(logger);
        }

        return _this;
      }
      /** @inheritDoc */


      DefaultHttpClient.prototype.send = function (request) {
        // Check that abort was not signaled before calling send
        if (request.abortSignal && request.abortSignal.aborted) {
          return Promise.reject(new AbortError());
        }

        if (!request.method) {
          return Promise.reject(new Error("No method defined."));
        }

        if (!request.url) {
          return Promise.reject(new Error("No url defined."));
        }

        return this.httpClient.send(request);
      };

      DefaultHttpClient.prototype.getCookieString = function (url) {
        return this.httpClient.getCookieString(url);
      };

      return DefaultHttpClient;
    }(HttpClient);

    // Copyright (c) .NET Foundation. All rights reserved.
    // Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.
    // Not exported from index

    /** @private */
    var TextMessageFormat =
    /** @class */
    function () {
      function TextMessageFormat() {}

      TextMessageFormat.write = function (output) {
        return "" + output + TextMessageFormat.RecordSeparator;
      };

      TextMessageFormat.parse = function (input) {
        if (input[input.length - 1] !== TextMessageFormat.RecordSeparator) {
          throw new Error("Message is incomplete.");
        }

        var messages = input.split(TextMessageFormat.RecordSeparator);
        messages.pop();
        return messages;
      };

      TextMessageFormat.RecordSeparatorCode = 0x1e;
      TextMessageFormat.RecordSeparator = String.fromCharCode(TextMessageFormat.RecordSeparatorCode);
      return TextMessageFormat;
    }();

    // Copyright (c) .NET Foundation. All rights reserved.
    /** @private */

    var HandshakeProtocol =
    /** @class */
    function () {
      function HandshakeProtocol() {} // Handshake request is always JSON


      HandshakeProtocol.prototype.writeHandshakeRequest = function (handshakeRequest) {
        return TextMessageFormat.write(JSON.stringify(handshakeRequest));
      };

      HandshakeProtocol.prototype.parseHandshakeResponse = function (data) {
        var responseMessage;
        var messageData;
        var remainingData;

        if (isArrayBuffer(data) || typeof Buffer !== "undefined" && data instanceof Buffer) {
          // Format is binary but still need to read JSON text from handshake response
          var binaryData = new Uint8Array(data);
          var separatorIndex = binaryData.indexOf(TextMessageFormat.RecordSeparatorCode);

          if (separatorIndex === -1) {
            throw new Error("Message is incomplete.");
          } // content before separator is handshake response
          // optional content after is additional messages


          var responseLength = separatorIndex + 1;
          messageData = String.fromCharCode.apply(null, binaryData.slice(0, responseLength));
          remainingData = binaryData.byteLength > responseLength ? binaryData.slice(responseLength).buffer : null;
        } else {
          var textData = data;
          var separatorIndex = textData.indexOf(TextMessageFormat.RecordSeparator);

          if (separatorIndex === -1) {
            throw new Error("Message is incomplete.");
          } // content before separator is handshake response
          // optional content after is additional messages


          var responseLength = separatorIndex + 1;
          messageData = textData.substring(0, responseLength);
          remainingData = textData.length > responseLength ? textData.substring(responseLength) : null;
        } // At this point we should have just the single handshake message


        var messages = TextMessageFormat.parse(messageData);
        var response = JSON.parse(messages[0]);

        if (response.type) {
          throw new Error("Expected a handshake response from the server.");
        }

        responseMessage = response; // multiple messages could have arrived with handshake
        // return additional data to be parsed as usual, or null if all parsed

        return [remainingData, responseMessage];
      };

      return HandshakeProtocol;
    }();

    // Copyright (c) .NET Foundation. All rights reserved.
    // Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.

    /** Defines the type of a Hub Message. */
    var MessageType;

    (function (MessageType) {
      /** Indicates the message is an Invocation message and implements the {@link @microsoft/signalr.InvocationMessage} interface. */
      MessageType[MessageType["Invocation"] = 1] = "Invocation";
      /** Indicates the message is a StreamItem message and implements the {@link @microsoft/signalr.StreamItemMessage} interface. */

      MessageType[MessageType["StreamItem"] = 2] = "StreamItem";
      /** Indicates the message is a Completion message and implements the {@link @microsoft/signalr.CompletionMessage} interface. */

      MessageType[MessageType["Completion"] = 3] = "Completion";
      /** Indicates the message is a Stream Invocation message and implements the {@link @microsoft/signalr.StreamInvocationMessage} interface. */

      MessageType[MessageType["StreamInvocation"] = 4] = "StreamInvocation";
      /** Indicates the message is a Cancel Invocation message and implements the {@link @microsoft/signalr.CancelInvocationMessage} interface. */

      MessageType[MessageType["CancelInvocation"] = 5] = "CancelInvocation";
      /** Indicates the message is a Ping message and implements the {@link @microsoft/signalr.PingMessage} interface. */

      MessageType[MessageType["Ping"] = 6] = "Ping";
      /** Indicates the message is a Close message and implements the {@link @microsoft/signalr.CloseMessage} interface. */

      MessageType[MessageType["Close"] = 7] = "Close";
    })(MessageType || (MessageType = {}));

    // Copyright (c) .NET Foundation. All rights reserved.
    /** Stream implementation to stream items to the server. */

    var Subject =
    /** @class */
    function () {
      function Subject() {
        this.observers = [];
      }

      Subject.prototype.next = function (item) {
        for (var _i = 0, _a = this.observers; _i < _a.length; _i++) {
          var observer = _a[_i];
          observer.next(item);
        }
      };

      Subject.prototype.error = function (err) {
        for (var _i = 0, _a = this.observers; _i < _a.length; _i++) {
          var observer = _a[_i];

          if (observer.error) {
            observer.error(err);
          }
        }
      };

      Subject.prototype.complete = function () {
        for (var _i = 0, _a = this.observers; _i < _a.length; _i++) {
          var observer = _a[_i];

          if (observer.complete) {
            observer.complete();
          }
        }
      };

      Subject.prototype.subscribe = function (observer) {
        this.observers.push(observer);
        return new SubjectSubscription(this, observer);
      };

      return Subject;
    }();

    // Copyright (c) .NET Foundation. All rights reserved.
    // Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.
    var __awaiter$1 = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
      return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }

        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }

        function step(result) {
          result.done ? resolve(result.value) : new P(function (resolve) {
            resolve(result.value);
          }).then(fulfilled, rejected);
        }

        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };

    var __generator$1 = undefined && undefined.__generator || function (thisArg, body) {
      var _ = {
        label: 0,
        sent: function () {
          if (t[0] & 1) throw t[1];
          return t[1];
        },
        trys: [],
        ops: []
      },
          f,
          y,
          t,
          g;
      return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
      }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
        return this;
      }), g;

      function verb(n) {
        return function (v) {
          return step([n, v]);
        };
      }

      function step(op) {
        if (f) throw new TypeError("Generator is already executing.");

        while (_) try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];

          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;

            case 4:
              _.label++;
              return {
                value: op[1],
                done: false
              };

            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;

            case 7:
              op = _.ops.pop();

              _.trys.pop();

              continue;

            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }

              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }

              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }

              if (t && _.label < t[2]) {
                _.label = t[2];

                _.ops.push(op);

                break;
              }

              if (t[2]) _.ops.pop();

              _.trys.pop();

              continue;
          }

          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }

        if (op[0] & 5) throw op[1];
        return {
          value: op[0] ? op[1] : void 0,
          done: true
        };
      }
    };
    var DEFAULT_TIMEOUT_IN_MS = 30 * 1000;
    var DEFAULT_PING_INTERVAL_IN_MS = 15 * 1000;
    /** Describes the current state of the {@link HubConnection} to the server. */

    var HubConnectionState;

    (function (HubConnectionState) {
      /** The hub connection is disconnected. */
      HubConnectionState["Disconnected"] = "Disconnected";
      /** The hub connection is connecting. */

      HubConnectionState["Connecting"] = "Connecting";
      /** The hub connection is connected. */

      HubConnectionState["Connected"] = "Connected";
      /** The hub connection is disconnecting. */

      HubConnectionState["Disconnecting"] = "Disconnecting";
      /** The hub connection is reconnecting. */

      HubConnectionState["Reconnecting"] = "Reconnecting";
    })(HubConnectionState || (HubConnectionState = {}));
    /** Represents a connection to a SignalR Hub. */


    var HubConnection =
    /** @class */
    function () {
      function HubConnection(connection, logger, protocol, reconnectPolicy) {
        var _this = this;

        Arg.isRequired(connection, "connection");
        Arg.isRequired(logger, "logger");
        Arg.isRequired(protocol, "protocol");
        this.serverTimeoutInMilliseconds = DEFAULT_TIMEOUT_IN_MS;
        this.keepAliveIntervalInMilliseconds = DEFAULT_PING_INTERVAL_IN_MS;
        this.logger = logger;
        this.protocol = protocol;
        this.connection = connection;
        this.reconnectPolicy = reconnectPolicy;
        this.handshakeProtocol = new HandshakeProtocol();

        this.connection.onreceive = function (data) {
          return _this.processIncomingData(data);
        };

        this.connection.onclose = function (error) {
          return _this.connectionClosed(error);
        };

        this.callbacks = {};
        this.methods = {};
        this.closedCallbacks = [];
        this.reconnectingCallbacks = [];
        this.reconnectedCallbacks = [];
        this.invocationId = 0;
        this.receivedHandshakeResponse = false;
        this.connectionState = HubConnectionState.Disconnected;
        this.connectionStarted = false;
        this.cachedPingMessage = this.protocol.writeMessage({
          type: MessageType.Ping
        });
      }
      /** @internal */
      // Using a public static factory method means we can have a private constructor and an _internal_
      // create method that can be used by HubConnectionBuilder. An "internal" constructor would just
      // be stripped away and the '.d.ts' file would have no constructor, which is interpreted as a
      // public parameter-less constructor.


      HubConnection.create = function (connection, logger, protocol, reconnectPolicy) {
        return new HubConnection(connection, logger, protocol, reconnectPolicy);
      };

      Object.defineProperty(HubConnection.prototype, "state", {
        /** Indicates the state of the {@link HubConnection} to the server. */
        get: function () {
          return this.connectionState;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(HubConnection.prototype, "connectionId", {
        /** Represents the connection id of the {@link HubConnection} on the server. The connection id will be null when the connection is either
         *  in the disconnected state or if the negotiation step was skipped.
         */
        get: function () {
          return this.connection ? this.connection.connectionId || null : null;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(HubConnection.prototype, "baseUrl", {
        /** Indicates the url of the {@link HubConnection} to the server. */
        get: function () {
          return this.connection.baseUrl || "";
        },

        /**
         * Sets a new url for the HubConnection. Note that the url can only be changed when the connection is in either the Disconnected or
         * Reconnecting states.
         * @param {string} url The url to connect to.
         */
        set: function (url) {
          if (this.connectionState !== HubConnectionState.Disconnected && this.connectionState !== HubConnectionState.Reconnecting) {
            throw new Error("The HubConnection must be in the Disconnected or Reconnecting state to change the url.");
          }

          if (!url) {
            throw new Error("The HubConnection url must be a valid url.");
          }

          this.connection.baseUrl = url;
        },
        enumerable: true,
        configurable: true
      });
      /** Starts the connection.
       *
       * @returns {Promise<void>} A Promise that resolves when the connection has been successfully established, or rejects with an error.
       */

      HubConnection.prototype.start = function () {
        this.startPromise = this.startWithStateTransitions();
        return this.startPromise;
      };

      HubConnection.prototype.startWithStateTransitions = function () {
        return __awaiter$1(this, void 0, void 0, function () {
          var e_1;
          return __generator$1(this, function (_a) {
            switch (_a.label) {
              case 0:
                if (this.connectionState !== HubConnectionState.Disconnected) {
                  return [2
                  /*return*/
                  , Promise.reject(new Error("Cannot start a HubConnection that is not in the 'Disconnected' state."))];
                }

                this.connectionState = HubConnectionState.Connecting;
                this.logger.log(LogLevel.Debug, "Starting HubConnection.");
                _a.label = 1;

              case 1:
                _a.trys.push([1, 3,, 4]);

                return [4
                /*yield*/
                , this.startInternal()];

              case 2:
                _a.sent();

                this.connectionState = HubConnectionState.Connected;
                this.connectionStarted = true;
                this.logger.log(LogLevel.Debug, "HubConnection connected successfully.");
                return [3
                /*break*/
                , 4];

              case 3:
                e_1 = _a.sent();
                this.connectionState = HubConnectionState.Disconnected;
                this.logger.log(LogLevel.Debug, "HubConnection failed to start successfully because of error '" + e_1 + "'.");
                return [2
                /*return*/
                , Promise.reject(e_1)];

              case 4:
                return [2
                /*return*/
                ];
            }
          });
        });
      };

      HubConnection.prototype.startInternal = function () {
        return __awaiter$1(this, void 0, void 0, function () {
          var handshakePromise, handshakeRequest, e_2;

          var _this = this;

          return __generator$1(this, function (_a) {
            switch (_a.label) {
              case 0:
                this.stopDuringStartError = undefined;
                this.receivedHandshakeResponse = false;
                handshakePromise = new Promise(function (resolve, reject) {
                  _this.handshakeResolver = resolve;
                  _this.handshakeRejecter = reject;
                });
                return [4
                /*yield*/
                , this.connection.start(this.protocol.transferFormat)];

              case 1:
                _a.sent();

                _a.label = 2;

              case 2:
                _a.trys.push([2, 5,, 7]);

                handshakeRequest = {
                  protocol: this.protocol.name,
                  version: this.protocol.version
                };
                this.logger.log(LogLevel.Debug, "Sending handshake request.");
                return [4
                /*yield*/
                , this.sendMessage(this.handshakeProtocol.writeHandshakeRequest(handshakeRequest))];

              case 3:
                _a.sent();

                this.logger.log(LogLevel.Information, "Using HubProtocol '" + this.protocol.name + "'."); // defensively cleanup timeout in case we receive a message from the server before we finish start

                this.cleanupTimeout();
                this.resetTimeoutPeriod();
                this.resetKeepAliveInterval();
                return [4
                /*yield*/
                , handshakePromise];

              case 4:
                _a.sent(); // It's important to check the stopDuringStartError instead of just relying on the handshakePromise
                // being rejected on close, because this continuation can run after both the handshake completed successfully
                // and the connection was closed.


                if (this.stopDuringStartError) {
                  // It's important to throw instead of returning a rejected promise, because we don't want to allow any state
                  // transitions to occur between now and the calling code observing the exceptions. Returning a rejected promise
                  // will cause the calling continuation to get scheduled to run later.
                  throw this.stopDuringStartError;
                }

                return [3
                /*break*/
                , 7];

              case 5:
                e_2 = _a.sent();
                this.logger.log(LogLevel.Debug, "Hub handshake failed with error '" + e_2 + "' during start(). Stopping HubConnection.");
                this.cleanupTimeout();
                this.cleanupPingTimer(); // HttpConnection.stop() should not complete until after the onclose callback is invoked.
                // This will transition the HubConnection to the disconnected state before HttpConnection.stop() completes.

                return [4
                /*yield*/
                , this.connection.stop(e_2)];

              case 6:
                // HttpConnection.stop() should not complete until after the onclose callback is invoked.
                // This will transition the HubConnection to the disconnected state before HttpConnection.stop() completes.
                _a.sent();

                throw e_2;

              case 7:
                return [2
                /*return*/
                ];
            }
          });
        });
      };
      /** Stops the connection.
       *
       * @returns {Promise<void>} A Promise that resolves when the connection has been successfully terminated, or rejects with an error.
       */


      HubConnection.prototype.stop = function () {
        return __awaiter$1(this, void 0, void 0, function () {
          var startPromise, e_3;
          return __generator$1(this, function (_a) {
            switch (_a.label) {
              case 0:
                startPromise = this.startPromise;
                this.stopPromise = this.stopInternal();
                return [4
                /*yield*/
                , this.stopPromise];

              case 1:
                _a.sent();

                _a.label = 2;

              case 2:
                _a.trys.push([2, 4,, 5]); // Awaiting undefined continues immediately


                return [4
                /*yield*/
                , startPromise];

              case 3:
                // Awaiting undefined continues immediately
                _a.sent();

                return [3
                /*break*/
                , 5];

              case 4:
                e_3 = _a.sent();
                return [3
                /*break*/
                , 5];

              case 5:
                return [2
                /*return*/
                ];
            }
          });
        });
      };

      HubConnection.prototype.stopInternal = function (error) {
        if (this.connectionState === HubConnectionState.Disconnected) {
          this.logger.log(LogLevel.Debug, "Call to HubConnection.stop(" + error + ") ignored because it is already in the disconnected state.");
          return Promise.resolve();
        }

        if (this.connectionState === HubConnectionState.Disconnecting) {
          this.logger.log(LogLevel.Debug, "Call to HttpConnection.stop(" + error + ") ignored because the connection is already in the disconnecting state.");
          return this.stopPromise;
        }

        this.connectionState = HubConnectionState.Disconnecting;
        this.logger.log(LogLevel.Debug, "Stopping HubConnection.");

        if (this.reconnectDelayHandle) {
          // We're in a reconnect delay which means the underlying connection is currently already stopped.
          // Just clear the handle to stop the reconnect loop (which no one is waiting on thankfully) and
          // fire the onclose callbacks.
          this.logger.log(LogLevel.Debug, "Connection stopped during reconnect delay. Done reconnecting.");
          clearTimeout(this.reconnectDelayHandle);
          this.reconnectDelayHandle = undefined;
          this.completeClose();
          return Promise.resolve();
        }

        this.cleanupTimeout();
        this.cleanupPingTimer();
        this.stopDuringStartError = error || new Error("The connection was stopped before the hub handshake could complete."); // HttpConnection.stop() should not complete until after either HttpConnection.start() fails
        // or the onclose callback is invoked. The onclose callback will transition the HubConnection
        // to the disconnected state if need be before HttpConnection.stop() completes.

        return this.connection.stop(error);
      };
      /** Invokes a streaming hub method on the server using the specified name and arguments.
       *
       * @typeparam T The type of the items returned by the server.
       * @param {string} methodName The name of the server method to invoke.
       * @param {any[]} args The arguments used to invoke the server method.
       * @returns {IStreamResult<T>} An object that yields results from the server as they are received.
       */


      HubConnection.prototype.stream = function (methodName) {
        var _this = this;

        var args = [];

        for (var _i = 1; _i < arguments.length; _i++) {
          args[_i - 1] = arguments[_i];
        }

        var _a = this.replaceStreamingParams(args),
            streams = _a[0],
            streamIds = _a[1];

        var invocationDescriptor = this.createStreamInvocation(methodName, args, streamIds);
        var promiseQueue;
        var subject = new Subject();

        subject.cancelCallback = function () {
          var cancelInvocation = _this.createCancelInvocation(invocationDescriptor.invocationId);

          delete _this.callbacks[invocationDescriptor.invocationId];
          return promiseQueue.then(function () {
            return _this.sendWithProtocol(cancelInvocation);
          });
        };

        this.callbacks[invocationDescriptor.invocationId] = function (invocationEvent, error) {
          if (error) {
            subject.error(error);
            return;
          } else if (invocationEvent) {
            // invocationEvent will not be null when an error is not passed to the callback
            if (invocationEvent.type === MessageType.Completion) {
              if (invocationEvent.error) {
                subject.error(new Error(invocationEvent.error));
              } else {
                subject.complete();
              }
            } else {
              subject.next(invocationEvent.item);
            }
          }
        };

        promiseQueue = this.sendWithProtocol(invocationDescriptor).catch(function (e) {
          subject.error(e);
          delete _this.callbacks[invocationDescriptor.invocationId];
        });
        this.launchStreams(streams, promiseQueue);
        return subject;
      };

      HubConnection.prototype.sendMessage = function (message) {
        this.resetKeepAliveInterval();
        return this.connection.send(message);
      };
      /**
       * Sends a js object to the server.
       * @param message The js object to serialize and send.
       */


      HubConnection.prototype.sendWithProtocol = function (message) {
        return this.sendMessage(this.protocol.writeMessage(message));
      };
      /** Invokes a hub method on the server using the specified name and arguments. Does not wait for a response from the receiver.
       *
       * The Promise returned by this method resolves when the client has sent the invocation to the server. The server may still
       * be processing the invocation.
       *
       * @param {string} methodName The name of the server method to invoke.
       * @param {any[]} args The arguments used to invoke the server method.
       * @returns {Promise<void>} A Promise that resolves when the invocation has been successfully sent, or rejects with an error.
       */


      HubConnection.prototype.send = function (methodName) {
        var args = [];

        for (var _i = 1; _i < arguments.length; _i++) {
          args[_i - 1] = arguments[_i];
        }

        var _a = this.replaceStreamingParams(args),
            streams = _a[0],
            streamIds = _a[1];

        var sendPromise = this.sendWithProtocol(this.createInvocation(methodName, args, true, streamIds));
        this.launchStreams(streams, sendPromise);
        return sendPromise;
      };
      /** Invokes a hub method on the server using the specified name and arguments.
       *
       * The Promise returned by this method resolves when the server indicates it has finished invoking the method. When the promise
       * resolves, the server has finished invoking the method. If the server method returns a result, it is produced as the result of
       * resolving the Promise.
       *
       * @typeparam T The expected return type.
       * @param {string} methodName The name of the server method to invoke.
       * @param {any[]} args The arguments used to invoke the server method.
       * @returns {Promise<T>} A Promise that resolves with the result of the server method (if any), or rejects with an error.
       */


      HubConnection.prototype.invoke = function (methodName) {
        var _this = this;

        var args = [];

        for (var _i = 1; _i < arguments.length; _i++) {
          args[_i - 1] = arguments[_i];
        }

        var _a = this.replaceStreamingParams(args),
            streams = _a[0],
            streamIds = _a[1];

        var invocationDescriptor = this.createInvocation(methodName, args, false, streamIds);
        var p = new Promise(function (resolve, reject) {
          // invocationId will always have a value for a non-blocking invocation
          _this.callbacks[invocationDescriptor.invocationId] = function (invocationEvent, error) {
            if (error) {
              reject(error);
              return;
            } else if (invocationEvent) {
              // invocationEvent will not be null when an error is not passed to the callback
              if (invocationEvent.type === MessageType.Completion) {
                if (invocationEvent.error) {
                  reject(new Error(invocationEvent.error));
                } else {
                  resolve(invocationEvent.result);
                }
              } else {
                reject(new Error("Unexpected message type: " + invocationEvent.type));
              }
            }
          };

          var promiseQueue = _this.sendWithProtocol(invocationDescriptor).catch(function (e) {
            reject(e); // invocationId will always have a value for a non-blocking invocation

            delete _this.callbacks[invocationDescriptor.invocationId];
          });

          _this.launchStreams(streams, promiseQueue);
        });
        return p;
      };
      /** Registers a handler that will be invoked when the hub method with the specified method name is invoked.
       *
       * @param {string} methodName The name of the hub method to define.
       * @param {Function} newMethod The handler that will be raised when the hub method is invoked.
       */


      HubConnection.prototype.on = function (methodName, newMethod) {
        if (!methodName || !newMethod) {
          return;
        }

        methodName = methodName.toLowerCase();

        if (!this.methods[methodName]) {
          this.methods[methodName] = [];
        } // Preventing adding the same handler multiple times.


        if (this.methods[methodName].indexOf(newMethod) !== -1) {
          return;
        }

        this.methods[methodName].push(newMethod);
      };

      HubConnection.prototype.off = function (methodName, method) {
        if (!methodName) {
          return;
        }

        methodName = methodName.toLowerCase();
        var handlers = this.methods[methodName];

        if (!handlers) {
          return;
        }

        if (method) {
          var removeIdx = handlers.indexOf(method);

          if (removeIdx !== -1) {
            handlers.splice(removeIdx, 1);

            if (handlers.length === 0) {
              delete this.methods[methodName];
            }
          }
        } else {
          delete this.methods[methodName];
        }
      };
      /** Registers a handler that will be invoked when the connection is closed.
       *
       * @param {Function} callback The handler that will be invoked when the connection is closed. Optionally receives a single argument containing the error that caused the connection to close (if any).
       */


      HubConnection.prototype.onclose = function (callback) {
        if (callback) {
          this.closedCallbacks.push(callback);
        }
      };
      /** Registers a handler that will be invoked when the connection starts reconnecting.
       *
       * @param {Function} callback The handler that will be invoked when the connection starts reconnecting. Optionally receives a single argument containing the error that caused the connection to start reconnecting (if any).
       */


      HubConnection.prototype.onreconnecting = function (callback) {
        if (callback) {
          this.reconnectingCallbacks.push(callback);
        }
      };
      /** Registers a handler that will be invoked when the connection successfully reconnects.
       *
       * @param {Function} callback The handler that will be invoked when the connection successfully reconnects.
       */


      HubConnection.prototype.onreconnected = function (callback) {
        if (callback) {
          this.reconnectedCallbacks.push(callback);
        }
      };

      HubConnection.prototype.processIncomingData = function (data) {
        this.cleanupTimeout();

        if (!this.receivedHandshakeResponse) {
          data = this.processHandshakeResponse(data);
          this.receivedHandshakeResponse = true;
        } // Data may have all been read when processing handshake response


        if (data) {
          // Parse the messages
          var messages = this.protocol.parseMessages(data, this.logger);

          for (var _i = 0, messages_1 = messages; _i < messages_1.length; _i++) {
            var message = messages_1[_i];

            switch (message.type) {
              case MessageType.Invocation:
                this.invokeClientMethod(message);
                break;

              case MessageType.StreamItem:
              case MessageType.Completion:
                var callback = this.callbacks[message.invocationId];

                if (callback) {
                  if (message.type === MessageType.Completion) {
                    delete this.callbacks[message.invocationId];
                  }

                  callback(message);
                }

                break;

              case MessageType.Ping:
                // Don't care about pings
                break;

              case MessageType.Close:
                this.logger.log(LogLevel.Information, "Close message received from server.");
                var error = message.error ? new Error("Server returned an error on close: " + message.error) : undefined;

                if (message.allowReconnect === true) {
                  // It feels wrong not to await connection.stop() here, but processIncomingData is called as part of an onreceive callback which is not async,
                  // this is already the behavior for serverTimeout(), and HttpConnection.Stop() should catch and log all possible exceptions.
                  // tslint:disable-next-line:no-floating-promises
                  this.connection.stop(error);
                } else {
                  // We cannot await stopInternal() here, but subsequent calls to stop() will await this if stopInternal() is still ongoing.
                  this.stopPromise = this.stopInternal(error);
                }

                break;

              default:
                this.logger.log(LogLevel.Warning, "Invalid message type: " + message.type + ".");
                break;
            }
          }
        }

        this.resetTimeoutPeriod();
      };

      HubConnection.prototype.processHandshakeResponse = function (data) {
        var _a;

        var responseMessage;
        var remainingData;

        try {
          _a = this.handshakeProtocol.parseHandshakeResponse(data), remainingData = _a[0], responseMessage = _a[1];
        } catch (e) {
          var message = "Error parsing handshake response: " + e;
          this.logger.log(LogLevel.Error, message);
          var error = new Error(message);
          this.handshakeRejecter(error);
          throw error;
        }

        if (responseMessage.error) {
          var message = "Server returned handshake error: " + responseMessage.error;
          this.logger.log(LogLevel.Error, message);
          var error = new Error(message);
          this.handshakeRejecter(error);
          throw error;
        } else {
          this.logger.log(LogLevel.Debug, "Server handshake complete.");
        }

        this.handshakeResolver();
        return remainingData;
      };

      HubConnection.prototype.resetKeepAliveInterval = function () {
        var _this = this;

        this.cleanupPingTimer();
        this.pingServerHandle = setTimeout(function () {
          return __awaiter$1(_this, void 0, void 0, function () {
            var _a;

            return __generator$1(this, function (_b) {
              switch (_b.label) {
                case 0:
                  if (!(this.connectionState === HubConnectionState.Connected)) return [3
                  /*break*/
                  , 4];
                  _b.label = 1;

                case 1:
                  _b.trys.push([1, 3,, 4]);

                  return [4
                  /*yield*/
                  , this.sendMessage(this.cachedPingMessage)];

                case 2:
                  _b.sent();

                  return [3
                  /*break*/
                  , 4];

                case 3:
                  _a = _b.sent(); // We don't care about the error. It should be seen elsewhere in the client.
                  // The connection is probably in a bad or closed state now, cleanup the timer so it stops triggering

                  this.cleanupPingTimer();
                  return [3
                  /*break*/
                  , 4];

                case 4:
                  return [2
                  /*return*/
                  ];
              }
            });
          });
        }, this.keepAliveIntervalInMilliseconds);
      };

      HubConnection.prototype.resetTimeoutPeriod = function () {
        var _this = this;

        if (!this.connection.features || !this.connection.features.inherentKeepAlive) {
          // Set the timeout timer
          this.timeoutHandle = setTimeout(function () {
            return _this.serverTimeout();
          }, this.serverTimeoutInMilliseconds);
        }
      };

      HubConnection.prototype.serverTimeout = function () {
        // The server hasn't talked to us in a while. It doesn't like us anymore ... :(
        // Terminate the connection, but we don't need to wait on the promise. This could trigger reconnecting.
        // tslint:disable-next-line:no-floating-promises
        this.connection.stop(new Error("Server timeout elapsed without receiving a message from the server."));
      };

      HubConnection.prototype.invokeClientMethod = function (invocationMessage) {
        var _this = this;

        var methods = this.methods[invocationMessage.target.toLowerCase()];

        if (methods) {
          try {
            methods.forEach(function (m) {
              return m.apply(_this, invocationMessage.arguments);
            });
          } catch (e) {
            this.logger.log(LogLevel.Error, "A callback for the method " + invocationMessage.target.toLowerCase() + " threw error '" + e + "'.");
          }

          if (invocationMessage.invocationId) {
            // This is not supported in v1. So we return an error to avoid blocking the server waiting for the response.
            var message = "Server requested a response, which is not supported in this version of the client.";
            this.logger.log(LogLevel.Error, message); // We don't want to wait on the stop itself.

            this.stopPromise = this.stopInternal(new Error(message));
          }
        } else {
          this.logger.log(LogLevel.Warning, "No client method with the name '" + invocationMessage.target + "' found.");
        }
      };

      HubConnection.prototype.connectionClosed = function (error) {
        this.logger.log(LogLevel.Debug, "HubConnection.connectionClosed(" + error + ") called while in state " + this.connectionState + "."); // Triggering this.handshakeRejecter is insufficient because it could already be resolved without the continuation having run yet.

        this.stopDuringStartError = this.stopDuringStartError || error || new Error("The underlying connection was closed before the hub handshake could complete."); // If the handshake is in progress, start will be waiting for the handshake promise, so we complete it.
        // If it has already completed, this should just noop.

        if (this.handshakeResolver) {
          this.handshakeResolver();
        }

        this.cancelCallbacksWithError(error || new Error("Invocation canceled due to the underlying connection being closed."));
        this.cleanupTimeout();
        this.cleanupPingTimer();

        if (this.connectionState === HubConnectionState.Disconnecting) {
          this.completeClose(error);
        } else if (this.connectionState === HubConnectionState.Connected && this.reconnectPolicy) {
          // tslint:disable-next-line:no-floating-promises
          this.reconnect(error);
        } else if (this.connectionState === HubConnectionState.Connected) {
          this.completeClose(error);
        } // If none of the above if conditions were true were called the HubConnection must be in either:
        // 1. The Connecting state in which case the handshakeResolver will complete it and stopDuringStartError will fail it.
        // 2. The Reconnecting state in which case the handshakeResolver will complete it and stopDuringStartError will fail the current reconnect attempt
        //    and potentially continue the reconnect() loop.
        // 3. The Disconnected state in which case we're already done.

      };

      HubConnection.prototype.completeClose = function (error) {
        var _this = this;

        if (this.connectionStarted) {
          this.connectionState = HubConnectionState.Disconnected;
          this.connectionStarted = false;

          try {
            this.closedCallbacks.forEach(function (c) {
              return c.apply(_this, [error]);
            });
          } catch (e) {
            this.logger.log(LogLevel.Error, "An onclose callback called with error '" + error + "' threw error '" + e + "'.");
          }
        }
      };

      HubConnection.prototype.reconnect = function (error) {
        return __awaiter$1(this, void 0, void 0, function () {
          var reconnectStartTime, previousReconnectAttempts, retryError, nextRetryDelay, e_4;

          var _this = this;

          return __generator$1(this, function (_a) {
            switch (_a.label) {
              case 0:
                reconnectStartTime = Date.now();
                previousReconnectAttempts = 0;
                retryError = error !== undefined ? error : new Error("Attempting to reconnect due to a unknown error.");
                nextRetryDelay = this.getNextRetryDelay(previousReconnectAttempts++, 0, retryError);

                if (nextRetryDelay === null) {
                  this.logger.log(LogLevel.Debug, "Connection not reconnecting because the IRetryPolicy returned null on the first reconnect attempt.");
                  this.completeClose(error);
                  return [2
                  /*return*/
                  ];
                }

                this.connectionState = HubConnectionState.Reconnecting;

                if (error) {
                  this.logger.log(LogLevel.Information, "Connection reconnecting because of error '" + error + "'.");
                } else {
                  this.logger.log(LogLevel.Information, "Connection reconnecting.");
                }

                if (this.onreconnecting) {
                  try {
                    this.reconnectingCallbacks.forEach(function (c) {
                      return c.apply(_this, [error]);
                    });
                  } catch (e) {
                    this.logger.log(LogLevel.Error, "An onreconnecting callback called with error '" + error + "' threw error '" + e + "'.");
                  } // Exit early if an onreconnecting callback called connection.stop().


                  if (this.connectionState !== HubConnectionState.Reconnecting) {
                    this.logger.log(LogLevel.Debug, "Connection left the reconnecting state in onreconnecting callback. Done reconnecting.");
                    return [2
                    /*return*/
                    ];
                  }
                }

                _a.label = 1;

              case 1:
                if (!(nextRetryDelay !== null)) return [3
                /*break*/
                , 7];
                this.logger.log(LogLevel.Information, "Reconnect attempt number " + previousReconnectAttempts + " will start in " + nextRetryDelay + " ms.");
                return [4
                /*yield*/
                , new Promise(function (resolve) {
                  _this.reconnectDelayHandle = setTimeout(resolve, nextRetryDelay);
                })];

              case 2:
                _a.sent();

                this.reconnectDelayHandle = undefined;

                if (this.connectionState !== HubConnectionState.Reconnecting) {
                  this.logger.log(LogLevel.Debug, "Connection left the reconnecting state during reconnect delay. Done reconnecting.");
                  return [2
                  /*return*/
                  ];
                }

                _a.label = 3;

              case 3:
                _a.trys.push([3, 5,, 6]);

                return [4
                /*yield*/
                , this.startInternal()];

              case 4:
                _a.sent();

                this.connectionState = HubConnectionState.Connected;
                this.logger.log(LogLevel.Information, "HubConnection reconnected successfully.");

                if (this.onreconnected) {
                  try {
                    this.reconnectedCallbacks.forEach(function (c) {
                      return c.apply(_this, [_this.connection.connectionId]);
                    });
                  } catch (e) {
                    this.logger.log(LogLevel.Error, "An onreconnected callback called with connectionId '" + this.connection.connectionId + "; threw error '" + e + "'.");
                  }
                }

                return [2
                /*return*/
                ];

              case 5:
                e_4 = _a.sent();
                this.logger.log(LogLevel.Information, "Reconnect attempt failed because of error '" + e_4 + "'.");

                if (this.connectionState !== HubConnectionState.Reconnecting) {
                  this.logger.log(LogLevel.Debug, "Connection left the reconnecting state during reconnect attempt. Done reconnecting.");
                  return [2
                  /*return*/
                  ];
                }

                retryError = e_4 instanceof Error ? e_4 : new Error(e_4.toString());
                nextRetryDelay = this.getNextRetryDelay(previousReconnectAttempts++, Date.now() - reconnectStartTime, retryError);
                return [3
                /*break*/
                , 6];

              case 6:
                return [3
                /*break*/
                , 1];

              case 7:
                this.logger.log(LogLevel.Information, "Reconnect retries have been exhausted after " + (Date.now() - reconnectStartTime) + " ms and " + previousReconnectAttempts + " failed attempts. Connection disconnecting.");
                this.completeClose();
                return [2
                /*return*/
                ];
            }
          });
        });
      };

      HubConnection.prototype.getNextRetryDelay = function (previousRetryCount, elapsedMilliseconds, retryReason) {
        try {
          return this.reconnectPolicy.nextRetryDelayInMilliseconds({
            elapsedMilliseconds: elapsedMilliseconds,
            previousRetryCount: previousRetryCount,
            retryReason: retryReason
          });
        } catch (e) {
          this.logger.log(LogLevel.Error, "IRetryPolicy.nextRetryDelayInMilliseconds(" + previousRetryCount + ", " + elapsedMilliseconds + ") threw error '" + e + "'.");
          return null;
        }
      };

      HubConnection.prototype.cancelCallbacksWithError = function (error) {
        var callbacks = this.callbacks;
        this.callbacks = {};
        Object.keys(callbacks).forEach(function (key) {
          var callback = callbacks[key];
          callback(null, error);
        });
      };

      HubConnection.prototype.cleanupPingTimer = function () {
        if (this.pingServerHandle) {
          clearTimeout(this.pingServerHandle);
        }
      };

      HubConnection.prototype.cleanupTimeout = function () {
        if (this.timeoutHandle) {
          clearTimeout(this.timeoutHandle);
        }
      };

      HubConnection.prototype.createInvocation = function (methodName, args, nonblocking, streamIds) {
        if (nonblocking) {
          return {
            arguments: args,
            streamIds: streamIds,
            target: methodName,
            type: MessageType.Invocation
          };
        } else {
          var invocationId = this.invocationId;
          this.invocationId++;
          return {
            arguments: args,
            invocationId: invocationId.toString(),
            streamIds: streamIds,
            target: methodName,
            type: MessageType.Invocation
          };
        }
      };

      HubConnection.prototype.launchStreams = function (streams, promiseQueue) {
        var _this = this;

        if (streams.length === 0) {
          return;
        } // Synchronize stream data so they arrive in-order on the server


        if (!promiseQueue) {
          promiseQueue = Promise.resolve();
        }

        var _loop_1 = function (streamId) {
          streams[streamId].subscribe({
            complete: function () {
              promiseQueue = promiseQueue.then(function () {
                return _this.sendWithProtocol(_this.createCompletionMessage(streamId));
              });
            },
            error: function (err) {
              var message;

              if (err instanceof Error) {
                message = err.message;
              } else if (err && err.toString) {
                message = err.toString();
              } else {
                message = "Unknown error";
              }

              promiseQueue = promiseQueue.then(function () {
                return _this.sendWithProtocol(_this.createCompletionMessage(streamId, message));
              });
            },
            next: function (item) {
              promiseQueue = promiseQueue.then(function () {
                return _this.sendWithProtocol(_this.createStreamItemMessage(streamId, item));
              });
            }
          });
        }; // We want to iterate over the keys, since the keys are the stream ids
        // tslint:disable-next-line:forin


        for (var streamId in streams) {
          _loop_1(streamId);
        }
      };

      HubConnection.prototype.replaceStreamingParams = function (args) {
        var streams = [];
        var streamIds = [];

        for (var i = 0; i < args.length; i++) {
          var argument = args[i];

          if (this.isObservable(argument)) {
            var streamId = this.invocationId;
            this.invocationId++; // Store the stream for later use

            streams[streamId] = argument;
            streamIds.push(streamId.toString()); // remove stream from args

            args.splice(i, 1);
          }
        }

        return [streams, streamIds];
      };

      HubConnection.prototype.isObservable = function (arg) {
        // This allows other stream implementations to just work (like rxjs)
        return arg && arg.subscribe && typeof arg.subscribe === "function";
      };

      HubConnection.prototype.createStreamInvocation = function (methodName, args, streamIds) {
        var invocationId = this.invocationId;
        this.invocationId++;
        return {
          arguments: args,
          invocationId: invocationId.toString(),
          streamIds: streamIds,
          target: methodName,
          type: MessageType.StreamInvocation
        };
      };

      HubConnection.prototype.createCancelInvocation = function (id) {
        return {
          invocationId: id,
          type: MessageType.CancelInvocation
        };
      };

      HubConnection.prototype.createStreamItemMessage = function (id, item) {
        return {
          invocationId: id,
          item: item,
          type: MessageType.StreamItem
        };
      };

      HubConnection.prototype.createCompletionMessage = function (id, error, result) {
        if (error) {
          return {
            error: error,
            invocationId: id,
            type: MessageType.Completion
          };
        }

        return {
          invocationId: id,
          result: result,
          type: MessageType.Completion
        };
      };

      return HubConnection;
    }();

    // Copyright (c) .NET Foundation. All rights reserved.
    // Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.
    // 0, 2, 10, 30 second delays before reconnect attempts.
    var DEFAULT_RETRY_DELAYS_IN_MILLISECONDS = [0, 2000, 10000, 30000, null];
    /** @private */

    var DefaultReconnectPolicy =
    /** @class */
    function () {
      function DefaultReconnectPolicy(retryDelays) {
        this.retryDelays = retryDelays !== undefined ? retryDelays.concat([null]) : DEFAULT_RETRY_DELAYS_IN_MILLISECONDS;
      }

      DefaultReconnectPolicy.prototype.nextRetryDelayInMilliseconds = function (retryContext) {
        return this.retryDelays[retryContext.previousRetryCount];
      };

      return DefaultReconnectPolicy;
    }();

    // Copyright (c) .NET Foundation. All rights reserved.
    // Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.
    // This will be treated as a bit flag in the future, so we keep it using power-of-two values.

    /** Specifies a specific HTTP transport type. */
    var HttpTransportType;

    (function (HttpTransportType) {
      /** Specifies no transport preference. */
      HttpTransportType[HttpTransportType["None"] = 0] = "None";
      /** Specifies the WebSockets transport. */

      HttpTransportType[HttpTransportType["WebSockets"] = 1] = "WebSockets";
      /** Specifies the Server-Sent Events transport. */

      HttpTransportType[HttpTransportType["ServerSentEvents"] = 2] = "ServerSentEvents";
      /** Specifies the Long Polling transport. */

      HttpTransportType[HttpTransportType["LongPolling"] = 4] = "LongPolling";
    })(HttpTransportType || (HttpTransportType = {}));
    /** Specifies the transfer format for a connection. */


    var TransferFormat;

    (function (TransferFormat) {
      /** Specifies that only text data will be transmitted over the connection. */
      TransferFormat[TransferFormat["Text"] = 1] = "Text";
      /** Specifies that binary data will be transmitted over the connection. */

      TransferFormat[TransferFormat["Binary"] = 2] = "Binary";
    })(TransferFormat || (TransferFormat = {}));

    // Copyright (c) .NET Foundation. All rights reserved.
    // Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.
    // Rough polyfill of https://developer.mozilla.org/en-US/docs/Web/API/AbortController
    // We don't actually ever use the API being polyfilled, we always use the polyfill because
    // it's a very new API right now.
    // Not exported from index.

    /** @private */
    var AbortController =
    /** @class */
    function () {
      function AbortController() {
        this.isAborted = false;
        this.onabort = null;
      }

      AbortController.prototype.abort = function () {
        if (!this.isAborted) {
          this.isAborted = true;

          if (this.onabort) {
            this.onabort();
          }
        }
      };

      Object.defineProperty(AbortController.prototype, "signal", {
        get: function () {
          return this;
        },
        enumerable: true,
        configurable: true
      });
      Object.defineProperty(AbortController.prototype, "aborted", {
        get: function () {
          return this.isAborted;
        },
        enumerable: true,
        configurable: true
      });
      return AbortController;
    }();

    // Copyright (c) .NET Foundation. All rights reserved.
    // Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.
    var __awaiter$2 = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
      return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }

        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }

        function step(result) {
          result.done ? resolve(result.value) : new P(function (resolve) {
            resolve(result.value);
          }).then(fulfilled, rejected);
        }

        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };

    var __generator$2 = undefined && undefined.__generator || function (thisArg, body) {
      var _ = {
        label: 0,
        sent: function () {
          if (t[0] & 1) throw t[1];
          return t[1];
        },
        trys: [],
        ops: []
      },
          f,
          y,
          t,
          g;
      return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
      }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
        return this;
      }), g;

      function verb(n) {
        return function (v) {
          return step([n, v]);
        };
      }

      function step(op) {
        if (f) throw new TypeError("Generator is already executing.");

        while (_) try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];

          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;

            case 4:
              _.label++;
              return {
                value: op[1],
                done: false
              };

            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;

            case 7:
              op = _.ops.pop();

              _.trys.pop();

              continue;

            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }

              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }

              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }

              if (t && _.label < t[2]) {
                _.label = t[2];

                _.ops.push(op);

                break;
              }

              if (t[2]) _.ops.pop();

              _.trys.pop();

              continue;
          }

          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }

        if (op[0] & 5) throw op[1];
        return {
          value: op[0] ? op[1] : void 0,
          done: true
        };
      }
    };

    /** @private */

    var LongPollingTransport =
    /** @class */
    function () {
      function LongPollingTransport(httpClient, accessTokenFactory, logger, logMessageContent) {
        this.httpClient = httpClient;
        this.accessTokenFactory = accessTokenFactory;
        this.logger = logger;
        this.pollAbort = new AbortController();
        this.logMessageContent = logMessageContent;
        this.running = false;
        this.onreceive = null;
        this.onclose = null;
      }

      Object.defineProperty(LongPollingTransport.prototype, "pollAborted", {
        // This is an internal type, not exported from 'index' so this is really just internal.
        get: function () {
          return this.pollAbort.aborted;
        },
        enumerable: true,
        configurable: true
      });

      LongPollingTransport.prototype.connect = function (url, transferFormat) {
        return __awaiter$2(this, void 0, void 0, function () {
          var pollOptions, token, pollUrl, response;
          return __generator$2(this, function (_a) {
            switch (_a.label) {
              case 0:
                Arg.isRequired(url, "url");
                Arg.isRequired(transferFormat, "transferFormat");
                Arg.isIn(transferFormat, TransferFormat, "transferFormat");
                this.url = url;
                this.logger.log(LogLevel.Trace, "(LongPolling transport) Connecting."); // Allow binary format on Node and Browsers that support binary content (indicated by the presence of responseType property)

                if (transferFormat === TransferFormat.Binary && typeof XMLHttpRequest !== "undefined" && typeof new XMLHttpRequest().responseType !== "string") {
                  throw new Error("Binary protocols over XmlHttpRequest not implementing advanced features are not supported.");
                }

                pollOptions = {
                  abortSignal: this.pollAbort.signal,
                  headers: {},
                  timeout: 100000
                };

                if (transferFormat === TransferFormat.Binary) {
                  pollOptions.responseType = "arraybuffer";
                }

                return [4
                /*yield*/
                , this.getAccessToken()];

              case 1:
                token = _a.sent();
                this.updateHeaderToken(pollOptions, token);
                pollUrl = url + "&_=" + Date.now();
                this.logger.log(LogLevel.Trace, "(LongPolling transport) polling: " + pollUrl + ".");
                return [4
                /*yield*/
                , this.httpClient.get(pollUrl, pollOptions)];

              case 2:
                response = _a.sent();

                if (response.statusCode !== 200) {
                  this.logger.log(LogLevel.Error, "(LongPolling transport) Unexpected response code: " + response.statusCode + "."); // Mark running as false so that the poll immediately ends and runs the close logic

                  this.closeError = new HttpError(response.statusText || "", response.statusCode);
                  this.running = false;
                } else {
                  this.running = true;
                }

                this.receiving = this.poll(this.url, pollOptions);
                return [2
                /*return*/
                ];
            }
          });
        });
      };

      LongPollingTransport.prototype.getAccessToken = function () {
        return __awaiter$2(this, void 0, void 0, function () {
          return __generator$2(this, function (_a) {
            switch (_a.label) {
              case 0:
                if (!this.accessTokenFactory) return [3
                /*break*/
                , 2];
                return [4
                /*yield*/
                , this.accessTokenFactory()];

              case 1:
                return [2
                /*return*/
                , _a.sent()];

              case 2:
                return [2
                /*return*/
                , null];
            }
          });
        });
      };

      LongPollingTransport.prototype.updateHeaderToken = function (request, token) {
        if (!request.headers) {
          request.headers = {};
        }

        if (token) {
          // tslint:disable-next-line:no-string-literal
          request.headers["Authorization"] = "Bearer " + token;
          return;
        } // tslint:disable-next-line:no-string-literal


        if (request.headers["Authorization"]) {
          // tslint:disable-next-line:no-string-literal
          delete request.headers["Authorization"];
        }
      };

      LongPollingTransport.prototype.poll = function (url, pollOptions) {
        return __awaiter$2(this, void 0, void 0, function () {
          var token, pollUrl, response, e_1;
          return __generator$2(this, function (_a) {
            switch (_a.label) {
              case 0:
                _a.trys.push([0,, 8, 9]);

                _a.label = 1;

              case 1:
                if (!this.running) return [3
                /*break*/
                , 7];
                return [4
                /*yield*/
                , this.getAccessToken()];

              case 2:
                token = _a.sent();
                this.updateHeaderToken(pollOptions, token);
                _a.label = 3;

              case 3:
                _a.trys.push([3, 5,, 6]);

                pollUrl = url + "&_=" + Date.now();
                this.logger.log(LogLevel.Trace, "(LongPolling transport) polling: " + pollUrl + ".");
                return [4
                /*yield*/
                , this.httpClient.get(pollUrl, pollOptions)];

              case 4:
                response = _a.sent();

                if (response.statusCode === 204) {
                  this.logger.log(LogLevel.Information, "(LongPolling transport) Poll terminated by server.");
                  this.running = false;
                } else if (response.statusCode !== 200) {
                  this.logger.log(LogLevel.Error, "(LongPolling transport) Unexpected response code: " + response.statusCode + "."); // Unexpected status code

                  this.closeError = new HttpError(response.statusText || "", response.statusCode);
                  this.running = false;
                } else {
                  // Process the response
                  if (response.content) {
                    this.logger.log(LogLevel.Trace, "(LongPolling transport) data received. " + getDataDetail(response.content, this.logMessageContent) + ".");

                    if (this.onreceive) {
                      this.onreceive(response.content);
                    }
                  } else {
                    // This is another way timeout manifest.
                    this.logger.log(LogLevel.Trace, "(LongPolling transport) Poll timed out, reissuing.");
                  }
                }

                return [3
                /*break*/
                , 6];

              case 5:
                e_1 = _a.sent();

                if (!this.running) {
                  // Log but disregard errors that occur after stopping
                  this.logger.log(LogLevel.Trace, "(LongPolling transport) Poll errored after shutdown: " + e_1.message);
                } else {
                  if (e_1 instanceof TimeoutError) {
                    // Ignore timeouts and reissue the poll.
                    this.logger.log(LogLevel.Trace, "(LongPolling transport) Poll timed out, reissuing.");
                  } else {
                    // Close the connection with the error as the result.
                    this.closeError = e_1;
                    this.running = false;
                  }
                }

                return [3
                /*break*/
                , 6];

              case 6:
                return [3
                /*break*/
                , 1];

              case 7:
                return [3
                /*break*/
                , 9];

              case 8:
                this.logger.log(LogLevel.Trace, "(LongPolling transport) Polling complete."); // We will reach here with pollAborted==false when the server returned a response causing the transport to stop.
                // If pollAborted==true then client initiated the stop and the stop method will raise the close event after DELETE is sent.

                if (!this.pollAborted) {
                  this.raiseOnClose();
                }

                return [7
                /*endfinally*/
                ];

              case 9:
                return [2
                /*return*/
                ];
            }
          });
        });
      };

      LongPollingTransport.prototype.send = function (data) {
        return __awaiter$2(this, void 0, void 0, function () {
          return __generator$2(this, function (_a) {
            if (!this.running) {
              return [2
              /*return*/
              , Promise.reject(new Error("Cannot send until the transport is connected"))];
            }

            return [2
            /*return*/
            , sendMessage(this.logger, "LongPolling", this.httpClient, this.url, this.accessTokenFactory, data, this.logMessageContent)];
          });
        });
      };

      LongPollingTransport.prototype.stop = function () {
        return __awaiter$2(this, void 0, void 0, function () {
          var deleteOptions, token;
          return __generator$2(this, function (_a) {
            switch (_a.label) {
              case 0:
                this.logger.log(LogLevel.Trace, "(LongPolling transport) Stopping polling."); // Tell receiving loop to stop, abort any current request, and then wait for it to finish

                this.running = false;
                this.pollAbort.abort();
                _a.label = 1;

              case 1:
                _a.trys.push([1,, 5, 6]);

                return [4
                /*yield*/
                , this.receiving];

              case 2:
                _a.sent(); // Send DELETE to clean up long polling on the server


                this.logger.log(LogLevel.Trace, "(LongPolling transport) sending DELETE request to " + this.url + ".");
                deleteOptions = {
                  headers: {}
                };
                return [4
                /*yield*/
                , this.getAccessToken()];

              case 3:
                token = _a.sent();
                this.updateHeaderToken(deleteOptions, token);
                return [4
                /*yield*/
                , this.httpClient.delete(this.url, deleteOptions)];

              case 4:
                _a.sent();

                this.logger.log(LogLevel.Trace, "(LongPolling transport) DELETE request sent.");
                return [3
                /*break*/
                , 6];

              case 5:
                this.logger.log(LogLevel.Trace, "(LongPolling transport) Stop finished."); // Raise close event here instead of in polling
                // It needs to happen after the DELETE request is sent

                this.raiseOnClose();
                return [7
                /*endfinally*/
                ];

              case 6:
                return [2
                /*return*/
                ];
            }
          });
        });
      };

      LongPollingTransport.prototype.raiseOnClose = function () {
        if (this.onclose) {
          var logMessage = "(LongPolling transport) Firing onclose event.";

          if (this.closeError) {
            logMessage += " Error: " + this.closeError;
          }

          this.logger.log(LogLevel.Trace, logMessage);
          this.onclose(this.closeError);
        }
      };

      return LongPollingTransport;
    }();

    // Copyright (c) .NET Foundation. All rights reserved.
    // Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.
    var __awaiter$3 = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
      return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }

        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }

        function step(result) {
          result.done ? resolve(result.value) : new P(function (resolve) {
            resolve(result.value);
          }).then(fulfilled, rejected);
        }

        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };

    var __generator$3 = undefined && undefined.__generator || function (thisArg, body) {
      var _ = {
        label: 0,
        sent: function () {
          if (t[0] & 1) throw t[1];
          return t[1];
        },
        trys: [],
        ops: []
      },
          f,
          y,
          t,
          g;
      return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
      }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
        return this;
      }), g;

      function verb(n) {
        return function (v) {
          return step([n, v]);
        };
      }

      function step(op) {
        if (f) throw new TypeError("Generator is already executing.");

        while (_) try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];

          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;

            case 4:
              _.label++;
              return {
                value: op[1],
                done: false
              };

            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;

            case 7:
              op = _.ops.pop();

              _.trys.pop();

              continue;

            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }

              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }

              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }

              if (t && _.label < t[2]) {
                _.label = t[2];

                _.ops.push(op);

                break;
              }

              if (t[2]) _.ops.pop();

              _.trys.pop();

              continue;
          }

          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }

        if (op[0] & 5) throw op[1];
        return {
          value: op[0] ? op[1] : void 0,
          done: true
        };
      }
    };
    /** @private */

    var ServerSentEventsTransport =
    /** @class */
    function () {
      function ServerSentEventsTransport(httpClient, accessTokenFactory, logger, logMessageContent, eventSourceConstructor) {
        this.httpClient = httpClient;
        this.accessTokenFactory = accessTokenFactory;
        this.logger = logger;
        this.logMessageContent = logMessageContent;
        this.eventSourceConstructor = eventSourceConstructor;
        this.onreceive = null;
        this.onclose = null;
      }

      ServerSentEventsTransport.prototype.connect = function (url, transferFormat) {
        return __awaiter$3(this, void 0, void 0, function () {
          var token;

          var _this = this;

          return __generator$3(this, function (_a) {
            switch (_a.label) {
              case 0:
                Arg.isRequired(url, "url");
                Arg.isRequired(transferFormat, "transferFormat");
                Arg.isIn(transferFormat, TransferFormat, "transferFormat");
                this.logger.log(LogLevel.Trace, "(SSE transport) Connecting."); // set url before accessTokenFactory because this.url is only for send and we set the auth header instead of the query string for send

                this.url = url;
                if (!this.accessTokenFactory) return [3
                /*break*/
                , 2];
                return [4
                /*yield*/
                , this.accessTokenFactory()];

              case 1:
                token = _a.sent();

                if (token) {
                  url += (url.indexOf("?") < 0 ? "?" : "&") + ("access_token=" + encodeURIComponent(token));
                }

                _a.label = 2;

              case 2:
                return [2
                /*return*/
                , new Promise(function (resolve, reject) {
                  var opened = false;

                  if (transferFormat !== TransferFormat.Text) {
                    reject(new Error("The Server-Sent Events transport only supports the 'Text' transfer format"));
                    return;
                  }

                  var eventSource;

                  if (Platform.isBrowser || Platform.isWebWorker) {
                    eventSource = new _this.eventSourceConstructor(url, {
                      withCredentials: true
                    });
                  } else {
                    // Non-browser passes cookies via the dictionary
                    var cookies = _this.httpClient.getCookieString(url);

                    eventSource = new _this.eventSourceConstructor(url, {
                      withCredentials: true,
                      headers: {
                        Cookie: cookies
                      }
                    });
                  }

                  try {
                    eventSource.onmessage = function (e) {
                      if (_this.onreceive) {
                        try {
                          _this.logger.log(LogLevel.Trace, "(SSE transport) data received. " + getDataDetail(e.data, _this.logMessageContent) + ".");

                          _this.onreceive(e.data);
                        } catch (error) {
                          _this.close(error);

                          return;
                        }
                      }
                    };

                    eventSource.onerror = function (e) {
                      var error = new Error(e.data || "Error occurred");

                      if (opened) {
                        _this.close(error);
                      } else {
                        reject(error);
                      }
                    };

                    eventSource.onopen = function () {
                      _this.logger.log(LogLevel.Information, "SSE connected to " + _this.url);

                      _this.eventSource = eventSource;
                      opened = true;
                      resolve();
                    };
                  } catch (e) {
                    reject(e);
                    return;
                  }
                })];
            }
          });
        });
      };

      ServerSentEventsTransport.prototype.send = function (data) {
        return __awaiter$3(this, void 0, void 0, function () {
          return __generator$3(this, function (_a) {
            if (!this.eventSource) {
              return [2
              /*return*/
              , Promise.reject(new Error("Cannot send until the transport is connected"))];
            }

            return [2
            /*return*/
            , sendMessage(this.logger, "SSE", this.httpClient, this.url, this.accessTokenFactory, data, this.logMessageContent)];
          });
        });
      };

      ServerSentEventsTransport.prototype.stop = function () {
        this.close();
        return Promise.resolve();
      };

      ServerSentEventsTransport.prototype.close = function (e) {
        if (this.eventSource) {
          this.eventSource.close();
          this.eventSource = undefined;

          if (this.onclose) {
            this.onclose(e);
          }
        }
      };

      return ServerSentEventsTransport;
    }();

    // Copyright (c) .NET Foundation. All rights reserved.
    // Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.
    var __awaiter$4 = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
      return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }

        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }

        function step(result) {
          result.done ? resolve(result.value) : new P(function (resolve) {
            resolve(result.value);
          }).then(fulfilled, rejected);
        }

        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };

    var __generator$4 = undefined && undefined.__generator || function (thisArg, body) {
      var _ = {
        label: 0,
        sent: function () {
          if (t[0] & 1) throw t[1];
          return t[1];
        },
        trys: [],
        ops: []
      },
          f,
          y,
          t,
          g;
      return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
      }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
        return this;
      }), g;

      function verb(n) {
        return function (v) {
          return step([n, v]);
        };
      }

      function step(op) {
        if (f) throw new TypeError("Generator is already executing.");

        while (_) try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];

          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;

            case 4:
              _.label++;
              return {
                value: op[1],
                done: false
              };

            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;

            case 7:
              op = _.ops.pop();

              _.trys.pop();

              continue;

            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }

              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }

              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }

              if (t && _.label < t[2]) {
                _.label = t[2];

                _.ops.push(op);

                break;
              }

              if (t[2]) _.ops.pop();

              _.trys.pop();

              continue;
          }

          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }

        if (op[0] & 5) throw op[1];
        return {
          value: op[0] ? op[1] : void 0,
          done: true
        };
      }
    };
    /** @private */

    var WebSocketTransport =
    /** @class */
    function () {
      function WebSocketTransport(httpClient, accessTokenFactory, logger, logMessageContent, webSocketConstructor) {
        this.logger = logger;
        this.accessTokenFactory = accessTokenFactory;
        this.logMessageContent = logMessageContent;
        this.webSocketConstructor = webSocketConstructor;
        this.httpClient = httpClient;
        this.onreceive = null;
        this.onclose = null;
      }

      WebSocketTransport.prototype.connect = function (url, transferFormat) {
        return __awaiter$4(this, void 0, void 0, function () {
          var token;

          var _this = this;

          return __generator$4(this, function (_a) {
            switch (_a.label) {
              case 0:
                Arg.isRequired(url, "url");
                Arg.isRequired(transferFormat, "transferFormat");
                Arg.isIn(transferFormat, TransferFormat, "transferFormat");
                this.logger.log(LogLevel.Trace, "(WebSockets transport) Connecting.");
                if (!this.accessTokenFactory) return [3
                /*break*/
                , 2];
                return [4
                /*yield*/
                , this.accessTokenFactory()];

              case 1:
                token = _a.sent();

                if (token) {
                  url += (url.indexOf("?") < 0 ? "?" : "&") + ("access_token=" + encodeURIComponent(token));
                }

                _a.label = 2;

              case 2:
                return [2
                /*return*/
                , new Promise(function (resolve, reject) {
                  url = url.replace(/^http/, "ws");
                  var webSocket;

                  var cookies = _this.httpClient.getCookieString(url);

                  var opened = false;

                  if (Platform.isNode && cookies) {
                    // Only pass cookies when in non-browser environments
                    webSocket = new _this.webSocketConstructor(url, undefined, {
                      headers: {
                        Cookie: "" + cookies
                      }
                    });
                  }

                  if (!webSocket) {
                    // Chrome is not happy with passing 'undefined' as protocol
                    webSocket = new _this.webSocketConstructor(url);
                  }

                  if (transferFormat === TransferFormat.Binary) {
                    webSocket.binaryType = "arraybuffer";
                  } // tslint:disable-next-line:variable-name


                  webSocket.onopen = function (_event) {
                    _this.logger.log(LogLevel.Information, "WebSocket connected to " + url + ".");

                    _this.webSocket = webSocket;
                    opened = true;
                    resolve();
                  };

                  webSocket.onerror = function (event) {
                    var error = null; // ErrorEvent is a browser only type we need to check if the type exists before using it

                    if (typeof ErrorEvent !== "undefined" && event instanceof ErrorEvent) {
                      error = event.error;
                    } else {
                      error = new Error("There was an error with the transport.");
                    }

                    reject(error);
                  };

                  webSocket.onmessage = function (message) {
                    _this.logger.log(LogLevel.Trace, "(WebSockets transport) data received. " + getDataDetail(message.data, _this.logMessageContent) + ".");

                    if (_this.onreceive) {
                      _this.onreceive(message.data);
                    }
                  };

                  webSocket.onclose = function (event) {
                    // Don't call close handler if connection was never established
                    // We'll reject the connect call instead
                    if (opened) {
                      _this.close(event);
                    } else {
                      var error = null; // ErrorEvent is a browser only type we need to check if the type exists before using it

                      if (typeof ErrorEvent !== "undefined" && event instanceof ErrorEvent) {
                        error = event.error;
                      } else {
                        error = new Error("There was an error with the transport.");
                      }

                      reject(error);
                    }
                  };
                })];
            }
          });
        });
      };

      WebSocketTransport.prototype.send = function (data) {
        if (this.webSocket && this.webSocket.readyState === this.webSocketConstructor.OPEN) {
          this.logger.log(LogLevel.Trace, "(WebSockets transport) sending data. " + getDataDetail(data, this.logMessageContent) + ".");
          this.webSocket.send(data);
          return Promise.resolve();
        }

        return Promise.reject("WebSocket is not in the OPEN state");
      };

      WebSocketTransport.prototype.stop = function () {
        if (this.webSocket) {
          // Manually invoke onclose callback inline so we know the HttpConnection was closed properly before returning
          // This also solves an issue where websocket.onclose could take 18+ seconds to trigger during network disconnects
          this.close(undefined);
        }

        return Promise.resolve();
      };

      WebSocketTransport.prototype.close = function (event) {
        // webSocket will be null if the transport did not start successfully
        if (this.webSocket) {
          // Clear websocket handlers because we are considering the socket closed now
          this.webSocket.onclose = function () {};

          this.webSocket.onmessage = function () {};

          this.webSocket.onerror = function () {};

          this.webSocket.close();
          this.webSocket = undefined;
        }

        this.logger.log(LogLevel.Trace, "(WebSockets transport) socket closed.");

        if (this.onclose) {
          if (event && (event.wasClean === false || event.code !== 1000)) {
            this.onclose(new Error("WebSocket closed with status code: " + event.code + " (" + event.reason + ")."));
          } else {
            this.onclose();
          }
        }
      };

      return WebSocketTransport;
    }();

    // Copyright (c) .NET Foundation. All rights reserved.
    // Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.
    var __awaiter$5 = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {
      return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }

        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }

        function step(result) {
          result.done ? resolve(result.value) : new P(function (resolve) {
            resolve(result.value);
          }).then(fulfilled, rejected);
        }

        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };

    var __generator$5 = undefined && undefined.__generator || function (thisArg, body) {
      var _ = {
        label: 0,
        sent: function () {
          if (t[0] & 1) throw t[1];
          return t[1];
        },
        trys: [],
        ops: []
      },
          f,
          y,
          t,
          g;
      return g = {
        next: verb(0),
        "throw": verb(1),
        "return": verb(2)
      }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
        return this;
      }), g;

      function verb(n) {
        return function (v) {
          return step([n, v]);
        };
      }

      function step(op) {
        if (f) throw new TypeError("Generator is already executing.");

        while (_) try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];

          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;

            case 4:
              _.label++;
              return {
                value: op[1],
                done: false
              };

            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;

            case 7:
              op = _.ops.pop();

              _.trys.pop();

              continue;

            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }

              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }

              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }

              if (t && _.label < t[2]) {
                _.label = t[2];

                _.ops.push(op);

                break;
              }

              if (t[2]) _.ops.pop();

              _.trys.pop();

              continue;
          }

          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }

        if (op[0] & 5) throw op[1];
        return {
          value: op[0] ? op[1] : void 0,
          done: true
        };
      }
    };
    var MAX_REDIRECTS = 100;
    var WebSocketModule = null;
    var EventSourceModule = null;

    if (Platform.isNode && typeof require !== "undefined") {
      // In order to ignore the dynamic require in webpack builds we need to do this magic
      // @ts-ignore: TS doesn't know about these names
      var requireFunc$1 = typeof __webpack_require__ === "function" ? __non_webpack_require__ : require;
      WebSocketModule = requireFunc$1("ws");
      EventSourceModule = requireFunc$1("eventsource");
    }
    /** @private */


    var HttpConnection =
    /** @class */
    function () {
      function HttpConnection(url, options) {
        if (options === void 0) {
          options = {};
        }

        this.features = {};
        this.negotiateVersion = 1;
        Arg.isRequired(url, "url");
        this.logger = createLogger(options.logger);
        this.baseUrl = this.resolveUrl(url);
        options = options || {};
        options.logMessageContent = options.logMessageContent || false;

        if (!Platform.isNode && typeof WebSocket !== "undefined" && !options.WebSocket) {
          options.WebSocket = WebSocket;
        } else if (Platform.isNode && !options.WebSocket) {
          if (WebSocketModule) {
            options.WebSocket = WebSocketModule;
          }
        }

        if (!Platform.isNode && typeof EventSource !== "undefined" && !options.EventSource) {
          options.EventSource = EventSource;
        } else if (Platform.isNode && !options.EventSource) {
          if (typeof EventSourceModule !== "undefined") {
            options.EventSource = EventSourceModule;
          }
        }

        this.httpClient = options.httpClient || new DefaultHttpClient(this.logger);
        this.connectionState = "Disconnected"
        /* Disconnected */
        ;
        this.connectionStarted = false;
        this.options = options;
        this.onreceive = null;
        this.onclose = null;
      }

      HttpConnection.prototype.start = function (transferFormat) {
        return __awaiter$5(this, void 0, void 0, function () {
          var message, message;
          return __generator$5(this, function (_a) {
            switch (_a.label) {
              case 0:
                transferFormat = transferFormat || TransferFormat.Binary;
                Arg.isIn(transferFormat, TransferFormat, "transferFormat");
                this.logger.log(LogLevel.Debug, "Starting connection with transfer format '" + TransferFormat[transferFormat] + "'.");

                if (this.connectionState !== "Disconnected"
                /* Disconnected */
                ) {
                    return [2
                    /*return*/
                    , Promise.reject(new Error("Cannot start an HttpConnection that is not in the 'Disconnected' state."))];
                  }

                this.connectionState = "Connecting "
                /* Connecting */
                ;
                this.startInternalPromise = this.startInternal(transferFormat);
                return [4
                /*yield*/
                , this.startInternalPromise];

              case 1:
                _a.sent();

                if (!(this.connectionState === "Disconnecting"
                /* Disconnecting */
                )) return [3
                  /*break*/
                  , 3];
                message = "Failed to start the HttpConnection before stop() was called.";
                this.logger.log(LogLevel.Error, message); // We cannot await stopPromise inside startInternal since stopInternal awaits the startInternalPromise.

                return [4
                /*yield*/
                , this.stopPromise];

              case 2:
                // We cannot await stopPromise inside startInternal since stopInternal awaits the startInternalPromise.
                _a.sent();

                return [2
                /*return*/
                , Promise.reject(new Error(message))];

              case 3:
                if (this.connectionState !== "Connected"
                /* Connected */
                ) {
                    message = "HttpConnection.startInternal completed gracefully but didn't enter the connection into the connected state!";
                    this.logger.log(LogLevel.Error, message);
                    return [2
                    /*return*/
                    , Promise.reject(new Error(message))];
                  }

                _a.label = 4;

              case 4:
                this.connectionStarted = true;
                return [2
                /*return*/
                ];
            }
          });
        });
      };

      HttpConnection.prototype.send = function (data) {
        if (this.connectionState !== "Connected"
        /* Connected */
        ) {
            return Promise.reject(new Error("Cannot send data if the connection is not in the 'Connected' State."));
          }

        if (!this.sendQueue) {
          this.sendQueue = new TransportSendQueue(this.transport);
        } // Transport will not be null if state is connected


        return this.sendQueue.send(data);
      };

      HttpConnection.prototype.stop = function (error) {
        return __awaiter$5(this, void 0, void 0, function () {
          var _this = this;

          return __generator$5(this, function (_a) {
            switch (_a.label) {
              case 0:
                if (this.connectionState === "Disconnected"
                /* Disconnected */
                ) {
                    this.logger.log(LogLevel.Debug, "Call to HttpConnection.stop(" + error + ") ignored because the connection is already in the disconnected state.");
                    return [2
                    /*return*/
                    , Promise.resolve()];
                  }

                if (this.connectionState === "Disconnecting"
                /* Disconnecting */
                ) {
                    this.logger.log(LogLevel.Debug, "Call to HttpConnection.stop(" + error + ") ignored because the connection is already in the disconnecting state.");
                    return [2
                    /*return*/
                    , this.stopPromise];
                  }

                this.connectionState = "Disconnecting"
                /* Disconnecting */
                ;
                this.stopPromise = new Promise(function (resolve) {
                  // Don't complete stop() until stopConnection() completes.
                  _this.stopPromiseResolver = resolve;
                }); // stopInternal should never throw so just observe it.

                return [4
                /*yield*/
                , this.stopInternal(error)];

              case 1:
                // stopInternal should never throw so just observe it.
                _a.sent();

                return [4
                /*yield*/
                , this.stopPromise];

              case 2:
                _a.sent();

                return [2
                /*return*/
                ];
            }
          });
        });
      };

      HttpConnection.prototype.stopInternal = function (error) {
        return __awaiter$5(this, void 0, void 0, function () {
          var e_1, e_2;
          return __generator$5(this, function (_a) {
            switch (_a.label) {
              case 0:
                // Set error as soon as possible otherwise there is a race between
                // the transport closing and providing an error and the error from a close message
                // We would prefer the close message error.
                this.stopError = error;
                _a.label = 1;

              case 1:
                _a.trys.push([1, 3,, 4]);

                return [4
                /*yield*/
                , this.startInternalPromise];

              case 2:
                _a.sent();

                return [3
                /*break*/
                , 4];

              case 3:
                e_1 = _a.sent();
                return [3
                /*break*/
                , 4];

              case 4:
                if (!this.transport) return [3
                /*break*/
                , 9];
                _a.label = 5;

              case 5:
                _a.trys.push([5, 7,, 8]);

                return [4
                /*yield*/
                , this.transport.stop()];

              case 6:
                _a.sent();

                return [3
                /*break*/
                , 8];

              case 7:
                e_2 = _a.sent();
                this.logger.log(LogLevel.Error, "HttpConnection.transport.stop() threw error '" + e_2 + "'.");
                this.stopConnection();
                return [3
                /*break*/
                , 8];

              case 8:
                this.transport = undefined;
                return [3
                /*break*/
                , 10];

              case 9:
                this.logger.log(LogLevel.Debug, "HttpConnection.transport is undefined in HttpConnection.stop() because start() failed.");
                this.stopConnection();
                _a.label = 10;

              case 10:
                return [2
                /*return*/
                ];
            }
          });
        });
      };

      HttpConnection.prototype.startInternal = function (transferFormat) {
        return __awaiter$5(this, void 0, void 0, function () {
          var url, negotiateResponse, redirects, _loop_1, this_1, e_3;

          return __generator$5(this, function (_a) {
            switch (_a.label) {
              case 0:
                url = this.baseUrl;
                this.accessTokenFactory = this.options.accessTokenFactory;
                _a.label = 1;

              case 1:
                _a.trys.push([1, 12,, 13]);

                if (!this.options.skipNegotiation) return [3
                /*break*/
                , 5];
                if (!(this.options.transport === HttpTransportType.WebSockets)) return [3
                /*break*/
                , 3]; // No need to add a connection ID in this case

                this.transport = this.constructTransport(HttpTransportType.WebSockets); // We should just call connect directly in this case.
                // No fallback or negotiate in this case.

                return [4
                /*yield*/
                , this.startTransport(url, transferFormat)];

              case 2:
                // We should just call connect directly in this case.
                // No fallback or negotiate in this case.
                _a.sent();

                return [3
                /*break*/
                , 4];

              case 3:
                throw new Error("Negotiation can only be skipped when using the WebSocket transport directly.");

              case 4:
                return [3
                /*break*/
                , 11];

              case 5:
                negotiateResponse = null;
                redirects = 0;

                _loop_1 = function () {
                  var accessToken_1;
                  return __generator$5(this, function (_a) {
                    switch (_a.label) {
                      case 0:
                        return [4
                        /*yield*/
                        , this_1.getNegotiationResponse(url)];

                      case 1:
                        negotiateResponse = _a.sent(); // the user tries to stop the connection when it is being started

                        if (this_1.connectionState === "Disconnecting"
                        /* Disconnecting */
                        || this_1.connectionState === "Disconnected"
                        /* Disconnected */
                        ) {
                            throw new Error("The connection was stopped during negotiation.");
                          }

                        if (negotiateResponse.error) {
                          throw new Error(negotiateResponse.error);
                        }

                        if (negotiateResponse.ProtocolVersion) {
                          throw new Error("Detected a connection attempt to an ASP.NET SignalR Server. This client only supports connecting to an ASP.NET Core SignalR Server. See https://aka.ms/signalr-core-differences for details.");
                        }

                        if (negotiateResponse.url) {
                          url = negotiateResponse.url;
                        }

                        if (negotiateResponse.accessToken) {
                          accessToken_1 = negotiateResponse.accessToken;

                          this_1.accessTokenFactory = function () {
                            return accessToken_1;
                          };
                        }

                        redirects++;
                        return [2
                        /*return*/
                        ];
                    }
                  });
                };

                this_1 = this;
                _a.label = 6;

              case 6:
                return [5
                /*yield**/
                , _loop_1()];

              case 7:
                _a.sent();

                _a.label = 8;

              case 8:
                if (negotiateResponse.url && redirects < MAX_REDIRECTS) return [3
                /*break*/
                , 6];
                _a.label = 9;

              case 9:
                if (redirects === MAX_REDIRECTS && negotiateResponse.url) {
                  throw new Error("Negotiate redirection limit exceeded.");
                }

                return [4
                /*yield*/
                , this.createTransport(url, this.options.transport, negotiateResponse, transferFormat)];

              case 10:
                _a.sent();

                _a.label = 11;

              case 11:
                if (this.transport instanceof LongPollingTransport) {
                  this.features.inherentKeepAlive = true;
                }

                if (this.connectionState === "Connecting "
                /* Connecting */
                ) {
                    // Ensure the connection transitions to the connected state prior to completing this.startInternalPromise.
                    // start() will handle the case when stop was called and startInternal exits still in the disconnecting state.
                    this.logger.log(LogLevel.Debug, "The HttpConnection connected successfully.");
                    this.connectionState = "Connected"
                    /* Connected */
                    ;
                  }

                return [3
                /*break*/
                , 13];

              case 12:
                e_3 = _a.sent();
                this.logger.log(LogLevel.Error, "Failed to start the connection: " + e_3);
                this.connectionState = "Disconnected"
                /* Disconnected */
                ;
                this.transport = undefined;
                return [2
                /*return*/
                , Promise.reject(e_3)];

              case 13:
                return [2
                /*return*/
                ];
            }
          });
        });
      };

      HttpConnection.prototype.getNegotiationResponse = function (url) {
        return __awaiter$5(this, void 0, void 0, function () {
          var _a, headers, token, negotiateUrl, response, negotiateResponse, e_4;

          return __generator$5(this, function (_b) {
            switch (_b.label) {
              case 0:
                if (!this.accessTokenFactory) return [3
                /*break*/
                , 2];
                return [4
                /*yield*/
                , this.accessTokenFactory()];

              case 1:
                token = _b.sent();

                if (token) {
                  headers = (_a = {}, _a["Authorization"] = "Bearer " + token, _a);
                }

                _b.label = 2;

              case 2:
                negotiateUrl = this.resolveNegotiateUrl(url);
                this.logger.log(LogLevel.Debug, "Sending negotiation request: " + negotiateUrl + ".");
                _b.label = 3;

              case 3:
                _b.trys.push([3, 5,, 6]);

                return [4
                /*yield*/
                , this.httpClient.post(negotiateUrl, {
                  content: "",
                  headers: headers
                })];

              case 4:
                response = _b.sent();

                if (response.statusCode !== 200) {
                  return [2
                  /*return*/
                  , Promise.reject(new Error("Unexpected status code returned from negotiate " + response.statusCode))];
                }

                negotiateResponse = JSON.parse(response.content);

                if (!negotiateResponse.negotiateVersion || negotiateResponse.negotiateVersion < 1) {
                  // Negotiate version 0 doesn't use connectionToken
                  // So we set it equal to connectionId so all our logic can use connectionToken without being aware of the negotiate version
                  negotiateResponse.connectionToken = negotiateResponse.connectionId;
                }

                return [2
                /*return*/
                , negotiateResponse];

              case 5:
                e_4 = _b.sent();
                this.logger.log(LogLevel.Error, "Failed to complete negotiation with the server: " + e_4);
                return [2
                /*return*/
                , Promise.reject(e_4)];

              case 6:
                return [2
                /*return*/
                ];
            }
          });
        });
      };

      HttpConnection.prototype.createConnectUrl = function (url, connectionToken) {
        if (!connectionToken) {
          return url;
        }

        return url + (url.indexOf("?") === -1 ? "?" : "&") + ("id=" + connectionToken);
      };

      HttpConnection.prototype.createTransport = function (url, requestedTransport, negotiateResponse, requestedTransferFormat) {
        return __awaiter$5(this, void 0, void 0, function () {
          var connectUrl, transportExceptions, transports, negotiate, _i, transports_1, endpoint, transportOrError, ex_1, ex_2, message;

          return __generator$5(this, function (_a) {
            switch (_a.label) {
              case 0:
                connectUrl = this.createConnectUrl(url, negotiateResponse.connectionToken);
                if (!this.isITransport(requestedTransport)) return [3
                /*break*/
                , 2];
                this.logger.log(LogLevel.Debug, "Connection was provided an instance of ITransport, using that directly.");
                this.transport = requestedTransport;
                return [4
                /*yield*/
                , this.startTransport(connectUrl, requestedTransferFormat)];

              case 1:
                _a.sent();

                this.connectionId = negotiateResponse.connectionId;
                return [2
                /*return*/
                ];

              case 2:
                transportExceptions = [];
                transports = negotiateResponse.availableTransports || [];
                negotiate = negotiateResponse;
                _i = 0, transports_1 = transports;
                _a.label = 3;

              case 3:
                if (!(_i < transports_1.length)) return [3
                /*break*/
                , 13];
                endpoint = transports_1[_i];
                transportOrError = this.resolveTransportOrError(endpoint, requestedTransport, requestedTransferFormat);
                if (!(transportOrError instanceof Error)) return [3
                /*break*/
                , 4]; // Store the error and continue, we don't want to cause a re-negotiate in these cases

                transportExceptions.push(endpoint.transport + " failed: " + transportOrError);
                return [3
                /*break*/
                , 12];

              case 4:
                if (!this.isITransport(transportOrError)) return [3
                /*break*/
                , 12];
                this.transport = transportOrError;
                if (!!negotiate) return [3
                /*break*/
                , 9];
                _a.label = 5;

              case 5:
                _a.trys.push([5, 7,, 8]);

                return [4
                /*yield*/
                , this.getNegotiationResponse(url)];

              case 6:
                negotiate = _a.sent();
                return [3
                /*break*/
                , 8];

              case 7:
                ex_1 = _a.sent();
                return [2
                /*return*/
                , Promise.reject(ex_1)];

              case 8:
                connectUrl = this.createConnectUrl(url, negotiate.connectionToken);
                _a.label = 9;

              case 9:
                _a.trys.push([9, 11,, 12]);

                return [4
                /*yield*/
                , this.startTransport(connectUrl, requestedTransferFormat)];

              case 10:
                _a.sent();

                this.connectionId = negotiate.connectionId;
                return [2
                /*return*/
                ];

              case 11:
                ex_2 = _a.sent();
                this.logger.log(LogLevel.Error, "Failed to start the transport '" + endpoint.transport + "': " + ex_2);
                negotiate = undefined;
                transportExceptions.push(endpoint.transport + " failed: " + ex_2);

                if (this.connectionState !== "Connecting "
                /* Connecting */
                ) {
                    message = "Failed to select transport before stop() was called.";
                    this.logger.log(LogLevel.Debug, message);
                    return [2
                    /*return*/
                    , Promise.reject(new Error(message))];
                  }

                return [3
                /*break*/
                , 12];

              case 12:
                _i++;
                return [3
                /*break*/
                , 3];

              case 13:
                if (transportExceptions.length > 0) {
                  return [2
                  /*return*/
                  , Promise.reject(new Error("Unable to connect to the server with any of the available transports. " + transportExceptions.join(" ")))];
                }

                return [2
                /*return*/
                , Promise.reject(new Error("None of the transports supported by the client are supported by the server."))];
            }
          });
        });
      };

      HttpConnection.prototype.constructTransport = function (transport) {
        switch (transport) {
          case HttpTransportType.WebSockets:
            if (!this.options.WebSocket) {
              throw new Error("'WebSocket' is not supported in your environment.");
            }

            return new WebSocketTransport(this.httpClient, this.accessTokenFactory, this.logger, this.options.logMessageContent || false, this.options.WebSocket);

          case HttpTransportType.ServerSentEvents:
            if (!this.options.EventSource) {
              throw new Error("'EventSource' is not supported in your environment.");
            }

            return new ServerSentEventsTransport(this.httpClient, this.accessTokenFactory, this.logger, this.options.logMessageContent || false, this.options.EventSource);

          case HttpTransportType.LongPolling:
            return new LongPollingTransport(this.httpClient, this.accessTokenFactory, this.logger, this.options.logMessageContent || false);

          default:
            throw new Error("Unknown transport: " + transport + ".");
        }
      };

      HttpConnection.prototype.startTransport = function (url, transferFormat) {
        var _this = this;

        this.transport.onreceive = this.onreceive;

        this.transport.onclose = function (e) {
          return _this.stopConnection(e);
        };

        return this.transport.connect(url, transferFormat);
      };

      HttpConnection.prototype.resolveTransportOrError = function (endpoint, requestedTransport, requestedTransferFormat) {
        var transport = HttpTransportType[endpoint.transport];

        if (transport === null || transport === undefined) {
          this.logger.log(LogLevel.Debug, "Skipping transport '" + endpoint.transport + "' because it is not supported by this client.");
          return new Error("Skipping transport '" + endpoint.transport + "' because it is not supported by this client.");
        } else {
          if (transportMatches(requestedTransport, transport)) {
            var transferFormats = endpoint.transferFormats.map(function (s) {
              return TransferFormat[s];
            });

            if (transferFormats.indexOf(requestedTransferFormat) >= 0) {
              if (transport === HttpTransportType.WebSockets && !this.options.WebSocket || transport === HttpTransportType.ServerSentEvents && !this.options.EventSource) {
                this.logger.log(LogLevel.Debug, "Skipping transport '" + HttpTransportType[transport] + "' because it is not supported in your environment.'");
                return new Error("'" + HttpTransportType[transport] + "' is not supported in your environment.");
              } else {
                this.logger.log(LogLevel.Debug, "Selecting transport '" + HttpTransportType[transport] + "'.");

                try {
                  return this.constructTransport(transport);
                } catch (ex) {
                  return ex;
                }
              }
            } else {
              this.logger.log(LogLevel.Debug, "Skipping transport '" + HttpTransportType[transport] + "' because it does not support the requested transfer format '" + TransferFormat[requestedTransferFormat] + "'.");
              return new Error("'" + HttpTransportType[transport] + "' does not support " + TransferFormat[requestedTransferFormat] + ".");
            }
          } else {
            this.logger.log(LogLevel.Debug, "Skipping transport '" + HttpTransportType[transport] + "' because it was disabled by the client.");
            return new Error("'" + HttpTransportType[transport] + "' is disabled by the client.");
          }
        }
      };

      HttpConnection.prototype.isITransport = function (transport) {
        return transport && typeof transport === "object" && "connect" in transport;
      };

      HttpConnection.prototype.stopConnection = function (error) {
        var _this = this;

        this.logger.log(LogLevel.Debug, "HttpConnection.stopConnection(" + error + ") called while in state " + this.connectionState + ".");
        this.transport = undefined; // If we have a stopError, it takes precedence over the error from the transport

        error = this.stopError || error;
        this.stopError = undefined;

        if (this.connectionState === "Disconnected"
        /* Disconnected */
        ) {
            this.logger.log(LogLevel.Debug, "Call to HttpConnection.stopConnection(" + error + ") was ignored because the connection is already in the disconnected state.");
            return;
          }

        if (this.connectionState === "Connecting "
        /* Connecting */
        ) {
            this.logger.log(LogLevel.Warning, "Call to HttpConnection.stopConnection(" + error + ") was ignored because the connection hasn't yet left the in the connecting state.");
            return;
          }

        if (this.connectionState === "Disconnecting"
        /* Disconnecting */
        ) {
            // A call to stop() induced this call to stopConnection and needs to be completed.
            // Any stop() awaiters will be scheduled to continue after the onclose callback fires.
            this.stopPromiseResolver();
          }

        if (error) {
          this.logger.log(LogLevel.Error, "Connection disconnected with error '" + error + "'.");
        } else {
          this.logger.log(LogLevel.Information, "Connection disconnected.");
        }

        if (this.sendQueue) {
          this.sendQueue.stop().catch(function (e) {
            _this.logger.log(LogLevel.Error, "TransportSendQueue.stop() threw error '" + e + "'.");
          });
          this.sendQueue = undefined;
        }

        this.connectionId = undefined;
        this.connectionState = "Disconnected"
        /* Disconnected */
        ;

        if (this.connectionStarted) {
          this.connectionStarted = false;

          try {
            if (this.onclose) {
              this.onclose(error);
            }
          } catch (e) {
            this.logger.log(LogLevel.Error, "HttpConnection.onclose(" + error + ") threw error '" + e + "'.");
          }
        }
      };

      HttpConnection.prototype.resolveUrl = function (url) {
        // startsWith is not supported in IE
        if (url.lastIndexOf("https://", 0) === 0 || url.lastIndexOf("http://", 0) === 0) {
          return url;
        }

        if (!Platform.isBrowser || !window.document) {
          throw new Error("Cannot resolve '" + url + "'.");
        } // Setting the url to the href propery of an anchor tag handles normalization
        // for us. There are 3 main cases.
        // 1. Relative path normalization e.g "b" -> "http://localhost:5000/a/b"
        // 2. Absolute path normalization e.g "/a/b" -> "http://localhost:5000/a/b"
        // 3. Networkpath reference normalization e.g "//localhost:5000/a/b" -> "http://localhost:5000/a/b"


        var aTag = window.document.createElement("a");
        aTag.href = url;
        this.logger.log(LogLevel.Information, "Normalizing '" + url + "' to '" + aTag.href + "'.");
        return aTag.href;
      };

      HttpConnection.prototype.resolveNegotiateUrl = function (url) {
        var index = url.indexOf("?");
        var negotiateUrl = url.substring(0, index === -1 ? url.length : index);

        if (negotiateUrl[negotiateUrl.length - 1] !== "/") {
          negotiateUrl += "/";
        }

        negotiateUrl += "negotiate";
        negotiateUrl += index === -1 ? "" : url.substring(index);

        if (negotiateUrl.indexOf("negotiateVersion") === -1) {
          negotiateUrl += index === -1 ? "?" : "&";
          negotiateUrl += "negotiateVersion=" + this.negotiateVersion;
        }

        return negotiateUrl;
      };

      return HttpConnection;
    }();

    function transportMatches(requestedTransport, actualTransport) {
      return !requestedTransport || (actualTransport & requestedTransport) !== 0;
    }
    /** @private */


    var TransportSendQueue =
    /** @class */
    function () {
      function TransportSendQueue(transport) {
        this.transport = transport;
        this.buffer = [];
        this.executing = true;
        this.sendBufferedData = new PromiseSource();
        this.transportResult = new PromiseSource();
        this.sendLoopPromise = this.sendLoop();
      }

      TransportSendQueue.prototype.send = function (data) {
        this.bufferData(data);

        if (!this.transportResult) {
          this.transportResult = new PromiseSource();
        }

        return this.transportResult.promise;
      };

      TransportSendQueue.prototype.stop = function () {
        this.executing = false;
        this.sendBufferedData.resolve();
        return this.sendLoopPromise;
      };

      TransportSendQueue.prototype.bufferData = function (data) {
        if (this.buffer.length && typeof this.buffer[0] !== typeof data) {
          throw new Error("Expected data to be of type " + typeof this.buffer + " but was of type " + typeof data);
        }

        this.buffer.push(data);
        this.sendBufferedData.resolve();
      };

      TransportSendQueue.prototype.sendLoop = function () {
        return __awaiter$5(this, void 0, void 0, function () {
          var transportResult, data, error_1;
          return __generator$5(this, function (_a) {
            switch (_a.label) {
              case 0:
                return [4
                /*yield*/
                , this.sendBufferedData.promise];

              case 1:
                _a.sent();

                if (!this.executing) {
                  if (this.transportResult) {
                    this.transportResult.reject("Connection stopped.");
                  }

                  return [3
                  /*break*/
                  , 6];
                }

                this.sendBufferedData = new PromiseSource();
                transportResult = this.transportResult;
                this.transportResult = undefined;
                data = typeof this.buffer[0] === "string" ? this.buffer.join("") : TransportSendQueue.concatBuffers(this.buffer);
                this.buffer.length = 0;
                _a.label = 2;

              case 2:
                _a.trys.push([2, 4,, 5]);

                return [4
                /*yield*/
                , this.transport.send(data)];

              case 3:
                _a.sent();

                transportResult.resolve();
                return [3
                /*break*/
                , 5];

              case 4:
                error_1 = _a.sent();
                transportResult.reject(error_1);
                return [3
                /*break*/
                , 5];

              case 5:
                return [3
                /*break*/
                , 0];

              case 6:
                return [2
                /*return*/
                ];
            }
          });
        });
      };

      TransportSendQueue.concatBuffers = function (arrayBuffers) {
        var totalLength = arrayBuffers.map(function (b) {
          return b.byteLength;
        }).reduce(function (a, b) {
          return a + b;
        });
        var result = new Uint8Array(totalLength);
        var offset = 0;

        for (var _i = 0, arrayBuffers_1 = arrayBuffers; _i < arrayBuffers_1.length; _i++) {
          var item = arrayBuffers_1[_i];
          result.set(new Uint8Array(item), offset);
          offset += item.byteLength;
        }

        return result;
      };

      return TransportSendQueue;
    }();

    var PromiseSource =
    /** @class */
    function () {
      function PromiseSource() {
        var _this = this;

        this.promise = new Promise(function (resolve, reject) {
          var _a;

          return _a = [resolve, reject], _this.resolver = _a[0], _this.rejecter = _a[1], _a;
        });
      }

      PromiseSource.prototype.resolve = function () {
        this.resolver();
      };

      PromiseSource.prototype.reject = function (reason) {
        this.rejecter(reason);
      };

      return PromiseSource;
    }();

    // Copyright (c) .NET Foundation. All rights reserved.
    var JSON_HUB_PROTOCOL_NAME = "json";
    /** Implements the JSON Hub Protocol. */

    var JsonHubProtocol =
    /** @class */
    function () {
      function JsonHubProtocol() {
        /** @inheritDoc */
        this.name = JSON_HUB_PROTOCOL_NAME;
        /** @inheritDoc */

        this.version = 1;
        /** @inheritDoc */

        this.transferFormat = TransferFormat.Text;
      }
      /** Creates an array of {@link @microsoft/signalr.HubMessage} objects from the specified serialized representation.
       *
       * @param {string} input A string containing the serialized representation.
       * @param {ILogger} logger A logger that will be used to log messages that occur during parsing.
       */


      JsonHubProtocol.prototype.parseMessages = function (input, logger) {
        // The interface does allow "ArrayBuffer" to be passed in, but this implementation does not. So let's throw a useful error.
        if (typeof input !== "string") {
          throw new Error("Invalid input for JSON hub protocol. Expected a string.");
        }

        if (!input) {
          return [];
        }

        if (logger === null) {
          logger = NullLogger.instance;
        } // Parse the messages


        var messages = TextMessageFormat.parse(input);
        var hubMessages = [];

        for (var _i = 0, messages_1 = messages; _i < messages_1.length; _i++) {
          var message = messages_1[_i];
          var parsedMessage = JSON.parse(message);

          if (typeof parsedMessage.type !== "number") {
            throw new Error("Invalid payload.");
          }

          switch (parsedMessage.type) {
            case MessageType.Invocation:
              this.isInvocationMessage(parsedMessage);
              break;

            case MessageType.StreamItem:
              this.isStreamItemMessage(parsedMessage);
              break;

            case MessageType.Completion:
              this.isCompletionMessage(parsedMessage);
              break;

            case MessageType.Ping:
              // Single value, no need to validate
              break;

            case MessageType.Close:
              // All optional values, no need to validate
              break;

            default:
              // Future protocol changes can add message types, old clients can ignore them
              logger.log(LogLevel.Information, "Unknown message type '" + parsedMessage.type + "' ignored.");
              continue;
          }

          hubMessages.push(parsedMessage);
        }

        return hubMessages;
      };
      /** Writes the specified {@link @microsoft/signalr.HubMessage} to a string and returns it.
       *
       * @param {HubMessage} message The message to write.
       * @returns {string} A string containing the serialized representation of the message.
       */


      JsonHubProtocol.prototype.writeMessage = function (message) {
        return TextMessageFormat.write(JSON.stringify(message));
      };

      JsonHubProtocol.prototype.isInvocationMessage = function (message) {
        this.assertNotEmptyString(message.target, "Invalid payload for Invocation message.");

        if (message.invocationId !== undefined) {
          this.assertNotEmptyString(message.invocationId, "Invalid payload for Invocation message.");
        }
      };

      JsonHubProtocol.prototype.isStreamItemMessage = function (message) {
        this.assertNotEmptyString(message.invocationId, "Invalid payload for StreamItem message.");

        if (message.item === undefined) {
          throw new Error("Invalid payload for StreamItem message.");
        }
      };

      JsonHubProtocol.prototype.isCompletionMessage = function (message) {
        if (message.result && message.error) {
          throw new Error("Invalid payload for Completion message.");
        }

        if (!message.result && message.error) {
          this.assertNotEmptyString(message.error, "Invalid payload for Completion message.");
        }

        this.assertNotEmptyString(message.invocationId, "Invalid payload for Completion message.");
      };

      JsonHubProtocol.prototype.assertNotEmptyString = function (value, errorMessage) {
        if (typeof value !== "string" || value === "") {
          throw new Error(errorMessage);
        }
      };

      return JsonHubProtocol;
    }();

    // Copyright (c) .NET Foundation. All rights reserved.
    // Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.
    var __assign$2 = undefined && undefined.__assign || Object.assign || function (t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];

        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
      }

      return t;
    };

    var LogLevelNameMapping = {
      trace: LogLevel.Trace,
      debug: LogLevel.Debug,
      info: LogLevel.Information,
      information: LogLevel.Information,
      warn: LogLevel.Warning,
      warning: LogLevel.Warning,
      error: LogLevel.Error,
      critical: LogLevel.Critical,
      none: LogLevel.None
    };

    function parseLogLevel(name) {
      // Case-insensitive matching via lower-casing
      // Yes, I know case-folding is a complicated problem in Unicode, but we only support
      // the ASCII strings defined in LogLevelNameMapping anyway, so it's fine -anurse.
      var mapping = LogLevelNameMapping[name.toLowerCase()];

      if (typeof mapping !== "undefined") {
        return mapping;
      } else {
        throw new Error("Unknown log level: " + name);
      }
    }
    /** A builder for configuring {@link @microsoft/signalr.HubConnection} instances. */


    var HubConnectionBuilder =
    /** @class */
    function () {
      function HubConnectionBuilder() {}

      HubConnectionBuilder.prototype.configureLogging = function (logging) {
        Arg.isRequired(logging, "logging");

        if (isLogger(logging)) {
          this.logger = logging;
        } else if (typeof logging === "string") {
          var logLevel = parseLogLevel(logging);
          this.logger = new ConsoleLogger(logLevel);
        } else {
          this.logger = new ConsoleLogger(logging);
        }

        return this;
      };

      HubConnectionBuilder.prototype.withUrl = function (url, transportTypeOrOptions) {
        Arg.isRequired(url, "url");
        this.url = url; // Flow-typing knows where it's at. Since HttpTransportType is a number and IHttpConnectionOptions is guaranteed
        // to be an object, we know (as does TypeScript) this comparison is all we need to figure out which overload was called.

        if (typeof transportTypeOrOptions === "object") {
          this.httpConnectionOptions = __assign$2({}, this.httpConnectionOptions, transportTypeOrOptions);
        } else {
          this.httpConnectionOptions = __assign$2({}, this.httpConnectionOptions, {
            transport: transportTypeOrOptions
          });
        }

        return this;
      };
      /** Configures the {@link @microsoft/signalr.HubConnection} to use the specified Hub Protocol.
       *
       * @param {IHubProtocol} protocol The {@link @microsoft/signalr.IHubProtocol} implementation to use.
       */


      HubConnectionBuilder.prototype.withHubProtocol = function (protocol) {
        Arg.isRequired(protocol, "protocol");
        this.protocol = protocol;
        return this;
      };

      HubConnectionBuilder.prototype.withAutomaticReconnect = function (retryDelaysOrReconnectPolicy) {
        if (this.reconnectPolicy) {
          throw new Error("A reconnectPolicy has already been set.");
        }

        if (!retryDelaysOrReconnectPolicy) {
          this.reconnectPolicy = new DefaultReconnectPolicy();
        } else if (Array.isArray(retryDelaysOrReconnectPolicy)) {
          this.reconnectPolicy = new DefaultReconnectPolicy(retryDelaysOrReconnectPolicy);
        } else {
          this.reconnectPolicy = retryDelaysOrReconnectPolicy;
        }

        return this;
      };
      /** Creates a {@link @microsoft/signalr.HubConnection} from the configuration options specified in this builder.
       *
       * @returns {HubConnection} The configured {@link @microsoft/signalr.HubConnection}.
       */


      HubConnectionBuilder.prototype.build = function () {
        // If httpConnectionOptions has a logger, use it. Otherwise, override it with the one
        // provided to configureLogger
        var httpConnectionOptions = this.httpConnectionOptions || {}; // If it's 'null', the user **explicitly** asked for null, don't mess with it.

        if (httpConnectionOptions.logger === undefined) {
          // If our logger is undefined or null, that's OK, the HttpConnection constructor will handle it.
          httpConnectionOptions.logger = this.logger;
        } // Now create the connection


        if (!this.url) {
          throw new Error("The 'HubConnectionBuilder.withUrl' method must be called before building the connection.");
        }

        var connection = new HttpConnection(this.url, httpConnectionOptions);
        return HubConnection.create(connection, this.logger || NullLogger.instance, this.protocol || new JsonHubProtocol(), this.reconnectPolicy);
      };

      return HubConnectionBuilder;
    }();

    function isLogger(logger) {
      return logger.log !== undefined;
    }

    // let colaDeSubscripciones = []
    // function subscribirseAHilo(hiloid) {
    //     colaDeSubscripciones.push(() => coneccion.invoke("SubscribirseAHilo", hiloid))
    // }

    class Signal {
      static subscribirseAHilo(hiloid) {
        this.colaDeSubscripciones.push(() => this.coneccion.invoke("SubscribirseAHilo", hiloid));
      }

      static subscribirAHome() {
        this.colaDeSubscripciones.push(() => this.coneccion.invoke("SubscribirAHome"));
      }

      static subscribirAAdministracion() {
        this.colaDeSubscripciones.push(() => this.coneccion.invoke("SubscribirAAdministracion"));
      }

      static subscribirAModeracion() {
        this.colaDeSubscripciones.push(() => this.coneccion.invoke("SubscribirAModeracion"));
      }

      static subscribirARozed() {
        this.colaDeSubscripciones.push(() => this.coneccion.invoke("SubscribirARozed"));
      }

    }

    _defineProperty(Signal, "coneccion", new HubConnectionBuilder().withUrl("/hub").build());

    _defineProperty(Signal, "colaDeSubscripciones", []);

    Signal.coneccion.start().then(() => {
      console.log("ConectandoSignal");
      Promise.all(Signal.colaDeSubscripciones.map(s => s())); // Signal.colaDeSubscripciones.forEach(s => {
      //     s()
      // })
    }).catch(console.error);
    Signal.coneccion.on("domado", () => window.location.href = "/Domado");

    let gruposOrdenados = window.config.grupos.sort((g1, g2) => g1.id - g2.id);
    let sfw = window.config.categorias.filter(c => !c.nsfw).sort((c1, c2) => c1.nombre.localeCompare(c2.nombre));
    let nsfw = window.config.categorias.filter(c => c.nsfw).sort((c1, c2) => c1.nombre.localeCompare(c2.nombre));
    let categoriasOrdenadas = [...sfw, ...nsfw];
    class config {
      static categoriaPorId(id) {
        return config.categorias.filter(c => c.id == id)[0];
      }

      static grupoPorId(id) {
        return config.grupos.filter(g => g.id == id)[0];
      }

      static getCategoriaById(id) {
        return this.categorias[id - 1];
      }

    }

    _defineProperty(config, "grupos", gruposOrdenados);

    _defineProperty(config, "categorias", categoriasOrdenadas);

    _defineProperty(config, "nombre", window.config.general.nombre);

    _defineProperty(config, "general", window.config.general);

    let configStore = writable({
      categorias: categoriasOrdenadas,
      general: window.config.general,

      categoriaPorId(id) {
        return config.categorias.filter(c => c.id == id)[0];
      }

    });
    Signal.subscribirARozed();
    Signal.coneccion.on("configuracionActualizada", nuevaConfig => {
      configStore.update(c => {
        c.general = nuevaConfig;
        return c;
      });
    });

    function createCommonjsModule(fn, basedir, module) {
    	return module = {
    	  path: basedir,
    	  exports: {},
    	  require: function (path, base) {
          return commonjsRequire(path, (base === undefined || base === null) ? module.path : base);
        }
    	}, fn(module, module.exports), module.exports;
    }

    function commonjsRequire () {
    	throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
    }

    var js_cookie = createCommonjsModule(function (module, exports) {

    (function (factory) {
      var registeredInModuleLoader;

      {
        module.exports = factory();
        registeredInModuleLoader = true;
      }

      if (!registeredInModuleLoader) {
        var OldCookies = window.Cookies;
        var api = window.Cookies = factory();

        api.noConflict = function () {
          window.Cookies = OldCookies;
          return api;
        };
      }
    })(function () {
      function extend() {
        var i = 0;
        var result = {};

        for (; i < arguments.length; i++) {
          var attributes = arguments[i];

          for (var key in attributes) {
            result[key] = attributes[key];
          }
        }

        return result;
      }

      function decode(s) {
        return s.replace(/(%[0-9A-Z]{2})+/g, decodeURIComponent);
      }

      function init(converter) {
        function api() {}

        function set(key, value, attributes) {
          if (typeof document === 'undefined') {
            return;
          }

          attributes = extend({
            path: '/'
          }, api.defaults, attributes);

          if (typeof attributes.expires === 'number') {
            attributes.expires = new Date(new Date() * 1 + attributes.expires * 864e+5);
          } // We're using "expires" because "max-age" is not supported by IE


          attributes.expires = attributes.expires ? attributes.expires.toUTCString() : '';

          try {
            var result = JSON.stringify(value);

            if (/^[\{\[]/.test(result)) {
              value = result;
            }
          } catch (e) {}

          value = converter.write ? converter.write(value, key) : encodeURIComponent(String(value)).replace(/%(23|24|26|2B|3A|3C|3E|3D|2F|3F|40|5B|5D|5E|60|7B|7D|7C)/g, decodeURIComponent);
          key = encodeURIComponent(String(key)).replace(/%(23|24|26|2B|5E|60|7C)/g, decodeURIComponent).replace(/[\(\)]/g, escape);
          var stringifiedAttributes = '';

          for (var attributeName in attributes) {
            if (!attributes[attributeName]) {
              continue;
            }

            stringifiedAttributes += '; ' + attributeName;

            if (attributes[attributeName] === true) {
              continue;
            } // Considers RFC 6265 section 5.2:
            // ...
            // 3.  If the remaining unparsed-attributes contains a %x3B (";")
            //     character:
            // Consume the characters of the unparsed-attributes up to,
            // not including, the first %x3B (";") character.
            // ...


            stringifiedAttributes += '=' + attributes[attributeName].split(';')[0];
          }

          return document.cookie = key + '=' + value + stringifiedAttributes;
        }

        function get(key, json) {
          if (typeof document === 'undefined') {
            return;
          }

          var jar = {}; // To prevent the for loop in the first place assign an empty array
          // in case there are no cookies at all.

          var cookies = document.cookie ? document.cookie.split('; ') : [];
          var i = 0;

          for (; i < cookies.length; i++) {
            var parts = cookies[i].split('=');
            var cookie = parts.slice(1).join('=');

            if (!json && cookie.charAt(0) === '"') {
              cookie = cookie.slice(1, -1);
            }

            try {
              var name = decode(parts[0]);
              cookie = (converter.read || converter)(cookie, name) || decode(cookie);

              if (json) {
                try {
                  cookie = JSON.parse(cookie);
                } catch (e) {}
              }

              jar[name] = cookie;

              if (key === name) {
                break;
              }
            } catch (e) {}
          }

          return key ? jar[key] : jar;
        }

        api.set = set;

        api.get = function (key) {
          return get(key, false
          /* read as raw */
          );
        };

        api.getJSON = function (key) {
          return get(key, true
          /* read as json */
          );
        };

        api.remove = function (key, attributes) {
          set(key, '', extend(attributes, {
            expires: -1
          }));
        };

        api.defaults = {};
        api.withConverter = init;
        return api;
      }

      return init(function () {});
    });
    });

    let data = Object.assign({
      mostrarLogin: false,
      mostrarRegistro: false,
      debug: true,
      fondo: 'url(/imagenes/rosed.png)',
      esCelular: false
    }, window.globalState); // Categorias 

    data.categoriasActivas = config.categorias.filter(c => !c.nsfw).map(c => c.id);

    if (js_cookie.getJSON('categoriasActivas')) {
      data.categoriasActivas = js_cookie.getJSON('categoriasActivas'); // Quitar este despues (es para activar la categoria programacion automaticamente)
      // data.categoriasActivas = [...data.categoriasActivas, 38]
    } else js_cookie.set('categoriasActivas', data.categoriasActivas);

    data.gruposActivos = [];

    if (js_cookie.getJSON('gruposActivos')) {
      data.gruposActivos = js_cookie.getJSON('gruposActivos');
    } else {
      js_cookie.set('gruposActivos', data.gruposActivos);
    } // Hide comentarios


    let comentariosOcultosStorage = localStorage.getItem('comentariosOcultos');
    if (!comentariosOcultosStorage) comentariosOcultosStorage = JSON.stringify(['test']);
    data.comentariosOcultos = new Map(JSON.parse(comentariosOcultosStorage).map(e => [e, true])); // Checkeo si es celular

    data.esCelular = window.innerWidth < 600;
    const store = writable(data);
    var globalStore = {
      subscribe: store.subscribe,

      set(value) {
        localStorage.setItem('comentariosOcultos', JSON.stringify(Array.from(value.comentariosOcultos.keys())));
        js_cookie.set('categoriasActivas', value.categoriasActivas, {
          expires: 696969
        });
        js_cookie.set('gruposActivos', value.gruposActivos, {
          expires: 696969
        });
        store.set(value);
      },

      update(config) {
        js_cookie.set('categoriasActivas', config.categoriasActivas, {
          expires: 696969
        });
        js_cookie.set('gruposActivos', config.gruposActivos, {
          expires: 696969
        });
        store.update(config);
      }

    };

    class MediaType {}

    _defineProperty(MediaType, "Imagen", 0);

    _defineProperty(MediaType, "Video", 1);

    _defineProperty(MediaType, "Youtube", 2);

    _defineProperty(MediaType, "Bitchute", 4);

    _defineProperty(MediaType, "DailyMotion", 5);

    _defineProperty(MediaType, "PornHub", 6);

    var bind$1 = function bind(fn, thisArg) {
      return function wrap() {
        var args = new Array(arguments.length);

        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }

        return fn.apply(thisArg, args);
      };
    };

    /*global toString:true*/
    // utils is a library of generic helper functions non-specific to axios


    var toString = Object.prototype.toString;
    /**
     * Determine if a value is an Array
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is an Array, otherwise false
     */

    function isArray(val) {
      return toString.call(val) === '[object Array]';
    }
    /**
     * Determine if a value is undefined
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if the value is undefined, otherwise false
     */


    function isUndefined(val) {
      return typeof val === 'undefined';
    }
    /**
     * Determine if a value is a Buffer
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a Buffer, otherwise false
     */


    function isBuffer(val) {
      return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && typeof val.constructor.isBuffer === 'function' && val.constructor.isBuffer(val);
    }
    /**
     * Determine if a value is an ArrayBuffer
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is an ArrayBuffer, otherwise false
     */


    function isArrayBuffer$1(val) {
      return toString.call(val) === '[object ArrayBuffer]';
    }
    /**
     * Determine if a value is a FormData
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is an FormData, otherwise false
     */


    function isFormData(val) {
      return typeof FormData !== 'undefined' && val instanceof FormData;
    }
    /**
     * Determine if a value is a view on an ArrayBuffer
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
     */


    function isArrayBufferView(val) {
      var result;

      if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {
        result = ArrayBuffer.isView(val);
      } else {
        result = val && val.buffer && val.buffer instanceof ArrayBuffer;
      }

      return result;
    }
    /**
     * Determine if a value is a String
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a String, otherwise false
     */


    function isString(val) {
      return typeof val === 'string';
    }
    /**
     * Determine if a value is a Number
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a Number, otherwise false
     */


    function isNumber(val) {
      return typeof val === 'number';
    }
    /**
     * Determine if a value is an Object
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is an Object, otherwise false
     */


    function isObject(val) {
      return val !== null && typeof val === 'object';
    }
    /**
     * Determine if a value is a plain Object
     *
     * @param {Object} val The value to test
     * @return {boolean} True if value is a plain Object, otherwise false
     */


    function isPlainObject(val) {
      if (toString.call(val) !== '[object Object]') {
        return false;
      }

      var prototype = Object.getPrototypeOf(val);
      return prototype === null || prototype === Object.prototype;
    }
    /**
     * Determine if a value is a Date
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a Date, otherwise false
     */


    function isDate(val) {
      return toString.call(val) === '[object Date]';
    }
    /**
     * Determine if a value is a File
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a File, otherwise false
     */


    function isFile(val) {
      return toString.call(val) === '[object File]';
    }
    /**
     * Determine if a value is a Blob
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a Blob, otherwise false
     */


    function isBlob(val) {
      return toString.call(val) === '[object Blob]';
    }
    /**
     * Determine if a value is a Function
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a Function, otherwise false
     */


    function isFunction(val) {
      return toString.call(val) === '[object Function]';
    }
    /**
     * Determine if a value is a Stream
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a Stream, otherwise false
     */


    function isStream(val) {
      return isObject(val) && isFunction(val.pipe);
    }
    /**
     * Determine if a value is a URLSearchParams object
     *
     * @param {Object} val The value to test
     * @returns {boolean} True if value is a URLSearchParams object, otherwise false
     */


    function isURLSearchParams(val) {
      return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;
    }
    /**
     * Trim excess whitespace off the beginning and end of a string
     *
     * @param {String} str The String to trim
     * @returns {String} The String freed of excess whitespace
     */


    function trim(str) {
      return str.replace(/^\s*/, '').replace(/\s*$/, '');
    }
    /**
     * Determine if we're running in a standard browser environment
     *
     * This allows axios to run in a web worker, and react-native.
     * Both environments support XMLHttpRequest, but not fully standard globals.
     *
     * web workers:
     *  typeof window -> undefined
     *  typeof document -> undefined
     *
     * react-native:
     *  navigator.product -> 'ReactNative'
     * nativescript
     *  navigator.product -> 'NativeScript' or 'NS'
     */


    function isStandardBrowserEnv() {
      if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' || navigator.product === 'NativeScript' || navigator.product === 'NS')) {
        return false;
      }

      return typeof window !== 'undefined' && typeof document !== 'undefined';
    }
    /**
     * Iterate over an Array or an Object invoking a function for each item.
     *
     * If `obj` is an Array callback will be called passing
     * the value, index, and complete array for each item.
     *
     * If 'obj' is an Object callback will be called passing
     * the value, key, and complete object for each property.
     *
     * @param {Object|Array} obj The object to iterate
     * @param {Function} fn The callback to invoke for each item
     */


    function forEach(obj, fn) {
      // Don't bother if no value provided
      if (obj === null || typeof obj === 'undefined') {
        return;
      } // Force an array if not already something iterable


      if (typeof obj !== 'object') {
        /*eslint no-param-reassign:0*/
        obj = [obj];
      }

      if (isArray(obj)) {
        // Iterate over array values
        for (var i = 0, l = obj.length; i < l; i++) {
          fn.call(null, obj[i], i, obj);
        }
      } else {
        // Iterate over object keys
        for (var key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) {
            fn.call(null, obj[key], key, obj);
          }
        }
      }
    }
    /**
     * Accepts varargs expecting each argument to be an object, then
     * immutably merges the properties of each object and returns result.
     *
     * When multiple objects contain the same key the later object in
     * the arguments list will take precedence.
     *
     * Example:
     *
     * ```js
     * var result = merge({foo: 123}, {foo: 456});
     * console.log(result.foo); // outputs 456
     * ```
     *
     * @param {Object} obj1 Object to merge
     * @returns {Object} Result of all merge properties
     */


    function merge()
    /* obj1, obj2, obj3, ... */
    {
      var result = {};

      function assignValue(val, key) {
        if (isPlainObject(result[key]) && isPlainObject(val)) {
          result[key] = merge(result[key], val);
        } else if (isPlainObject(val)) {
          result[key] = merge({}, val);
        } else if (isArray(val)) {
          result[key] = val.slice();
        } else {
          result[key] = val;
        }
      }

      for (var i = 0, l = arguments.length; i < l; i++) {
        forEach(arguments[i], assignValue);
      }

      return result;
    }
    /**
     * Extends object a by mutably adding to it the properties of object b.
     *
     * @param {Object} a The object to be extended
     * @param {Object} b The object to copy properties from
     * @param {Object} thisArg The object to bind function to
     * @return {Object} The resulting value of object a
     */


    function extend(a, b, thisArg) {
      forEach(b, function assignValue(val, key) {
        if (thisArg && typeof val === 'function') {
          a[key] = bind$1(val, thisArg);
        } else {
          a[key] = val;
        }
      });
      return a;
    }
    /**
     * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
     *
     * @param {string} content with BOM
     * @return {string} content value without BOM
     */


    function stripBOM(content) {
      if (content.charCodeAt(0) === 0xFEFF) {
        content = content.slice(1);
      }

      return content;
    }

    var utils = {
      isArray: isArray,
      isArrayBuffer: isArrayBuffer$1,
      isBuffer: isBuffer,
      isFormData: isFormData,
      isArrayBufferView: isArrayBufferView,
      isString: isString,
      isNumber: isNumber,
      isObject: isObject,
      isPlainObject: isPlainObject,
      isUndefined: isUndefined,
      isDate: isDate,
      isFile: isFile,
      isBlob: isBlob,
      isFunction: isFunction,
      isStream: isStream,
      isURLSearchParams: isURLSearchParams,
      isStandardBrowserEnv: isStandardBrowserEnv,
      forEach: forEach,
      merge: merge,
      extend: extend,
      trim: trim,
      stripBOM: stripBOM
    };

    function encode(val) {
      return encodeURIComponent(val).replace(/%3A/gi, ':').replace(/%24/g, '$').replace(/%2C/gi, ',').replace(/%20/g, '+').replace(/%5B/gi, '[').replace(/%5D/gi, ']');
    }
    /**
     * Build a URL by appending params to the end
     *
     * @param {string} url The base of the url (e.g., http://www.google.com)
     * @param {object} [params] The params to be appended
     * @returns {string} The formatted url
     */


    var buildURL = function buildURL(url, params, paramsSerializer) {
      /*eslint no-param-reassign:0*/
      if (!params) {
        return url;
      }

      var serializedParams;

      if (paramsSerializer) {
        serializedParams = paramsSerializer(params);
      } else if (utils.isURLSearchParams(params)) {
        serializedParams = params.toString();
      } else {
        var parts = [];
        utils.forEach(params, function serialize(val, key) {
          if (val === null || typeof val === 'undefined') {
            return;
          }

          if (utils.isArray(val)) {
            key = key + '[]';
          } else {
            val = [val];
          }

          utils.forEach(val, function parseValue(v) {
            if (utils.isDate(v)) {
              v = v.toISOString();
            } else if (utils.isObject(v)) {
              v = JSON.stringify(v);
            }

            parts.push(encode(key) + '=' + encode(v));
          });
        });
        serializedParams = parts.join('&');
      }

      if (serializedParams) {
        var hashmarkIndex = url.indexOf('#');

        if (hashmarkIndex !== -1) {
          url = url.slice(0, hashmarkIndex);
        }

        url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
      }

      return url;
    };

    function InterceptorManager() {
      this.handlers = [];
    }
    /**
     * Add a new interceptor to the stack
     *
     * @param {Function} fulfilled The function to handle `then` for a `Promise`
     * @param {Function} rejected The function to handle `reject` for a `Promise`
     *
     * @return {Number} An ID used to remove interceptor later
     */


    InterceptorManager.prototype.use = function use(fulfilled, rejected) {
      this.handlers.push({
        fulfilled: fulfilled,
        rejected: rejected
      });
      return this.handlers.length - 1;
    };
    /**
     * Remove an interceptor from the stack
     *
     * @param {Number} id The ID that was returned by `use`
     */


    InterceptorManager.prototype.eject = function eject(id) {
      if (this.handlers[id]) {
        this.handlers[id] = null;
      }
    };
    /**
     * Iterate over all the registered interceptors
     *
     * This method is particularly useful for skipping over any
     * interceptors that may have become `null` calling `eject`.
     *
     * @param {Function} fn The function to call for each interceptor
     */


    InterceptorManager.prototype.forEach = function forEach(fn) {
      utils.forEach(this.handlers, function forEachHandler(h) {
        if (h !== null) {
          fn(h);
        }
      });
    };

    var InterceptorManager_1 = InterceptorManager;

    /**
     * Transform the data for a request or a response
     *
     * @param {Object|String} data The data to be transformed
     * @param {Array} headers The headers for the request or response
     * @param {Array|Function} fns A single function or Array of functions
     * @returns {*} The resulting transformed data
     */


    var transformData = function transformData(data, headers, fns) {
      /*eslint no-param-reassign:0*/
      utils.forEach(fns, function transform(fn) {
        data = fn(data, headers);
      });
      return data;
    };

    var isCancel = function isCancel(value) {
      return !!(value && value.__CANCEL__);
    };

    var normalizeHeaderName = function normalizeHeaderName(headers, normalizedName) {
      utils.forEach(headers, function processHeader(value, name) {
        if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
          headers[normalizedName] = value;
          delete headers[name];
        }
      });
    };

    /**
     * Update an Error with the specified config, error code, and response.
     *
     * @param {Error} error The error to update.
     * @param {Object} config The config.
     * @param {string} [code] The error code (for example, 'ECONNABORTED').
     * @param {Object} [request] The request.
     * @param {Object} [response] The response.
     * @returns {Error} The error.
     */

    var enhanceError = function enhanceError(error, config, code, request, response) {
      error.config = config;

      if (code) {
        error.code = code;
      }

      error.request = request;
      error.response = response;
      error.isAxiosError = true;

      error.toJSON = function toJSON() {
        return {
          // Standard
          message: this.message,
          name: this.name,
          // Microsoft
          description: this.description,
          number: this.number,
          // Mozilla
          fileName: this.fileName,
          lineNumber: this.lineNumber,
          columnNumber: this.columnNumber,
          stack: this.stack,
          // Axios
          config: this.config,
          code: this.code
        };
      };

      return error;
    };

    /**
     * Create an Error with the specified message, config, error code, request and response.
     *
     * @param {string} message The error message.
     * @param {Object} config The config.
     * @param {string} [code] The error code (for example, 'ECONNABORTED').
     * @param {Object} [request] The request.
     * @param {Object} [response] The response.
     * @returns {Error} The created error.
     */


    var createError = function createError(message, config, code, request, response) {
      var error = new Error(message);
      return enhanceError(error, config, code, request, response);
    };

    /**
     * Resolve or reject a Promise based on response status.
     *
     * @param {Function} resolve A function that resolves the promise.
     * @param {Function} reject A function that rejects the promise.
     * @param {object} response The response.
     */


    var settle = function settle(resolve, reject, response) {
      var validateStatus = response.config.validateStatus;

      if (!response.status || !validateStatus || validateStatus(response.status)) {
        resolve(response);
      } else {
        reject(createError('Request failed with status code ' + response.status, response.config, null, response.request, response));
      }
    };

    var cookies = utils.isStandardBrowserEnv() ? // Standard browser envs support document.cookie
    function standardBrowserEnv() {
      return {
        write: function write(name, value, expires, path, domain, secure) {
          var cookie = [];
          cookie.push(name + '=' + encodeURIComponent(value));

          if (utils.isNumber(expires)) {
            cookie.push('expires=' + new Date(expires).toGMTString());
          }

          if (utils.isString(path)) {
            cookie.push('path=' + path);
          }

          if (utils.isString(domain)) {
            cookie.push('domain=' + domain);
          }

          if (secure === true) {
            cookie.push('secure');
          }

          document.cookie = cookie.join('; ');
        },
        read: function read(name) {
          var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
          return match ? decodeURIComponent(match[3]) : null;
        },
        remove: function remove(name) {
          this.write(name, '', Date.now() - 86400000);
        }
      };
    }() : // Non standard browser env (web workers, react-native) lack needed support.
    function nonStandardBrowserEnv() {
      return {
        write: function write() {},
        read: function read() {
          return null;
        },
        remove: function remove() {}
      };
    }();

    /**
     * Determines whether the specified URL is absolute
     *
     * @param {string} url The URL to test
     * @returns {boolean} True if the specified URL is absolute, otherwise false
     */

    var isAbsoluteURL = function isAbsoluteURL(url) {
      // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
      // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
      // by any combination of letters, digits, plus, period, or hyphen.
      return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
    };

    /**
     * Creates a new URL by combining the specified URLs
     *
     * @param {string} baseURL The base URL
     * @param {string} relativeURL The relative URL
     * @returns {string} The combined URL
     */

    var combineURLs = function combineURLs(baseURL, relativeURL) {
      return relativeURL ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '') : baseURL;
    };

    /**
     * Creates a new URL by combining the baseURL with the requestedURL,
     * only when the requestedURL is not already an absolute URL.
     * If the requestURL is absolute, this function returns the requestedURL untouched.
     *
     * @param {string} baseURL The base URL
     * @param {string} requestedURL Absolute or relative URL to combine
     * @returns {string} The combined full path
     */


    var buildFullPath = function buildFullPath(baseURL, requestedURL) {
      if (baseURL && !isAbsoluteURL(requestedURL)) {
        return combineURLs(baseURL, requestedURL);
      }

      return requestedURL;
    };

    // Headers whose duplicates are ignored by node
    // c.f. https://nodejs.org/api/http.html#http_message_headers


    var ignoreDuplicateOf = ['age', 'authorization', 'content-length', 'content-type', 'etag', 'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since', 'last-modified', 'location', 'max-forwards', 'proxy-authorization', 'referer', 'retry-after', 'user-agent'];
    /**
     * Parse headers into an object
     *
     * ```
     * Date: Wed, 27 Aug 2014 08:58:49 GMT
     * Content-Type: application/json
     * Connection: keep-alive
     * Transfer-Encoding: chunked
     * ```
     *
     * @param {String} headers Headers needing to be parsed
     * @returns {Object} Headers parsed into an object
     */

    var parseHeaders = function parseHeaders(headers) {
      var parsed = {};
      var key;
      var val;
      var i;

      if (!headers) {
        return parsed;
      }

      utils.forEach(headers.split('\n'), function parser(line) {
        i = line.indexOf(':');
        key = utils.trim(line.substr(0, i)).toLowerCase();
        val = utils.trim(line.substr(i + 1));

        if (key) {
          if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
            return;
          }

          if (key === 'set-cookie') {
            parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
          } else {
            parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
          }
        }
      });
      return parsed;
    };

    var isURLSameOrigin = utils.isStandardBrowserEnv() ? // Standard browser envs have full support of the APIs needed to test
    // whether the request URL is of the same origin as current location.
    function standardBrowserEnv() {
      var msie = /(msie|trident)/i.test(navigator.userAgent);
      var urlParsingNode = document.createElement('a');
      var originURL;
      /**
      * Parse a URL to discover it's components
      *
      * @param {String} url The URL to be parsed
      * @returns {Object}
      */

      function resolveURL(url) {
        var href = url;

        if (msie) {
          // IE needs attribute set twice to normalize properties
          urlParsingNode.setAttribute('href', href);
          href = urlParsingNode.href;
        }

        urlParsingNode.setAttribute('href', href); // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils

        return {
          href: urlParsingNode.href,
          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
          host: urlParsingNode.host,
          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
          hostname: urlParsingNode.hostname,
          port: urlParsingNode.port,
          pathname: urlParsingNode.pathname.charAt(0) === '/' ? urlParsingNode.pathname : '/' + urlParsingNode.pathname
        };
      }

      originURL = resolveURL(window.location.href);
      /**
      * Determine if a URL shares the same origin as the current location
      *
      * @param {String} requestURL The URL to test
      * @returns {boolean} True if URL shares the same origin, otherwise false
      */

      return function isURLSameOrigin(requestURL) {
        var parsed = utils.isString(requestURL) ? resolveURL(requestURL) : requestURL;
        return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
      };
    }() : // Non standard browser envs (web workers, react-native) lack needed support.
    function nonStandardBrowserEnv() {
      return function isURLSameOrigin() {
        return true;
      };
    }();

    var xhr = function xhrAdapter(config) {
      return new Promise(function dispatchXhrRequest(resolve, reject) {
        var requestData = config.data;
        var requestHeaders = config.headers;

        if (utils.isFormData(requestData)) {
          delete requestHeaders['Content-Type']; // Let the browser set it
        }

        if ((utils.isBlob(requestData) || utils.isFile(requestData)) && requestData.type) {
          delete requestHeaders['Content-Type']; // Let the browser set it
        }

        var request = new XMLHttpRequest(); // HTTP basic authentication

        if (config.auth) {
          var username = config.auth.username || '';
          var password = unescape(encodeURIComponent(config.auth.password)) || '';
          requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
        }

        var fullPath = buildFullPath(config.baseURL, config.url);
        request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true); // Set the request timeout in MS

        request.timeout = config.timeout; // Listen for ready state

        request.onreadystatechange = function handleLoad() {
          if (!request || request.readyState !== 4) {
            return;
          } // The request errored out and we didn't get a response, this will be
          // handled by onerror instead
          // With one exception: request that using file: protocol, most browsers
          // will return status as 0 even though it's a successful request


          if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
            return;
          } // Prepare the response


          var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
          var responseData = !config.responseType || config.responseType === 'text' ? request.responseText : request.response;
          var response = {
            data: responseData,
            status: request.status,
            statusText: request.statusText,
            headers: responseHeaders,
            config: config,
            request: request
          };
          settle(resolve, reject, response); // Clean up request

          request = null;
        }; // Handle browser request cancellation (as opposed to a manual cancellation)


        request.onabort = function handleAbort() {
          if (!request) {
            return;
          }

          reject(createError('Request aborted', config, 'ECONNABORTED', request)); // Clean up request

          request = null;
        }; // Handle low level network errors


        request.onerror = function handleError() {
          // Real errors are hidden from us by the browser
          // onerror should only fire if it's a network error
          reject(createError('Network Error', config, null, request)); // Clean up request

          request = null;
        }; // Handle timeout


        request.ontimeout = function handleTimeout() {
          var timeoutErrorMessage = 'timeout of ' + config.timeout + 'ms exceeded';

          if (config.timeoutErrorMessage) {
            timeoutErrorMessage = config.timeoutErrorMessage;
          }

          reject(createError(timeoutErrorMessage, config, 'ECONNABORTED', request)); // Clean up request

          request = null;
        }; // Add xsrf header
        // This is only done if running in a standard browser environment.
        // Specifically not if we're in a web worker, or react-native.


        if (utils.isStandardBrowserEnv()) {
          // Add xsrf header
          var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ? cookies.read(config.xsrfCookieName) : undefined;

          if (xsrfValue) {
            requestHeaders[config.xsrfHeaderName] = xsrfValue;
          }
        } // Add headers to the request


        if ('setRequestHeader' in request) {
          utils.forEach(requestHeaders, function setRequestHeader(val, key) {
            if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
              // Remove Content-Type if data is undefined
              delete requestHeaders[key];
            } else {
              // Otherwise add header to the request
              request.setRequestHeader(key, val);
            }
          });
        } // Add withCredentials to request if needed


        if (!utils.isUndefined(config.withCredentials)) {
          request.withCredentials = !!config.withCredentials;
        } // Add responseType to request if needed


        if (config.responseType) {
          try {
            request.responseType = config.responseType;
          } catch (e) {
            // Expected DOMException thrown by browsers not compatible XMLHttpRequest Level 2.
            // But, this can be suppressed for 'json' type as it can be parsed by default 'transformResponse' function.
            if (config.responseType !== 'json') {
              throw e;
            }
          }
        } // Handle progress if needed


        if (typeof config.onDownloadProgress === 'function') {
          request.addEventListener('progress', config.onDownloadProgress);
        } // Not all browsers support upload events


        if (typeof config.onUploadProgress === 'function' && request.upload) {
          request.upload.addEventListener('progress', config.onUploadProgress);
        }

        if (config.cancelToken) {
          // Handle cancellation
          config.cancelToken.promise.then(function onCanceled(cancel) {
            if (!request) {
              return;
            }

            request.abort();
            reject(cancel); // Clean up request

            request = null;
          });
        }

        if (!requestData) {
          requestData = null;
        } // Send the request


        request.send(requestData);
      });
    };

    var DEFAULT_CONTENT_TYPE = {
      'Content-Type': 'application/x-www-form-urlencoded'
    };

    function setContentTypeIfUnset(headers, value) {
      if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
        headers['Content-Type'] = value;
      }
    }

    function getDefaultAdapter() {
      var adapter;

      if (typeof XMLHttpRequest !== 'undefined') {
        // For browsers use XHR adapter
        adapter = xhr;
      } else if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {
        // For node use HTTP adapter
        adapter = xhr;
      }

      return adapter;
    }

    var defaults = {
      adapter: getDefaultAdapter(),
      transformRequest: [function transformRequest(data, headers) {
        normalizeHeaderName(headers, 'Accept');
        normalizeHeaderName(headers, 'Content-Type');

        if (utils.isFormData(data) || utils.isArrayBuffer(data) || utils.isBuffer(data) || utils.isStream(data) || utils.isFile(data) || utils.isBlob(data)) {
          return data;
        }

        if (utils.isArrayBufferView(data)) {
          return data.buffer;
        }

        if (utils.isURLSearchParams(data)) {
          setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
          return data.toString();
        }

        if (utils.isObject(data)) {
          setContentTypeIfUnset(headers, 'application/json;charset=utf-8');
          return JSON.stringify(data);
        }

        return data;
      }],
      transformResponse: [function transformResponse(data) {
        /*eslint no-param-reassign:0*/
        if (typeof data === 'string') {
          try {
            data = JSON.parse(data);
          } catch (e) {
            /* Ignore */
          }
        }

        return data;
      }],

      /**
       * A timeout in milliseconds to abort a request. If set to 0 (default) a
       * timeout is not created.
       */
      timeout: 0,
      xsrfCookieName: 'XSRF-TOKEN',
      xsrfHeaderName: 'X-XSRF-TOKEN',
      maxContentLength: -1,
      maxBodyLength: -1,
      validateStatus: function validateStatus(status) {
        return status >= 200 && status < 300;
      }
    };
    defaults.headers = {
      common: {
        'Accept': 'application/json, text/plain, */*'
      }
    };
    utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
      defaults.headers[method] = {};
    });
    utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
      defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
    });
    var defaults_1 = defaults;

    /**
     * Throws a `Cancel` if cancellation has been requested.
     */


    function throwIfCancellationRequested(config) {
      if (config.cancelToken) {
        config.cancelToken.throwIfRequested();
      }
    }
    /**
     * Dispatch a request to the server using the configured adapter.
     *
     * @param {object} config The config that is to be used for the request
     * @returns {Promise} The Promise to be fulfilled
     */


    var dispatchRequest = function dispatchRequest(config) {
      throwIfCancellationRequested(config); // Ensure headers exist

      config.headers = config.headers || {}; // Transform request data

      config.data = transformData(config.data, config.headers, config.transformRequest); // Flatten headers

      config.headers = utils.merge(config.headers.common || {}, config.headers[config.method] || {}, config.headers);
      utils.forEach(['delete', 'get', 'head', 'post', 'put', 'patch', 'common'], function cleanHeaderConfig(method) {
        delete config.headers[method];
      });
      var adapter = config.adapter || defaults_1.adapter;
      return adapter(config).then(function onAdapterResolution(response) {
        throwIfCancellationRequested(config); // Transform response data

        response.data = transformData(response.data, response.headers, config.transformResponse);
        return response;
      }, function onAdapterRejection(reason) {
        if (!isCancel(reason)) {
          throwIfCancellationRequested(config); // Transform response data

          if (reason && reason.response) {
            reason.response.data = transformData(reason.response.data, reason.response.headers, config.transformResponse);
          }
        }

        return Promise.reject(reason);
      });
    };

    /**
     * Config-specific merge-function which creates a new config-object
     * by merging two configuration objects together.
     *
     * @param {Object} config1
     * @param {Object} config2
     * @returns {Object} New object resulting from merging config2 to config1
     */


    var mergeConfig = function mergeConfig(config1, config2) {
      // eslint-disable-next-line no-param-reassign
      config2 = config2 || {};
      var config = {};
      var valueFromConfig2Keys = ['url', 'method', 'data'];
      var mergeDeepPropertiesKeys = ['headers', 'auth', 'proxy', 'params'];
      var defaultToConfig2Keys = ['baseURL', 'transformRequest', 'transformResponse', 'paramsSerializer', 'timeout', 'timeoutMessage', 'withCredentials', 'adapter', 'responseType', 'xsrfCookieName', 'xsrfHeaderName', 'onUploadProgress', 'onDownloadProgress', 'decompress', 'maxContentLength', 'maxBodyLength', 'maxRedirects', 'transport', 'httpAgent', 'httpsAgent', 'cancelToken', 'socketPath', 'responseEncoding'];
      var directMergeKeys = ['validateStatus'];

      function getMergedValue(target, source) {
        if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
          return utils.merge(target, source);
        } else if (utils.isPlainObject(source)) {
          return utils.merge({}, source);
        } else if (utils.isArray(source)) {
          return source.slice();
        }

        return source;
      }

      function mergeDeepProperties(prop) {
        if (!utils.isUndefined(config2[prop])) {
          config[prop] = getMergedValue(config1[prop], config2[prop]);
        } else if (!utils.isUndefined(config1[prop])) {
          config[prop] = getMergedValue(undefined, config1[prop]);
        }
      }

      utils.forEach(valueFromConfig2Keys, function valueFromConfig2(prop) {
        if (!utils.isUndefined(config2[prop])) {
          config[prop] = getMergedValue(undefined, config2[prop]);
        }
      });
      utils.forEach(mergeDeepPropertiesKeys, mergeDeepProperties);
      utils.forEach(defaultToConfig2Keys, function defaultToConfig2(prop) {
        if (!utils.isUndefined(config2[prop])) {
          config[prop] = getMergedValue(undefined, config2[prop]);
        } else if (!utils.isUndefined(config1[prop])) {
          config[prop] = getMergedValue(undefined, config1[prop]);
        }
      });
      utils.forEach(directMergeKeys, function merge(prop) {
        if (prop in config2) {
          config[prop] = getMergedValue(config1[prop], config2[prop]);
        } else if (prop in config1) {
          config[prop] = getMergedValue(undefined, config1[prop]);
        }
      });
      var axiosKeys = valueFromConfig2Keys.concat(mergeDeepPropertiesKeys).concat(defaultToConfig2Keys).concat(directMergeKeys);
      var otherKeys = Object.keys(config1).concat(Object.keys(config2)).filter(function filterAxiosKeys(key) {
        return axiosKeys.indexOf(key) === -1;
      });
      utils.forEach(otherKeys, mergeDeepProperties);
      return config;
    };

    /**
     * Create a new instance of Axios
     *
     * @param {Object} instanceConfig The default config for the instance
     */


    function Axios(instanceConfig) {
      this.defaults = instanceConfig;
      this.interceptors = {
        request: new InterceptorManager_1(),
        response: new InterceptorManager_1()
      };
    }
    /**
     * Dispatch a request
     *
     * @param {Object} config The config specific for this request (merged with this.defaults)
     */


    Axios.prototype.request = function request(config) {
      /*eslint no-param-reassign:0*/
      // Allow for axios('example/url'[, config]) a la fetch API
      if (typeof config === 'string') {
        config = arguments[1] || {};
        config.url = arguments[0];
      } else {
        config = config || {};
      }

      config = mergeConfig(this.defaults, config); // Set config.method

      if (config.method) {
        config.method = config.method.toLowerCase();
      } else if (this.defaults.method) {
        config.method = this.defaults.method.toLowerCase();
      } else {
        config.method = 'get';
      } // Hook up interceptors middleware


      var chain = [dispatchRequest, undefined];
      var promise = Promise.resolve(config);
      this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
        chain.unshift(interceptor.fulfilled, interceptor.rejected);
      });
      this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
        chain.push(interceptor.fulfilled, interceptor.rejected);
      });

      while (chain.length) {
        promise = promise.then(chain.shift(), chain.shift());
      }

      return promise;
    };

    Axios.prototype.getUri = function getUri(config) {
      config = mergeConfig(this.defaults, config);
      return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\?/, '');
    }; // Provide aliases for supported request methods


    utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
      /*eslint func-names:0*/
      Axios.prototype[method] = function (url, config) {
        return this.request(mergeConfig(config || {}, {
          method: method,
          url: url
        }));
      };
    });
    utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
      /*eslint func-names:0*/
      Axios.prototype[method] = function (url, data, config) {
        return this.request(mergeConfig(config || {}, {
          method: method,
          url: url,
          data: data
        }));
      };
    });
    var Axios_1 = Axios;

    /**
     * A `Cancel` is an object that is thrown when an operation is canceled.
     *
     * @class
     * @param {string=} message The message.
     */

    function Cancel(message) {
      this.message = message;
    }

    Cancel.prototype.toString = function toString() {
      return 'Cancel' + (this.message ? ': ' + this.message : '');
    };

    Cancel.prototype.__CANCEL__ = true;
    var Cancel_1 = Cancel;

    /**
     * A `CancelToken` is an object that can be used to request cancellation of an operation.
     *
     * @class
     * @param {Function} executor The executor function.
     */


    function CancelToken(executor) {
      if (typeof executor !== 'function') {
        throw new TypeError('executor must be a function.');
      }

      var resolvePromise;
      this.promise = new Promise(function promiseExecutor(resolve) {
        resolvePromise = resolve;
      });
      var token = this;
      executor(function cancel(message) {
        if (token.reason) {
          // Cancellation has already been requested
          return;
        }

        token.reason = new Cancel_1(message);
        resolvePromise(token.reason);
      });
    }
    /**
     * Throws a `Cancel` if cancellation has been requested.
     */


    CancelToken.prototype.throwIfRequested = function throwIfRequested() {
      if (this.reason) {
        throw this.reason;
      }
    };
    /**
     * Returns an object that contains a new `CancelToken` and a function that, when called,
     * cancels the `CancelToken`.
     */


    CancelToken.source = function source() {
      var cancel;
      var token = new CancelToken(function executor(c) {
        cancel = c;
      });
      return {
        token: token,
        cancel: cancel
      };
    };

    var CancelToken_1 = CancelToken;

    /**
     * Syntactic sugar for invoking a function and expanding an array for arguments.
     *
     * Common use case would be to use `Function.prototype.apply`.
     *
     *  ```js
     *  function f(x, y, z) {}
     *  var args = [1, 2, 3];
     *  f.apply(null, args);
     *  ```
     *
     * With `spread` this example can be re-written.
     *
     *  ```js
     *  spread(function(x, y, z) {})([1, 2, 3]);
     *  ```
     *
     * @param {Function} callback
     * @returns {Function}
     */

    var spread = function spread(callback) {
      return function wrap(arr) {
        return callback.apply(null, arr);
      };
    };

    /**
     * Create an instance of Axios
     *
     * @param {Object} defaultConfig The default config for the instance
     * @return {Axios} A new instance of Axios
     */


    function createInstance(defaultConfig) {
      var context = new Axios_1(defaultConfig);
      var instance = bind$1(Axios_1.prototype.request, context); // Copy axios.prototype to instance

      utils.extend(instance, Axios_1.prototype, context); // Copy context to instance

      utils.extend(instance, context);
      return instance;
    } // Create the default instance to be exported


    var axios = createInstance(defaults_1); // Expose Axios class to allow class inheritance

    axios.Axios = Axios_1; // Factory for creating new instances

    axios.create = function create(instanceConfig) {
      return createInstance(mergeConfig(axios.defaults, instanceConfig));
    }; // Expose Cancel & CancelToken


    axios.Cancel = Cancel_1;
    axios.CancelToken = CancelToken_1;
    axios.isCancel = isCancel; // Expose all/spread

    axios.all = function all(promises) {
      return Promise.all(promises);
    };

    axios.spread = spread;
    var axios_1 = axios; // Allow use of default import syntax in TypeScript

    var _default = axios;
    axios_1.default = _default;

    var axios$1 = axios_1;

    axios$1.maxRedirects = 0;
    axios$1.interceptors.response.use(function (response) {
      // Any status code that lie within the range of 2xx cause this function to trigger
      // Do something with response data
      if (response && response.data && response.data.redirect) {
        //??quitado
        console.log(response.data.redirect);
        window.location.href = response.data.redirect; // throw new Error("Redirigido")

        return;
      } // if(response?.data?.redirect || false){ //??quitado
      //     window.location.href = response.data.redirect
      //     throw new Error("Redirigido")
      // }
      // if(response.request.responseURL && response.request.responseURL.indexOf("/Domad") != -1) {
      //     window.location = response.request.responseURL
      // }
      // if(response.data.redirect) window.location = response.data.redirect;


      return response;
    }, function (error) {
      // if(error?.response?.data.redirect){
      if (error.response && error.response.data && error.response.data.redirect) {
        console.log(JSON.stringify(error.response));
        window.location = error.response.data.redirect;
        return Promise.resolve();
      }

      return Promise.reject(error);
    });
    axios$1.interceptors.request.use(function (config) {
      // Do something before request is sent
      config.headers["RequestVerificationToken"] = window.token;
      return config;
    }, function (error) {
      // Do something with request error
      return Promise.reject(error);
    });
    class RChanClient {
      // Acciones
      static crearHilo(titulo, categoria, contenido, archivo, link = "", audio = null, captcha = "", encuesta = [], mostrarNombre = false, mostrarRango = false) {
        let form = new FormData();
        form.append("Titulo", titulo);
        form.append("CategoriaId", categoria);
        form.append("Contenido", contenido);
        form.append("Archivo", archivo);
        form.append("Link", link);
        form.append("captcha", captcha);
        form.append("encuesta", JSON.stringify(encuesta));

        if (mostrarNombre || mostrarRango) {
          form.append('mostrarNombre', mostrarNombre);
          form.append('mostrarRango', mostrarRango);
        }

        form.append("Audio", audio);
        return axios$1.post("/api/Hilo/Crear", form);
      }

      static crearComentario(hiloId, contenido, archivo = null, link = "", audio = null, captcha = "", mostrarNombre = false, mostrarRango = false) {
        let form = new FormData();
        form.append('hiloId', hiloId);
        form.append('contenido', contenido);
        form.append('archivo', archivo);
        form.append("Link", link);
        form.append('captcha', captcha);

        if (mostrarNombre || mostrarRango) {
          form.append('mostrarNombre', mostrarNombre);
          form.append('mostrarRango', mostrarRango);
        }

        form.append("audio", audio);
        return axios$1.post('/api/Comentario/Crear', form);
      }

      static registrase(nick, contraseña, captcha, codigoDeInvitacion = "") {
        return axios$1.post('/api/Usuario/Registro', {
          nick,
          contraseña,
          captcha,
          codigo: codigoDeInvitacion
        });
      }

      static restaurarSesion(token) {
        return axios$1.post('/api/Usuario/RestaurarSesion', {
          token
        });
      }

      static inicio(captcha, codigoDeInvitacion = "") {
        return axios$1.post('/api/Usuario/Inicio', {
          captcha,
          codigo: codigoDeInvitacion
        });
      }

      static logearse(nick, contraseña) {
        return axios$1.post('/api/Usuario/Login', {
          nick,
          contraseña
        });
      }

      static deslogearse() {
        return axios$1.post('/logout');
      }

      static agregar(accion, id) {
        return axios$1.post('/api/Hilo/Agregar', {
          accion,
          // favoritos | seguidos | ocultos
          hiloId: id
        });
      }

      static limpiarNotificaciones() {
        return axios$1.post("/api/Notificacion/Limpiar");
      }

      static añadirRol(nick, role) {
        return axios$1.post("/api/Administracion/AñadirRol", {
          username: nick,
          role
        });
      }

      static removerRol(nick, role) {
        return axios$1.post("/api/Administracion/RemoverRol", {
          username: nick,
          role
        });
      }

      static refrescarOnlines() {
        return axios$1.post("/api/Administracion/RefrescarOnlines");
      }

      static añadirSticky(hiloId, global, importancia) {
        return axios$1.post("/api/Moderacion/AñadirSticky", {
          hiloId,
          global,
          importancia: Number(importancia)
        });
      }

      static borrarHilos(ids, borrarMedia = false, borrarAudio = false) {
        return axios$1.post("/api/Moderacion/BorrarHilo", {
          ids,
          borrarMedia,
          borrarAudio
        });
      }

      static borrarHilo(id, borrarMedia = false) {
        return RChanClient.borrarHilos([id], borrarMedia);
      }

      static cambiarCategoria(hiloId, categoriaId, advertencia = true) {
        return axios$1.post("/api/Moderacion/CambiarCategoria", {
          hiloId,
          categoriaId,
          advertencia
        });
      }

      static ActualizarConfiguracion(config) {
        return axios$1.post("/api/Administracion/ActualizarConfiguracion", config);
      }

      static Denunciar(tipo, hiloId, motivo, aclaracion, comentarioId) {
        return axios$1.post("/api/Hilo/Denunciar", {
          tipo,
          hiloId,
          motivo,
          aclaracion,
          comentarioId
        });
      }

      static banear(motivo, aclaracion, duracion, usuarioId, hiloId = "", comentarioId = "", eliminarElemento = true, eliminarAdjunto = false, eliminarAudio = false, desaparecer = false) {
        return axios$1.post("/api/Moderacion/Banear", {
          motivo,
          aclaracion,
          duracion,
          eliminarElemento,
          eliminarAdjunto,
          eliminarAudio,
          hiloId,
          comentarioId,
          desaparecer
        });
      }

      static cargarMasHilos(ultimoBump, categorias, serios = false) {
        return axios$1.get('api/Hilo/CargarMas', {
          params: {
            ultimoBump,
            categorias: categorias.join(","),
            serios
          }
        });
      } //Paginas


      static index() {
        return axios$1.get("/");
      }

      static hilo(id) {
        return axios$1.get(`/Hilo/${id}`);
      }

      static favoritos(id) {
        return axios$1.get(`/Hilo/Favoritos`);
      } //Denuncias


      static rechazarDenuncia(denunciaId) {
        return axios$1.post(`/api/Moderacion/RechazarDenuncia/${denunciaId}`);
      }

      static eliminarComentarios(ids, borrarMedia = false, borrarAudio = false) {
        return axios$1.post(`/api/Moderacion/EliminarComentarios`, {
          ids,
          borrarMedia,
          borrarAudio
        });
      }

      static removerBan(id) {
        return axios$1.post(`/api/Moderacion/RemoverBan/${id}`);
      }

      static restaurarRoz(id) {
        return axios$1.post(`/api/Moderacion/RestaurarHilo/${id}`);
      }

      static restaurarComentario(id) {
        return axios$1.post(`/api/Moderacion/RestaurarComentario/${id}`);
      }

      static generarNuevoLinkDeInvitacion() {
        return axios$1.post(`/api/Administracion/GenerarNuevoLinkDeInvitacion`);
      }

      static eliminarMedias(ids) {
        return axios$1.post(`/api/Moderacion/EliminarMedia`, ids);
      }

      static eliminarMedia(mediaId, eliminarElementos = true) {
        return axios$1.post(`/api/Moderacion/EliminarMedia`, {
          mediaId,
          eliminarElementos
        });
      }

      static limpiarRozesViejos() {
        return axios$1.post(`/api/Administracion/LimpiarRozesViejos`);
      }

      static buscar(cadenaDeBusqueda) {
        return axios$1.post(`/api/Hilo/Buscar?busqueda=${cadenaDeBusqueda}`);
      }

      static votarEncuesta(hiloId, opcion) {
        return axios$1.post(`/api/Hilo/VotarEncuesta`, {
          hiloId,
          opcion
        });
      }

      static hackYoutube(link) {
        return axios$1.get(`/api/Otros/YoutubeAArchivo?url=${link}`);
      }

      static crearSpam(urlImagen, link, duracion) {
        return axios$1.post('/api/Administracion/CrearSpam', {
          urlImagen,
          link,
          duracion
        });
      }

      static eliminarSpam(id) {
        return axios$1.post('/api/Administracion/EliminarSpam', {
          id
        });
      }

    }

    /* src\components\Media.svelte generated by Svelte v3.29.0 */
    const file$2 = "src\\components\\Media.svelte"; // (45:4) {#if !abierto}

    function create_if_block_15(ctx) {
      let div;
      let button;
      let current;
      button = new ye({
        props: {
          class: "cerrar",
          icon: true,
          $$slots: {
            default: [create_default_slot_10]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      button.$on("click",
      /*click_handler*/
      ctx[10]);
      const block = {
        c: function create() {
          div = element("div");
          create_component(button.$$.fragment);
          attr_dev(div, "class", "ocultar svelte-1eiejjx");
          add_location(div, file$2, 45, 8, 1112);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          mount_component(button, div, null);
          current = true;
        },
        p: function update(ctx, dirty) {
          const button_changes = {};

          if (dirty &
          /*$$scope, oculto*/
          524296) {
            button_changes.$$scope = {
              dirty,
              ctx
            };
          }

          button.$set(button_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(button.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(button.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
          destroy_component(button);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_15.name,
        type: "if",
        source: "(45:4) {#if !abierto}",
        ctx
      });
      return block;
    } // (47:12) <Button on:click={() => (oculto = !oculto)} class="cerrar" icon>


    function create_default_slot_10(ctx) {
      let i;
      let i_class_value;
      const block = {
        c: function create() {
          i = element("i");
          attr_dev(i, "class", i_class_value = "fe fe-eye" + (!
          /*oculto*/
          ctx[3] ? "-off" : ""));
          add_location(i, file$2, 47, 16, 1229);
        },
        m: function mount(target, anchor) {
          insert_dev(target, i, anchor);
        },
        p: function update(ctx, dirty) {
          if (dirty &
          /*oculto*/
          8 && i_class_value !== (i_class_value = "fe fe-eye" + (!
          /*oculto*/
          ctx[3] ? "-off" : ""))) {
            attr_dev(i, "class", i_class_value);
          }
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(i);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_10.name,
        type: "slot",
        source: "(47:12) <Button on:click={() => (oculto = !oculto)} class=\\\"cerrar\\\" icon>",
        ctx
      });
      return block;
    } // (208:50) 


    function create_if_block_13(ctx) {
      let current_block_type_index;
      let if_block;
      let t0;
      let div;
      let a;
      let t1;
      let ripple;
      let a_href_value;
      let current;
      const if_block_creators = [create_if_block_14, create_else_block_7];
      const if_blocks = [];

      function select_block_type_8(ctx, dirty) {
        if (
        /*abierto*/
        ctx[0]) return 0;
        return 1;
      }

      current_block_type_index = select_block_type_8(ctx);
      if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
      ripple = new he({
        $$inline: true
      });
      const block = {
        c: function create() {
          if_block.c();
          t0 = space();
          div = element("div");
          a = element("a");
          t1 = text("Abrir en PornHub\r\n                ");
          create_component(ripple.$$.fragment);
          attr_dev(a, "class", "medialink svelte-1eiejjx");
          attr_dev(a, "target", "_blanck");
          attr_dev(a, "href", a_href_value = "https://pornhub.com/view_video.php?viewkey=" +
          /*media*/
          ctx[1].hash.replace(/[a-zA-Z]*_/g, ""));
          add_location(a, file$2, 233, 12, 8245);
          attr_dev(div, "class", "youtube-footer svelte-1eiejjx");
          add_location(div, file$2, 232, 8, 8203);
        },
        m: function mount(target, anchor) {
          if_blocks[current_block_type_index].m(target, anchor);
          insert_dev(target, t0, anchor);
          insert_dev(target, div, anchor);
          append_dev(div, a);
          append_dev(a, t1);
          mount_component(ripple, a, null);
          current = true;
        },
        p: function update(ctx, dirty) {
          let previous_block_index = current_block_type_index;
          current_block_type_index = select_block_type_8(ctx);

          if (current_block_type_index === previous_block_index) {
            if_blocks[current_block_type_index].p(ctx, dirty);
          } else {
            group_outros();
            transition_out(if_blocks[previous_block_index], 1, 1, () => {
              if_blocks[previous_block_index] = null;
            });
            check_outros();
            if_block = if_blocks[current_block_type_index];

            if (!if_block) {
              if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
              if_block.c();
            }

            transition_in(if_block, 1);
            if_block.m(t0.parentNode, t0);
          }

          if (!current || dirty &
          /*media*/
          2 && a_href_value !== (a_href_value = "https://pornhub.com/view_video.php?viewkey=" +
          /*media*/
          ctx[1].hash.replace(/[a-zA-Z]*_/g, ""))) {
            attr_dev(a, "href", a_href_value);
          }
        },
        i: function intro(local) {
          if (current) return;
          transition_in(if_block);
          transition_in(ripple.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(if_block);
          transition_out(ripple.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if_blocks[current_block_type_index].d(detaching);
          if (detaching) detach_dev(t0);
          if (detaching) detach_dev(div);
          destroy_component(ripple);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_13.name,
        type: "if",
        source: "(208:50) ",
        ctx
      });
      return block;
    } // (171:50) 


    function create_if_block_11(ctx) {
      let current_block_type_index;
      let if_block;
      let t0;
      let div;
      let a;
      let t1;
      let ripple;
      let a_href_value;
      let current;
      const if_block_creators = [create_if_block_12, create_else_block_6];
      const if_blocks = [];

      function select_block_type_7(ctx, dirty) {
        if (
        /*abierto*/
        ctx[0]) return 0;
        return 1;
      }

      current_block_type_index = select_block_type_7(ctx);
      if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
      ripple = new he({
        $$inline: true
      });
      const block = {
        c: function create() {
          if_block.c();
          t0 = space();
          div = element("div");
          a = element("a");
          t1 = text("Abrir en DailyMotion\r\n                ");
          create_component(ripple.$$.fragment);
          attr_dev(a, "class", "medialink svelte-1eiejjx");
          attr_dev(a, "target", "_blanck");
          attr_dev(a, "href", a_href_value = "https://dai.ly/" +
          /*media*/
          ctx[1].hash.replace(/[a-zA-Z]*_/g, ""));
          add_location(a, file$2, 198, 12, 6936);
          attr_dev(div, "class", "youtube-footer svelte-1eiejjx");
          add_location(div, file$2, 197, 8, 6894);
        },
        m: function mount(target, anchor) {
          if_blocks[current_block_type_index].m(target, anchor);
          insert_dev(target, t0, anchor);
          insert_dev(target, div, anchor);
          append_dev(div, a);
          append_dev(a, t1);
          mount_component(ripple, a, null);
          current = true;
        },
        p: function update(ctx, dirty) {
          let previous_block_index = current_block_type_index;
          current_block_type_index = select_block_type_7(ctx);

          if (current_block_type_index === previous_block_index) {
            if_blocks[current_block_type_index].p(ctx, dirty);
          } else {
            group_outros();
            transition_out(if_blocks[previous_block_index], 1, 1, () => {
              if_blocks[previous_block_index] = null;
            });
            check_outros();
            if_block = if_blocks[current_block_type_index];

            if (!if_block) {
              if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
              if_block.c();
            }

            transition_in(if_block, 1);
            if_block.m(t0.parentNode, t0);
          }

          if (!current || dirty &
          /*media*/
          2 && a_href_value !== (a_href_value = "https://dai.ly/" +
          /*media*/
          ctx[1].hash.replace(/[a-zA-Z]*_/g, ""))) {
            attr_dev(a, "href", a_href_value);
          }
        },
        i: function intro(local) {
          if (current) return;
          transition_in(if_block);
          transition_in(ripple.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(if_block);
          transition_out(ripple.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if_blocks[current_block_type_index].d(detaching);
          if (detaching) detach_dev(t0);
          if (detaching) detach_dev(div);
          destroy_component(ripple);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_11.name,
        type: "if",
        source: "(171:50) ",
        ctx
      });
      return block;
    } // (134:47) 


    function create_if_block_9(ctx) {
      let current_block_type_index;
      let if_block;
      let t0;
      let div;
      let a;
      let t1;
      let ripple;
      let a_href_value;
      let current;
      const if_block_creators = [create_if_block_10, create_else_block_5];
      const if_blocks = [];

      function select_block_type_6(ctx, dirty) {
        if (
        /*abierto*/
        ctx[0]) return 0;
        return 1;
      }

      current_block_type_index = select_block_type_6(ctx);
      if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
      ripple = new he({
        $$inline: true
      });
      const block = {
        c: function create() {
          if_block.c();
          t0 = space();
          div = element("div");
          a = element("a");
          t1 = text("Abrir en Bitchute\r\n                ");
          create_component(ripple.$$.fragment);
          attr_dev(a, "class", "medialink svelte-1eiejjx");
          attr_dev(a, "target", "_blanck");
          attr_dev(a, "href", a_href_value = "https://www.bitchute.com/video/" +
          /*media*/
          ctx[1].hash.replace(/[a-zA-Z]*_/g, "") + "/");
          add_location(a, file$2, 158, 12, 5391);
          attr_dev(div, "class", "youtube-footer svelte-1eiejjx");
          add_location(div, file$2, 157, 8, 5349);
        },
        m: function mount(target, anchor) {
          if_blocks[current_block_type_index].m(target, anchor);
          insert_dev(target, t0, anchor);
          insert_dev(target, div, anchor);
          append_dev(div, a);
          append_dev(a, t1);
          mount_component(ripple, a, null);
          current = true;
        },
        p: function update(ctx, dirty) {
          let previous_block_index = current_block_type_index;
          current_block_type_index = select_block_type_6(ctx);

          if (current_block_type_index === previous_block_index) {
            if_blocks[current_block_type_index].p(ctx, dirty);
          } else {
            group_outros();
            transition_out(if_blocks[previous_block_index], 1, 1, () => {
              if_blocks[previous_block_index] = null;
            });
            check_outros();
            if_block = if_blocks[current_block_type_index];

            if (!if_block) {
              if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
              if_block.c();
            }

            transition_in(if_block, 1);
            if_block.m(t0.parentNode, t0);
          }

          if (!current || dirty &
          /*media*/
          2 && a_href_value !== (a_href_value = "https://www.bitchute.com/video/" +
          /*media*/
          ctx[1].hash.replace(/[a-zA-Z]*_/g, "") + "/")) {
            attr_dev(a, "href", a_href_value);
          }
        },
        i: function intro(local) {
          if (current) return;
          transition_in(if_block);
          transition_in(ripple.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(if_block);
          transition_out(ripple.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if_blocks[current_block_type_index].d(detaching);
          if (detaching) detach_dev(t0);
          if (detaching) detach_dev(div);
          destroy_component(ripple);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_9.name,
        type: "if",
        source: "(134:47) ",
        ctx
      });
      return block;
    } // (83:46) 


    function create_if_block_5(ctx) {
      let current_block_type_index;
      let if_block0;
      let t0;
      let div;
      let current_block_type_index_1;
      let if_block1;
      let t1;
      let a;
      let t2;
      let ripple;
      let a_href_value;
      let current;
      const if_block_creators = [create_if_block_7, create_else_block_4];
      const if_blocks = [];

      function select_block_type_3(ctx, dirty) {
        if (
        /*abierto*/
        ctx[0]) return 0;
        return 1;
      }

      current_block_type_index = select_block_type_3(ctx);
      if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
      const if_block_creators_1 = [create_if_block_6, create_else_block_2];
      const if_blocks_1 = [];

      function select_block_type_5(ctx, dirty) {
        if (!
        /*hackYoutubeActivo*/
        ctx[5]) return 0;
        return 1;
      }

      current_block_type_index_1 = select_block_type_5(ctx);
      if_block1 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);
      ripple = new he({
        $$inline: true
      });
      const block = {
        c: function create() {
          if_block0.c();
          t0 = space();
          div = element("div");
          if_block1.c();
          t1 = space();
          a = element("a");
          t2 = text("Abrir en Jewtube\r\n                ");
          create_component(ripple.$$.fragment);
          attr_dev(a, "class", "medialink svelte-1eiejjx");
          attr_dev(a, "target", "_blanck");
          attr_dev(a, "href", a_href_value = "https://www.youtube.com/watch/" +
          /*media*/
          ctx[1].hash);
          add_location(a, file$2, 124, 12, 4130);
          attr_dev(div, "class", "youtube-footer svelte-1eiejjx");
          add_location(div, file$2, 107, 8, 3510);
        },
        m: function mount(target, anchor) {
          if_blocks[current_block_type_index].m(target, anchor);
          insert_dev(target, t0, anchor);
          insert_dev(target, div, anchor);
          if_blocks_1[current_block_type_index_1].m(div, null);
          append_dev(div, t1);
          append_dev(div, a);
          append_dev(a, t2);
          mount_component(ripple, a, null);
          current = true;
        },
        p: function update(ctx, dirty) {
          let previous_block_index = current_block_type_index;
          current_block_type_index = select_block_type_3(ctx);

          if (current_block_type_index === previous_block_index) {
            if_blocks[current_block_type_index].p(ctx, dirty);
          } else {
            group_outros();
            transition_out(if_blocks[previous_block_index], 1, 1, () => {
              if_blocks[previous_block_index] = null;
            });
            check_outros();
            if_block0 = if_blocks[current_block_type_index];

            if (!if_block0) {
              if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
              if_block0.c();
            }

            transition_in(if_block0, 1);
            if_block0.m(t0.parentNode, t0);
          }

          let previous_block_index_1 = current_block_type_index_1;
          current_block_type_index_1 = select_block_type_5(ctx);

          if (current_block_type_index_1 === previous_block_index_1) {
            if_blocks_1[current_block_type_index_1].p(ctx, dirty);
          } else {
            group_outros();
            transition_out(if_blocks_1[previous_block_index_1], 1, 1, () => {
              if_blocks_1[previous_block_index_1] = null;
            });
            check_outros();
            if_block1 = if_blocks_1[current_block_type_index_1];

            if (!if_block1) {
              if_block1 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);
              if_block1.c();
            }

            transition_in(if_block1, 1);
            if_block1.m(div, t1);
          }

          if (!current || dirty &
          /*media*/
          2 && a_href_value !== (a_href_value = "https://www.youtube.com/watch/" +
          /*media*/
          ctx[1].hash)) {
            attr_dev(a, "href", a_href_value);
          }
        },
        i: function intro(local) {
          if (current) return;
          transition_in(if_block0);
          transition_in(if_block1);
          transition_in(ripple.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(if_block0);
          transition_out(if_block1);
          transition_out(ripple.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if_blocks[current_block_type_index].d(detaching);
          if (detaching) detach_dev(t0);
          if (detaching) detach_dev(div);
          if_blocks_1[current_block_type_index_1].d();
          destroy_component(ripple);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_5.name,
        type: "if",
        source: "(83:46) ",
        ctx
      });
      return block;
    } // (64:44) 


    function create_if_block_3(ctx) {
      let current_block_type_index;
      let if_block;
      let if_block_anchor;
      let current;
      const if_block_creators = [create_if_block_4, create_else_block_1];
      const if_blocks = [];

      function select_block_type_2(ctx, dirty) {
        if (
        /*abierto*/
        ctx[0]) return 0;
        return 1;
      }

      current_block_type_index = select_block_type_2(ctx);
      if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
      const block = {
        c: function create() {
          if_block.c();
          if_block_anchor = empty();
        },
        m: function mount(target, anchor) {
          if_blocks[current_block_type_index].m(target, anchor);
          insert_dev(target, if_block_anchor, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          let previous_block_index = current_block_type_index;
          current_block_type_index = select_block_type_2(ctx);

          if (current_block_type_index === previous_block_index) {
            if_blocks[current_block_type_index].p(ctx, dirty);
          } else {
            group_outros();
            transition_out(if_blocks[previous_block_index], 1, 1, () => {
              if_blocks[previous_block_index] = null;
            });
            check_outros();
            if_block = if_blocks[current_block_type_index];

            if (!if_block) {
              if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
              if_block.c();
            }

            transition_in(if_block, 1);
            if_block.m(if_block_anchor.parentNode, if_block_anchor);
          }
        },
        i: function intro(local) {
          if (current) return;
          transition_in(if_block);
          current = true;
        },
        o: function outro(local) {
          transition_out(if_block);
          current = false;
        },
        d: function destroy(detaching) {
          if_blocks[current_block_type_index].d(detaching);
          if (detaching) detach_dev(if_block_anchor);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_3.name,
        type: "if",
        source: "(64:44) ",
        ctx
      });
      return block;
    } // (54:45) 


    function create_if_block_1(ctx) {
      let if_block_anchor;

      function select_block_type_1(ctx, dirty) {
        if (
        /*media*/
        ctx[1].esGif) return create_if_block_2;
        return create_else_block;
      }

      let current_block_type = select_block_type_1(ctx);
      let if_block = current_block_type(ctx);
      const block = {
        c: function create() {
          if_block.c();
          if_block_anchor = empty();
        },
        m: function mount(target, anchor) {
          if_block.m(target, anchor);
          insert_dev(target, if_block_anchor, anchor);
        },
        p: function update(ctx, dirty) {
          if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block) {
            if_block.p(ctx, dirty);
          } else {
            if_block.d(1);
            if_block = current_block_type(ctx);

            if (if_block) {
              if_block.c();
              if_block.m(if_block_anchor.parentNode, if_block_anchor);
            }
          }
        },
        i: noop,
        o: noop,
        d: function destroy(detaching) {
          if_block.d(detaching);
          if (detaching) detach_dev(if_block_anchor);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_1.name,
        type: "if",
        source: "(54:45) ",
        ctx
      });
      return block;
    } // (52:4) {#if oculto}


    function create_if_block$1(ctx) {
      let div;
      const block = {
        c: function create() {
          div = element("div");
          set_style(div, "height", "64px");
          add_location(div, file$2, 52, 8, 1353);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
        },
        p: noop,
        i: noop,
        o: noop,
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block$1.name,
        type: "if",
        source: "(52:4) {#if oculto}",
        ctx
      });
      return block;
    } // (224:8) {:else}


    function create_else_block_7(ctx) {
      let img;
      let img_src_value;
      let t;
      let button;
      let current;
      let mounted;
      let dispose;
      button = new ye({
        props: {
          color: "red",
          class: "play",
          icon: true,
          $$slots: {
            default: [create_default_slot_9]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      button.$on("click",
      /*abrirVideo*/
      ctx[8]);
      const block = {
        c: function create() {
          img = element("img");
          t = space();
          create_component(button.$$.fragment);
          if (img.src !== (img_src_value =
          /*vistaPrevia*/
          ctx[7])) attr_dev(img, "src", img_src_value);
          attr_dev(img, "alt", "");
          attr_dev(img, "srcset", "");
          attr_dev(img, "class", "svelte-1eiejjx");
          add_location(img, file$2, 224, 12, 7875);
        },
        m: function mount(target, anchor) {
          insert_dev(target, img, anchor);
          insert_dev(target, t, anchor);
          mount_component(button, target, anchor);
          current = true;

          if (!mounted) {
            dispose = listen_dev(img, "click",
            /*abrirVideo*/
            ctx[8], false, false, false);
            mounted = true;
          }
        },
        p: function update(ctx, dirty) {
          if (!current || dirty &
          /*vistaPrevia*/
          128 && img.src !== (img_src_value =
          /*vistaPrevia*/
          ctx[7])) {
            attr_dev(img, "src", img_src_value);
          }

          const button_changes = {};

          if (dirty &
          /*$$scope*/
          524288) {
            button_changes.$$scope = {
              dirty,
              ctx
            };
          }

          button.$set(button_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(button.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(button.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(img);
          if (detaching) detach_dev(t);
          destroy_component(button, detaching);
          mounted = false;
          dispose();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_else_block_7.name,
        type: "else",
        source: "(224:8) {:else}",
        ctx
      });
      return block;
    } // (209:8) {#if abierto}


    function create_if_block_14(ctx) {
      let div;
      let iframe;
      let iframe_src_value;
      let t;
      let button;
      let current;
      button = new ye({
        props: {
          class: "cerrar",
          icon: true,
          $$slots: {
            default: [create_default_slot_8]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      button.$on("click",
      /*click_handler_6*/
      ctx[18]);
      const block = {
        c: function create() {
          div = element("div");
          iframe = element("iframe");
          t = space();
          create_component(button.$$.fragment);
          attr_dev(iframe, "title", "PornHub");
          if (iframe.src !== (iframe_src_value = "https://www.pornhub.com/embed/" +
          /*media*/
          ctx[1].hash.replace(/[a-zA-Z]*_/g, ""))) attr_dev(iframe, "src", iframe_src_value);
          attr_dev(iframe, "frameborder", "0");
          attr_dev(iframe, "width", "100%");
          attr_dev(iframe, "height", "100%");
          attr_dev(iframe, "scrolling", "no");
          iframe.allowFullscreen = true;
          attr_dev(iframe, "class", "svelte-1eiejjx");
          add_location(iframe, file$2, 210, 16, 7338);
          attr_dev(div, "class", "youtube-container svelte-1eiejjx");
          add_location(div, file$2, 209, 12, 7289);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          append_dev(div, iframe);
          insert_dev(target, t, anchor);
          mount_component(button, target, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          if (!current || dirty &
          /*media*/
          2 && iframe.src !== (iframe_src_value = "https://www.pornhub.com/embed/" +
          /*media*/
          ctx[1].hash.replace(/[a-zA-Z]*_/g, ""))) {
            attr_dev(iframe, "src", iframe_src_value);
          }

          const button_changes = {};

          if (dirty &
          /*$$scope*/
          524288) {
            button_changes.$$scope = {
              dirty,
              ctx
            };
          }

          button.$set(button_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(button.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(button.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
          if (detaching) detach_dev(t);
          destroy_component(button, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_14.name,
        type: "if",
        source: "(209:8) {#if abierto}",
        ctx
      });
      return block;
    } // (226:12) <Button on:click={abrirVideo} color="red" class="play" icon>


    function create_default_slot_9(ctx) {
      let i;
      const block = {
        c: function create() {
          i = element("i");
          attr_dev(i, "class", "fe fe-youtube");
          set_style(i, "position", "relative");
          set_style(i, "left", "1px");
          add_location(i, file$2, 226, 16, 8031);
        },
        m: function mount(target, anchor) {
          insert_dev(target, i, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(i);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_9.name,
        type: "slot",
        source: "(226:12) <Button on:click={abrirVideo} color=\\\"red\\\" class=\\\"play\\\" icon>",
        ctx
      });
      return block;
    } // (221:12) <Button on:click={() => (abierto = false)} class="cerrar" icon>


    function create_default_slot_8(ctx) {
      let i;
      const block = {
        c: function create() {
          i = element("i");
          attr_dev(i, "class", "fe fe-x");
          add_location(i, file$2, 221, 16, 7800);
        },
        m: function mount(target, anchor) {
          insert_dev(target, i, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(i);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_8.name,
        type: "slot",
        source: "(221:12) <Button on:click={() => (abierto = false)} class=\\\"cerrar\\\" icon>",
        ctx
      });
      return block;
    } // (189:8) {:else}


    function create_else_block_6(ctx) {
      let img;
      let img_src_value;
      let t;
      let button;
      let current;
      let mounted;
      let dispose;
      button = new ye({
        props: {
          color: "red",
          class: "play",
          icon: true,
          $$slots: {
            default: [create_default_slot_7]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      button.$on("click",
      /*abrirVideo*/
      ctx[8]);
      const block = {
        c: function create() {
          img = element("img");
          t = space();
          create_component(button.$$.fragment);
          if (img.src !== (img_src_value =
          /*vistaPrevia*/
          ctx[7])) attr_dev(img, "src", img_src_value);
          attr_dev(img, "alt", "");
          attr_dev(img, "srcset", "");
          attr_dev(img, "class", "svelte-1eiejjx");
          add_location(img, file$2, 189, 12, 6566);
        },
        m: function mount(target, anchor) {
          insert_dev(target, img, anchor);
          insert_dev(target, t, anchor);
          mount_component(button, target, anchor);
          current = true;

          if (!mounted) {
            dispose = listen_dev(img, "click",
            /*abrirVideo*/
            ctx[8], false, false, false);
            mounted = true;
          }
        },
        p: function update(ctx, dirty) {
          if (!current || dirty &
          /*vistaPrevia*/
          128 && img.src !== (img_src_value =
          /*vistaPrevia*/
          ctx[7])) {
            attr_dev(img, "src", img_src_value);
          }

          const button_changes = {};

          if (dirty &
          /*$$scope*/
          524288) {
            button_changes.$$scope = {
              dirty,
              ctx
            };
          }

          button.$set(button_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(button.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(button.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(img);
          if (detaching) detach_dev(t);
          destroy_component(button, detaching);
          mounted = false;
          dispose();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_else_block_6.name,
        type: "else",
        source: "(189:8) {:else}",
        ctx
      });
      return block;
    } // (172:8) {#if abierto}


    function create_if_block_12(ctx) {
      let div;
      let iframe;
      let iframe_src_value;
      let t;
      let button;
      let current;
      button = new ye({
        props: {
          class: "cerrar",
          icon: true,
          $$slots: {
            default: [create_default_slot_6]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      button.$on("click",
      /*click_handler_5*/
      ctx[17]);
      const block = {
        c: function create() {
          div = element("div");
          iframe = element("iframe");
          t = space();
          create_component(button.$$.fragment);
          attr_dev(iframe, "title", "DailyMotion");
          set_style(iframe, "width", "100%");
          set_style(iframe, "height", "100%");
          set_style(iframe, "position", "absolute");
          set_style(iframe, "left", "0px");
          set_style(iframe, "top", "0px");
          set_style(iframe, "overflow", "hidden");
          attr_dev(iframe, "frameborder", "0");
          attr_dev(iframe, "type", "text/html");
          if (iframe.src !== (iframe_src_value = "https://www.dailymotion.com/embed/video/" +
          /*media*/
          ctx[1].hash.replace(/[a-zA-Z]*_/g, "") + "?autoplay=1")) attr_dev(iframe, "src", iframe_src_value);
          attr_dev(iframe, "width", "100%");
          attr_dev(iframe, "height", "100%");
          iframe.allowFullscreen = true;
          attr_dev(iframe, "allow", "autoplay");
          attr_dev(iframe, "class", "svelte-1eiejjx");
          add_location(iframe, file$2, 173, 16, 5869);
          attr_dev(div, "class", "youtube-container svelte-1eiejjx");
          add_location(div, file$2, 172, 12, 5820);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          append_dev(div, iframe);
          insert_dev(target, t, anchor);
          mount_component(button, target, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          if (!current || dirty &
          /*media*/
          2 && iframe.src !== (iframe_src_value = "https://www.dailymotion.com/embed/video/" +
          /*media*/
          ctx[1].hash.replace(/[a-zA-Z]*_/g, "") + "?autoplay=1")) {
            attr_dev(iframe, "src", iframe_src_value);
          }

          const button_changes = {};

          if (dirty &
          /*$$scope*/
          524288) {
            button_changes.$$scope = {
              dirty,
              ctx
            };
          }

          button.$set(button_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(button.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(button.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
          if (detaching) detach_dev(t);
          destroy_component(button, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_12.name,
        type: "if",
        source: "(172:8) {#if abierto}",
        ctx
      });
      return block;
    } // (191:12) <Button on:click={abrirVideo} color="red" class="play" icon>


    function create_default_slot_7(ctx) {
      let i;
      const block = {
        c: function create() {
          i = element("i");
          attr_dev(i, "class", "fe fe-youtube");
          set_style(i, "position", "relative");
          set_style(i, "left", "1px");
          add_location(i, file$2, 191, 16, 6722);
        },
        m: function mount(target, anchor) {
          insert_dev(target, i, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(i);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_7.name,
        type: "slot",
        source: "(191:12) <Button on:click={abrirVideo} color=\\\"red\\\" class=\\\"play\\\" icon>",
        ctx
      });
      return block;
    } // (186:12) <Button on:click={() => (abierto = false)} class="cerrar" icon>


    function create_default_slot_6(ctx) {
      let i;
      const block = {
        c: function create() {
          i = element("i");
          attr_dev(i, "class", "fe fe-x");
          add_location(i, file$2, 186, 16, 6491);
        },
        m: function mount(target, anchor) {
          insert_dev(target, i, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(i);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_6.name,
        type: "slot",
        source: "(186:12) <Button on:click={() => (abierto = false)} class=\\\"cerrar\\\" icon>",
        ctx
      });
      return block;
    } // (149:8) {:else}


    function create_else_block_5(ctx) {
      let img;
      let img_src_value;
      let t;
      let button;
      let current;
      let mounted;
      let dispose;
      button = new ye({
        props: {
          color: "red",
          class: "play",
          icon: true,
          $$slots: {
            default: [create_default_slot_5]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      button.$on("click",
      /*abrirVideo*/
      ctx[8]);
      const block = {
        c: function create() {
          img = element("img");
          t = space();
          create_component(button.$$.fragment);
          if (img.src !== (img_src_value =
          /*vistaPrevia*/
          ctx[7])) attr_dev(img, "src", img_src_value);
          attr_dev(img, "alt", "");
          attr_dev(img, "srcset", "");
          attr_dev(img, "class", "svelte-1eiejjx");
          add_location(img, file$2, 149, 12, 5021);
        },
        m: function mount(target, anchor) {
          insert_dev(target, img, anchor);
          insert_dev(target, t, anchor);
          mount_component(button, target, anchor);
          current = true;

          if (!mounted) {
            dispose = listen_dev(img, "click",
            /*abrirVideo*/
            ctx[8], false, false, false);
            mounted = true;
          }
        },
        p: function update(ctx, dirty) {
          if (!current || dirty &
          /*vistaPrevia*/
          128 && img.src !== (img_src_value =
          /*vistaPrevia*/
          ctx[7])) {
            attr_dev(img, "src", img_src_value);
          }

          const button_changes = {};

          if (dirty &
          /*$$scope*/
          524288) {
            button_changes.$$scope = {
              dirty,
              ctx
            };
          }

          button.$set(button_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(button.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(button.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(img);
          if (detaching) detach_dev(t);
          destroy_component(button, detaching);
          mounted = false;
          dispose();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_else_block_5.name,
        type: "else",
        source: "(149:8) {:else}",
        ctx
      });
      return block;
    } // (135:8) {#if abierto}


    function create_if_block_10(ctx) {
      let div;
      let iframe;
      let iframe_src_value;
      let t;
      let button;
      let current;
      button = new ye({
        props: {
          class: "cerrar",
          icon: true,
          $$slots: {
            default: [create_default_slot_4]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      button.$on("click",
      /*click_handler_4*/
      ctx[16]);
      const block = {
        c: function create() {
          div = element("div");
          iframe = element("iframe");
          t = space();
          create_component(button.$$.fragment);
          attr_dev(iframe, "title", "bitchute");
          attr_dev(iframe, "scrolling", "no");
          attr_dev(iframe, "frameborder", "0");
          set_style(iframe, "border", "none");
          if (iframe.src !== (iframe_src_value = "https://www.bitchute.com/embed/" +
          /*media*/
          ctx[1].hash.replace(/[a-zA-Z]*_/g, "") + "/")) attr_dev(iframe, "src", iframe_src_value);
          attr_dev(iframe, "allow", "autoplay");
          attr_dev(iframe, "class", "svelte-1eiejjx");
          add_location(iframe, file$2, 136, 16, 4514);
          attr_dev(div, "class", "youtube-container svelte-1eiejjx");
          add_location(div, file$2, 135, 12, 4465);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          append_dev(div, iframe);
          insert_dev(target, t, anchor);
          mount_component(button, target, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          if (!current || dirty &
          /*media*/
          2 && iframe.src !== (iframe_src_value = "https://www.bitchute.com/embed/" +
          /*media*/
          ctx[1].hash.replace(/[a-zA-Z]*_/g, "") + "/")) {
            attr_dev(iframe, "src", iframe_src_value);
          }

          const button_changes = {};

          if (dirty &
          /*$$scope*/
          524288) {
            button_changes.$$scope = {
              dirty,
              ctx
            };
          }

          button.$set(button_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(button.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(button.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
          if (detaching) detach_dev(t);
          destroy_component(button, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_10.name,
        type: "if",
        source: "(135:8) {#if abierto}",
        ctx
      });
      return block;
    } // (151:12) <Button on:click={abrirVideo} color="red" class="play" icon>


    function create_default_slot_5(ctx) {
      let i;
      const block = {
        c: function create() {
          i = element("i");
          attr_dev(i, "class", "fe fe-youtube");
          set_style(i, "position", "relative");
          set_style(i, "left", "1px");
          add_location(i, file$2, 151, 16, 5177);
        },
        m: function mount(target, anchor) {
          insert_dev(target, i, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(i);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_5.name,
        type: "slot",
        source: "(151:12) <Button on:click={abrirVideo} color=\\\"red\\\" class=\\\"play\\\" icon>",
        ctx
      });
      return block;
    } // (146:12) <Button on:click={() => (abierto = false)} class="cerrar" icon>


    function create_default_slot_4(ctx) {
      let i;
      const block = {
        c: function create() {
          i = element("i");
          attr_dev(i, "class", "fe fe-x");
          add_location(i, file$2, 146, 16, 4946);
        },
        m: function mount(target, anchor) {
          insert_dev(target, i, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(i);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_4.name,
        type: "slot",
        source: "(146:12) <Button on:click={() => (abierto = false)} class=\\\"cerrar\\\" icon>",
        ctx
      });
      return block;
    } // (99:8) {:else}


    function create_else_block_4(ctx) {
      let img;
      let img_src_value;
      let t;
      let button;
      let current;
      let mounted;
      let dispose;
      button = new ye({
        props: {
          color: "red",
          class: "play",
          icon: true,
          $$slots: {
            default: [create_default_slot_3]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      button.$on("click",
      /*abrirVideo*/
      ctx[8]);
      const block = {
        c: function create() {
          img = element("img");
          t = space();
          create_component(button.$$.fragment);
          if (img.src !== (img_src_value =
          /*vistaPrevia*/
          ctx[7])) attr_dev(img, "src", img_src_value);
          attr_dev(img, "alt", "");
          attr_dev(img, "srcset", "");
          attr_dev(img, "class", "svelte-1eiejjx");
          add_location(img, file$2, 99, 12, 3182);
        },
        m: function mount(target, anchor) {
          insert_dev(target, img, anchor);
          insert_dev(target, t, anchor);
          mount_component(button, target, anchor);
          current = true;

          if (!mounted) {
            dispose = listen_dev(img, "click",
            /*abrirVideo*/
            ctx[8], false, false, false);
            mounted = true;
          }
        },
        p: function update(ctx, dirty) {
          if (!current || dirty &
          /*vistaPrevia*/
          128 && img.src !== (img_src_value =
          /*vistaPrevia*/
          ctx[7])) {
            attr_dev(img, "src", img_src_value);
          }

          const button_changes = {};

          if (dirty &
          /*$$scope*/
          524288) {
            button_changes.$$scope = {
              dirty,
              ctx
            };
          }

          button.$set(button_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(button.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(button.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(img);
          if (detaching) detach_dev(t);
          destroy_component(button, detaching);
          mounted = false;
          dispose();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_else_block_4.name,
        type: "else",
        source: "(99:8) {:else}",
        ctx
      });
      return block;
    } // (84:8) {#if abierto}


    function create_if_block_7(ctx) {
      let t;
      let button;
      let current;

      function select_block_type_4(ctx, dirty) {
        if (!
        /*hackYoutubeActivo*/
        ctx[5]) return create_if_block_8;
        return create_else_block_3;
      }

      let current_block_type = select_block_type_4(ctx);
      let if_block = current_block_type(ctx);
      button = new ye({
        props: {
          class: "cerrar",
          icon: true,
          $$slots: {
            default: [create_default_slot_2]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      button.$on("click",
      /*click_handler_2*/
      ctx[14]);
      const block = {
        c: function create() {
          if_block.c();
          t = space();
          create_component(button.$$.fragment);
        },
        m: function mount(target, anchor) {
          if_block.m(target, anchor);
          insert_dev(target, t, anchor);
          mount_component(button, target, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          if (current_block_type === (current_block_type = select_block_type_4(ctx)) && if_block) {
            if_block.p(ctx, dirty);
          } else {
            if_block.d(1);
            if_block = current_block_type(ctx);

            if (if_block) {
              if_block.c();
              if_block.m(t.parentNode, t);
            }
          }

          const button_changes = {};

          if (dirty &
          /*$$scope*/
          524288) {
            button_changes.$$scope = {
              dirty,
              ctx
            };
          }

          button.$set(button_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(button.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(button.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if_block.d(detaching);
          if (detaching) detach_dev(t);
          destroy_component(button, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_7.name,
        type: "if",
        source: "(84:8) {#if abierto}",
        ctx
      });
      return block;
    } // (101:12) <Button on:click={abrirVideo} color="red" class="play" icon>


    function create_default_slot_3(ctx) {
      let i;
      const block = {
        c: function create() {
          i = element("i");
          attr_dev(i, "class", "fe fe-youtube");
          set_style(i, "position", "relative");
          set_style(i, "left", "1px");
          add_location(i, file$2, 101, 16, 3338);
        },
        m: function mount(target, anchor) {
          insert_dev(target, i, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(i);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_3.name,
        type: "slot",
        source: "(101:12) <Button on:click={abrirVideo} color=\\\"red\\\" class=\\\"play\\\" icon>",
        ctx
      });
      return block;
    } // (93:12) {:else}


    function create_else_block_3(ctx) {
      let video;
      let video_src_value;
      const block = {
        c: function create() {
          video = element("video");
          video.loop = true;
          video.controls = true;
          if (video.src !== (video_src_value =
          /*hackYoutubeLink*/
          ctx[6])) attr_dev(video, "src", video_src_value);
          attr_dev(video, "class", "svelte-1eiejjx");
          add_location(video, file$2, 93, 16, 2932);
        },
        m: function mount(target, anchor) {
          insert_dev(target, video, anchor);
          /*video_binding_1*/

          ctx[13](video);
        },
        p: function update(ctx, dirty) {
          if (dirty &
          /*hackYoutubeLink*/
          64 && video.src !== (video_src_value =
          /*hackYoutubeLink*/
          ctx[6])) {
            attr_dev(video, "src", video_src_value);
          }
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(video);
          /*video_binding_1*/

          ctx[13](null);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_else_block_3.name,
        type: "else",
        source: "(93:12) {:else}",
        ctx
      });
      return block;
    } // (85:12) {#if !hackYoutubeActivo}


    function create_if_block_8(ctx) {
      let div;
      let iframe;
      let iframe_src_value;
      const block = {
        c: function create() {
          div = element("div");
          iframe = element("iframe");
          attr_dev(iframe, "title", "youtube");
          iframe.allowFullscreen = true;
          if (iframe.src !== (iframe_src_value = "https://www.youtube.com/embed/" +
          /*media*/
          ctx[1].hash + "?autoplay=1")) attr_dev(iframe, "src", iframe_src_value);
          attr_dev(iframe, "class", "svelte-1eiejjx");
          add_location(iframe, file$2, 86, 20, 2671);
          attr_dev(div, "class", "youtube-container svelte-1eiejjx");
          add_location(div, file$2, 85, 16, 2618);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          append_dev(div, iframe);
        },
        p: function update(ctx, dirty) {
          if (dirty &
          /*media*/
          2 && iframe.src !== (iframe_src_value = "https://www.youtube.com/embed/" +
          /*media*/
          ctx[1].hash + "?autoplay=1")) {
            attr_dev(iframe, "src", iframe_src_value);
          }
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_8.name,
        type: "if",
        source: "(85:12) {#if !hackYoutubeActivo}",
        ctx
      });
      return block;
    } // (96:12) <Button on:click={() => (abierto = false)} class="cerrar" icon>


    function create_default_slot_2(ctx) {
      let i;
      const block = {
        c: function create() {
          i = element("i");
          attr_dev(i, "class", "fe fe-x");
          add_location(i, file$2, 96, 16, 3107);
        },
        m: function mount(target, anchor) {
          insert_dev(target, i, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(i);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_2.name,
        type: "slot",
        source: "(96:12) <Button on:click={() => (abierto = false)} class=\\\"cerrar\\\" icon>",
        ctx
      });
      return block;
    } // (117:12) {:else}


    function create_else_block_2(ctx) {
      let span;
      let t;
      let ripple;
      let current;
      let mounted;
      let dispose;
      ripple = new he({
        $$inline: true
      });
      const block = {
        c: function create() {
          span = element("span");
          t = text("Volver ");
          create_component(ripple.$$.fragment);
          attr_dev(span, "class", "medialink cpt svelte-1eiejjx");
          add_location(span, file$2, 117, 16, 3900);
        },
        m: function mount(target, anchor) {
          insert_dev(target, span, anchor);
          append_dev(span, t);
          mount_component(ripple, span, null);
          current = true;

          if (!mounted) {
            dispose = listen_dev(span, "click",
            /*click_handler_3*/
            ctx[15], false, false, false);
            mounted = true;
          }
        },
        p: noop,
        i: function intro(local) {
          if (current) return;
          transition_in(ripple.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(ripple.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(span);
          destroy_component(ripple);
          mounted = false;
          dispose();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_else_block_2.name,
        type: "else",
        source: "(117:12) {:else}",
        ctx
      });
      return block;
    } // (109:12) {#if !hackYoutubeActivo}


    function create_if_block_6(ctx) {
      let span;
      let t;
      let ripple;
      let current;
      let mounted;
      let dispose;
      ripple = new he({
        $$inline: true
      });
      const block = {
        c: function create() {
          span = element("span");
          t = text("Hack ");
          create_component(ripple.$$.fragment);
          attr_dev(span, "class", "medialink cpt svelte-1eiejjx");
          attr_dev(span, "title", "Sirve para reproducir el video en el sitio aunque este bloqueado");
          add_location(span, file$2, 109, 16, 3594);
        },
        m: function mount(target, anchor) {
          insert_dev(target, span, anchor);
          append_dev(span, t);
          mount_component(ripple, span, null);
          current = true;

          if (!mounted) {
            dispose = listen_dev(span, "click",
            /*hackYoutube*/
            ctx[9], false, false, false);
            mounted = true;
          }
        },
        p: noop,
        i: function intro(local) {
          if (current) return;
          transition_in(ripple.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(ripple.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(span);
          destroy_component(ripple);
          mounted = false;
          dispose();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_6.name,
        type: "if",
        source: "(109:12) {#if !hackYoutubeActivo}",
        ctx
      });
      return block;
    } // (77:8) {:else}


    function create_else_block_1(ctx) {
      let img;
      let img_src_value;
      let t;
      let button;
      let current;
      let mounted;
      let dispose;
      button = new ye({
        props: {
          color: "red",
          class: "play",
          icon: true,
          $$slots: {
            default: [create_default_slot_1]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      button.$on("click",
      /*abrirVideo*/
      ctx[8]);
      const block = {
        c: function create() {
          img = element("img");
          t = space();
          create_component(button.$$.fragment);
          if (img.src !== (img_src_value =
          /*vistaPrevia*/
          ctx[7])) attr_dev(img, "src", img_src_value);
          attr_dev(img, "alt", "");
          attr_dev(img, "srcset", "");
          attr_dev(img, "class", "svelte-1eiejjx");
          add_location(img, file$2, 77, 12, 2235);
        },
        m: function mount(target, anchor) {
          insert_dev(target, img, anchor);
          insert_dev(target, t, anchor);
          mount_component(button, target, anchor);
          current = true;

          if (!mounted) {
            dispose = listen_dev(img, "click",
            /*abrirVideo*/
            ctx[8], false, false, false);
            mounted = true;
          }
        },
        p: function update(ctx, dirty) {
          if (!current || dirty &
          /*vistaPrevia*/
          128 && img.src !== (img_src_value =
          /*vistaPrevia*/
          ctx[7])) {
            attr_dev(img, "src", img_src_value);
          }

          const button_changes = {};

          if (dirty &
          /*$$scope*/
          524288) {
            button_changes.$$scope = {
              dirty,
              ctx
            };
          }

          button.$set(button_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(button.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(button.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(img);
          if (detaching) detach_dev(t);
          destroy_component(button, detaching);
          mounted = false;
          dispose();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_else_block_1.name,
        type: "else",
        source: "(77:8) {:else}",
        ctx
      });
      return block;
    } // (65:8) {#if abierto}


    function create_if_block_4(ctx) {
      let video;
      let video_src_value;
      let t;
      let button;
      let current;
      button = new ye({
        props: {
          class: "cerrar",
          icon: true,
          $$slots: {
            default: [create_default_slot]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      button.$on("click",
      /*click_handler_1*/
      ctx[12]);
      const block = {
        c: function create() {
          video = element("video");
          t = space();
          create_component(button.$$.fragment);
          video.muted = true;
          video.loop = true;
          video.controls = true;
          if (video.src !== (video_src_value = "/Media/" +
          /*media*/
          ctx[1].url)) attr_dev(video, "src", video_src_value);
          set_style(video, "margin-bottom", "16px");
          attr_dev(video, "class", "svelte-1eiejjx");
          add_location(video, file$2, 65, 12, 1851);
        },
        m: function mount(target, anchor) {
          insert_dev(target, video, anchor);
          /*video_binding*/

          ctx[11](video);
          insert_dev(target, t, anchor);
          mount_component(button, target, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          if (!current || dirty &
          /*media*/
          2 && video.src !== (video_src_value = "/Media/" +
          /*media*/
          ctx[1].url)) {
            attr_dev(video, "src", video_src_value);
          }

          const button_changes = {};

          if (dirty &
          /*$$scope*/
          524288) {
            button_changes.$$scope = {
              dirty,
              ctx
            };
          }

          button.$set(button_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(button.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(button.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(video);
          /*video_binding*/

          ctx[11](null);
          if (detaching) detach_dev(t);
          destroy_component(button, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_4.name,
        type: "if",
        source: "(65:8) {#if abierto}",
        ctx
      });
      return block;
    } // (79:12) <Button on:click={abrirVideo} color="red" class="play" icon>


    function create_default_slot_1(ctx) {
      let i;
      const block = {
        c: function create() {
          i = element("i");
          attr_dev(i, "class", "fe fe-play");
          set_style(i, "position", "relative");
          set_style(i, "left", "2px");
          add_location(i, file$2, 79, 16, 2391);
        },
        m: function mount(target, anchor) {
          insert_dev(target, i, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(i);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_1.name,
        type: "slot",
        source: "(79:12) <Button on:click={abrirVideo} color=\\\"red\\\" class=\\\"play\\\" icon>",
        ctx
      });
      return block;
    } // (74:12) <Button on:click={() => (abierto = false)} class="cerrar" icon>


    function create_default_slot(ctx) {
      let i;
      const block = {
        c: function create() {
          i = element("i");
          attr_dev(i, "class", "fe fe-x");
          add_location(i, file$2, 74, 16, 2160);
        },
        m: function mount(target, anchor) {
          insert_dev(target, i, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(i);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot.name,
        type: "slot",
        source: "(74:12) <Button on:click={() => (abierto = false)} class=\\\"cerrar\\\" icon>",
        ctx
      });
      return block;
    } // (59:8) {:else}


    function create_else_block(ctx) {
      let a;
      let img;
      let img_src_value;
      let a_href_value;
      const block = {
        c: function create() {
          a = element("a");
          img = element("img");
          if (img.src !== (img_src_value =
          /*vistaPrevia*/
          ctx[7])) attr_dev(img, "src", img_src_value);
          attr_dev(img, "alt", "");
          attr_dev(img, "srcset", "");
          attr_dev(img, "class", "svelte-1eiejjx");
          add_location(img, file$2, 60, 16, 1693);
          attr_dev(a, "href", a_href_value = "/Media/" +
          /*media*/
          ctx[1].url);
          attr_dev(a, "target", "_blank");
          add_location(a, file$2, 59, 12, 1630);
        },
        m: function mount(target, anchor) {
          insert_dev(target, a, anchor);
          append_dev(a, img);
        },
        p: function update(ctx, dirty) {
          if (dirty &
          /*vistaPrevia*/
          128 && img.src !== (img_src_value =
          /*vistaPrevia*/
          ctx[7])) {
            attr_dev(img, "src", img_src_value);
          }

          if (dirty &
          /*media*/
          2 && a_href_value !== (a_href_value = "/Media/" +
          /*media*/
          ctx[1].url)) {
            attr_dev(a, "href", a_href_value);
          }
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(a);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_else_block.name,
        type: "else",
        source: "(59:8) {:else}",
        ctx
      });
      return block;
    } // (55:8) {#if media.esGif}


    function create_if_block_2(ctx) {
      let a;
      let img;
      let img_src_value;
      let a_href_value;
      const block = {
        c: function create() {
          a = element("a");
          img = element("img");
          if (img.src !== (img_src_value = "/Media/" +
          /*media*/
          ctx[1].url)) attr_dev(img, "src", img_src_value);
          attr_dev(img, "alt", "");
          attr_dev(img, "srcset", "");
          attr_dev(img, "class", "svelte-1eiejjx");
          add_location(img, file$2, 56, 16, 1532);
          attr_dev(a, "href", a_href_value = "/Media/" +
          /*media*/
          ctx[1].url);
          attr_dev(a, "target", "_blank");
          add_location(a, file$2, 55, 12, 1469);
        },
        m: function mount(target, anchor) {
          insert_dev(target, a, anchor);
          append_dev(a, img);
        },
        p: function update(ctx, dirty) {
          if (dirty &
          /*media*/
          2 && img.src !== (img_src_value = "/Media/" +
          /*media*/
          ctx[1].url)) {
            attr_dev(img, "src", img_src_value);
          }

          if (dirty &
          /*media*/
          2 && a_href_value !== (a_href_value = "/Media/" +
          /*media*/
          ctx[1].url)) {
            attr_dev(a, "href", a_href_value);
          }
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(a);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_2.name,
        type: "if",
        source: "(55:8) {#if media.esGif}",
        ctx
      });
      return block;
    }

    function create_fragment$2(ctx) {
      let div;
      let t;
      let current_block_type_index;
      let if_block1;
      let current;
      let if_block0 = !
      /*abierto*/
      ctx[0] && create_if_block_15(ctx);
      const if_block_creators = [create_if_block$1, create_if_block_1, create_if_block_3, create_if_block_5, create_if_block_9, create_if_block_11, create_if_block_13];
      const if_blocks = [];

      function select_block_type(ctx, dirty) {
        if (
        /*oculto*/
        ctx[3]) return 0;
        if (
        /*media*/
        ctx[1].tipo == MediaType.Imagen) return 1;
        if (
        /*media*/
        ctx[1].tipo == MediaType.Video) return 2;
        if (
        /*media*/
        ctx[1].tipo == MediaType.Youtube) return 3;
        if (
        /*media*/
        ctx[1].tipo == MediaType.Bitchute) return 4;
        if (
        /*media*/
        ctx[1].tipo == MediaType.DailyMotion) return 5;
        if (
        /*media*/
        ctx[1].tipo == MediaType.PornHub) return 6;
        return -1;
      }

      if (~(current_block_type_index = select_block_type(ctx))) {
        if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
      }

      const block = {
        c: function create() {
          div = element("div");
          if (if_block0) if_block0.c();
          t = space();
          if (if_block1) if_block1.c();
          attr_dev(div, "class", "media svelte-1eiejjx");
          toggle_class(div, "abierto",
          /*abierto*/
          ctx[0]);
          toggle_class(div, "modoCuadrado",
          /*modoCuadrado*/
          ctx[2]);
          toggle_class(div, "youtube",
          /*media*/
          ctx[1].tipo == MediaType.Youtube);
          add_location(div, file$2, 38, 0, 960);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          if (if_block0) if_block0.m(div, null);
          append_dev(div, t);

          if (~current_block_type_index) {
            if_blocks[current_block_type_index].m(div, null);
          }

          current = true;
        },
        p: function update(ctx, [dirty]) {
          if (!
          /*abierto*/
          ctx[0]) {
            if (if_block0) {
              if_block0.p(ctx, dirty);

              if (dirty &
              /*abierto*/
              1) {
                transition_in(if_block0, 1);
              }
            } else {
              if_block0 = create_if_block_15(ctx);
              if_block0.c();
              transition_in(if_block0, 1);
              if_block0.m(div, t);
            }
          } else if (if_block0) {
            group_outros();
            transition_out(if_block0, 1, 1, () => {
              if_block0 = null;
            });
            check_outros();
          }

          let previous_block_index = current_block_type_index;
          current_block_type_index = select_block_type(ctx);

          if (current_block_type_index === previous_block_index) {
            if (~current_block_type_index) {
              if_blocks[current_block_type_index].p(ctx, dirty);
            }
          } else {
            if (if_block1) {
              group_outros();
              transition_out(if_blocks[previous_block_index], 1, 1, () => {
                if_blocks[previous_block_index] = null;
              });
              check_outros();
            }

            if (~current_block_type_index) {
              if_block1 = if_blocks[current_block_type_index];

              if (!if_block1) {
                if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
                if_block1.c();
              }

              transition_in(if_block1, 1);
              if_block1.m(div, null);
            } else {
              if_block1 = null;
            }
          }

          if (dirty &
          /*abierto*/
          1) {
            toggle_class(div, "abierto",
            /*abierto*/
            ctx[0]);
          }

          if (dirty &
          /*modoCuadrado*/
          4) {
            toggle_class(div, "modoCuadrado",
            /*modoCuadrado*/
            ctx[2]);
          }

          if (dirty &
          /*media, MediaType*/
          2) {
            toggle_class(div, "youtube",
            /*media*/
            ctx[1].tipo == MediaType.Youtube);
          }
        },
        i: function intro(local) {
          if (current) return;
          transition_in(if_block0);
          transition_in(if_block1);
          current = true;
        },
        o: function outro(local) {
          transition_out(if_block0);
          transition_out(if_block1);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
          if (if_block0) if_block0.d();

          if (~current_block_type_index) {
            if_blocks[current_block_type_index].d();
          }
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$2.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }

    function instance$2($$self, $$props, $$invalidate) {
      let {
        $$slots: slots = {},
        $$scope
      } = $$props;
      validate_slots("Media", slots, []);
      let {
        media
      } = $$props;
      let {
        modoCuadrado = false
      } = $$props;
      let {
        abierto = false
      } = $$props;
      let oculto = false;
      let vid;

      function abrirVideo() {
        $$invalidate(0, abierto = true);
        setTimeout(async () => {
          if (vid != undefined) {
            await vid.play();
            $$invalidate(4, vid.muted = true, vid);
          }
        }, 1);
      }

      let hackYoutubeActivo = false;
      let hackYoutubeLink = "";

      async function hackYoutube() {
        var res = await RChanClient.hackYoutube(media.url);
        $$invalidate(6, hackYoutubeLink = res.data.link);
        $$invalidate(5, hackYoutubeActivo = true);
        abrirVideo();
      }

      const writable_props = ["media", "modoCuadrado", "abierto"];
      Object.keys($$props).forEach(key => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Media> was created with unknown prop '${key}'`);
      });

      const click_handler = () => $$invalidate(3, oculto = !oculto);

      function video_binding($$value) {
        binding_callbacks[$$value ? "unshift" : "push"](() => {
          vid = $$value;
          $$invalidate(4, vid);
        });
      }

      const click_handler_1 = () => $$invalidate(0, abierto = false);

      function video_binding_1($$value) {
        binding_callbacks[$$value ? "unshift" : "push"](() => {
          vid = $$value;
          $$invalidate(4, vid);
        });
      }

      const click_handler_2 = () => $$invalidate(0, abierto = false);

      const click_handler_3 = () => $$invalidate(5, hackYoutubeActivo = false);

      const click_handler_4 = () => $$invalidate(0, abierto = false);

      const click_handler_5 = () => $$invalidate(0, abierto = false);

      const click_handler_6 = () => $$invalidate(0, abierto = false);

      $$self.$$set = $$props => {
        if ("media" in $$props) $$invalidate(1, media = $$props.media);
        if ("modoCuadrado" in $$props) $$invalidate(2, modoCuadrado = $$props.modoCuadrado);
        if ("abierto" in $$props) $$invalidate(0, abierto = $$props.abierto);
      };

      $$self.$capture_state = () => ({
        MediaType,
        onMount,
        Icon: Me,
        Button: ye,
        Ripple: he,
        RChanClient,
        media,
        modoCuadrado,
        abierto,
        oculto,
        vid,
        abrirVideo,
        hackYoutubeActivo,
        hackYoutubeLink,
        hackYoutube,
        vistaPrevia
      });

      $$self.$inject_state = $$props => {
        if ("media" in $$props) $$invalidate(1, media = $$props.media);
        if ("modoCuadrado" in $$props) $$invalidate(2, modoCuadrado = $$props.modoCuadrado);
        if ("abierto" in $$props) $$invalidate(0, abierto = $$props.abierto);
        if ("oculto" in $$props) $$invalidate(3, oculto = $$props.oculto);
        if ("vid" in $$props) $$invalidate(4, vid = $$props.vid);
        if ("hackYoutubeActivo" in $$props) $$invalidate(5, hackYoutubeActivo = $$props.hackYoutubeActivo);
        if ("hackYoutubeLink" in $$props) $$invalidate(6, hackYoutubeLink = $$props.hackYoutubeLink);
        if ("vistaPrevia" in $$props) $$invalidate(7, vistaPrevia = $$props.vistaPrevia);
      };

      let vistaPrevia;

      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }

      $$self.$$.update = () => {
        if ($$self.$$.dirty &
        /*modoCuadrado, media*/
        6) {
           $$invalidate(7, vistaPrevia = modoCuadrado ? media.vistaPreviaCuadrado : media.vistaPrevia);
        }
      };

      return [abierto, media, modoCuadrado, oculto, vid, hackYoutubeActivo, hackYoutubeLink, vistaPrevia, abrirVideo, hackYoutube, click_handler, video_binding, click_handler_1, video_binding_1, click_handler_2, click_handler_3, click_handler_4, click_handler_5, click_handler_6];
    }

    class Media extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$2, create_fragment$2, safe_not_equal, {
          media: 1,
          modoCuadrado: 2,
          abierto: 0
        });
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "Media",
          options,
          id: create_fragment$2.name
        });
        const {
          ctx
        } = this.$$;
        const props = options.props || {};

        if (
        /*media*/
        ctx[1] === undefined && !("media" in props)) {
          console.warn("<Media> was created without expected prop 'media'");
        }
      }

      get media() {
        throw new Error("<Media>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set media(value) {
        throw new Error("<Media>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get modoCuadrado() {
        throw new Error("<Media>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set modoCuadrado(value) {
        throw new Error("<Media>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get abierto() {
        throw new Error("<Media>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set abierto(value) {
        throw new Error("<Media>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

    }

    /* src\components\ErrorValidacion.svelte generated by Svelte v3.29.0 */
    const {
      Object: Object_1,
      console: console_1
    } = globals;
    const file$3 = "src\\components\\ErrorValidacion.svelte";

    function get_each_context_3(ctx, list, i) {
      const child_ctx = ctx.slice();
      child_ctx[4] = list[i];
      return child_ctx;
    }

    function get_each_context_2(ctx, list, i) {
      const child_ctx = ctx.slice();
      child_ctx[1] = list[i];
      return child_ctx;
    }

    function get_each_context_1(ctx, list, i) {
      const child_ctx = ctx.slice();
      child_ctx[4] = list[i];
      return child_ctx;
    }

    function get_each_context(ctx, list, i) {
      const child_ctx = ctx.slice();
      child_ctx[1] = list[i];
      return child_ctx;
    } // (23:16) 


    function create_if_block_2$1(ctx) {
      let div;
      let h3;
      let t1;
      let each_value_2 = Object.keys(
      /*error*/
      ctx[0]);
      validate_each_argument(each_value_2);
      let each_blocks = [];

      for (let i = 0; i < each_value_2.length; i += 1) {
        each_blocks[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
      }

      const block = {
        c: function create() {
          div = element("div");
          h3 = element("h3");
          h3.textContent = "Ay no se!";
          t1 = space();

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].c();
          }

          add_location(h3, file$3, 24, 8, 614);
          attr_dev(div, "class", "error-validacion");
          add_location(div, file$3, 23, 4, 575);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          append_dev(div, h3);
          append_dev(div, t1);

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].m(div, null);
          }
        },
        p: function update(ctx, dirty) {
          if (dirty &
          /*error, Object*/
          1) {
            each_value_2 = Object.keys(
            /*error*/
            ctx[0]);
            validate_each_argument(each_value_2);
            let i;

            for (i = 0; i < each_value_2.length; i += 1) {
              const child_ctx = get_each_context_2(ctx, each_value_2, i);

              if (each_blocks[i]) {
                each_blocks[i].p(child_ctx, dirty);
              } else {
                each_blocks[i] = create_each_block_2(child_ctx);
                each_blocks[i].c();
                each_blocks[i].m(div, null);
              }
            }

            for (; i < each_blocks.length; i += 1) {
              each_blocks[i].d(1);
            }

            each_blocks.length = each_value_2.length;
          }
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
          destroy_each(each_blocks, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_2$1.name,
        type: "if",
        source: "(23:16) ",
        ctx
      });
      return block;
    } // (11:32) 


    function create_if_block_1$1(ctx) {
      let div;
      let h3;
      let t1;
      let each_value = Object.keys(
      /*error*/
      ctx[0].errors);
      validate_each_argument(each_value);
      let each_blocks = [];

      for (let i = 0; i < each_value.length; i += 1) {
        each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
      }

      const block = {
        c: function create() {
          div = element("div");
          h3 = element("h3");
          h3.textContent = "Ay no se!";
          t1 = space();

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].c();
          }

          add_location(h3, file$3, 12, 8, 278);
          attr_dev(div, "class", "error-validacion");
          add_location(div, file$3, 11, 4, 239);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          append_dev(div, h3);
          append_dev(div, t1);

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].m(div, null);
          }
        },
        p: function update(ctx, dirty) {
          if (dirty &
          /*error, Object*/
          1) {
            each_value = Object.keys(
            /*error*/
            ctx[0].errors);
            validate_each_argument(each_value);
            let i;

            for (i = 0; i < each_value.length; i += 1) {
              const child_ctx = get_each_context(ctx, each_value, i);

              if (each_blocks[i]) {
                each_blocks[i].p(child_ctx, dirty);
              } else {
                each_blocks[i] = create_each_block(child_ctx);
                each_blocks[i].c();
                each_blocks[i].m(div, null);
              }
            }

            for (; i < each_blocks.length; i += 1) {
              each_blocks[i].d(1);
            }

            each_blocks.length = each_value.length;
          }
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
          destroy_each(each_blocks, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_1$1.name,
        type: "if",
        source: "(11:32) ",
        ctx
      });
      return block;
    } // (7:0) {#if typeof error == "string"}


    function create_if_block$2(ctx) {
      let div;
      let h3;
      const block = {
        c: function create() {
          div = element("div");
          h3 = element("h3");
          h3.textContent = "Chocamo chocamo. Intenta de nuevo";
          add_location(h3, file$3, 8, 8, 148);
          attr_dev(div, "class", "error-validacion");
          add_location(div, file$3, 7, 4, 109);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          append_dev(div, h3);
        },
        p: noop,
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block$2.name,
        type: "if",
        source: "(7:0) {#if typeof error == \\\"string\\\"}",
        ctx
      });
      return block;
    } // (29:16) {#each error[key] as e}


    function create_each_block_3(ctx) {
      let t_value =
      /*e*/
      ctx[4] + "";
      let t;
      const block = {
        c: function create() {
          t = text(t_value);
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        p: function update(ctx, dirty) {
          if (dirty &
          /*error*/
          1 && t_value !== (t_value =
          /*e*/
          ctx[4] + "")) set_data_dev(t, t_value);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_each_block_3.name,
        type: "each",
        source: "(29:16) {#each error[key] as e}",
        ctx
      });
      return block;
    } // (26:8) {#each Object.keys(error) as key}


    function create_each_block_2(ctx) {
      let div;
      let strong;
      let t0_value =
      /*key*/
      ctx[1] + "";
      let t0;
      let t1;
      let t2;
      let t3;
      let each_value_3 =
      /*error*/
      ctx[0][
      /*key*/
      ctx[1]];
      validate_each_argument(each_value_3);
      let each_blocks = [];

      for (let i = 0; i < each_value_3.length; i += 1) {
        each_blocks[i] = create_each_block_3(get_each_context_3(ctx, each_value_3, i));
      }

      const block = {
        c: function create() {
          div = element("div");
          strong = element("strong");
          t0 = text(t0_value);
          t1 = text(":");
          t2 = space();

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].c();
          }

          t3 = space();
          add_location(strong, file$3, 27, 16, 718);
          attr_dev(div, "class", "");
          add_location(div, file$3, 26, 12, 687);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          append_dev(div, strong);
          append_dev(strong, t0);
          append_dev(strong, t1);
          append_dev(div, t2);

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].m(div, null);
          }

          append_dev(div, t3);
        },
        p: function update(ctx, dirty) {
          if (dirty &
          /*error*/
          1 && t0_value !== (t0_value =
          /*key*/
          ctx[1] + "")) set_data_dev(t0, t0_value);

          if (dirty &
          /*error, Object*/
          1) {
            each_value_3 =
            /*error*/
            ctx[0][
            /*key*/
            ctx[1]];
            validate_each_argument(each_value_3);
            let i;

            for (i = 0; i < each_value_3.length; i += 1) {
              const child_ctx = get_each_context_3(ctx, each_value_3, i);

              if (each_blocks[i]) {
                each_blocks[i].p(child_ctx, dirty);
              } else {
                each_blocks[i] = create_each_block_3(child_ctx);
                each_blocks[i].c();
                each_blocks[i].m(div, t3);
              }
            }

            for (; i < each_blocks.length; i += 1) {
              each_blocks[i].d(1);
            }

            each_blocks.length = each_value_3.length;
          }
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
          destroy_each(each_blocks, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_each_block_2.name,
        type: "each",
        source: "(26:8) {#each Object.keys(error) as key}",
        ctx
      });
      return block;
    } // (17:16) {#each error.errors[key] as e}


    function create_each_block_1(ctx) {
      let t_value =
      /*e*/
      ctx[4] + "";
      let t;
      const block = {
        c: function create() {
          t = text(t_value);
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        p: function update(ctx, dirty) {
          if (dirty &
          /*error*/
          1 && t_value !== (t_value =
          /*e*/
          ctx[4] + "")) set_data_dev(t, t_value);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_each_block_1.name,
        type: "each",
        source: "(17:16) {#each error.errors[key] as e}",
        ctx
      });
      return block;
    } // (14:8) {#each Object.keys(error.errors) as key}


    function create_each_block(ctx) {
      let div;
      let strong;
      let t0_value =
      /*key*/
      ctx[1] + "";
      let t0;
      let t1;
      let t2;
      let t3;
      let each_value_1 =
      /*error*/
      ctx[0].errors[
      /*key*/
      ctx[1]];
      validate_each_argument(each_value_1);
      let each_blocks = [];

      for (let i = 0; i < each_value_1.length; i += 1) {
        each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
      }

      const block = {
        c: function create() {
          div = element("div");
          strong = element("strong");
          t0 = text(t0_value);
          t1 = text(":");
          t2 = space();

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].c();
          }

          t3 = space();
          add_location(strong, file$3, 15, 16, 389);
          attr_dev(div, "class", "");
          add_location(div, file$3, 14, 12, 358);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          append_dev(div, strong);
          append_dev(strong, t0);
          append_dev(strong, t1);
          append_dev(div, t2);

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].m(div, null);
          }

          append_dev(div, t3);
        },
        p: function update(ctx, dirty) {
          if (dirty &
          /*error*/
          1 && t0_value !== (t0_value =
          /*key*/
          ctx[1] + "")) set_data_dev(t0, t0_value);

          if (dirty &
          /*error, Object*/
          1) {
            each_value_1 =
            /*error*/
            ctx[0].errors[
            /*key*/
            ctx[1]];
            validate_each_argument(each_value_1);
            let i;

            for (i = 0; i < each_value_1.length; i += 1) {
              const child_ctx = get_each_context_1(ctx, each_value_1, i);

              if (each_blocks[i]) {
                each_blocks[i].p(child_ctx, dirty);
              } else {
                each_blocks[i] = create_each_block_1(child_ctx);
                each_blocks[i].c();
                each_blocks[i].m(div, t3);
              }
            }

            for (; i < each_blocks.length; i += 1) {
              each_blocks[i].d(1);
            }

            each_blocks.length = each_value_1.length;
          }
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
          destroy_each(each_blocks, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_each_block.name,
        type: "each",
        source: "(14:8) {#each Object.keys(error.errors) as key}",
        ctx
      });
      return block;
    }

    function create_fragment$3(ctx) {
      let if_block_anchor;

      function select_block_type(ctx, dirty) {
        if (typeof
        /*error*/
        ctx[0] == "string") return create_if_block$2;
        if (
        /*error*/
        ctx[0] &&
        /*error*/
        ctx[0].errors) return create_if_block_1$1;
        if (
        /*error*/
        ctx[0]) return create_if_block_2$1;
      }

      let current_block_type = select_block_type(ctx);
      let if_block = current_block_type && current_block_type(ctx);
      const block = {
        c: function create() {
          if (if_block) if_block.c();
          if_block_anchor = empty();
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          if (if_block) if_block.m(target, anchor);
          insert_dev(target, if_block_anchor, anchor);
        },
        p: function update(ctx, [dirty]) {
          if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
            if_block.p(ctx, dirty);
          } else {
            if (if_block) if_block.d(1);
            if_block = current_block_type && current_block_type(ctx);

            if (if_block) {
              if_block.c();
              if_block.m(if_block_anchor.parentNode, if_block_anchor);
            }
          }
        },
        i: noop,
        o: noop,
        d: function destroy(detaching) {
          if (if_block) {
            if_block.d(detaching);
          }

          if (detaching) detach_dev(if_block_anchor);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$3.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }

    function instance$3($$self, $$props, $$invalidate) {
      let {
        $$slots: slots = {},
        $$scope
      } = $$props;
      validate_slots("ErrorValidacion", slots, []);
      let {
        error = null
      } = $$props;
      console.log(error);
      const writable_props = ["error"];
      Object_1.keys($$props).forEach(key => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1.warn(`<ErrorValidacion> was created with unknown prop '${key}'`);
      });

      $$self.$$set = $$props => {
        if ("error" in $$props) $$invalidate(0, error = $$props.error);
      };

      $$self.$capture_state = () => ({
        error
      });

      $$self.$inject_state = $$props => {
        if ("error" in $$props) $$invalidate(0, error = $$props.error);
      };

      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }

      return [error];
    }

    class ErrorValidacion extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$3, create_fragment$3, safe_not_equal, {
          error: 0
        });
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "ErrorValidacion",
          options,
          id: create_fragment$3.name
        });
      }

      get error() {
        throw new Error("<ErrorValidacion>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set error(value) {
        throw new Error("<ErrorValidacion>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

    }

    /* src\components\Dialogo.svelte generated by Svelte v3.29.0 */
    const {
      console: console_1$1
    } = globals;
    const file$4 = "src\\components\\Dialogo.svelte";

    const get_body_slot_changes = dirty => ({});

    const get_body_slot_context = ctx => ({});

    const get_activador_slot_changes$1 = dirty => ({});

    const get_activador_slot_context$1 = ctx => ({}); // (42:8) <Button >


    function create_default_slot_3$1(ctx) {
      let t;
      const block = {
        c: function create() {
          t = text(
          /*textoActivador*/
          ctx[2]);
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        p: function update(ctx, dirty) {
          if (dirty &
          /*textoActivador*/
          4) set_data_dev(t,
          /*textoActivador*/
          ctx[2]);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_3$1.name,
        type: "slot",
        source: "(42:8) <Button >",
        ctx
      });
      return block;
    } // (41:28)           


    function fallback_block_1(ctx) {
      let button;
      let current;
      button = new ye({
        props: {
          $$slots: {
            default: [create_default_slot_3$1]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          create_component(button.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(button, target, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          const button_changes = {};

          if (dirty &
          /*$$scope, textoActivador*/
          8196) {
            button_changes.$$scope = {
              dirty,
              ctx
            };
          }

          button.$set(button_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(button.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(button.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(button, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: fallback_block_1.name,
        type: "fallback",
        source: "(41:28)           ",
        ctx
      });
      return block;
    } // (47:8) <div slot="title">


    function create_title_slot(ctx) {
      let div;
      let t;
      const block = {
        c: function create() {
          div = element("div");
          t = text(
          /*titulo*/
          ctx[1]);
          attr_dev(div, "slot", "title");
          add_location(div, file$4, 46, 8, 1163);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          append_dev(div, t);
        },
        p: function update(ctx, dirty) {
          if (dirty &
          /*titulo*/
          2) set_data_dev(t,
          /*titulo*/
          ctx[1]);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_title_slot.name,
        type: "slot",
        source: "(47:8) <div slot=\\\"title\\\">",
        ctx
      });
      return block;
    } // (50:8) {#if exito}


    function create_if_block$3(ctx) {
      let p;
      let t_value =
      /*respuesta*/
      ctx[4].mensaje + "";
      let t;
      const block = {
        c: function create() {
          p = element("p");
          t = text(t_value);
          attr_dev(p, "class", "exito svelte-1eg803u");
          add_location(p, file$4, 50, 12, 1280);
        },
        m: function mount(target, anchor) {
          insert_dev(target, p, anchor);
          append_dev(p, t);
        },
        p: function update(ctx, dirty) {
          if (dirty &
          /*respuesta*/
          16 && t_value !== (t_value =
          /*respuesta*/
          ctx[4].mensaje + "")) set_data_dev(t, t_value);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(p);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block$3.name,
        type: "if",
        source: "(50:8) {#if exito}",
        ctx
      });
      return block;
    } // (59:12) <Button color="primary" on:click={()=> visible = false}>


    function create_default_slot_2$1(ctx) {
      let t;
      const block = {
        c: function create() {
          t = text("Cancelar");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_2$1.name,
        type: "slot",
        source: "(59:12) <Button color=\\\"primary\\\" on:click={()=> visible = false}>",
        ctx
      });
      return block;
    } // (60:12) <Button color="primary" on:click={ejecutarAccion}>


    function create_default_slot_1$1(ctx) {
      let t;
      const block = {
        c: function create() {
          t = text("Aceptar");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_1$1.name,
        type: "slot",
        source: "(60:12) <Button color=\\\"primary\\\" on:click={ejecutarAccion}>",
        ctx
      });
      return block;
    } // (58:8) <div slot="actions" class="actions center">


    function create_actions_slot(ctx) {
      let div;
      let button0;
      let t;
      let button1;
      let current;
      button0 = new ye({
        props: {
          color: "primary",
          $$slots: {
            default: [create_default_slot_2$1]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      button0.$on("click",
      /*click_handler_1*/
      ctx[11]);
      button1 = new ye({
        props: {
          color: "primary",
          $$slots: {
            default: [create_default_slot_1$1]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      button1.$on("click",
      /*ejecutarAccion*/
      ctx[6]);
      const block = {
        c: function create() {
          div = element("div");
          create_component(button0.$$.fragment);
          t = space();
          create_component(button1.$$.fragment);
          attr_dev(div, "slot", "actions");
          attr_dev(div, "class", "actions center");
          add_location(div, file$4, 57, 8, 1416);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          mount_component(button0, div, null);
          append_dev(div, t);
          mount_component(button1, div, null);
          current = true;
        },
        p: function update(ctx, dirty) {
          const button0_changes = {};

          if (dirty &
          /*$$scope*/
          8192) {
            button0_changes.$$scope = {
              dirty,
              ctx
            };
          }

          button0.$set(button0_changes);
          const button1_changes = {};

          if (dirty &
          /*$$scope*/
          8192) {
            button1_changes.$$scope = {
              dirty,
              ctx
            };
          }

          button1.$set(button1_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(button0.$$.fragment, local);
          transition_in(button1.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(button0.$$.fragment, local);
          transition_out(button1.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
          destroy_component(button0);
          destroy_component(button1);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_actions_slot.name,
        type: "slot",
        source: "(58:8) <div slot=\\\"actions\\\" class=\\\"actions center\\\">",
        ctx
      });
      return block;
    } // (46:4) <Dialog width="320" bind:visible={visible}>


    function create_default_slot$1(ctx) {
      let t0;
      let errorvalidacion;
      let updating_error;
      let t1;
      let t2;
      let t3;
      let current;

      function errorvalidacion_error_binding(value) {
        /*errorvalidacion_error_binding*/
        ctx[10].call(null, value);
      }

      let errorvalidacion_props = {};

      if (
      /*error*/
      ctx[5] !== void 0) {
        errorvalidacion_props.error =
        /*error*/
        ctx[5];
      }

      errorvalidacion = new ErrorValidacion({
        props: errorvalidacion_props,
        $$inline: true
      });
      binding_callbacks.push(() => bind(errorvalidacion, "error", errorvalidacion_error_binding));
      let if_block =
      /*exito*/
      ctx[3] && create_if_block$3(ctx);
      const body_slot_template =
      /*#slots*/
      ctx[8].body;
      const body_slot = create_slot(body_slot_template, ctx,
      /*$$scope*/
      ctx[13], get_body_slot_context);
      const block = {
        c: function create() {
          t0 = space();
          create_component(errorvalidacion.$$.fragment);
          t1 = space();
          if (if_block) if_block.c();
          t2 = space();
          if (body_slot) body_slot.c();
          t3 = space();
        },
        m: function mount(target, anchor) {
          insert_dev(target, t0, anchor);
          mount_component(errorvalidacion, target, anchor);
          insert_dev(target, t1, anchor);
          if (if_block) if_block.m(target, anchor);
          insert_dev(target, t2, anchor);

          if (body_slot) {
            body_slot.m(target, anchor);
          }

          insert_dev(target, t3, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          const errorvalidacion_changes = {};

          if (!updating_error && dirty &
          /*error*/
          32) {
            updating_error = true;
            errorvalidacion_changes.error =
            /*error*/
            ctx[5];
            add_flush_callback(() => updating_error = false);
          }

          errorvalidacion.$set(errorvalidacion_changes);

          if (
          /*exito*/
          ctx[3]) {
            if (if_block) {
              if_block.p(ctx, dirty);
            } else {
              if_block = create_if_block$3(ctx);
              if_block.c();
              if_block.m(t2.parentNode, t2);
            }
          } else if (if_block) {
            if_block.d(1);
            if_block = null;
          }

          if (body_slot) {
            if (body_slot.p && dirty &
            /*$$scope*/
            8192) {
              update_slot(body_slot, body_slot_template, ctx,
              /*$$scope*/
              ctx[13], dirty, get_body_slot_changes, get_body_slot_context);
            }
          }
        },
        i: function intro(local) {
          if (current) return;
          transition_in(errorvalidacion.$$.fragment, local);
          transition_in(body_slot, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(errorvalidacion.$$.fragment, local);
          transition_out(body_slot, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(t0);
          destroy_component(errorvalidacion, detaching);
          if (detaching) detach_dev(t1);
          if (if_block) if_block.d(detaching);
          if (detaching) detach_dev(t2);
          if (body_slot) body_slot.d(detaching);
          if (detaching) detach_dev(t3);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot$1.name,
        type: "slot",
        source: "(46:4) <Dialog width=\\\"320\\\" bind:visible={visible}>",
        ctx
      });
      return block;
    }

    function create_fragment$4(ctx) {
      let span;
      let t;
      let dialog;
      let updating_visible;
      let current;
      let mounted;
      let dispose;
      const activador_slot_template =
      /*#slots*/
      ctx[8].activador;
      const activador_slot = create_slot(activador_slot_template, ctx,
      /*$$scope*/
      ctx[13], get_activador_slot_context$1);
      const activador_slot_or_fallback = activador_slot || fallback_block_1(ctx);

      function dialog_visible_binding(value) {
        /*dialog_visible_binding*/
        ctx[12].call(null, value);
      }

      let dialog_props = {
        width: "320",
        $$slots: {
          default: [create_default_slot$1],
          actions: [create_actions_slot],
          title: [create_title_slot]
        },
        $$scope: {
          ctx
        }
      };

      if (
      /*visible*/
      ctx[0] !== void 0) {
        dialog_props.visible =
        /*visible*/
        ctx[0];
      }

      dialog = new pn({
        props: dialog_props,
        $$inline: true
      });
      binding_callbacks.push(() => bind(dialog, "visible", dialog_visible_binding));
      const block = {
        c: function create() {
          span = element("span");
          if (activador_slot_or_fallback) activador_slot_or_fallback.c();
          t = space();
          create_component(dialog.$$.fragment);
          add_location(span, file$4, 39, 0, 968);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, span, anchor);

          if (activador_slot_or_fallback) {
            activador_slot_or_fallback.m(span, null);
          }

          insert_dev(target, t, anchor);
          mount_component(dialog, target, anchor);
          current = true;

          if (!mounted) {
            dispose = listen_dev(span, "click",
            /*click_handler*/
            ctx[9], false, false, false);
            mounted = true;
          }
        },
        p: function update(ctx, [dirty]) {
          if (activador_slot) {
            if (activador_slot.p && dirty &
            /*$$scope*/
            8192) {
              update_slot(activador_slot, activador_slot_template, ctx,
              /*$$scope*/
              ctx[13], dirty, get_activador_slot_changes$1, get_activador_slot_context$1);
            }
          } else {
            if (activador_slot_or_fallback && activador_slot_or_fallback.p && dirty &
            /*textoActivador*/
            4) {
              activador_slot_or_fallback.p(ctx, dirty);
            }
          }

          const dialog_changes = {};

          if (dirty &
          /*$$scope, visible, respuesta, exito, error, titulo*/
          8251) {
            dialog_changes.$$scope = {
              dirty,
              ctx
            };
          }

          if (!updating_visible && dirty &
          /*visible*/
          1) {
            updating_visible = true;
            dialog_changes.visible =
            /*visible*/
            ctx[0];
            add_flush_callback(() => updating_visible = false);
          }

          dialog.$set(dialog_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(activador_slot_or_fallback, local);
          transition_in(dialog.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(activador_slot_or_fallback, local);
          transition_out(dialog.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(span);
          if (activador_slot_or_fallback) activador_slot_or_fallback.d(detaching);
          if (detaching) detach_dev(t);
          destroy_component(dialog, detaching);
          mounted = false;
          dispose();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$4.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }

    function instance$4($$self, $$props, $$invalidate) {
      let {
        $$slots: slots = {},
        $$scope
      } = $$props;
      validate_slots("Dialogo", slots, ['activador', 'body']);
      let {
        titulo = "Accion"
      } = $$props;
      let {
        accion = () => console.log("Accionado")
      } = $$props;
      let {
        visible = false
      } = $$props;
      let {
        textoActivador = "Accion"
      } = $$props;
      let exito = false;
      let respuesta = null;

      async function ejecutarAccion() {
        try {
          $$invalidate(5, error = null);
          $$invalidate(4, respuesta = (await accion()).data);
          $$invalidate(3, exito = true);
          setTimeout(() => $$invalidate(0, visible = false), 1000);
        } catch (e) {
          console.log(e.response.data);
          $$invalidate(3, exito = false);
          $$invalidate(5, error = e.response.data);
        }
      }

      let error = null;
      onDestroy(() => {
        $$invalidate(4, respuesta = null);
        $$invalidate(5, error = null);
      });
      const writable_props = ["titulo", "accion", "visible", "textoActivador"];
      Object.keys($$props).forEach(key => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$1.warn(`<Dialogo> was created with unknown prop '${key}'`);
      });

      const click_handler = () => $$invalidate(0, visible = true);

      function errorvalidacion_error_binding(value) {
        error = value;
        $$invalidate(5, error), $$invalidate(0, visible);
      }

      const click_handler_1 = () => $$invalidate(0, visible = false);

      function dialog_visible_binding(value) {
        visible = value;
        $$invalidate(0, visible);
      }

      $$self.$$set = $$props => {
        if ("titulo" in $$props) $$invalidate(1, titulo = $$props.titulo);
        if ("accion" in $$props) $$invalidate(7, accion = $$props.accion);
        if ("visible" in $$props) $$invalidate(0, visible = $$props.visible);
        if ("textoActivador" in $$props) $$invalidate(2, textoActivador = $$props.textoActivador);
        if ("$$scope" in $$props) $$invalidate(13, $$scope = $$props.$$scope);
      };

      $$self.$capture_state = () => ({
        ErrorValidacion,
        Dialog: pn,
        Button: ye,
        onDestroy,
        titulo,
        accion,
        visible,
        textoActivador,
        exito,
        respuesta,
        ejecutarAccion,
        error
      });

      $$self.$inject_state = $$props => {
        if ("titulo" in $$props) $$invalidate(1, titulo = $$props.titulo);
        if ("accion" in $$props) $$invalidate(7, accion = $$props.accion);
        if ("visible" in $$props) $$invalidate(0, visible = $$props.visible);
        if ("textoActivador" in $$props) $$invalidate(2, textoActivador = $$props.textoActivador);
        if ("exito" in $$props) $$invalidate(3, exito = $$props.exito);
        if ("respuesta" in $$props) $$invalidate(4, respuesta = $$props.respuesta);
        if ("error" in $$props) $$invalidate(5, error = $$props.error);
      };

      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }

      $$self.$$.update = () => {
        if ($$self.$$.dirty &
        /*visible*/
        1) {
           if (visible == false) {
            $$invalidate(4, respuesta = null);
            $$invalidate(5, error = null);
            $$invalidate(3, exito = false);
          }
        }
      };

      return [visible, titulo, textoActivador, exito, respuesta, error, ejecutarAccion, accion, slots, click_handler, errorvalidacion_error_binding, click_handler_1, dialog_visible_binding, $$scope];
    }

    class Dialogo extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$4, create_fragment$4, safe_not_equal, {
          titulo: 1,
          accion: 7,
          visible: 0,
          textoActivador: 2
        });
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "Dialogo",
          options,
          id: create_fragment$4.name
        });
      }

      get titulo() {
        throw new Error("<Dialogo>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set titulo(value) {
        throw new Error("<Dialogo>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get accion() {
        throw new Error("<Dialogo>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set accion(value) {
        throw new Error("<Dialogo>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get visible() {
        throw new Error("<Dialogo>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set visible(value) {
        throw new Error("<Dialogo>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get textoActivador() {
        throw new Error("<Dialogo>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set textoActivador(value) {
        throw new Error("<Dialogo>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

    }

    class Enum {
      static aString(rango) {
        let keys = Object.keys(this);
        let string = "";
        keys.forEach(k => {
          if (this[k] == rango) string = k;
        });
        return string;
      }

    }

    class HiloEstado {}

    _defineProperty(HiloEstado, "normal", 0);

    _defineProperty(HiloEstado, "archivado", 1);

    _defineProperty(HiloEstado, "eliminado", 2);

    class ComentarioEstado {}

    _defineProperty(ComentarioEstado, "normal", 0);

    _defineProperty(ComentarioEstado, "eliminado", 1);

    class MotivoDenuncia extends Enum {}

    _defineProperty(MotivoDenuncia, "CategoriaIncorrecta", 0);

    _defineProperty(MotivoDenuncia, "Spam", 1);

    _defineProperty(MotivoDenuncia, "Doxxeo", 2);

    _defineProperty(MotivoDenuncia, "ContenidoIlegal", 3);

    _defineProperty(MotivoDenuncia, "Gore", 4);

    _defineProperty(MotivoDenuncia, "MaltratoAnimal", 5);

    class EstadoDenuncia {}

    _defineProperty(EstadoDenuncia, "Aceptada", 0);

    _defineProperty(EstadoDenuncia, "Rechazada", 1);

    _defineProperty(EstadoDenuncia, "NoRevisada", 2);

    class CreacionRango {
      static aString(rango) {
        let keys = Object.keys(CreacionRango);
        let string = "";
        keys.forEach(k => {
          if (CreacionRango[k] == rango) string = k;
        });
        return string;
      }

    }

    _defineProperty(CreacionRango, "Anon", 0);

    _defineProperty(CreacionRango, "Auxliar", 1);

    _defineProperty(CreacionRango, "Mod", 2);

    _defineProperty(CreacionRango, "Admin", 3);

    class TipoAccion {
      static aString(rango) {
        let keys = Object.keys(TipoAccion);
        let string = "";
        keys.forEach(k => {
          if (TipoAccion[k] == rango) string = k;
        });
        return string;
      }

    }

    _defineProperty(TipoAccion, "ComentarioBorrado", 0);

    _defineProperty(TipoAccion, "HiloBorrado", 1);

    _defineProperty(TipoAccion, "CategoriaCambiada", 2);

    _defineProperty(TipoAccion, "DenunciaRechazada", 3);

    _defineProperty(TipoAccion, "UsuarioBaneado", 4);

    _defineProperty(TipoAccion, "UsuarioDesbaneado", 5);

    _defineProperty(TipoAccion, "ComentarioRestaurado", 6);

    _defineProperty(TipoAccion, "HiloRestaurado", 7);

    _defineProperty(TipoAccion, "HiloStickeado", 8);

    _defineProperty(TipoAccion, "HiloDeestickeado", 9);

    _defineProperty(TipoAccion, "MediaEliminado", 10);

    _defineProperty(TipoAccion, "AudioEliminado", 11);

    /* src\components\Dialogos\DialogoReporte.svelte generated by Svelte v3.29.0 */
    const {
      Object: Object_1$1
    } = globals;
    const file$5 = "src\\components\\Dialogos\\DialogoReporte.svelte";

    function get_each_context_1$1(ctx, list, i) {
      const child_ctx = ctx.slice();
      child_ctx[18] = list[i];
      return child_ctx;
    }

    function get_each_context$1(ctx, list, i) {
      const child_ctx = ctx.slice();
      child_ctx[15] = list[i];
      return child_ctx;
    }

    function get_each_context_2$1(ctx, list, i) {
      const child_ctx = ctx.slice();
      child_ctx[21] = list[i];
      child_ctx[23] = i;
      return child_ctx;
    }

    const get_default_slot_changes = dirty => ({});

    const get_default_slot_context = ctx => ({
      slot: "activador"
    }); // (62:4) <slot slot="activador" />      <div slot="body">          <p>              Reportar el {tipoString}


    function create_activador_slot(ctx) {
      let current;
      const default_slot_template =
      /*#slots*/
      ctx[8].default;
      const default_slot = create_slot(default_slot_template, ctx,
      /*$$scope*/
      ctx[14], get_default_slot_context);
      const block = {
        c: function create() {
          if (default_slot) default_slot.c();
        },
        m: function mount(target, anchor) {
          if (default_slot) {
            default_slot.m(target, anchor);
          }

          current = true;
        },
        p: function update(ctx, dirty) {
          if (default_slot) {
            if (default_slot.p && dirty &
            /*$$scope*/
            16384) {
              update_slot(default_slot, default_slot_template, ctx,
              /*$$scope*/
              ctx[14], dirty, get_default_slot_changes, get_default_slot_context);
            }
          }
        },
        i: function intro(local) {
          if (current) return;
          transition_in(default_slot, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(default_slot, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (default_slot) default_slot.d(detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_activador_slot.name,
        type: "slot",
        source: "(62:4) <slot slot=\\\"activador\\\" />      <div slot=\\\"body\\\">          <p>              Reportar el {tipoString}",
        ctx
      });
      return block;
    } // (75:12) {#each Object.keys(MotivoDenuncia) as k, i}


    function create_each_block_2$1(ctx) {
      let option;
      let t_value =
      /*k*/
      ctx[21] + "";
      let t;
      let option_value_value;
      const block = {
        c: function create() {
          option = element("option");
          t = text(t_value);
          option.__value = option_value_value = MotivoDenuncia[
          /*k*/
          ctx[21]];
          option.value = option.__value;
          add_location(option, file$5, 75, 16, 2334);
        },
        m: function mount(target, anchor) {
          insert_dev(target, option, anchor);
          append_dev(option, t);
        },
        p: noop,
        d: function destroy(detaching) {
          if (detaching) detach_dev(option);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_each_block_2$1.name,
        type: "each",
        source: "(75:12) {#each Object.keys(MotivoDenuncia) as k, i}",
        ctx
      });
      return block;
    } // (79:8) {#if motivo === 0}


    function create_if_block$4(ctx) {
      let select;
      let option;
      let mounted;
      let dispose;
      let each_value = config.grupos;
      validate_each_argument(each_value);
      let each_blocks = [];

      for (let i = 0; i < each_value.length; i += 1) {
        each_blocks[i] = create_each_block$1(get_each_context$1(ctx, each_value, i));
      }

      const block = {
        c: function create() {
          select = element("select");
          option = element("option");
          option.textContent = "Categoría";

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].c();
          }

          option.__value = "-1";
          option.value = option.__value;
          option.selected = "selected";
          option.disabled = "disabled";
          add_location(option, file$5, 80, 16, 2528);
          attr_dev(select, "name", "categoria");
          if (
          /*categoria*/
          ctx[5] === void 0) add_render_callback(() =>
          /*select_change_handler_1*/
          ctx[10].call(select));
          add_location(select, file$5, 79, 12, 2462);
        },
        m: function mount(target, anchor) {
          insert_dev(target, select, anchor);
          append_dev(select, option);

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].m(select, null);
          }

          select_option(select,
          /*categoria*/
          ctx[5]);

          if (!mounted) {
            dispose = listen_dev(select, "change",
            /*select_change_handler_1*/
            ctx[10]);
            mounted = true;
          }
        },
        p: function update(ctx, dirty) {
          if (dirty &
          /*config*/
          0) {
            each_value = config.grupos;
            validate_each_argument(each_value);
            let i;

            for (i = 0; i < each_value.length; i += 1) {
              const child_ctx = get_each_context$1(ctx, each_value, i);

              if (each_blocks[i]) {
                each_blocks[i].p(child_ctx, dirty);
              } else {
                each_blocks[i] = create_each_block$1(child_ctx);
                each_blocks[i].c();
                each_blocks[i].m(select, null);
              }
            }

            for (; i < each_blocks.length; i += 1) {
              each_blocks[i].d(1);
            }

            each_blocks.length = each_value.length;
          }

          if (dirty &
          /*categoria, config*/
          32) {
            select_option(select,
            /*categoria*/
            ctx[5]);
          }
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(select);
          destroy_each(each_blocks, detaching);
          mounted = false;
          dispose();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block$4.name,
        type: "if",
        source: "(79:8) {#if motivo === 0}",
        ctx
      });
      return block;
    } // (90:24) {#each g.categorias as cid}


    function create_each_block_1$1(ctx) {
      let option;
      let t_value = config.categoriaPorId(
      /*cid*/
      ctx[18]).nombre + "";
      let t;
      let option_value_value;
      const block = {
        c: function create() {
          option = element("option");
          t = text(t_value);
          option.__value = option_value_value =
          /*cid*/
          ctx[18];
          option.value = option.__value;
          add_location(option, file$5, 90, 28, 2961);
        },
        m: function mount(target, anchor) {
          insert_dev(target, option, anchor);
          append_dev(option, t);
        },
        p: noop,
        d: function destroy(detaching) {
          if (detaching) detach_dev(option);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_each_block_1$1.name,
        type: "each",
        source: "(90:24) {#each g.categorias as cid}",
        ctx
      });
      return block;
    } // (84:16) {#each config.grupos as g}


    function create_each_block$1(ctx) {
      let optgroup;
      let optgroup_id_value;
      let optgroup_label_value;
      let each_value_1 =
      /*g*/
      ctx[15].categorias;
      validate_each_argument(each_value_1);
      let each_blocks = [];

      for (let i = 0; i < each_value_1.length; i += 1) {
        each_blocks[i] = create_each_block_1$1(get_each_context_1$1(ctx, each_value_1, i));
      }

      const block = {
        c: function create() {
          optgroup = element("optgroup");

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].c();
          }

          attr_dev(optgroup, "id", optgroup_id_value = "grupo_" +
          /*g*/
          ctx[15].id);
          attr_dev(optgroup, "label", optgroup_label_value =
          /*g*/
          ctx[15].nombre);
          attr_dev(optgroup, "class", "grupo-categorias");
          add_location(optgroup, file$5, 84, 20, 2711);
        },
        m: function mount(target, anchor) {
          insert_dev(target, optgroup, anchor);

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].m(optgroup, null);
          }
        },
        p: function update(ctx, dirty) {
          if (dirty &
          /*config*/
          0) {
            each_value_1 =
            /*g*/
            ctx[15].categorias;
            validate_each_argument(each_value_1);
            let i;

            for (i = 0; i < each_value_1.length; i += 1) {
              const child_ctx = get_each_context_1$1(ctx, each_value_1, i);

              if (each_blocks[i]) {
                each_blocks[i].p(child_ctx, dirty);
              } else {
                each_blocks[i] = create_each_block_1$1(child_ctx);
                each_blocks[i].c();
                each_blocks[i].m(optgroup, null);
              }
            }

            for (; i < each_blocks.length; i += 1) {
              each_blocks[i].d(1);
            }

            each_blocks.length = each_value_1.length;
          }
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(optgroup);
          destroy_each(each_blocks, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_each_block$1.name,
        type: "each",
        source: "(84:16) {#each config.grupos as g}",
        ctx
      });
      return block;
    } // (63:4) <div slot="body">


    function create_body_slot(ctx) {
      let div;
      let p;
      let t0;
      let t1;
      let t2;
      let t3_value = (
      /*tipoString*/
      ctx[7] == "hilo" ?
      /*hiloId*/
      ctx[2] :
      /*comentarioId*/
      ctx[1]) + "";
      let t3;
      let t4;
      let select;
      let option;
      let t6;
      let t7;
      let textarea;
      let textarea_placeholder_value;
      let mounted;
      let dispose;
      let each_value_2 = Object.keys(MotivoDenuncia);
      validate_each_argument(each_value_2);
      let each_blocks = [];

      for (let i = 0; i < each_value_2.length; i += 1) {
        each_blocks[i] = create_each_block_2$1(get_each_context_2$1(ctx, each_value_2, i));
      }

      let if_block =
      /*motivo*/
      ctx[3] === 0 && create_if_block$4(ctx);
      const block = {
        c: function create() {
          div = element("div");
          p = element("p");
          t0 = text("Reportar el ");
          t1 = text(
          /*tipoString*/
          ctx[7]);
          t2 = space();
          t3 = text(t3_value);
          t4 = space();
          select = element("select");
          option = element("option");
          option.textContent = "Motivo";

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].c();
          }

          t6 = space();
          if (if_block) if_block.c();
          t7 = space();
          textarea = element("textarea");
          add_location(p, file$5, 63, 8, 1836);
          option.__value = "-1";
          option.value = option.__value;
          option.selected = "selected";
          option.disabled = "disabled";
          add_location(option, file$5, 68, 12, 2017);
          attr_dev(select, "name", "motivo");
          if (
          /*motivo*/
          ctx[3] === void 0) add_render_callback(() =>
          /*select_change_handler*/
          ctx[9].call(select));
          add_location(select, file$5, 67, 8, 1961);
          attr_dev(textarea, "placeholder", textarea_placeholder_value = "Aclaracion " + (
          /*motivo*/
          ctx[3] === 0 ? "(opcional)" : "(obligatoria)"));
          add_location(textarea, file$5, 99, 8, 3230);
          attr_dev(div, "slot", "body");
          add_location(div, file$5, 62, 4, 1809);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          append_dev(div, p);
          append_dev(p, t0);
          append_dev(p, t1);
          append_dev(p, t2);
          append_dev(p, t3);
          append_dev(div, t4);
          append_dev(div, select);
          append_dev(select, option);

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].m(select, null);
          }

          select_option(select,
          /*motivo*/
          ctx[3]);
          append_dev(div, t6);
          if (if_block) if_block.m(div, null);
          append_dev(div, t7);
          append_dev(div, textarea);
          set_input_value(textarea,
          /*aclaracion*/
          ctx[4]);

          if (!mounted) {
            dispose = [listen_dev(select, "change",
            /*select_change_handler*/
            ctx[9]), listen_dev(textarea, "input",
            /*textarea_input_handler*/
            ctx[11])];
            mounted = true;
          }
        },
        p: function update(ctx, dirty) {
          if (dirty &
          /*tipoString*/
          128) set_data_dev(t1,
          /*tipoString*/
          ctx[7]);
          if (dirty &
          /*tipoString, hiloId, comentarioId*/
          134 && t3_value !== (t3_value = (
          /*tipoString*/
          ctx[7] == "hilo" ?
          /*hiloId*/
          ctx[2] :
          /*comentarioId*/
          ctx[1]) + "")) set_data_dev(t3, t3_value);

          if (dirty &
          /*MotivoDenuncia, Object*/
          0) {
            each_value_2 = Object.keys(MotivoDenuncia);
            validate_each_argument(each_value_2);
            let i;

            for (i = 0; i < each_value_2.length; i += 1) {
              const child_ctx = get_each_context_2$1(ctx, each_value_2, i);

              if (each_blocks[i]) {
                each_blocks[i].p(child_ctx, dirty);
              } else {
                each_blocks[i] = create_each_block_2$1(child_ctx);
                each_blocks[i].c();
                each_blocks[i].m(select, null);
              }
            }

            for (; i < each_blocks.length; i += 1) {
              each_blocks[i].d(1);
            }

            each_blocks.length = each_value_2.length;
          }

          if (dirty &
          /*motivo, MotivoDenuncia, Object*/
          8) {
            select_option(select,
            /*motivo*/
            ctx[3]);
          }

          if (
          /*motivo*/
          ctx[3] === 0) {
            if (if_block) {
              if_block.p(ctx, dirty);
            } else {
              if_block = create_if_block$4(ctx);
              if_block.c();
              if_block.m(div, t7);
            }
          } else if (if_block) {
            if_block.d(1);
            if_block = null;
          }

          if (dirty &
          /*motivo, MotivoDenuncia, Object*/
          8 && textarea_placeholder_value !== (textarea_placeholder_value = "Aclaracion " + (
          /*motivo*/
          ctx[3] === 0 ? "(opcional)" : "(obligatoria)"))) {
            attr_dev(textarea, "placeholder", textarea_placeholder_value);
          }

          if (dirty &
          /*aclaracion*/
          16) {
            set_input_value(textarea,
            /*aclaracion*/
            ctx[4]);
          }
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
          destroy_each(each_blocks, detaching);
          if (if_block) if_block.d();
          mounted = false;
          run_all(dispose);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_body_slot.name,
        type: "slot",
        source: "(63:4) <div slot=\\\"body\\\">",
        ctx
      });
      return block;
    } // (30:0) <Dialogo      bind:visible      textoActivador="Reportar {tipoString}"      titulo="Reportar {tipoString}"      accion={() => {          let motivoReporte = motivo;          let aclaracionReporte = aclaracion;          if (motivoReporte === 0) {              if (categoria === -1) {                  let e = new ExceptionReporte("Especifique categoría");                  throw e;              }              if (aclaracionReporte != "") {                  aclaracionReporte += "\n";              }              aclaracionReporte += `[${config.categoriaPorId(categoria).nombre}]`;          }          if (aclaracionReporte === "" && motivoReporte != -1) {              let e = new ExceptionReporte(                  "Ingrese una breve descripción de su denuncia"              );              throw e;          }          return RChanClient.Denunciar(              tipo,              hiloId,              motivoReporte,              aclaracionReporte,              comentarioId          );      }}  >


    function create_default_slot$2(ctx) {
      let t;
      const block = {
        c: function create() {
          t = space();
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        p: noop,
        i: noop,
        o: noop,
        d: function destroy(detaching) {
          if (detaching) detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot$2.name,
        type: "slot",
        source: "(30:0) <Dialogo      bind:visible      textoActivador=\\\"Reportar {tipoString}\\\"      titulo=\\\"Reportar {tipoString}\\\"      accion={() => {          let motivoReporte = motivo;          let aclaracionReporte = aclaracion;          if (motivoReporte === 0) {              if (categoria === -1) {                  let e = new ExceptionReporte(\\\"Especifique categoría\\\");                  throw e;              }              if (aclaracionReporte != \\\"\\\") {                  aclaracionReporte += \\\"\\n\\\";              }              aclaracionReporte += `[${config.categoriaPorId(categoria).nombre}]`;          }          if (aclaracionReporte === \\\"\\\" && motivoReporte != -1) {              let e = new ExceptionReporte(                  \\\"Ingrese una breve descripción de su denuncia\\\"              );              throw e;          }          return RChanClient.Denunciar(              tipo,              hiloId,              motivoReporte,              aclaracionReporte,              comentarioId          );      }}  >",
        ctx
      });
      return block;
    }

    function create_fragment$5(ctx) {
      let dialogo;
      let updating_visible;
      let current;

      function dialogo_visible_binding(value) {
        /*dialogo_visible_binding*/
        ctx[13].call(null, value);
      }

      let dialogo_props = {
        textoActivador: "Reportar " +
        /*tipoString*/
        ctx[7],
        titulo: "Reportar " +
        /*tipoString*/
        ctx[7],
        accion:
        /*func*/
        ctx[12],
        $$slots: {
          default: [create_default_slot$2],
          body: [create_body_slot],
          activador: [create_activador_slot]
        },
        $$scope: {
          ctx
        }
      };

      if (
      /*visible*/
      ctx[0] !== void 0) {
        dialogo_props.visible =
        /*visible*/
        ctx[0];
      }

      dialogo = new Dialogo({
        props: dialogo_props,
        $$inline: true
      });
      binding_callbacks.push(() => bind(dialogo, "visible", dialogo_visible_binding));
      const block = {
        c: function create() {
          create_component(dialogo.$$.fragment);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          mount_component(dialogo, target, anchor);
          current = true;
        },
        p: function update(ctx, [dirty]) {
          const dialogo_changes = {};
          if (dirty &
          /*tipoString*/
          128) dialogo_changes.textoActivador = "Reportar " +
          /*tipoString*/
          ctx[7];
          if (dirty &
          /*tipoString*/
          128) dialogo_changes.titulo = "Reportar " +
          /*tipoString*/
          ctx[7];
          if (dirty &
          /*motivo, aclaracion, categoria, tipo, hiloId, comentarioId*/
          126) dialogo_changes.accion =
          /*func*/
          ctx[12];

          if (dirty &
          /*$$scope, motivo, aclaracion, categoria, tipoString, hiloId, comentarioId*/
          16574) {
            dialogo_changes.$$scope = {
              dirty,
              ctx
            };
          }

          if (!updating_visible && dirty &
          /*visible*/
          1) {
            updating_visible = true;
            dialogo_changes.visible =
            /*visible*/
            ctx[0];
            add_flush_callback(() => updating_visible = false);
          }

          dialogo.$set(dialogo_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(dialogo.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(dialogo.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(dialogo, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$5.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }

    function ExceptionReporte(mensaje) {
      this.response = {
        data: {
          Motivo: mensaje
        }
      };
    }

    function instance$5($$self, $$props, $$invalidate) {
      let {
        $$slots: slots = {},
        $$scope
      } = $$props;
      validate_slots("DialogoReporte", slots, ['default']);
      let {
        comentarioId = ""
      } = $$props;
      let {
        hiloId = ""
      } = $$props;
      let motivo = -1;
      let aclaracion = "";
      let categoria = -1;
      let {
        visible = false
      } = $$props;
      const writable_props = ["comentarioId", "hiloId", "visible"];
      Object_1$1.keys($$props).forEach(key => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<DialogoReporte> was created with unknown prop '${key}'`);
      });

      function select_change_handler() {
        motivo = select_value(this);
        $$invalidate(3, motivo), $$invalidate(0, visible);
      }

      function select_change_handler_1() {
        categoria = select_value(this);
        $$invalidate(5, categoria), $$invalidate(0, visible);
      }

      function textarea_input_handler() {
        aclaracion = this.value;
        $$invalidate(4, aclaracion), $$invalidate(0, visible);
      }

      const func = () => {
        let motivoReporte = motivo;
        let aclaracionReporte = aclaracion;

        if (motivoReporte === 0) {
          if (categoria === -1) {
            let e = new ExceptionReporte("Especifique categoría");
            throw e;
          }

          if (aclaracionReporte != "") {
            aclaracionReporte += "\n";
          }

          aclaracionReporte += `[${config.categoriaPorId(categoria).nombre}]`;
        }

        if (aclaracionReporte === "" && motivoReporte != -1) {
          let e = new ExceptionReporte("Ingrese una breve descripción de su denuncia");
          throw e;
        }

        return RChanClient.Denunciar(tipo, hiloId, motivoReporte, aclaracionReporte, comentarioId);
      };

      function dialogo_visible_binding(value) {
        visible = value;
        $$invalidate(0, visible);
      }

      $$self.$$set = $$props => {
        if ("comentarioId" in $$props) $$invalidate(1, comentarioId = $$props.comentarioId);
        if ("hiloId" in $$props) $$invalidate(2, hiloId = $$props.hiloId);
        if ("visible" in $$props) $$invalidate(0, visible = $$props.visible);
        if ("$$scope" in $$props) $$invalidate(14, $$scope = $$props.$$scope);
      };

      $$self.$capture_state = () => ({
        Dialogo,
        globalStore,
        RChanClient,
        MotivoDenuncia,
        config,
        comentarioId,
        hiloId,
        motivo,
        aclaracion,
        categoria,
        visible,
        ExceptionReporte,
        tipo,
        tipoString
      });

      $$self.$inject_state = $$props => {
        if ("comentarioId" in $$props) $$invalidate(1, comentarioId = $$props.comentarioId);
        if ("hiloId" in $$props) $$invalidate(2, hiloId = $$props.hiloId);
        if ("motivo" in $$props) $$invalidate(3, motivo = $$props.motivo);
        if ("aclaracion" in $$props) $$invalidate(4, aclaracion = $$props.aclaracion);
        if ("categoria" in $$props) $$invalidate(5, categoria = $$props.categoria);
        if ("visible" in $$props) $$invalidate(0, visible = $$props.visible);
        if ("tipo" in $$props) $$invalidate(6, tipo = $$props.tipo);
        if ("tipoString" in $$props) $$invalidate(7, tipoString = $$props.tipoString);
      };

      let tipo;
      let tipoString;

      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }

      $$self.$$.update = () => {
        if ($$self.$$.dirty &
        /*comentarioId*/
        2) {
           $$invalidate(6, tipo = comentarioId == "" || !comentarioId ? 0 : 1);
        }

        if ($$self.$$.dirty &
        /*tipo*/
        64) {
           $$invalidate(7, tipoString = tipo == 0 ? "hilo" : "comentario");
        }

        if ($$self.$$.dirty &
        /*visible*/
        1) {
           if (visible == false) {
            $$invalidate(3, motivo = -1);
            $$invalidate(4, aclaracion = "");
            $$invalidate(5, categoria = -1);
          }
        }
      };

      return [visible, comentarioId, hiloId, motivo, aclaracion, categoria, tipo, tipoString, slots, select_change_handler, select_change_handler_1, textarea_input_handler, func, dialogo_visible_binding, $$scope];
    }

    class DialogoReporte extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$5, create_fragment$5, safe_not_equal, {
          comentarioId: 1,
          hiloId: 2,
          visible: 0
        });
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "DialogoReporte",
          options,
          id: create_fragment$5.name
        });
      }

      get comentarioId() {
        throw new Error("<DialogoReporte>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set comentarioId(value) {
        throw new Error("<DialogoReporte>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get hiloId() {
        throw new Error("<DialogoReporte>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set hiloId(value) {
        throw new Error("<DialogoReporte>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get visible() {
        throw new Error("<DialogoReporte>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set visible(value) {
        throw new Error("<DialogoReporte>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

    }

    /* src\components\Dialogos\DialogoBan.svelte generated by Svelte v3.29.0 */
    const {
      Object: Object_1$2
    } = globals;
    const file$6 = "src\\components\\Dialogos\\DialogoBan.svelte";

    function get_each_context$2(ctx, list, i) {
      const child_ctx = ctx.slice();
      child_ctx[23] = list[i];
      child_ctx[25] = i;
      return child_ctx;
    }

    const get_default_slot_changes$1 = dirty => ({});

    const get_default_slot_context$1 = ctx => ({
      slot: "activador"
    }); // (40:4) <slot slot="activador" />      <div slot="body">          <div class="">              {#if hiloId}


    function create_activador_slot$1(ctx) {
      let current;
      const default_slot_template =
      /*#slots*/
      ctx[12].default;
      const default_slot = create_slot(default_slot_template, ctx,
      /*$$scope*/
      ctx[20], get_default_slot_context$1);
      const block = {
        c: function create() {
          if (default_slot) default_slot.c();
        },
        m: function mount(target, anchor) {
          if (default_slot) {
            default_slot.m(target, anchor);
          }

          current = true;
        },
        p: function update(ctx, dirty) {
          if (default_slot) {
            if (default_slot.p && dirty &
            /*$$scope*/
            1048576) {
              update_slot(default_slot, default_slot_template, ctx,
              /*$$scope*/
              ctx[20], dirty, get_default_slot_changes$1, get_default_slot_context$1);
            }
          }
        },
        i: function intro(local) {
          if (current) return;
          transition_in(default_slot, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(default_slot, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (default_slot) default_slot.d(detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_activador_slot$1.name,
        type: "slot",
        source: "(40:4) <slot slot=\\\"activador\\\" />      <div slot=\\\"body\\\">          <div class=\\\"\\\">              {#if hiloId}",
        ctx
      });
      return block;
    } // (43:12) {#if hiloId}


    function create_if_block_3$1(ctx) {
      let t0;
      let t1;
      let t2;
      let t3;
      let t4;
      let t5;
      const block = {
        c: function create() {
          t0 = text("Banear al usuario ");
          t1 = text(
          /*usuarioId*/
          ctx[3]);
          t2 = text("\r\n                por ");
          t3 = text(
          /*hiloId*/
          ctx[1]);
          t4 = text("#");
          t5 = text(
          /*comentarioId*/
          ctx[2]);
        },
        m: function mount(target, anchor) {
          insert_dev(target, t0, anchor);
          insert_dev(target, t1, anchor);
          insert_dev(target, t2, anchor);
          insert_dev(target, t3, anchor);
          insert_dev(target, t4, anchor);
          insert_dev(target, t5, anchor);
        },
        p: function update(ctx, dirty) {
          if (dirty &
          /*usuarioId*/
          8) set_data_dev(t1,
          /*usuarioId*/
          ctx[3]);
          if (dirty &
          /*hiloId*/
          2) set_data_dev(t3,
          /*hiloId*/
          ctx[1]);
          if (dirty &
          /*comentarioId*/
          4) set_data_dev(t5,
          /*comentarioId*/
          ctx[2]);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(t0);
          if (detaching) detach_dev(t1);
          if (detaching) detach_dev(t2);
          if (detaching) detach_dev(t3);
          if (detaching) detach_dev(t4);
          if (detaching) detach_dev(t5);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_3$1.name,
        type: "if",
        source: "(43:12) {#if hiloId}",
        ctx
      });
      return block;
    } // (52:12) {#each Object.keys(MotivoDenuncia) as k, i}


    function create_each_block$2(ctx) {
      let option;
      let t_value =
      /*k*/
      ctx[23] + "";
      let t;
      let option_value_value;
      const block = {
        c: function create() {
          option = element("option");
          t = text(t_value);
          option.__value = option_value_value = MotivoDenuncia[
          /*k*/
          ctx[23]];
          option.value = option.__value;
          add_location(option, file$6, 52, 16, 1525);
        },
        m: function mount(target, anchor) {
          insert_dev(target, option, anchor);
          append_dev(option, t);
        },
        p: noop,
        d: function destroy(detaching) {
          if (detaching) detach_dev(option);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_each_block$2.name,
        type: "each",
        source: "(52:12) {#each Object.keys(MotivoDenuncia) as k, i}",
        ctx
      });
      return block;
    } // (76:8) {#if comentarioId || hiloId}


    function create_if_block_1$2(ctx) {
      let checkbox;
      let updating_checked;
      let t;
      let if_block_anchor;
      let current;

      function checkbox_checked_binding(value) {
        /*checkbox_checked_binding*/
        ctx[16].call(null, value);
      }

      let checkbox_props = {
        style: "padding: 0 8px",
        right: true,
        $$slots: {
          default: [create_default_slot_3$2]
        },
        $$scope: {
          ctx
        }
      };

      if (
      /*eliminarElemento*/
      ctx[7] !== void 0) {
        checkbox_props.checked =
        /*eliminarElemento*/
        ctx[7];
      }

      checkbox = new Ne({
        props: checkbox_props,
        $$inline: true
      });
      binding_callbacks.push(() => bind(checkbox, "checked", checkbox_checked_binding));
      let if_block =
      /*$globalStore*/
      ctx[10].usuario.esMod && create_if_block_2$2(ctx);
      const block = {
        c: function create() {
          create_component(checkbox.$$.fragment);
          t = space();
          if (if_block) if_block.c();
          if_block_anchor = empty();
        },
        m: function mount(target, anchor) {
          mount_component(checkbox, target, anchor);
          insert_dev(target, t, anchor);
          if (if_block) if_block.m(target, anchor);
          insert_dev(target, if_block_anchor, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          const checkbox_changes = {};

          if (dirty &
          /*$$scope*/
          1048576) {
            checkbox_changes.$$scope = {
              dirty,
              ctx
            };
          }

          if (!updating_checked && dirty &
          /*eliminarElemento*/
          128) {
            updating_checked = true;
            checkbox_changes.checked =
            /*eliminarElemento*/
            ctx[7];
            add_flush_callback(() => updating_checked = false);
          }

          checkbox.$set(checkbox_changes);

          if (
          /*$globalStore*/
          ctx[10].usuario.esMod) {
            if (if_block) {
              if_block.p(ctx, dirty);

              if (dirty &
              /*$globalStore*/
              1024) {
                transition_in(if_block, 1);
              }
            } else {
              if_block = create_if_block_2$2(ctx);
              if_block.c();
              transition_in(if_block, 1);
              if_block.m(if_block_anchor.parentNode, if_block_anchor);
            }
          } else if (if_block) {
            group_outros();
            transition_out(if_block, 1, 1, () => {
              if_block = null;
            });
            check_outros();
          }
        },
        i: function intro(local) {
          if (current) return;
          transition_in(checkbox.$$.fragment, local);
          transition_in(if_block);
          current = true;
        },
        o: function outro(local) {
          transition_out(checkbox.$$.fragment, local);
          transition_out(if_block);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(checkbox, detaching);
          if (detaching) detach_dev(t);
          if (if_block) if_block.d(detaching);
          if (detaching) detach_dev(if_block_anchor);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_1$2.name,
        type: "if",
        source: "(76:8) {#if comentarioId || hiloId}",
        ctx
      });
      return block;
    } // (77:12) <Checkbox                  style="padding: 0 8px"                  bind:checked={eliminarElemento}                  right              >


    function create_default_slot_3$2(ctx) {
      let t;
      const block = {
        c: function create() {
          t = text("Eliminar elemento(hilo/comentario)");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_3$2.name,
        type: "slot",
        source: "(77:12) <Checkbox                  style=\\\"padding: 0 8px\\\"                  bind:checked={eliminarElemento}                  right              >",
        ctx
      });
      return block;
    } // (84:12) {#if $globalStore.usuario.esMod}


    function create_if_block_2$2(ctx) {
      let checkbox;
      let updating_checked;
      let current;

      function checkbox_checked_binding_1(value) {
        /*checkbox_checked_binding_1*/
        ctx[17].call(null, value);
      }

      let checkbox_props = {
        style: "padding: 0 8px",
        title: "Borra la imagen del servidor, usar en caso de cp",
        right: true,
        $$slots: {
          default: [create_default_slot_2$2]
        },
        $$scope: {
          ctx
        }
      };

      if (
      /*eliminarAdjunto*/
      ctx[8] !== void 0) {
        checkbox_props.checked =
        /*eliminarAdjunto*/
        ctx[8];
      }

      checkbox = new Ne({
        props: checkbox_props,
        $$inline: true
      });
      binding_callbacks.push(() => bind(checkbox, "checked", checkbox_checked_binding_1));
      const block = {
        c: function create() {
          create_component(checkbox.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(checkbox, target, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          const checkbox_changes = {};

          if (dirty &
          /*$$scope*/
          1048576) {
            checkbox_changes.$$scope = {
              dirty,
              ctx
            };
          }

          if (!updating_checked && dirty &
          /*eliminarAdjunto*/
          256) {
            updating_checked = true;
            checkbox_changes.checked =
            /*eliminarAdjunto*/
            ctx[8];
            add_flush_callback(() => updating_checked = false);
          }

          checkbox.$set(checkbox_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(checkbox.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(checkbox.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(checkbox, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_2$2.name,
        type: "if",
        source: "(84:12) {#if $globalStore.usuario.esMod}",
        ctx
      });
      return block;
    } // (85:16) <Checkbox                      style="padding: 0 8px"                      title="Borra la imagen del servidor, usar en caso de cp"                      bind:checked={eliminarAdjunto}                      right                  >


    function create_default_slot_2$2(ctx) {
      let t;
      const block = {
        c: function create() {
          t = text("Eliminar adjunto(imagen/video)");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_2$2.name,
        type: "slot",
        source: "(85:16) <Checkbox                      style=\\\"padding: 0 8px\\\"                      title=\\\"Borra la imagen del servidor, usar en caso de cp\\\"                      bind:checked={eliminarAdjunto}                      right                  >",
        ctx
      });
      return block;
    } // (103:8) {#if duracion > 5000}


    function create_if_block$5(ctx) {
      let checkbox;
      let updating_checked;
      let current;

      function checkbox_checked_binding_2(value) {
        /*checkbox_checked_binding_2*/
        ctx[18].call(null, value);
      }

      let checkbox_props = {
        style: "padding: 0 8px",
        title: "Borra todos los rozes y comentarios del usuario",
        right: true,
        $$slots: {
          default: [create_default_slot_1$2]
        },
        $$scope: {
          ctx
        }
      };

      if (
      /*desaparecer*/
      ctx[9] !== void 0) {
        checkbox_props.checked =
        /*desaparecer*/
        ctx[9];
      }

      checkbox = new Ne({
        props: checkbox_props,
        $$inline: true
      });
      binding_callbacks.push(() => bind(checkbox, "checked", checkbox_checked_binding_2));
      const block = {
        c: function create() {
          create_component(checkbox.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(checkbox, target, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          const checkbox_changes = {};

          if (dirty &
          /*$$scope*/
          1048576) {
            checkbox_changes.$$scope = {
              dirty,
              ctx
            };
          }

          if (!updating_checked && dirty &
          /*desaparecer*/
          512) {
            updating_checked = true;
            checkbox_changes.checked =
            /*desaparecer*/
            ctx[9];
            add_flush_callback(() => updating_checked = false);
          }

          checkbox.$set(checkbox_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(checkbox.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(checkbox.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(checkbox, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block$5.name,
        type: "if",
        source: "(103:8) {#if duracion > 5000}",
        ctx
      });
      return block;
    } // (104:12) <Checkbox                  style="padding: 0 8px"                  title="Borra todos los rozes y comentarios del usuario"                  bind:checked={desaparecer}                  right              >


    function create_default_slot_1$2(ctx) {
      let t;
      const block = {
        c: function create() {
          t = text("Desaparecer");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_1$2.name,
        type: "slot",
        source: "(104:12) <Checkbox                  style=\\\"padding: 0 8px\\\"                  title=\\\"Borra todos los rozes y comentarios del usuario\\\"                  bind:checked={desaparecer}                  right              >",
        ctx
      });
      return block;
    } // (41:4) <div slot="body">


    function create_body_slot$1(ctx) {
      let div0;
      let div1;
      let t0;
      let select0;
      let option0;
      let t2;
      let textarea;
      let t3;
      let select1;
      let option1;
      let option2;
      let option3;
      let option4;
      let option5;
      let option6;
      let option7;
      let option8;
      let option9;
      let option10;
      let option11;
      let option12;
      let t16;
      let t17;
      let current;
      let mounted;
      let dispose;
      let if_block0 =
      /*hiloId*/
      ctx[1] && create_if_block_3$1(ctx);
      let each_value = Object.keys(MotivoDenuncia);
      validate_each_argument(each_value);
      let each_blocks = [];

      for (let i = 0; i < each_value.length; i += 1) {
        each_blocks[i] = create_each_block$2(get_each_context$2(ctx, each_value, i));
      }

      let if_block1 = (
      /*comentarioId*/
      ctx[2] ||
      /*hiloId*/
      ctx[1]) && create_if_block_1$2(ctx);
      let if_block2 =
      /*duracion*/
      ctx[5] > 5000 && create_if_block$5(ctx);
      const block = {
        c: function create() {
          div0 = element("div");
          div1 = element("div");
          if (if_block0) if_block0.c();
          t0 = space();
          select0 = element("select");
          option0 = element("option");
          option0.textContent = "Motivo";

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].c();
          }

          t2 = space();
          textarea = element("textarea");
          t3 = space();
          select1 = element("select");
          option1 = element("option");
          option1.textContent = "Duracion";
          option2 = element("option");
          option2.textContent = "0 min (Advertencia)";
          option3 = element("option");
          option3.textContent = "5 min";
          option4 = element("option");
          option4.textContent = "10 min";
          option5 = element("option");
          option5.textContent = "30 min";
          option6 = element("option");
          option6.textContent = "1 hora";
          option7 = element("option");
          option7.textContent = "6 horas";
          option8 = element("option");
          option8.textContent = "1 dia";
          option9 = element("option");
          option9.textContent = "3 dia";
          option10 = element("option");
          option10.textContent = "1 semana";
          option11 = element("option");
          option11.textContent = "1 mes";
          option12 = element("option");
          option12.textContent = "Permanente";
          t16 = space();
          if (if_block1) if_block1.c();
          t17 = space();
          if (if_block2) if_block2.c();
          attr_dev(div1, "class", "");
          add_location(div1, file$6, 41, 8, 1111);
          option0.__value = "-1";
          option0.value = option0.__value;
          option0.selected = "selected";
          option0.disabled = "disabled";
          add_location(option0, file$6, 48, 12, 1344);
          attr_dev(select0, "name", "motivo");
          if (
          /*motivo*/
          ctx[4] === void 0) add_render_callback(() =>
          /*select0_change_handler*/
          ctx[13].call(select0));
          add_location(select0, file$6, 47, 8, 1288);
          attr_dev(textarea, "placeholder", "Aclaracion, mensaje");
          add_location(textarea, file$6, 56, 8, 1623);
          option1.__value = "-1";
          option1.value = option1.__value;
          option1.selected = "selected";
          option1.disabled = "disabled";
          add_location(option1, file$6, 59, 12, 1765);
          option2.__value = "0";
          option2.value = option2.__value;
          add_location(option2, file$6, 62, 12, 1887);
          option3.__value = "5";
          option3.value = option3.__value;
          add_location(option3, file$6, 63, 12, 1947);
          option4.__value = "10";
          option4.value = option4.__value;
          add_location(option4, file$6, 64, 12, 1993);
          option5.__value = "30";
          option5.value = option5.__value;
          add_location(option5, file$6, 65, 12, 2041);
          option6.__value = "60";
          option6.value = option6.__value;
          add_location(option6, file$6, 66, 12, 2089);
          option7.__value = "360";
          option7.value = option7.__value;
          add_location(option7, file$6, 67, 12, 2137);
          option8.__value = "1440";
          option8.value = option8.__value;
          add_location(option8, file$6, 68, 12, 2187);
          option9.__value = "4320";
          option9.value = option9.__value;
          add_location(option9, file$6, 69, 12, 2236);
          option10.__value = "10080";
          option10.value = option10.__value;
          add_location(option10, file$6, 70, 12, 2285);
          option11.__value = "40320";
          option11.value = option11.__value;
          add_location(option11, file$6, 71, 12, 2338);
          option12.__value = "99999999";
          option12.value = option12.__value;
          add_location(option12, file$6, 72, 12, 2388);
          attr_dev(select1, "name", "duracion");
          if (
          /*duracion*/
          ctx[5] === void 0) add_render_callback(() =>
          /*select1_change_handler*/
          ctx[15].call(select1));
          add_location(select1, file$6, 58, 8, 1705);
          attr_dev(div0, "slot", "body");
          add_location(div0, file$6, 40, 4, 1084);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div0, anchor);
          append_dev(div0, div1);
          if (if_block0) if_block0.m(div1, null);
          append_dev(div0, t0);
          append_dev(div0, select0);
          append_dev(select0, option0);

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].m(select0, null);
          }

          select_option(select0,
          /*motivo*/
          ctx[4]);
          append_dev(div0, t2);
          append_dev(div0, textarea);
          set_input_value(textarea,
          /*aclaracion*/
          ctx[6]);
          append_dev(div0, t3);
          append_dev(div0, select1);
          append_dev(select1, option1);
          append_dev(select1, option2);
          append_dev(select1, option3);
          append_dev(select1, option4);
          append_dev(select1, option5);
          append_dev(select1, option6);
          append_dev(select1, option7);
          append_dev(select1, option8);
          append_dev(select1, option9);
          append_dev(select1, option10);
          append_dev(select1, option11);
          append_dev(select1, option12);
          select_option(select1,
          /*duracion*/
          ctx[5]);
          append_dev(div0, t16);
          if (if_block1) if_block1.m(div0, null);
          append_dev(div0, t17);
          if (if_block2) if_block2.m(div0, null);
          current = true;

          if (!mounted) {
            dispose = [listen_dev(select0, "change",
            /*select0_change_handler*/
            ctx[13]), listen_dev(textarea, "input",
            /*textarea_input_handler*/
            ctx[14]), listen_dev(select1, "change",
            /*select1_change_handler*/
            ctx[15])];
            mounted = true;
          }
        },
        p: function update(ctx, dirty) {
          if (
          /*hiloId*/
          ctx[1]) {
            if (if_block0) {
              if_block0.p(ctx, dirty);
            } else {
              if_block0 = create_if_block_3$1(ctx);
              if_block0.c();
              if_block0.m(div1, null);
            }
          } else if (if_block0) {
            if_block0.d(1);
            if_block0 = null;
          }

          if (dirty &
          /*MotivoDenuncia, Object*/
          0) {
            each_value = Object.keys(MotivoDenuncia);
            validate_each_argument(each_value);
            let i;

            for (i = 0; i < each_value.length; i += 1) {
              const child_ctx = get_each_context$2(ctx, each_value, i);

              if (each_blocks[i]) {
                each_blocks[i].p(child_ctx, dirty);
              } else {
                each_blocks[i] = create_each_block$2(child_ctx);
                each_blocks[i].c();
                each_blocks[i].m(select0, null);
              }
            }

            for (; i < each_blocks.length; i += 1) {
              each_blocks[i].d(1);
            }

            each_blocks.length = each_value.length;
          }

          if (dirty &
          /*motivo, MotivoDenuncia, Object*/
          16) {
            select_option(select0,
            /*motivo*/
            ctx[4]);
          }

          if (dirty &
          /*aclaracion*/
          64) {
            set_input_value(textarea,
            /*aclaracion*/
            ctx[6]);
          }

          if (dirty &
          /*duracion*/
          32) {
            select_option(select1,
            /*duracion*/
            ctx[5]);
          }

          if (
          /*comentarioId*/
          ctx[2] ||
          /*hiloId*/
          ctx[1]) {
            if (if_block1) {
              if_block1.p(ctx, dirty);

              if (dirty &
              /*comentarioId, hiloId*/
              6) {
                transition_in(if_block1, 1);
              }
            } else {
              if_block1 = create_if_block_1$2(ctx);
              if_block1.c();
              transition_in(if_block1, 1);
              if_block1.m(div0, t17);
            }
          } else if (if_block1) {
            group_outros();
            transition_out(if_block1, 1, 1, () => {
              if_block1 = null;
            });
            check_outros();
          }

          if (
          /*duracion*/
          ctx[5] > 5000) {
            if (if_block2) {
              if_block2.p(ctx, dirty);

              if (dirty &
              /*duracion*/
              32) {
                transition_in(if_block2, 1);
              }
            } else {
              if_block2 = create_if_block$5(ctx);
              if_block2.c();
              transition_in(if_block2, 1);
              if_block2.m(div0, null);
            }
          } else if (if_block2) {
            group_outros();
            transition_out(if_block2, 1, 1, () => {
              if_block2 = null;
            });
            check_outros();
          }
        },
        i: function intro(local) {
          if (current) return;
          transition_in(if_block1);
          transition_in(if_block2);
          current = true;
        },
        o: function outro(local) {
          transition_out(if_block1);
          transition_out(if_block2);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div0);
          if (if_block0) if_block0.d();
          destroy_each(each_blocks, detaching);
          if (if_block1) if_block1.d();
          if (if_block2) if_block2.d();
          mounted = false;
          run_all(dispose);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_body_slot$1.name,
        type: "slot",
        source: "(41:4) <div slot=\\\"body\\\">",
        ctx
      });
      return block;
    } // (39:0) <Dialogo bind:visible textoActivador="Banear" titulo="Banear" accion={banear}>


    function create_default_slot$3(ctx) {
      let t;
      const block = {
        c: function create() {
          t = space();
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        p: noop,
        i: noop,
        o: noop,
        d: function destroy(detaching) {
          if (detaching) detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot$3.name,
        type: "slot",
        source: "(39:0) <Dialogo bind:visible textoActivador=\\\"Banear\\\" titulo=\\\"Banear\\\" accion={banear}>",
        ctx
      });
      return block;
    }

    function create_fragment$6(ctx) {
      let dialogo;
      let updating_visible;
      let current;

      function dialogo_visible_binding(value) {
        /*dialogo_visible_binding*/
        ctx[19].call(null, value);
      }

      let dialogo_props = {
        textoActivador: "Banear",
        titulo: "Banear",
        accion:
        /*banear*/
        ctx[11],
        $$slots: {
          default: [create_default_slot$3],
          body: [create_body_slot$1],
          activador: [create_activador_slot$1]
        },
        $$scope: {
          ctx
        }
      };

      if (
      /*visible*/
      ctx[0] !== void 0) {
        dialogo_props.visible =
        /*visible*/
        ctx[0];
      }

      dialogo = new Dialogo({
        props: dialogo_props,
        $$inline: true
      });
      binding_callbacks.push(() => bind(dialogo, "visible", dialogo_visible_binding));
      const block = {
        c: function create() {
          create_component(dialogo.$$.fragment);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          mount_component(dialogo, target, anchor);
          current = true;
        },
        p: function update(ctx, [dirty]) {
          const dialogo_changes = {};

          if (dirty &
          /*$$scope, desaparecer, duracion, eliminarAdjunto, $globalStore, eliminarElemento, comentarioId, hiloId, aclaracion, motivo, usuarioId*/
          1050622) {
            dialogo_changes.$$scope = {
              dirty,
              ctx
            };
          }

          if (!updating_visible && dirty &
          /*visible*/
          1) {
            updating_visible = true;
            dialogo_changes.visible =
            /*visible*/
            ctx[0];
            add_flush_callback(() => updating_visible = false);
          }

          dialogo.$set(dialogo_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(dialogo.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(dialogo.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(dialogo, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$6.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }

    function instance$6($$self, $$props, $$invalidate) {
      let $globalStore;
      validate_store(globalStore, "globalStore");
      component_subscribe($$self, globalStore, $$value => $$invalidate(10, $globalStore = $$value));
      let {
        $$slots: slots = {},
        $$scope
      } = $$props;
      validate_slots("DialogoBan", slots, ['default']);
      let motivo;
      let duracion;
      let aclaracion;
      let eliminarElemento = false;
      let eliminarAdjunto = false;
      let eliminarAudio = false;
      let desaparecer = false;
      let {
        hiloId
      } = $$props;
      let {
        comentarioId
      } = $$props;
      let {
        usuarioId
      } = $$props;
      let {
        visible = false
      } = $$props;

      function banear() {
        return RChanClient.banear(motivo, aclaracion, duracion, usuarioId, hiloId, comentarioId, eliminarElemento, eliminarAdjunto, eliminarAudio, desaparecer);
      }

      const writable_props = ["hiloId", "comentarioId", "usuarioId", "visible"];
      Object_1$2.keys($$props).forEach(key => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<DialogoBan> was created with unknown prop '${key}'`);
      });

      function select0_change_handler() {
        motivo = select_value(this);
        $$invalidate(4, motivo);
      }

      function textarea_input_handler() {
        aclaracion = this.value;
        $$invalidate(6, aclaracion);
      }

      function select1_change_handler() {
        duracion = select_value(this);
        $$invalidate(5, duracion);
      }

      function checkbox_checked_binding(value) {
        eliminarElemento = value;
        $$invalidate(7, eliminarElemento);
      }

      function checkbox_checked_binding_1(value) {
        eliminarAdjunto = value;
        $$invalidate(8, eliminarAdjunto);
      }

      function checkbox_checked_binding_2(value) {
        desaparecer = value;
        $$invalidate(9, desaparecer);
      }

      function dialogo_visible_binding(value) {
        visible = value;
        $$invalidate(0, visible);
      }

      $$self.$$set = $$props => {
        if ("hiloId" in $$props) $$invalidate(1, hiloId = $$props.hiloId);
        if ("comentarioId" in $$props) $$invalidate(2, comentarioId = $$props.comentarioId);
        if ("usuarioId" in $$props) $$invalidate(3, usuarioId = $$props.usuarioId);
        if ("visible" in $$props) $$invalidate(0, visible = $$props.visible);
        if ("$$scope" in $$props) $$invalidate(20, $$scope = $$props.$$scope);
      };

      $$self.$capture_state = () => ({
        RChanClient,
        MotivoDenuncia,
        Dialogo,
        Checkbox: Ne,
        globalStore,
        motivo,
        duracion,
        aclaracion,
        eliminarElemento,
        eliminarAdjunto,
        eliminarAudio,
        desaparecer,
        hiloId,
        comentarioId,
        usuarioId,
        visible,
        banear,
        tipo,
        $globalStore
      });

      $$self.$inject_state = $$props => {
        if ("motivo" in $$props) $$invalidate(4, motivo = $$props.motivo);
        if ("duracion" in $$props) $$invalidate(5, duracion = $$props.duracion);
        if ("aclaracion" in $$props) $$invalidate(6, aclaracion = $$props.aclaracion);
        if ("eliminarElemento" in $$props) $$invalidate(7, eliminarElemento = $$props.eliminarElemento);
        if ("eliminarAdjunto" in $$props) $$invalidate(8, eliminarAdjunto = $$props.eliminarAdjunto);
        if ("eliminarAudio" in $$props) eliminarAudio = $$props.eliminarAudio;
        if ("desaparecer" in $$props) $$invalidate(9, desaparecer = $$props.desaparecer);
        if ("hiloId" in $$props) $$invalidate(1, hiloId = $$props.hiloId);
        if ("comentarioId" in $$props) $$invalidate(2, comentarioId = $$props.comentarioId);
        if ("usuarioId" in $$props) $$invalidate(3, usuarioId = $$props.usuarioId);
        if ("visible" in $$props) $$invalidate(0, visible = $$props.visible);
        if ("tipo" in $$props) tipo = $$props.tipo;
      };

      let tipo;

      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }

      $$self.$$.update = () => {
        if ($$self.$$.dirty &
        /*comentarioId*/
        4) {
           tipo = comentarioId == "" || !comentarioId ? 0 : 1;
        }
      };

      return [visible, hiloId, comentarioId, usuarioId, motivo, duracion, aclaracion, eliminarElemento, eliminarAdjunto, desaparecer, $globalStore, banear, slots, select0_change_handler, textarea_input_handler, select1_change_handler, checkbox_checked_binding, checkbox_checked_binding_1, checkbox_checked_binding_2, dialogo_visible_binding, $$scope];
    }

    class DialogoBan extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$6, create_fragment$6, safe_not_equal, {
          hiloId: 1,
          comentarioId: 2,
          usuarioId: 3,
          visible: 0
        });
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "DialogoBan",
          options,
          id: create_fragment$6.name
        });
        const {
          ctx
        } = this.$$;
        const props = options.props || {};

        if (
        /*hiloId*/
        ctx[1] === undefined && !("hiloId" in props)) {
          console.warn("<DialogoBan> was created without expected prop 'hiloId'");
        }

        if (
        /*comentarioId*/
        ctx[2] === undefined && !("comentarioId" in props)) {
          console.warn("<DialogoBan> was created without expected prop 'comentarioId'");
        }

        if (
        /*usuarioId*/
        ctx[3] === undefined && !("usuarioId" in props)) {
          console.warn("<DialogoBan> was created without expected prop 'usuarioId'");
        }
      }

      get hiloId() {
        throw new Error("<DialogoBan>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set hiloId(value) {
        throw new Error("<DialogoBan>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get comentarioId() {
        throw new Error("<DialogoBan>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set comentarioId(value) {
        throw new Error("<DialogoBan>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get usuarioId() {
        throw new Error("<DialogoBan>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set usuarioId(value) {
        throw new Error("<DialogoBan>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get visible() {
        throw new Error("<DialogoBan>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set visible(value) {
        throw new Error("<DialogoBan>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

    }

    /* src\components\Dialogos\Dialogos.svelte generated by Svelte v3.29.0 */
    const file$7 = "src\\components\\Dialogos\\Dialogos.svelte";

    function get_each_context_1$2(ctx, list, i) {
      const child_ctx = ctx.slice();
      child_ctx[16] = list[i];
      return child_ctx;
    }

    function get_each_context$3(ctx, list, i) {
      const child_ctx = ctx.slice();
      child_ctx[13] = list[i];
      return child_ctx;
    } // (104:0) {#if $dialogosStore.dialogoAbierto == "sticky"}


    function create_if_block_2$3(ctx) {
      let h1;
      const block = {
        c: function create() {
          h1 = element("h1");
          h1.textContent = "sticky";
          add_location(h1, file$7, 104, 4, 3383);
        },
        m: function mount(target, anchor) {
          insert_dev(target, h1, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(h1);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_2$3.name,
        type: "if",
        source: "(104:0) {#if $dialogosStore.dialogoAbierto == \\\"sticky\\\"}",
        ctx
      });
      return block;
    } // (124:4) <span slot="activador" />


    function create_activador_slot_5(ctx) {
      let span;
      const block = {
        c: function create() {
          span = element("span");
          attr_dev(span, "slot", "activador");
          add_location(span, file$7, 123, 4, 3898);
        },
        m: function mount(target, anchor) {
          insert_dev(target, span, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(span);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_activador_slot_5.name,
        type: "slot",
        source: "(124:4) <span slot=\\\"activador\\\" />",
        ctx
      });
      return block;
    } // (127:8) {#if $globalStore.usuario.esMod}


    function create_if_block_1$3(ctx) {
      let checkbox;
      let updating_checked;
      let current;

      function checkbox_checked_binding(value) {
        /*checkbox_checked_binding*/
        ctx[2].call(null, value);
      }

      let checkbox_props = {
        right: true,
        $$slots: {
          default: [create_default_slot_9$1]
        },
        $$scope: {
          ctx
        }
      };

      if (
      /*$dialogosStore*/
      ctx[0].eliminarMedia !== void 0) {
        checkbox_props.checked =
        /*$dialogosStore*/
        ctx[0].eliminarMedia;
      }

      checkbox = new Ne({
        props: checkbox_props,
        $$inline: true
      });
      binding_callbacks.push(() => bind(checkbox, "checked", checkbox_checked_binding));
      const block = {
        c: function create() {
          create_component(checkbox.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(checkbox, target, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          const checkbox_changes = {};

          if (dirty &
          /*$$scope*/
          524288) {
            checkbox_changes.$$scope = {
              dirty,
              ctx
            };
          }

          if (!updating_checked && dirty &
          /*$dialogosStore*/
          1) {
            updating_checked = true;
            checkbox_changes.checked =
            /*$dialogosStore*/
            ctx[0].eliminarMedia;
            add_flush_callback(() => updating_checked = false);
          }

          checkbox.$set(checkbox_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(checkbox.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(checkbox.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(checkbox, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_1$3.name,
        type: "if",
        source: "(127:8) {#if $globalStore.usuario.esMod}",
        ctx
      });
      return block;
    } // (128:12) <Checkbox bind:checked={$dialogosStore.eliminarMedia} right                  >


    function create_default_slot_9$1(ctx) {
      let t;
      const block = {
        c: function create() {
          t = text("Eliminar Archivos");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_9$1.name,
        type: "slot",
        source: "(128:12) <Checkbox bind:checked={$dialogosStore.eliminarMedia} right                  >",
        ctx
      });
      return block;
    } // (125:4) <div slot="body">


    function create_body_slot_5(ctx) {
      let div;
      let t;
      let current;
      let if_block =
      /*$globalStore*/
      ctx[1].usuario.esMod && create_if_block_1$3(ctx);
      const block = {
        c: function create() {
          div = element("div");
          t = text("¿Estas seguro de que queres domar el roz?\r\n        ");
          if (if_block) if_block.c();
          attr_dev(div, "slot", "body");
          add_location(div, file$7, 124, 4, 3929);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          append_dev(div, t);
          if (if_block) if_block.m(div, null);
          current = true;
        },
        p: function update(ctx, dirty) {
          if (
          /*$globalStore*/
          ctx[1].usuario.esMod) {
            if (if_block) {
              if_block.p(ctx, dirty);

              if (dirty &
              /*$globalStore*/
              2) {
                transition_in(if_block, 1);
              }
            } else {
              if_block = create_if_block_1$3(ctx);
              if_block.c();
              transition_in(if_block, 1);
              if_block.m(div, null);
            }
          } else if (if_block) {
            group_outros();
            transition_out(if_block, 1, 1, () => {
              if_block = null;
            });
            check_outros();
          }
        },
        i: function intro(local) {
          if (current) return;
          transition_in(if_block);
          current = true;
        },
        o: function outro(local) {
          transition_out(if_block);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
          if (if_block) if_block.d();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_body_slot_5.name,
        type: "slot",
        source: "(125:4) <div slot=\\\"body\\\">",
        ctx
      });
      return block;
    } // (113:0) <Dialogo      visible={$dialogosStore.dialogoAbierto == "eliminarHilo"}      textoActivador="Eliminar"      titulo="Eliminar roz"      accion={() =>          RChanClient.borrarHilos(              [$dialogosStore.hiloId],              $dialogosStore.eliminarMedia,              $dialogosStore.eliminarAudio          )}  >


    function create_default_slot_8$1(ctx) {
      let t;
      const block = {
        c: function create() {
          t = space();
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        p: noop,
        i: noop,
        o: noop,
        d: function destroy(detaching) {
          if (detaching) detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_8$1.name,
        type: "slot",
        source: "(113:0) <Dialogo      visible={$dialogosStore.dialogoAbierto == \\\"eliminarHilo\\\"}      textoActivador=\\\"Eliminar\\\"      titulo=\\\"Eliminar roz\\\"      accion={() =>          RChanClient.borrarHilos(              [$dialogosStore.hiloId],              $dialogosStore.eliminarMedia,              $dialogosStore.eliminarAudio          )}  >",
        ctx
      });
      return block;
    } // (144:4) <span slot="activador" />


    function create_activador_slot_4(ctx) {
      let span;
      const block = {
        c: function create() {
          span = element("span");
          attr_dev(span, "slot", "activador");
          add_location(span, file$7, 143, 4, 4566);
        },
        m: function mount(target, anchor) {
          insert_dev(target, span, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(span);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_activador_slot_4.name,
        type: "slot",
        source: "(144:4) <span slot=\\\"activador\\\" />",
        ctx
      });
      return block;
    } // (145:4) <div slot="body">


    function create_body_slot_4(ctx) {
      let div;
      const block = {
        c: function create() {
          div = element("div");
          div.textContent = "¿Estas seguro de que queres restaurar el roz?";
          attr_dev(div, "slot", "body");
          add_location(div, file$7, 144, 4, 4597);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_body_slot_4.name,
        type: "slot",
        source: "(145:4) <div slot=\\\"body\\\">",
        ctx
      });
      return block;
    } // (138:0) <Dialogo      visible={$dialogosStore.dialogoAbierto == "restaurarHilo"}      textoActivador="Restaurar"      titulo="Restaurar el roz"      accion={() => RChanClient.restaurarRoz($dialogosStore.hiloId)}  >


    function create_default_slot_7$1(ctx) {
      let t;
      const block = {
        c: function create() {
          t = space();
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        p: noop,
        d: function destroy(detaching) {
          if (detaching) detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_7$1.name,
        type: "slot",
        source: "(138:0) <Dialogo      visible={$dialogosStore.dialogoAbierto == \\\"restaurarHilo\\\"}      textoActivador=\\\"Restaurar\\\"      titulo=\\\"Restaurar el roz\\\"      accion={() => RChanClient.restaurarRoz($dialogosStore.hiloId)}  >",
        ctx
      });
      return block;
    } // (153:4) <span slot="activador" />


    function create_activador_slot_3(ctx) {
      let span;
      const block = {
        c: function create() {
          span = element("span");
          attr_dev(span, "slot", "activador");
          add_location(span, file$7, 152, 4, 4917);
        },
        m: function mount(target, anchor) {
          insert_dev(target, span, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(span);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_activador_slot_3.name,
        type: "slot",
        source: "(153:4) <span slot=\\\"activador\\\" />",
        ctx
      });
      return block;
    } // (154:4) <div slot="body">


    function create_body_slot_3(ctx) {
      let div;
      let t0;
      let t1_value =
      /*$dialogosStore*/
      ctx[0].comentarioId + "";
      let t1;
      let t2;
      const block = {
        c: function create() {
          div = element("div");
          t0 = text("¿Estas seguro de que queres restaurar el comentario ");
          t1 = text(t1_value);
          t2 = text("?");
          attr_dev(div, "slot", "body");
          add_location(div, file$7, 153, 4, 4948);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          append_dev(div, t0);
          append_dev(div, t1);
          append_dev(div, t2);
        },
        p: function update(ctx, dirty) {
          if (dirty &
          /*$dialogosStore*/
          1 && t1_value !== (t1_value =
          /*$dialogosStore*/
          ctx[0].comentarioId + "")) set_data_dev(t1, t1_value);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_body_slot_3.name,
        type: "slot",
        source: "(154:4) <div slot=\\\"body\\\">",
        ctx
      });
      return block;
    } // (147:0) <Dialogo      visible={$dialogosStore.dialogoAbierto == "restaurarComentario"}      textoActivador="Restaurar"      titulo="Restaurar el comentario"      accion={() => RChanClient.restaurarComentario($dialogosStore.comentarioId)}  >


    function create_default_slot_6$1(ctx) {
      let t;
      const block = {
        c: function create() {
          t = space();
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        p: noop,
        d: function destroy(detaching) {
          if (detaching) detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_6$1.name,
        type: "slot",
        source: "(147:0) <Dialogo      visible={$dialogosStore.dialogoAbierto == \\\"restaurarComentario\\\"}      textoActivador=\\\"Restaurar\\\"      titulo=\\\"Restaurar el comentario\\\"      accion={() => RChanClient.restaurarComentario($dialogosStore.comentarioId)}  >",
        ctx
      });
      return block;
    } // (170:4) <span slot="activador" />


    function create_activador_slot_2(ctx) {
      let span;
      const block = {
        c: function create() {
          span = element("span");
          attr_dev(span, "slot", "activador");
          add_location(span, file$7, 169, 4, 5439);
        },
        m: function mount(target, anchor) {
          insert_dev(target, span, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(span);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_activador_slot_2.name,
        type: "slot",
        source: "(170:4) <span slot=\\\"activador\\\" />",
        ctx
      });
      return block;
    } // (173:8) {#if $globalStore.usuario.esMod}


    function create_if_block$6(ctx) {
      let checkbox;
      let updating_checked;
      let current;

      function checkbox_checked_binding_1(value) {
        /*checkbox_checked_binding_1*/
        ctx[6].call(null, value);
      }

      let checkbox_props = {
        right: true,
        $$slots: {
          default: [create_default_slot_5$1]
        },
        $$scope: {
          ctx
        }
      };

      if (
      /*$dialogosStore*/
      ctx[0].eliminarMedia !== void 0) {
        checkbox_props.checked =
        /*$dialogosStore*/
        ctx[0].eliminarMedia;
      }

      checkbox = new Ne({
        props: checkbox_props,
        $$inline: true
      });
      binding_callbacks.push(() => bind(checkbox, "checked", checkbox_checked_binding_1));
      const block = {
        c: function create() {
          create_component(checkbox.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(checkbox, target, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          const checkbox_changes = {};

          if (dirty &
          /*$$scope*/
          524288) {
            checkbox_changes.$$scope = {
              dirty,
              ctx
            };
          }

          if (!updating_checked && dirty &
          /*$dialogosStore*/
          1) {
            updating_checked = true;
            checkbox_changes.checked =
            /*$dialogosStore*/
            ctx[0].eliminarMedia;
            add_flush_callback(() => updating_checked = false);
          }

          checkbox.$set(checkbox_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(checkbox.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(checkbox.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(checkbox, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block$6.name,
        type: "if",
        source: "(173:8) {#if $globalStore.usuario.esMod}",
        ctx
      });
      return block;
    } // (174:12) <Checkbox bind:checked={$dialogosStore.eliminarMedia} right                  >


    function create_default_slot_5$1(ctx) {
      let t;
      const block = {
        c: function create() {
          t = text("Eliminar Archivos");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_5$1.name,
        type: "slot",
        source: "(174:12) <Checkbox bind:checked={$dialogosStore.eliminarMedia} right                  >",
        ctx
      });
      return block;
    } // (171:4) <div slot="body">


    function create_body_slot_2(ctx) {
      let div;
      let t0;
      let t1_value =
      /*$dialogosStore*/
      ctx[0].comentariosIds + "";
      let t1;
      let t2;
      let current;
      let if_block =
      /*$globalStore*/
      ctx[1].usuario.esMod && create_if_block$6(ctx);
      const block = {
        c: function create() {
          div = element("div");
          t0 = text("¿Estas seguro de que queres borrar los comentarios ");
          t1 = text(t1_value);
          t2 = space();
          if (if_block) if_block.c();
          attr_dev(div, "slot", "body");
          add_location(div, file$7, 170, 4, 5470);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          append_dev(div, t0);
          append_dev(div, t1);
          append_dev(div, t2);
          if (if_block) if_block.m(div, null);
          current = true;
        },
        p: function update(ctx, dirty) {
          if ((!current || dirty &
          /*$dialogosStore*/
          1) && t1_value !== (t1_value =
          /*$dialogosStore*/
          ctx[0].comentariosIds + "")) set_data_dev(t1, t1_value);

          if (
          /*$globalStore*/
          ctx[1].usuario.esMod) {
            if (if_block) {
              if_block.p(ctx, dirty);

              if (dirty &
              /*$globalStore*/
              2) {
                transition_in(if_block, 1);
              }
            } else {
              if_block = create_if_block$6(ctx);
              if_block.c();
              transition_in(if_block, 1);
              if_block.m(div, null);
            }
          } else if (if_block) {
            group_outros();
            transition_out(if_block, 1, 1, () => {
              if_block = null;
            });
            check_outros();
          }
        },
        i: function intro(local) {
          if (current) return;
          transition_in(if_block);
          current = true;
        },
        o: function outro(local) {
          transition_out(if_block);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
          if (if_block) if_block.d();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_body_slot_2.name,
        type: "slot",
        source: "(171:4) <div slot=\\\"body\\\">",
        ctx
      });
      return block;
    } // (159:0) <Dialogo      visible={$dialogosStore.dialogoAbierto == "eliminarComentarios"}      textoActivador="Eliminar"      titulo="Eliminar comentario"      accion={() =>          RChanClient.eliminarComentarios(              $dialogosStore.comentariosIds,              $dialogosStore.eliminarMedia,              $dialogosStore.eliminarAudio          )}  >


    function create_default_slot_4$1(ctx) {
      let t;
      const block = {
        c: function create() {
          t = space();
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        p: noop,
        i: noop,
        o: noop,
        d: function destroy(detaching) {
          if (detaching) detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_4$1.name,
        type: "slot",
        source: "(159:0) <Dialogo      visible={$dialogosStore.dialogoAbierto == \\\"eliminarComentarios\\\"}      textoActivador=\\\"Eliminar\\\"      titulo=\\\"Eliminar comentario\\\"      accion={() =>          RChanClient.eliminarComentarios(              $dialogosStore.comentariosIds,              $dialogosStore.eliminarMedia,              $dialogosStore.eliminarAudio          )}  >",
        ctx
      });
      return block;
    } // (197:4) <span slot="activador" />


    function create_activador_slot_1(ctx) {
      let span;
      const block = {
        c: function create() {
          span = element("span");
          attr_dev(span, "slot", "activador");
          add_location(span, file$7, 196, 4, 6356);
        },
        m: function mount(target, anchor) {
          insert_dev(target, span, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(span);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_activador_slot_1.name,
        type: "slot",
        source: "(197:4) <span slot=\\\"activador\\\" />",
        ctx
      });
      return block;
    } // (199:8) <Checkbox bind:checked={$dialogosStore.mediaEliminarDependientes} right              >


    function create_default_slot_3$3(ctx) {
      let t;
      const block = {
        c: function create() {
          t = text("Eliminar todos los elementos con este archivo?");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_3$3.name,
        type: "slot",
        source: "(199:8) <Checkbox bind:checked={$dialogosStore.mediaEliminarDependientes} right              >",
        ctx
      });
      return block;
    } // (198:4) <div slot="body">


    function create_body_slot_1(ctx) {
      let div;
      let checkbox;
      let updating_checked;
      let current;

      function checkbox_checked_binding_2(value) {
        /*checkbox_checked_binding_2*/
        ctx[8].call(null, value);
      }

      let checkbox_props = {
        right: true,
        $$slots: {
          default: [create_default_slot_3$3]
        },
        $$scope: {
          ctx
        }
      };

      if (
      /*$dialogosStore*/
      ctx[0].mediaEliminarDependientes !== void 0) {
        checkbox_props.checked =
        /*$dialogosStore*/
        ctx[0].mediaEliminarDependientes;
      }

      checkbox = new Ne({
        props: checkbox_props,
        $$inline: true
      });
      binding_callbacks.push(() => bind(checkbox, "checked", checkbox_checked_binding_2));
      const block = {
        c: function create() {
          div = element("div");
          create_component(checkbox.$$.fragment);
          attr_dev(div, "slot", "body");
          add_location(div, file$7, 197, 4, 6387);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          mount_component(checkbox, div, null);
          current = true;
        },
        p: function update(ctx, dirty) {
          const checkbox_changes = {};

          if (dirty &
          /*$$scope*/
          524288) {
            checkbox_changes.$$scope = {
              dirty,
              ctx
            };
          }

          if (!updating_checked && dirty &
          /*$dialogosStore*/
          1) {
            updating_checked = true;
            checkbox_changes.checked =
            /*$dialogosStore*/
            ctx[0].mediaEliminarDependientes;
            add_flush_callback(() => updating_checked = false);
          }

          checkbox.$set(checkbox_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(checkbox.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(checkbox.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
          destroy_component(checkbox);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_body_slot_1.name,
        type: "slot",
        source: "(198:4) <div slot=\\\"body\\\">",
        ctx
      });
      return block;
    } // (191:0) <Dialogo      visible={$dialogosStore.dialogoAbierto == "eliminarMedia"}      textoActivador="Eliminar"      titulo="Eliminar la imagen/video"      accion={() => RChanClient.eliminarMedia($dialogosStore.mediaId)}  >


    function create_default_slot_2$3(ctx) {
      let t;
      const block = {
        c: function create() {
          t = space();
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        p: noop,
        i: noop,
        o: noop,
        d: function destroy(detaching) {
          if (detaching) detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_2$3.name,
        type: "slot",
        source: "(191:0) <Dialogo      visible={$dialogosStore.dialogoAbierto == \\\"eliminarMedia\\\"}      textoActivador=\\\"Eliminar\\\"      titulo=\\\"Eliminar la imagen/video\\\"      accion={() => RChanClient.eliminarMedia($dialogosStore.mediaId)}  >",
        ctx
      });
      return block;
    } // (215:4) <span slot="activador" />


    function create_activador_slot$2(ctx) {
      let span;
      const block = {
        c: function create() {
          span = element("span");
          attr_dev(span, "slot", "activador");
          add_location(span, file$7, 214, 4, 6907);
        },
        m: function mount(target, anchor) {
          insert_dev(target, span, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(span);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_activador_slot$2.name,
        type: "slot",
        source: "(215:4) <span slot=\\\"activador\\\" />",
        ctx
      });
      return block;
    } // (224:20) {#each g.categorias as cid}


    function create_each_block_1$2(ctx) {
      let option;
      let t_value = config.categoriaPorId(
      /*cid*/
      ctx[16]).nombre + "";
      let t;
      let option_value_value;
      const block = {
        c: function create() {
          option = element("option");
          t = text(t_value);
          option.__value = option_value_value =
          /*cid*/
          ctx[16];
          option.value = option.__value;
          add_location(option, file$7, 224, 24, 7389);
        },
        m: function mount(target, anchor) {
          insert_dev(target, option, anchor);
          append_dev(option, t);
        },
        p: noop,
        d: function destroy(detaching) {
          if (detaching) detach_dev(option);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_each_block_1$2.name,
        type: "each",
        source: "(224:20) {#each g.categorias as cid}",
        ctx
      });
      return block;
    } // (222:12) {#each config.grupos as g}


    function create_each_block$3(ctx) {
      let optgroup;
      let optgroup_label_value;
      let each_value_1 =
      /*g*/
      ctx[13].categorias;
      validate_each_argument(each_value_1);
      let each_blocks = [];

      for (let i = 0; i < each_value_1.length; i += 1) {
        each_blocks[i] = create_each_block_1$2(get_each_context_1$2(ctx, each_value_1, i));
      }

      const block = {
        c: function create() {
          optgroup = element("optgroup");

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].c();
          }

          attr_dev(optgroup, "label", optgroup_label_value =
          /*g*/
          ctx[13].nombre);
          attr_dev(optgroup, "class", "grupo-categorias");
          add_location(optgroup, file$7, 222, 16, 7262);
        },
        m: function mount(target, anchor) {
          insert_dev(target, optgroup, anchor);

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].m(optgroup, null);
          }
        },
        p: function update(ctx, dirty) {
          if (dirty &
          /*config*/
          0) {
            each_value_1 =
            /*g*/
            ctx[13].categorias;
            validate_each_argument(each_value_1);
            let i;

            for (i = 0; i < each_value_1.length; i += 1) {
              const child_ctx = get_each_context_1$2(ctx, each_value_1, i);

              if (each_blocks[i]) {
                each_blocks[i].p(child_ctx, dirty);
              } else {
                each_blocks[i] = create_each_block_1$2(child_ctx);
                each_blocks[i].c();
                each_blocks[i].m(optgroup, null);
              }
            }

            for (; i < each_blocks.length; i += 1) {
              each_blocks[i].d(1);
            }

            each_blocks.length = each_value_1.length;
          }
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(optgroup);
          destroy_each(each_blocks, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_each_block$3.name,
        type: "each",
        source: "(222:12) {#each config.grupos as g}",
        ctx
      });
      return block;
    } // (232:8) <Checkbox bind:checked={$dialogosStore.advertenciaCategoria} right              >


    function create_default_slot_1$3(ctx) {
      let t;
      const block = {
        c: function create() {
          t = text("Advertencia");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_1$3.name,
        type: "slot",
        source: "(232:8) <Checkbox bind:checked={$dialogosStore.advertenciaCategoria} right              >",
        ctx
      });
      return block;
    } // (216:4) <div slot="body">


    function create_body_slot$2(ctx) {
      let div;
      let span;
      let t0;
      let select;
      let option;
      let t2;
      let checkbox;
      let updating_checked;
      let current;
      let mounted;
      let dispose;
      let each_value = config.grupos;
      validate_each_argument(each_value);
      let each_blocks = [];

      for (let i = 0; i < each_value.length; i += 1) {
        each_blocks[i] = create_each_block$3(get_each_context$3(ctx, each_value, i));
      }

      function checkbox_checked_binding_3(value) {
        /*checkbox_checked_binding_3*/
        ctx[11].call(null, value);
      }

      let checkbox_props = {
        right: true,
        $$slots: {
          default: [create_default_slot_1$3]
        },
        $$scope: {
          ctx
        }
      };

      if (
      /*$dialogosStore*/
      ctx[0].advertenciaCategoria !== void 0) {
        checkbox_props.checked =
        /*$dialogosStore*/
        ctx[0].advertenciaCategoria;
      }

      checkbox = new Ne({
        props: checkbox_props,
        $$inline: true
      });
      binding_callbacks.push(() => bind(checkbox, "checked", checkbox_checked_binding_3));
      const block = {
        c: function create() {
          div = element("div");
          span = element("span");
          t0 = space();
          select = element("select");
          option = element("option");
          option.textContent = "Categoría";

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].c();
          }

          t2 = space();
          create_component(checkbox.$$.fragment);
          attr_dev(span, "asp-validation-for", "CategoriaId");
          add_location(span, file$7, 216, 8, 6965);
          option.__value = "-1";
          option.value = option.__value;
          option.selected = "selected";
          option.disabled = "disabled";
          add_location(option, file$7, 218, 12, 7095);
          attr_dev(select, "name", "categoria");
          if (
          /*$dialogosStore*/
          ctx[0].categoriaId === void 0) add_render_callback(() =>
          /*select_change_handler*/
          ctx[10].call(select));
          add_location(select, file$7, 217, 8, 7016);
          attr_dev(div, "slot", "body");
          add_location(div, file$7, 215, 4, 6938);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          append_dev(div, span);
          append_dev(div, t0);
          append_dev(div, select);
          append_dev(select, option);

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].m(select, null);
          }

          select_option(select,
          /*$dialogosStore*/
          ctx[0].categoriaId);
          append_dev(div, t2);
          mount_component(checkbox, div, null);
          current = true;

          if (!mounted) {
            dispose = listen_dev(select, "change",
            /*select_change_handler*/
            ctx[10]);
            mounted = true;
          }
        },
        p: function update(ctx, dirty) {
          if (dirty &
          /*config*/
          0) {
            each_value = config.grupos;
            validate_each_argument(each_value);
            let i;

            for (i = 0; i < each_value.length; i += 1) {
              const child_ctx = get_each_context$3(ctx, each_value, i);

              if (each_blocks[i]) {
                each_blocks[i].p(child_ctx, dirty);
              } else {
                each_blocks[i] = create_each_block$3(child_ctx);
                each_blocks[i].c();
                each_blocks[i].m(select, null);
              }
            }

            for (; i < each_blocks.length; i += 1) {
              each_blocks[i].d(1);
            }

            each_blocks.length = each_value.length;
          }

          if (dirty &
          /*$dialogosStore, config*/
          1) {
            select_option(select,
            /*$dialogosStore*/
            ctx[0].categoriaId);
          }

          const checkbox_changes = {};

          if (dirty &
          /*$$scope*/
          524288) {
            checkbox_changes.$$scope = {
              dirty,
              ctx
            };
          }

          if (!updating_checked && dirty &
          /*$dialogosStore*/
          1) {
            updating_checked = true;
            checkbox_changes.checked =
            /*$dialogosStore*/
            ctx[0].advertenciaCategoria;
            add_flush_callback(() => updating_checked = false);
          }

          checkbox.$set(checkbox_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(checkbox.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(checkbox.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
          destroy_each(each_blocks, detaching);
          destroy_component(checkbox);
          mounted = false;
          dispose();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_body_slot$2.name,
        type: "slot",
        source: "(216:4) <div slot=\\\"body\\\">",
        ctx
      });
      return block;
    } // (205:0) <Dialogo      visible={$dialogosStore.dialogoAbierto == "cambiarCategoria"}      titulo="Cambiar categoria"      accion={() =>          RChanClient.cambiarCategoria(              $dialogosStore.hiloId,              $dialogosStore.categoriaId,              $dialogosStore.advertenciaCategoria          )}  >


    function create_default_slot$4(ctx) {
      let t;
      const block = {
        c: function create() {
          t = space();
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        p: noop,
        i: noop,
        o: noop,
        d: function destroy(detaching) {
          if (detaching) detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot$4.name,
        type: "slot",
        source: "(205:0) <Dialogo      visible={$dialogosStore.dialogoAbierto == \\\"cambiarCategoria\\\"}      titulo=\\\"Cambiar categoria\\\"      accion={() =>          RChanClient.cambiarCategoria(              $dialogosStore.hiloId,              $dialogosStore.categoriaId,              $dialogosStore.advertenciaCategoria          )}  >",
        ctx
      });
      return block;
    }

    function create_fragment$7(ctx) {
      let t0;
      let dialogoreporte;
      let t1;
      let dialogo0;
      let t2;
      let dialogo1;
      let t3;
      let dialogo2;
      let t4;
      let dialogo3;
      let t5;
      let dialogoban;
      let t6;
      let dialogo4;
      let t7;
      let dialogo5;
      let current;
      let if_block =
      /*$dialogosStore*/
      ctx[0].dialogoAbierto == "sticky" && create_if_block_2$3(ctx);
      dialogoreporte = new DialogoReporte({
        props: {
          visible:
          /*$dialogosStore*/
          ctx[0].dialogoAbierto == "reporte",
          hiloId:
          /*$dialogosStore*/
          ctx[0].hiloId,
          comentarioId:
          /*$dialogosStore*/
          ctx[0].comentarioId
        },
        $$inline: true
      });
      dialogo0 = new Dialogo({
        props: {
          visible:
          /*$dialogosStore*/
          ctx[0].dialogoAbierto == "eliminarHilo",
          textoActivador: "Eliminar",
          titulo: "Eliminar roz",
          accion:
          /*func*/
          ctx[3],
          $$slots: {
            default: [create_default_slot_8$1],
            body: [create_body_slot_5],
            activador: [create_activador_slot_5]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      dialogo1 = new Dialogo({
        props: {
          visible:
          /*$dialogosStore*/
          ctx[0].dialogoAbierto == "restaurarHilo",
          textoActivador: "Restaurar",
          titulo: "Restaurar el roz",
          accion:
          /*func_1*/
          ctx[4],
          $$slots: {
            default: [create_default_slot_7$1],
            body: [create_body_slot_4],
            activador: [create_activador_slot_4]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      dialogo2 = new Dialogo({
        props: {
          visible:
          /*$dialogosStore*/
          ctx[0].dialogoAbierto == "restaurarComentario",
          textoActivador: "Restaurar",
          titulo: "Restaurar el comentario",
          accion:
          /*func_2*/
          ctx[5],
          $$slots: {
            default: [create_default_slot_6$1],
            body: [create_body_slot_3],
            activador: [create_activador_slot_3]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      dialogo3 = new Dialogo({
        props: {
          visible:
          /*$dialogosStore*/
          ctx[0].dialogoAbierto == "eliminarComentarios",
          textoActivador: "Eliminar",
          titulo: "Eliminar comentario",
          accion:
          /*func_3*/
          ctx[7],
          $$slots: {
            default: [create_default_slot_4$1],
            body: [create_body_slot_2],
            activador: [create_activador_slot_2]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      dialogoban = new DialogoBan({
        props: {
          visible:
          /*$dialogosStore*/
          ctx[0].dialogoAbierto == "ban",
          hiloId:
          /*$dialogosStore*/
          ctx[0].hiloId,
          usuarioId:
          /*$dialogosStore*/
          ctx[0].usuarioId,
          comentarioId:
          /*$dialogosStore*/
          ctx[0].comentarioId
        },
        $$inline: true
      });
      dialogo4 = new Dialogo({
        props: {
          visible:
          /*$dialogosStore*/
          ctx[0].dialogoAbierto == "eliminarMedia",
          textoActivador: "Eliminar",
          titulo: "Eliminar la imagen/video",
          accion:
          /*func_4*/
          ctx[9],
          $$slots: {
            default: [create_default_slot_2$3],
            body: [create_body_slot_1],
            activador: [create_activador_slot_1]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      dialogo5 = new Dialogo({
        props: {
          visible:
          /*$dialogosStore*/
          ctx[0].dialogoAbierto == "cambiarCategoria",
          titulo: "Cambiar categoria",
          accion:
          /*func_5*/
          ctx[12],
          $$slots: {
            default: [create_default_slot$4],
            body: [create_body_slot$2],
            activador: [create_activador_slot$2]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          if (if_block) if_block.c();
          t0 = space();
          create_component(dialogoreporte.$$.fragment);
          t1 = space();
          create_component(dialogo0.$$.fragment);
          t2 = space();
          create_component(dialogo1.$$.fragment);
          t3 = space();
          create_component(dialogo2.$$.fragment);
          t4 = space();
          create_component(dialogo3.$$.fragment);
          t5 = space();
          create_component(dialogoban.$$.fragment);
          t6 = space();
          create_component(dialogo4.$$.fragment);
          t7 = space();
          create_component(dialogo5.$$.fragment);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          if (if_block) if_block.m(target, anchor);
          insert_dev(target, t0, anchor);
          mount_component(dialogoreporte, target, anchor);
          insert_dev(target, t1, anchor);
          mount_component(dialogo0, target, anchor);
          insert_dev(target, t2, anchor);
          mount_component(dialogo1, target, anchor);
          insert_dev(target, t3, anchor);
          mount_component(dialogo2, target, anchor);
          insert_dev(target, t4, anchor);
          mount_component(dialogo3, target, anchor);
          insert_dev(target, t5, anchor);
          mount_component(dialogoban, target, anchor);
          insert_dev(target, t6, anchor);
          mount_component(dialogo4, target, anchor);
          insert_dev(target, t7, anchor);
          mount_component(dialogo5, target, anchor);
          current = true;
        },
        p: function update(ctx, [dirty]) {
          if (
          /*$dialogosStore*/
          ctx[0].dialogoAbierto == "sticky") {
            if (if_block) ; else {
              if_block = create_if_block_2$3(ctx);
              if_block.c();
              if_block.m(t0.parentNode, t0);
            }
          } else if (if_block) {
            if_block.d(1);
            if_block = null;
          }

          const dialogoreporte_changes = {};
          if (dirty &
          /*$dialogosStore*/
          1) dialogoreporte_changes.visible =
          /*$dialogosStore*/
          ctx[0].dialogoAbierto == "reporte";
          if (dirty &
          /*$dialogosStore*/
          1) dialogoreporte_changes.hiloId =
          /*$dialogosStore*/
          ctx[0].hiloId;
          if (dirty &
          /*$dialogosStore*/
          1) dialogoreporte_changes.comentarioId =
          /*$dialogosStore*/
          ctx[0].comentarioId;
          dialogoreporte.$set(dialogoreporte_changes);
          const dialogo0_changes = {};
          if (dirty &
          /*$dialogosStore*/
          1) dialogo0_changes.visible =
          /*$dialogosStore*/
          ctx[0].dialogoAbierto == "eliminarHilo";
          if (dirty &
          /*$dialogosStore*/
          1) dialogo0_changes.accion =
          /*func*/
          ctx[3];

          if (dirty &
          /*$$scope, $dialogosStore, $globalStore*/
          524291) {
            dialogo0_changes.$$scope = {
              dirty,
              ctx
            };
          }

          dialogo0.$set(dialogo0_changes);
          const dialogo1_changes = {};
          if (dirty &
          /*$dialogosStore*/
          1) dialogo1_changes.visible =
          /*$dialogosStore*/
          ctx[0].dialogoAbierto == "restaurarHilo";
          if (dirty &
          /*$dialogosStore*/
          1) dialogo1_changes.accion =
          /*func_1*/
          ctx[4];

          if (dirty &
          /*$$scope*/
          524288) {
            dialogo1_changes.$$scope = {
              dirty,
              ctx
            };
          }

          dialogo1.$set(dialogo1_changes);
          const dialogo2_changes = {};
          if (dirty &
          /*$dialogosStore*/
          1) dialogo2_changes.visible =
          /*$dialogosStore*/
          ctx[0].dialogoAbierto == "restaurarComentario";
          if (dirty &
          /*$dialogosStore*/
          1) dialogo2_changes.accion =
          /*func_2*/
          ctx[5];

          if (dirty &
          /*$$scope, $dialogosStore*/
          524289) {
            dialogo2_changes.$$scope = {
              dirty,
              ctx
            };
          }

          dialogo2.$set(dialogo2_changes);
          const dialogo3_changes = {};
          if (dirty &
          /*$dialogosStore*/
          1) dialogo3_changes.visible =
          /*$dialogosStore*/
          ctx[0].dialogoAbierto == "eliminarComentarios";
          if (dirty &
          /*$dialogosStore*/
          1) dialogo3_changes.accion =
          /*func_3*/
          ctx[7];

          if (dirty &
          /*$$scope, $dialogosStore, $globalStore*/
          524291) {
            dialogo3_changes.$$scope = {
              dirty,
              ctx
            };
          }

          dialogo3.$set(dialogo3_changes);
          const dialogoban_changes = {};
          if (dirty &
          /*$dialogosStore*/
          1) dialogoban_changes.visible =
          /*$dialogosStore*/
          ctx[0].dialogoAbierto == "ban";
          if (dirty &
          /*$dialogosStore*/
          1) dialogoban_changes.hiloId =
          /*$dialogosStore*/
          ctx[0].hiloId;
          if (dirty &
          /*$dialogosStore*/
          1) dialogoban_changes.usuarioId =
          /*$dialogosStore*/
          ctx[0].usuarioId;
          if (dirty &
          /*$dialogosStore*/
          1) dialogoban_changes.comentarioId =
          /*$dialogosStore*/
          ctx[0].comentarioId;
          dialogoban.$set(dialogoban_changes);
          const dialogo4_changes = {};
          if (dirty &
          /*$dialogosStore*/
          1) dialogo4_changes.visible =
          /*$dialogosStore*/
          ctx[0].dialogoAbierto == "eliminarMedia";
          if (dirty &
          /*$dialogosStore*/
          1) dialogo4_changes.accion =
          /*func_4*/
          ctx[9];

          if (dirty &
          /*$$scope, $dialogosStore*/
          524289) {
            dialogo4_changes.$$scope = {
              dirty,
              ctx
            };
          }

          dialogo4.$set(dialogo4_changes);
          const dialogo5_changes = {};
          if (dirty &
          /*$dialogosStore*/
          1) dialogo5_changes.visible =
          /*$dialogosStore*/
          ctx[0].dialogoAbierto == "cambiarCategoria";
          if (dirty &
          /*$dialogosStore*/
          1) dialogo5_changes.accion =
          /*func_5*/
          ctx[12];

          if (dirty &
          /*$$scope, $dialogosStore*/
          524289) {
            dialogo5_changes.$$scope = {
              dirty,
              ctx
            };
          }

          dialogo5.$set(dialogo5_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(dialogoreporte.$$.fragment, local);
          transition_in(dialogo0.$$.fragment, local);
          transition_in(dialogo1.$$.fragment, local);
          transition_in(dialogo2.$$.fragment, local);
          transition_in(dialogo3.$$.fragment, local);
          transition_in(dialogoban.$$.fragment, local);
          transition_in(dialogo4.$$.fragment, local);
          transition_in(dialogo5.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(dialogoreporte.$$.fragment, local);
          transition_out(dialogo0.$$.fragment, local);
          transition_out(dialogo1.$$.fragment, local);
          transition_out(dialogo2.$$.fragment, local);
          transition_out(dialogo3.$$.fragment, local);
          transition_out(dialogoban.$$.fragment, local);
          transition_out(dialogo4.$$.fragment, local);
          transition_out(dialogo5.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (if_block) if_block.d(detaching);
          if (detaching) detach_dev(t0);
          destroy_component(dialogoreporte, detaching);
          if (detaching) detach_dev(t1);
          destroy_component(dialogo0, detaching);
          if (detaching) detach_dev(t2);
          destroy_component(dialogo1, detaching);
          if (detaching) detach_dev(t3);
          destroy_component(dialogo2, detaching);
          if (detaching) detach_dev(t4);
          destroy_component(dialogo3, detaching);
          if (detaching) detach_dev(t5);
          destroy_component(dialogoban, detaching);
          if (detaching) detach_dev(t6);
          destroy_component(dialogo4, detaching);
          if (detaching) detach_dev(t7);
          destroy_component(dialogo5, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$7.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }

    const dialogosStore = writable({
      dialogoAbierto: "ninguno",
      hiloId: "",
      comentarioId: "",
      comentariosIds: [],
      usuarioId: "",
      mediaId: "",
      categoriaId: "-1",
      advertenciaCategoria: false,
      eliminarMedia: false,
      eliminarAudio: false,
      mediaEliminarDependientes: true
    });

    function abrirReporte(hiloId, comentarioId = null) {
      dialogosStore.update(s => {
        s.dialogoAbierto = "reporte";
        s.hiloId = hiloId;
        s.comentarioId = comentarioId;
        return s;
      });
    }

    function abrirEliminarhilo(hiloId, comentarioId = null) {
      dialogosStore.update(s => {
        s.dialogoAbierto = "eliminarHilo";
        s.hiloId = hiloId;
        s.comentarioId = comentarioId;
        return s;
      });
    }

    function abrirRestaurarHilo(hiloId, comentarioId = null) {
      dialogosStore.update(s => {
        s.dialogoAbierto = "restaurarHilo";
        s.hiloId = hiloId;
        return s;
      });
    }

    function abrirRestaurarComentario(hiloId, comentarioId = null) {
      dialogosStore.update(s => {
        s.dialogoAbierto = "restaurarComentario";
        s.hiloId = hiloId;
        s.comentarioId = comentarioId;
        return s;
      });
    }

    function abrirEliminarComentarios(ids) {
      dialogosStore.update(s => {
        s.dialogoAbierto = "eliminarComentarios";
        s.comentariosIds = ids;
        return s;
      });
    }

    function abrirBan(hiloId, comentarioId = null, usuarioId = null) {
      dialogosStore.update(s => {
        s.dialogoAbierto = "ban";
        s.hiloId = hiloId;
        s.comentarioId = comentarioId;
        s.usuarioId = usuarioId;
        return s;
      });
    }

    function abrirEliminarMedia(mediaId) {
      dialogosStore.update(s => {
        s.dialogoAbierto = "eliminarMedia";
        s.mediaId = mediaId;
        return s;
      });
    }

    function abrirCambiarCategoria(hiloId) {
      dialogosStore.update(s => {
        s.dialogoAbierto = "cambiarCategoria";
        s.hiloId = hiloId;
        return s;
      });
    }

    const abrir = {
      //  sticky : abrirDialogo("sticky"),
      ban: abrirBan,
      reporte: abrirReporte,
      eliminarHilo: abrirEliminarhilo,
      eliminarComentarios: abrirEliminarComentarios,
      restaurarHilo: abrirRestaurarHilo,
      restaurarComentario: abrirRestaurarComentario,
      eliminarMedia: abrirEliminarMedia,
      cambiarCategoria: abrirCambiarCategoria
    }; //  categoria : abrirDialogo("categoria"),
    //  eliminar : abrirDialogo("eliminar"),

    function instance$7($$self, $$props, $$invalidate) {
      let $dialogosStore;
      let $globalStore;
      validate_store(dialogosStore, "dialogosStore");
      component_subscribe($$self, dialogosStore, $$value => $$invalidate(0, $dialogosStore = $$value));
      validate_store(globalStore, "globalStore");
      component_subscribe($$self, globalStore, $$value => $$invalidate(1, $globalStore = $$value));
      let {
        $$slots: slots = {},
        $$scope
      } = $$props;
      validate_slots("Dialogos", slots, []);
      const writable_props = [];
      Object.keys($$props).forEach(key => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Dialogos> was created with unknown prop '${key}'`);
      });

      function checkbox_checked_binding(value) {
        $dialogosStore.eliminarMedia = value;
        dialogosStore.set($dialogosStore);
      }

      const func = () => RChanClient.borrarHilos([$dialogosStore.hiloId], $dialogosStore.eliminarMedia, $dialogosStore.eliminarAudio);

      const func_1 = () => RChanClient.restaurarRoz($dialogosStore.hiloId);

      const func_2 = () => RChanClient.restaurarComentario($dialogosStore.comentarioId);

      function checkbox_checked_binding_1(value) {
        $dialogosStore.eliminarMedia = value;
        dialogosStore.set($dialogosStore);
      }

      const func_3 = () => RChanClient.eliminarComentarios($dialogosStore.comentariosIds, $dialogosStore.eliminarMedia, $dialogosStore.eliminarAudio);

      function checkbox_checked_binding_2(value) {
        $dialogosStore.mediaEliminarDependientes = value;
        dialogosStore.set($dialogosStore);
      }

      const func_4 = () => RChanClient.eliminarMedia($dialogosStore.mediaId);

      function select_change_handler() {
        $dialogosStore.categoriaId = select_value(this);
        dialogosStore.set($dialogosStore);
      }

      function checkbox_checked_binding_3(value) {
        $dialogosStore.advertenciaCategoria = value;
        dialogosStore.set($dialogosStore);
      }

      const func_5 = () => RChanClient.cambiarCategoria($dialogosStore.hiloId, $dialogosStore.categoriaId, $dialogosStore.advertenciaCategoria);

      $$self.$capture_state = () => ({
        writable,
        RChanClient,
        Dialogo,
        DialogoBan,
        DialogoReporte,
        Checkbox: Ne,
        config,
        globalStore,
        dialogosStore,
        abrirReporte,
        abrirEliminarhilo,
        abrirRestaurarHilo,
        abrirRestaurarComentario,
        abrirEliminarComentarios,
        abrirBan,
        abrirEliminarMedia,
        abrirCambiarCategoria,
        abrir,
        $dialogosStore,
        $globalStore
      });

      return [$dialogosStore, $globalStore, checkbox_checked_binding, func, func_1, func_2, checkbox_checked_binding_1, func_3, checkbox_checked_binding_2, func_4, select_change_handler, checkbox_checked_binding_3, func_5];
    }

    class Dialogos extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$7, create_fragment$7, safe_not_equal, {});
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "Dialogos",
          options,
          id: create_fragment$7.name
        });
      }

    }

    let selectorStore = writable({
      activado: true,
      seleccionados: new Set()
    });

    selectorStore.selecionar = function selecionar(id) {
      selectorStore.update(v => {
        if (v.seleccionados.has(id)) {
          v.seleccionados.delete(id);
        } else {
          v.seleccionados.add(id);
        }

        v.seleccionados = v.seleccionados;
        return v;
      });
    };

    let teclas = {
      estaPresionada(tecla) {
        console.log(tecla);
        console.log(teclas[tecla]);
        return teclas[tecla];
      }

    };
    document.addEventListener('keydown', function (e) {
      teclas[e.key] = true;
    });
    document.addEventListener('keyup', function (e) {
      teclas[e.key] = false;
    });

    /* src\components\Audio.svelte generated by Svelte v3.29.0 */
    const file$8 = "src\\components\\Audio.svelte";

    function create_fragment$8(ctx) {
      let audio;
      let source;
      let source_src_value;
      const block = {
        c: function create() {
          audio = element("audio");
          source = element("source");
          if (source.src !== (source_src_value = "/Audios/" +
          /*urlBlobAudio*/
          ctx[0])) attr_dev(source, "src", source_src_value);
          attr_dev(source, "type", "audio/webm");
          add_location(source, file$8, 5, 4, 100);
          audio.controls = "controls";
          attr_dev(audio, "preload", "metadata");
          attr_dev(audio, "class", "svelte-1m7uih9");
          add_location(audio, file$8, 4, 0, 49);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, audio, anchor);
          append_dev(audio, source);
        },
        p: function update(ctx, [dirty]) {
          if (dirty &
          /*urlBlobAudio*/
          1 && source.src !== (source_src_value = "/Audios/" +
          /*urlBlobAudio*/
          ctx[0])) {
            attr_dev(source, "src", source_src_value);
          }
        },
        i: noop,
        o: noop,
        d: function destroy(detaching) {
          if (detaching) detach_dev(audio);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$8.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }

    function instance$8($$self, $$props, $$invalidate) {
      let {
        $$slots: slots = {},
        $$scope
      } = $$props;
      validate_slots("Audio", slots, []);
      let {
        urlBlobAudio
      } = $$props;
      const writable_props = ["urlBlobAudio"];
      Object.keys($$props).forEach(key => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Audio> was created with unknown prop '${key}'`);
      });

      $$self.$$set = $$props => {
        if ("urlBlobAudio" in $$props) $$invalidate(0, urlBlobAudio = $$props.urlBlobAudio);
      };

      $$self.$capture_state = () => ({
        urlBlobAudio
      });

      $$self.$inject_state = $$props => {
        if ("urlBlobAudio" in $$props) $$invalidate(0, urlBlobAudio = $$props.urlBlobAudio);
      };

      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }

      return [urlBlobAudio];
    }

    class Audio$1 extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$8, create_fragment$8, safe_not_equal, {
          urlBlobAudio: 0
        });
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "Audio",
          options,
          id: create_fragment$8.name
        });
        const {
          ctx
        } = this.$$;
        const props = options.props || {};

        if (
        /*urlBlobAudio*/
        ctx[0] === undefined && !("urlBlobAudio" in props)) {
          console.warn("<Audio> was created without expected prop 'urlBlobAudio'");
        }
      }

      get urlBlobAudio() {
        throw new Error("<Audio>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set urlBlobAudio(value) {
        throw new Error("<Audio>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

    }

    /* src\components\Comentarios\Comentario.svelte generated by Svelte v3.29.0 */
    const file$9 = "src\\components\\Comentarios\\Comentario.svelte";

    function get_each_context$4(ctx, list, i) {
      const child_ctx = ctx.slice();
      child_ctx[43] = list[i];
      return child_ctx;
    } // (153:4) {#if comentario.respuestas && comentario.respuestas.length > 0}


    function create_if_block_13$1(ctx) {
      let div0;
      let t0;
      let t1_value = (
      /*comentario*/
      ctx[0].respuestas &&
      /*comentario*/
      ctx[0].respuestas.length) + "";
      let t1;
      let t2;
      let div1;
      let mounted;
      let dispose;
      let each_value =
      /*comentario*/
      ctx[0].respuestas;
      validate_each_argument(each_value);
      let each_blocks = [];

      for (let i = 0; i < each_value.length; i += 1) {
        each_blocks[i] = create_each_block$4(get_each_context$4(ctx, each_value, i));
      }

      const block = {
        c: function create() {
          div0 = element("div");
          t0 = text("R: ");
          t1 = text(t1_value);
          t2 = space();
          div1 = element("div");

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].c();
          }

          attr_dev(div0, "class", "respuestas-compactas svelte-17xdt9k");
          add_location(div0, file$9, 153, 8, 5081);
          attr_dev(div1, "class", "respuestas svelte-17xdt9k");
          add_location(div1, file$9, 159, 8, 5310);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div0, anchor);
          append_dev(div0, t0);
          append_dev(div0, t1);
          insert_dev(target, t2, anchor);
          insert_dev(target, div1, anchor);

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].m(div1, null);
          }

          if (!mounted) {
            dispose = listen_dev(div0, "click",
            /*click_handler*/
            ctx[25], false, false, false);
            mounted = true;
          }
        },
        p: function update(ctx, dirty) {
          if (dirty[0] &
          /*comentario*/
          1 && t1_value !== (t1_value = (
          /*comentario*/
          ctx[0].respuestas &&
          /*comentario*/
          ctx[0].respuestas.length) + "")) set_data_dev(t1, t1_value);

          if (dirty[0] &
          /*comentario, mostrarRespuesta, ocultarRespuesta, esOp*/
          573441) {
            each_value =
            /*comentario*/
            ctx[0].respuestas;
            validate_each_argument(each_value);
            let i;

            for (i = 0; i < each_value.length; i += 1) {
              const child_ctx = get_each_context$4(ctx, each_value, i);

              if (each_blocks[i]) {
                each_blocks[i].p(child_ctx, dirty);
              } else {
                each_blocks[i] = create_each_block$4(child_ctx);
                each_blocks[i].c();
                each_blocks[i].m(div1, null);
              }
            }

            for (; i < each_blocks.length; i += 1) {
              each_blocks[i].d(1);
            }

            each_blocks.length = each_value.length;
          }
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div0);
          if (detaching) detach_dev(t2);
          if (detaching) detach_dev(div1);
          destroy_each(each_blocks, detaching);
          mounted = false;
          dispose();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_13$1.name,
        type: "if",
        source: "(153:4) {#if comentario.respuestas && comentario.respuestas.length > 0}",
        ctx
      });
      return block;
    } // (161:12) {#each comentario.respuestas as r}


    function create_each_block$4(ctx) {
      let a;
      let t0;
      let t1_value =
      /*r*/
      ctx[43] + "";
      let t1;
      let t2_value = (
      /*esOp*/
      ctx[19](
      /*r*/
      ctx[43]) ? "(OP)" : "") + "";
      let t2;
      let t3;
      let a_href_value;
      let a_r_id_value;
      let mounted;
      let dispose;

      function mouseover_handler(...args) {
        return (
          /*mouseover_handler*/
          ctx[26](
          /*r*/
          ctx[43], ...args)
        );
      }

      const block = {
        c: function create() {
          a = element("a");
          t0 = text(">>");
          t1 = text(t1_value);
          t2 = text(t2_value);
          t3 = space();
          attr_dev(a, "href", a_href_value = "#" +
          /*r*/
          ctx[43]);
          attr_dev(a, "class", "restag");
          attr_dev(a, "r-id", a_r_id_value =
          /*r*/
          ctx[43]);
          add_location(a, file$9, 161, 16, 5400);
        },
        m: function mount(target, anchor) {
          insert_dev(target, a, anchor);
          append_dev(a, t0);
          append_dev(a, t1);
          append_dev(a, t2);
          append_dev(a, t3);

          if (!mounted) {
            dispose = [listen_dev(a, "mouseover", mouseover_handler, false, false, false), listen_dev(a, "mouseleave",
            /*ocultarRespuesta*/
            ctx[15], false, false, false)];
            mounted = true;
          }
        },
        p: function update(new_ctx, dirty) {
          ctx = new_ctx;
          if (dirty[0] &
          /*comentario*/
          1 && t1_value !== (t1_value =
          /*r*/
          ctx[43] + "")) set_data_dev(t1, t1_value);
          if (dirty[0] &
          /*comentario*/
          1 && t2_value !== (t2_value = (
          /*esOp*/
          ctx[19](
          /*r*/
          ctx[43]) ? "(OP)" : "") + "")) set_data_dev(t2, t2_value);

          if (dirty[0] &
          /*comentario*/
          1 && a_href_value !== (a_href_value = "#" +
          /*r*/
          ctx[43])) {
            attr_dev(a, "href", a_href_value);
          }

          if (dirty[0] &
          /*comentario*/
          1 && a_r_id_value !== (a_r_id_value =
          /*r*/
          ctx[43])) {
            attr_dev(a, "r-id", a_r_id_value);
          }
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(a);
          mounted = false;
          run_all(dispose);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_each_block$4.name,
        type: "each",
        source: "(161:12) {#each comentario.respuestas as r}",
        ctx
      });
      return block;
    } // (182:8) {:else}


    function create_else_block_2$1(ctx) {
      let t;
      const block = {
        c: function create() {
          t = text("ANON");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        p: noop,
        d: function destroy(detaching) {
          if (detaching) detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_else_block_2$1.name,
        type: "else",
        source: "(182:8) {:else}",
        ctx
      });
      return block;
    } // (180:35) 


    function create_if_block_12$1(ctx) {
      let t_value = CreacionRango.aString(
      /*comentario*/
      ctx[0].rango).toUpperCase() + "";
      let t;
      const block = {
        c: function create() {
          t = text(t_value);
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        p: function update(ctx, dirty) {
          if (dirty[0] &
          /*comentario*/
          1 && t_value !== (t_value = CreacionRango.aString(
          /*comentario*/
          ctx[0].rango).toUpperCase() + "")) set_data_dev(t, t_value);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_12$1.name,
        type: "if",
        source: "(180:35) ",
        ctx
      });
      return block;
    } // (178:8) {#if comentario.dados != undefined && comentario.dados != -1}


    function create_if_block_11$1(ctx) {
      let t_value =
      /*comentario*/
      ctx[0].dados + "";
      let t;
      const block = {
        c: function create() {
          t = text(t_value);
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        p: function update(ctx, dirty) {
          if (dirty[0] &
          /*comentario*/
          1 && t_value !== (t_value =
          /*comentario*/
          ctx[0].dados + "")) set_data_dev(t, t_value);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_11$1.name,
        type: "if",
        source: "(178:8) {#if comentario.dados != undefined && comentario.dados != -1}",
        ctx
      });
      return block;
    } // (187:8) {#if comentario.esOp}


    function create_if_block_10$1(ctx) {
      let span;
      const block = {
        c: function create() {
          span = element("span");
          span.textContent = "OP";
          attr_dev(span, "class", "nick tag tag-op svelte-17xdt9k");
          add_location(span, file$9, 186, 30, 6280);
        },
        m: function mount(target, anchor) {
          insert_dev(target, span, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(span);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_10$1.name,
        type: "if",
        source: "(187:8) {#if comentario.esOp}",
        ctx
      });
      return block;
    } // (194:8) {#if comentario.banderita}


    function create_if_block_9$1(ctx) {
      let span1;
      let span0;
      let span0_class_value;
      const block = {
        c: function create() {
          span1 = element("span");
          span0 = element("span");
          attr_dev(span0, "class", span0_class_value = "flag " +
          /*comentario*/
          ctx[0].banderita + " svelte-17xdt9k");
          add_location(span0, file$9, 195, 17, 6626);
          attr_dev(span1, "class", "banderita f32 svelte-17xdt9k");
          add_location(span1, file$9, 194, 12, 6580);
        },
        m: function mount(target, anchor) {
          insert_dev(target, span1, anchor);
          append_dev(span1, span0);
        },
        p: function update(ctx, dirty) {
          if (dirty[0] &
          /*comentario*/
          1 && span0_class_value !== (span0_class_value = "flag " +
          /*comentario*/
          ctx[0].banderita + " svelte-17xdt9k")) {
            attr_dev(span0, "class", span0_class_value);
          }
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(span1);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_9$1.name,
        type: "if",
        source: "(194:8) {#if comentario.banderita}",
        ctx
      });
      return block;
    } // (198:8) {#if comentario.idUnico}


    function create_if_block_8$1(ctx) {
      let span;
      let t0_value =
      /*comentario*/
      ctx[0].idUnico + "";
      let t0;
      let t1;
      let ripple;
      let span_style_value;
      let current;
      let mounted;
      let dispose;
      ripple = new he({
        props: {
          color: "var(--color5)"
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          span = element("span");
          t0 = text(t0_value);
          t1 = space();
          create_component(ripple.$$.fragment);
          attr_dev(span, "class", "tag ns cpt idunico svelte-17xdt9k");
          attr_dev(span, "style", span_style_value = `background:${
      /*idUnicoColor*/
      ctx[20]()};`);
          add_location(span, file$9, 198, 12, 6744);
        },
        m: function mount(target, anchor) {
          insert_dev(target, span, anchor);
          append_dev(span, t0);
          append_dev(span, t1);
          mount_component(ripple, span, null);
          current = true;

          if (!mounted) {
            dispose = listen_dev(span, "click",
            /*click_handler_2*/
            ctx[28], false, false, false);
            mounted = true;
          }
        },
        p: function update(ctx, dirty) {
          if ((!current || dirty[0] &
          /*comentario*/
          1) && t0_value !== (t0_value =
          /*comentario*/
          ctx[0].idUnico + "")) set_data_dev(t0, t0_value);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(ripple.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(ripple.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(span);
          destroy_component(ripple);
          mounted = false;
          dispose();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_8$1.name,
        type: "if",
        source: "(198:8) {#if comentario.idUnico}",
        ctx
      });
      return block;
    } // (209:8) {#if comentario.usuarioId}


    function create_if_block_7$1(ctx) {
      let a;
      let span;
      let t_value =
      /*comentario*/
      ctx[0].usuarioId.split("-")[0] + "";
      let t;
      let a_href_value;
      const block = {
        c: function create() {
          a = element("a");
          span = element("span");
          t = text(t_value);
          attr_dev(span, "class", "nick svelte-17xdt9k");
          add_location(span, file$9, 213, 16, 7312);
          attr_dev(a, "href", a_href_value = "/Moderacion/HistorialDeUsuario/" +
          /*comentario*/
          ctx[0].usuarioId);
          set_style(a, "color", "var(--color6)", 1);
          add_location(a, file$9, 209, 12, 7143);
        },
        m: function mount(target, anchor) {
          insert_dev(target, a, anchor);
          append_dev(a, span);
          append_dev(span, t);
        },
        p: function update(ctx, dirty) {
          if (dirty[0] &
          /*comentario*/
          1 && t_value !== (t_value =
          /*comentario*/
          ctx[0].usuarioId.split("-")[0] + "")) set_data_dev(t, t_value);

          if (dirty[0] &
          /*comentario*/
          1 && a_href_value !== (a_href_value = "/Moderacion/HistorialDeUsuario/" +
          /*comentario*/
          ctx[0].usuarioId)) {
            attr_dev(a, "href", a_href_value);
          }
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(a);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_7$1.name,
        type: "if",
        source: "(209:8) {#if comentario.usuarioId}",
        ctx
      });
      return block;
    } // (280:12) {:else}


    function create_else_block_1$1(ctx) {
      let div;
      let button0;
      let t;
      let button1;
      let current;
      button0 = new ye({
        props: {
          icon: true,
          color: "red",
          style: "width:32px;height:16px;",
          $$slots: {
            default: [create_default_slot_6$2]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      button0.$on("click",
      /*click_handler_10*/
      ctx[36]);
      button1 = new ye({
        props: {
          icon: true,
          color: "white",
          style: "width:32px;height:16px;",
          $$slots: {
            default: [create_default_slot_5$2]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      button1.$on("click",
      /*toggle*/
      ctx[16]);
      const block = {
        c: function create() {
          div = element("div");
          create_component(button0.$$.fragment);
          t = space();
          create_component(button1.$$.fragment);
          attr_dev(div, "class", "acciones-comentario svelte-17xdt9k");
          add_location(div, file$9, 280, 16, 10112);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          mount_component(button0, div, null);
          append_dev(div, t);
          mount_component(button1, div, null);
          current = true;
        },
        p: function update(ctx, dirty) {
          const button0_changes = {};

          if (dirty[1] &
          /*$$scope*/
          32768) {
            button0_changes.$$scope = {
              dirty,
              ctx
            };
          }

          button0.$set(button0_changes);
          const button1_changes = {};

          if (dirty[1] &
          /*$$scope*/
          32768) {
            button1_changes.$$scope = {
              dirty,
              ctx
            };
          }

          button1.$set(button1_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(button0.$$.fragment, local);
          transition_in(button1.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(button0.$$.fragment, local);
          transition_out(button1.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
          destroy_component(button0);
          destroy_component(button1);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_else_block_1$1.name,
        type: "else",
        source: "(280:12) {:else}",
        ctx
      });
      return block;
    } // (224:12) {#if $globalStore.usuario.esMod || $globalStore.usuario.esAuxiliar}


    function create_if_block_4$1(ctx) {
      let menu;
      let current;
      menu = new Menu_1({
        props: {
          $$slots: {
            default: [create_default_slot$5],
            activador: [create_activador_slot$3]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          create_component(menu.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(menu, target, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          const menu_changes = {};

          if (dirty[0] &
          /*comentario, hilo, visible, mostrarMenu*/
          771 | dirty[1] &
          /*$$scope*/
          32768) {
            menu_changes.$$scope = {
              dirty,
              ctx
            };
          }

          menu.$set(menu_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(menu.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(menu.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(menu, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_4$1.name,
        type: "if",
        source: "(224:12) {#if $globalStore.usuario.esMod || $globalStore.usuario.esAuxiliar}",
        ctx
      });
      return block;
    } // (282:20) <Button                          icon                          color="red"                          style="width:32px;height:16px;"                          on:click={() =>                              abrir.reporte(                                  hilo.id || comentario.hiloId,                                  comentario.id                              )}                      >


    function create_default_slot_6$2(ctx) {
      let icon;
      const block = {
        c: function create() {
          icon = element("icon");
          attr_dev(icon, "class", "fe fe-flag");
          add_location(icon, file$9, 291, 24, 10574);
        },
        m: function mount(target, anchor) {
          insert_dev(target, icon, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(icon);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_6$2.name,
        type: "slot",
        source: "(282:20) <Button                          icon                          color=\\\"red\\\"                          style=\\\"width:32px;height:16px;\\\"                          on:click={() =>                              abrir.reporte(                                  hilo.id || comentario.hiloId,                                  comentario.id                              )}                      >",
        ctx
      });
      return block;
    } // (294:20) <Button                          icon                          color="white"                          style="width:32px;height:16px;"                          on:click={toggle}                      >


    function create_default_slot_5$2(ctx) {
      let icon;
      const block = {
        c: function create() {
          icon = element("icon");
          attr_dev(icon, "class", "fe fe-eye-off");
          add_location(icon, file$9, 299, 24, 10879);
        },
        m: function mount(target, anchor) {
          insert_dev(target, icon, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(icon);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_5$2.name,
        type: "slot",
        source: "(294:20) <Button                          icon                          color=\\\"white\\\"                          style=\\\"width:32px;height:16px;\\\"                          on:click={toggle}                      >",
        ctx
      });
      return block;
    } // (226:20) <span                          slot="activador"                          on:click={() => (mostrarMenu = !mostrarMenu)}                          class=""                          >


    function create_activador_slot$3(ctx) {
      let span;
      let i;
      let mounted;
      let dispose;
      const block = {
        c: function create() {
          span = element("span");
          i = element("i");
          attr_dev(i, "class", "fe fe-more-vertical relative");
          add_location(i, file$9, 229, 25, 7976);
          attr_dev(span, "slot", "activador");
          attr_dev(span, "class", " svelte-17xdt9k");
          add_location(span, file$9, 225, 20, 7797);
        },
        m: function mount(target, anchor) {
          insert_dev(target, span, anchor);
          append_dev(span, i);

          if (!mounted) {
            dispose = listen_dev(span, "click",
            /*click_handler_4*/
            ctx[30], false, false, false);
            mounted = true;
          }
        },
        p: noop,
        d: function destroy(detaching) {
          if (detaching) detach_dev(span);
          mounted = false;
          dispose();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_activador_slot$3.name,
        type: "slot",
        source: "(226:20) <span                          slot=\\\"activador\\\"                          on:click={() => (mostrarMenu = !mostrarMenu)}                          class=\\\"\\\"                          >",
        ctx
      });
      return block;
    } // (249:20) {#if comentario.hiloId}


    function create_if_block_6$1(ctx) {
      let a;
      let menuitem;
      let a_href_value;
      let current;
      menuitem = new jn({
        props: {
          $$slots: {
            default: [create_default_slot_4$2]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          a = element("a");
          create_component(menuitem.$$.fragment);
          attr_dev(a, "href", a_href_value = "/Hilo/" +
          /*comentario*/
          ctx[0].hiloId + "#" +
          /*comentario*/
          ctx[0].id);
          set_style(a, "color", "white", 1);
          add_location(a, file$9, 249, 24, 8776);
        },
        m: function mount(target, anchor) {
          insert_dev(target, a, anchor);
          mount_component(menuitem, a, null);
          current = true;
        },
        p: function update(ctx, dirty) {
          const menuitem_changes = {};

          if (dirty[1] &
          /*$$scope*/
          32768) {
            menuitem_changes.$$scope = {
              dirty,
              ctx
            };
          }

          menuitem.$set(menuitem_changes);

          if (!current || dirty[0] &
          /*comentario*/
          1 && a_href_value !== (a_href_value = "/Hilo/" +
          /*comentario*/
          ctx[0].hiloId + "#" +
          /*comentario*/
          ctx[0].id)) {
            attr_dev(a, "href", a_href_value);
          }
        },
        i: function intro(local) {
          if (current) return;
          transition_in(menuitem.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(menuitem.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(a);
          destroy_component(menuitem);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_6$1.name,
        type: "if",
        source: "(249:20) {#if comentario.hiloId}",
        ctx
      });
      return block;
    } // (254:28) <Menuitem>


    function create_default_slot_4$2(ctx) {
      let t;
      const block = {
        c: function create() {
          t = text("Ir");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_4$2.name,
        type: "slot",
        source: "(254:28) <Menuitem>",
        ctx
      });
      return block;
    } // (257:20) <Menuitem                          on:click={() =>                              abrir.ban(                                  hilo.id || comentario.hiloId,                                  comentario.id                              )}>


    function create_default_slot_3$4(ctx) {
      let t;
      const block = {
        c: function create() {
          t = text("Banear");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_3$4.name,
        type: "slot",
        source: "(257:20) <Menuitem                          on:click={() =>                              abrir.ban(                                  hilo.id || comentario.hiloId,                                  comentario.id                              )}>",
        ctx
      });
      return block;
    } // (270:20) {:else}


    function create_else_block$1(ctx) {
      let menuitem;
      let current;
      menuitem = new jn({
        props: {
          $$slots: {
            default: [create_default_slot_2$4]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      menuitem.$on("click",
      /*click_handler_9*/
      ctx[35]);
      const block = {
        c: function create() {
          create_component(menuitem.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(menuitem, target, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          const menuitem_changes = {};

          if (dirty[1] &
          /*$$scope*/
          32768) {
            menuitem_changes.$$scope = {
              dirty,
              ctx
            };
          }

          menuitem.$set(menuitem_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(menuitem.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(menuitem.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(menuitem, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_else_block$1.name,
        type: "else",
        source: "(270:20) {:else}",
        ctx
      });
      return block;
    } // (264:20) {#if comentario.estado == ComentarioEstado.normal}


    function create_if_block_5$1(ctx) {
      let menuitem;
      let current;
      menuitem = new jn({
        props: {
          $$slots: {
            default: [create_default_slot_1$4]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      menuitem.$on("click",
      /*click_handler_8*/
      ctx[34]);
      const block = {
        c: function create() {
          create_component(menuitem.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(menuitem, target, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          const menuitem_changes = {};

          if (dirty[1] &
          /*$$scope*/
          32768) {
            menuitem_changes.$$scope = {
              dirty,
              ctx
            };
          }

          menuitem.$set(menuitem_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(menuitem.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(menuitem.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(menuitem, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_5$1.name,
        type: "if",
        source: "(264:20) {#if comentario.estado == ComentarioEstado.normal}",
        ctx
      });
      return block;
    } // (271:24) <Menuitem                              on:click={() =>                                  abrir.restaurarComentario(                                      hilo.id || comentario.hiloId,                                      comentario.id                                  )}>


    function create_default_slot_2$4(ctx) {
      let t;
      const block = {
        c: function create() {
          t = text("Restaurar");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_2$4.name,
        type: "slot",
        source: "(271:24) <Menuitem                              on:click={() =>                                  abrir.restaurarComentario(                                      hilo.id || comentario.hiloId,                                      comentario.id                                  )}>",
        ctx
      });
      return block;
    } // (265:24) <Menuitem                              on:click={() =>                                  abrir.eliminarComentarios([comentario.id])}                              >


    function create_default_slot_1$4(ctx) {
      let t;
      const block = {
        c: function create() {
          t = text("Eliminar");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_1$4.name,
        type: "slot",
        source: "(265:24) <Menuitem                              on:click={() =>                                  abrir.eliminarComentarios([comentario.id])}                              >",
        ctx
      });
      return block;
    } // (225:16) <Menu>


    function create_default_slot$5(ctx) {
      let t0;
      let li0;
      let t1_value = (
      /*visible*/
      ctx[8] ?
      /*comentario*/
      ctx[0].propio ? "Ignorar" : "Ocultar" : "Mostrar") + "";
      let t1;
      let t2;
      let li1;
      let t4;
      let hr;
      let t5;
      let t6;
      let menuitem;
      let t7;
      let current_block_type_index;
      let if_block1;
      let if_block1_anchor;
      let current;
      let mounted;
      let dispose;
      let if_block0 =
      /*comentario*/
      ctx[0].hiloId && create_if_block_6$1(ctx);
      menuitem = new jn({
        props: {
          $$slots: {
            default: [create_default_slot_3$4]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      menuitem.$on("click",
      /*click_handler_7*/
      ctx[33]);
      const if_block_creators = [create_if_block_5$1, create_else_block$1];
      const if_blocks = [];

      function select_block_type_2(ctx, dirty) {
        if (
        /*comentario*/
        ctx[0].estado == ComentarioEstado.normal) return 0;
        return 1;
      }

      current_block_type_index = select_block_type_2(ctx);
      if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
      const block = {
        c: function create() {
          t0 = space();
          li0 = element("li");
          t1 = text(t1_value);
          t2 = space();
          li1 = element("li");
          li1.textContent = "Reportar";
          t4 = space();
          hr = element("hr");
          t5 = space();
          if (if_block0) if_block0.c();
          t6 = space();
          create_component(menuitem.$$.fragment);
          t7 = space();
          if_block1.c();
          if_block1_anchor = empty();
          add_location(li0, file$9, 231, 20, 8069);
          add_location(li1, file$9, 238, 20, 8363);
          add_location(hr, file$9, 247, 20, 8699);
        },
        m: function mount(target, anchor) {
          insert_dev(target, t0, anchor);
          insert_dev(target, li0, anchor);
          append_dev(li0, t1);
          insert_dev(target, t2, anchor);
          insert_dev(target, li1, anchor);
          insert_dev(target, t4, anchor);
          insert_dev(target, hr, anchor);
          insert_dev(target, t5, anchor);
          if (if_block0) if_block0.m(target, anchor);
          insert_dev(target, t6, anchor);
          mount_component(menuitem, target, anchor);
          insert_dev(target, t7, anchor);
          if_blocks[current_block_type_index].m(target, anchor);
          insert_dev(target, if_block1_anchor, anchor);
          current = true;

          if (!mounted) {
            dispose = [listen_dev(li0, "click",
            /*click_handler_5*/
            ctx[31], false, false, false), listen_dev(li1, "click",
            /*click_handler_6*/
            ctx[32], false, false, false)];
            mounted = true;
          }
        },
        p: function update(ctx, dirty) {
          if ((!current || dirty[0] &
          /*visible, comentario*/
          257) && t1_value !== (t1_value = (
          /*visible*/
          ctx[8] ?
          /*comentario*/
          ctx[0].propio ? "Ignorar" : "Ocultar" : "Mostrar") + "")) set_data_dev(t1, t1_value);

          if (
          /*comentario*/
          ctx[0].hiloId) {
            if (if_block0) {
              if_block0.p(ctx, dirty);

              if (dirty[0] &
              /*comentario*/
              1) {
                transition_in(if_block0, 1);
              }
            } else {
              if_block0 = create_if_block_6$1(ctx);
              if_block0.c();
              transition_in(if_block0, 1);
              if_block0.m(t6.parentNode, t6);
            }
          } else if (if_block0) {
            group_outros();
            transition_out(if_block0, 1, 1, () => {
              if_block0 = null;
            });
            check_outros();
          }

          const menuitem_changes = {};

          if (dirty[1] &
          /*$$scope*/
          32768) {
            menuitem_changes.$$scope = {
              dirty,
              ctx
            };
          }

          menuitem.$set(menuitem_changes);
          let previous_block_index = current_block_type_index;
          current_block_type_index = select_block_type_2(ctx);

          if (current_block_type_index === previous_block_index) {
            if_blocks[current_block_type_index].p(ctx, dirty);
          } else {
            group_outros();
            transition_out(if_blocks[previous_block_index], 1, 1, () => {
              if_blocks[previous_block_index] = null;
            });
            check_outros();
            if_block1 = if_blocks[current_block_type_index];

            if (!if_block1) {
              if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
              if_block1.c();
            }

            transition_in(if_block1, 1);
            if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
          }
        },
        i: function intro(local) {
          if (current) return;
          transition_in(if_block0);
          transition_in(menuitem.$$.fragment, local);
          transition_in(if_block1);
          current = true;
        },
        o: function outro(local) {
          transition_out(if_block0);
          transition_out(menuitem.$$.fragment, local);
          transition_out(if_block1);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(t0);
          if (detaching) detach_dev(li0);
          if (detaching) detach_dev(t2);
          if (detaching) detach_dev(li1);
          if (detaching) detach_dev(t4);
          if (detaching) detach_dev(hr);
          if (detaching) detach_dev(t5);
          if (if_block0) if_block0.d(detaching);
          if (detaching) detach_dev(t6);
          destroy_component(menuitem, detaching);
          if (detaching) detach_dev(t7);
          if_blocks[current_block_type_index].d(detaching);
          if (detaching) detach_dev(if_block1_anchor);
          mounted = false;
          run_all(dispose);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot$5.name,
        type: "slot",
        source: "(225:16) <Menu>",
        ctx
      });
      return block;
    } // (307:4) {#if visible}


    function create_if_block_1$4(ctx) {
      let div;
      let t0;
      let t1;
      let span;
      let raw_value =
      /*comentario*/
      ctx[0].contenido + "";
      let current;
      let if_block0 =
      /*comentario*/
      ctx[0].media && create_if_block_3$2(ctx);
      let if_block1 =
      /*comentario*/
      ctx[0].audio && create_if_block_2$4(ctx);
      const block = {
        c: function create() {
          div = element("div");
          if (if_block0) if_block0.c();
          t0 = space();
          if (if_block1) if_block1.c();
          t1 = space();
          span = element("span");
          attr_dev(span, "class", "texto svelte-17xdt9k");
          add_location(span, file$9, 314, 12, 11385);
          attr_dev(div, "class", "contenido svelte-17xdt9k");
          toggle_class(div, "mediaExpandido",
          /*mediaExpandido*/
          ctx[7]);
          add_location(div, file$9, 307, 8, 11072);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          if (if_block0) if_block0.m(div, null);
          append_dev(div, t0);
          if (if_block1) if_block1.m(div, null);
          append_dev(div, t1);
          append_dev(div, span);
          span.innerHTML = raw_value;
          current = true;
        },
        p: function update(ctx, dirty) {
          if (
          /*comentario*/
          ctx[0].media) {
            if (if_block0) {
              if_block0.p(ctx, dirty);

              if (dirty[0] &
              /*comentario*/
              1) {
                transition_in(if_block0, 1);
              }
            } else {
              if_block0 = create_if_block_3$2(ctx);
              if_block0.c();
              transition_in(if_block0, 1);
              if_block0.m(div, t0);
            }
          } else if (if_block0) {
            group_outros();
            transition_out(if_block0, 1, 1, () => {
              if_block0 = null;
            });
            check_outros();
          }

          if (
          /*comentario*/
          ctx[0].audio) {
            if (if_block1) {
              if_block1.p(ctx, dirty);

              if (dirty[0] &
              /*comentario*/
              1) {
                transition_in(if_block1, 1);
              }
            } else {
              if_block1 = create_if_block_2$4(ctx);
              if_block1.c();
              transition_in(if_block1, 1);
              if_block1.m(div, t1);
            }
          } else if (if_block1) {
            group_outros();
            transition_out(if_block1, 1, 1, () => {
              if_block1 = null;
            });
            check_outros();
          }

          if ((!current || dirty[0] &
          /*comentario*/
          1) && raw_value !== (raw_value =
          /*comentario*/
          ctx[0].contenido + "")) span.innerHTML = raw_value;

          if (dirty[0] &
          /*mediaExpandido*/
          128) {
            toggle_class(div, "mediaExpandido",
            /*mediaExpandido*/
            ctx[7]);
          }
        },
        i: function intro(local) {
          if (current) return;
          transition_in(if_block0);
          transition_in(if_block1);
          current = true;
        },
        o: function outro(local) {
          transition_out(if_block0);
          transition_out(if_block1);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
          if (if_block0) if_block0.d();
          if (if_block1) if_block1.d();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_1$4.name,
        type: "if",
        source: "(307:4) {#if visible}",
        ctx
      });
      return block;
    } // (309:12) {#if comentario.media}


    function create_if_block_3$2(ctx) {
      let media;
      let updating_abierto;
      let current;

      function media_abierto_binding(value) {
        /*media_abierto_binding*/
        ctx[37].call(null, value);
      }

      let media_props = {
        media:
        /*comentario*/
        ctx[0].media
      };

      if (
      /*mediaExpandido*/
      ctx[7] !== void 0) {
        media_props.abierto =
        /*mediaExpandido*/
        ctx[7];
      }

      media = new Media({
        props: media_props,
        $$inline: true
      });
      binding_callbacks.push(() => bind(media, "abierto", media_abierto_binding));
      const block = {
        c: function create() {
          create_component(media.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(media, target, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          const media_changes = {};
          if (dirty[0] &
          /*comentario*/
          1) media_changes.media =
          /*comentario*/
          ctx[0].media;

          if (!updating_abierto && dirty[0] &
          /*mediaExpandido*/
          128) {
            updating_abierto = true;
            media_changes.abierto =
            /*mediaExpandido*/
            ctx[7];
            add_flush_callback(() => updating_abierto = false);
          }

          media.$set(media_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(media.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(media.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(media, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_3$2.name,
        type: "if",
        source: "(309:12) {#if comentario.media}",
        ctx
      });
      return block;
    } // (312:12) {#if comentario.audio}


    function create_if_block_2$4(ctx) {
      let audio;
      let current;
      audio = new Audio$1({
        props: {
          urlBlobAudio:
          /*comentario*/
          ctx[0].audio.url
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          create_component(audio.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(audio, target, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          const audio_changes = {};
          if (dirty[0] &
          /*comentario*/
          1) audio_changes.urlBlobAudio =
          /*comentario*/
          ctx[0].audio.url;
          audio.$set(audio_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(audio.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(audio.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(audio, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_2$4.name,
        type: "if",
        source: "(312:12) {#if comentario.audio}",
        ctx
      });
      return block;
    } // (320:4) {#if mostrandoRespuesta}


    function create_if_block$7(ctx) {
      let div;
      let comentario_1;
      let div_transition;
      let current;
      comentario_1 = new Comentario({
        props: {
          comentario:
          /*respuestaMostrada*/
          ctx[6],
          esRespuesta: true
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          div = element("div");
          create_component(comentario_1.$$.fragment);
          attr_dev(div, "class", "comentario-flotante");
          add_location(div, file$9, 320, 8, 11539);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          mount_component(comentario_1, div, null);
          current = true;
        },
        p: function update(ctx, dirty) {
          const comentario_1_changes = {};
          if (dirty[0] &
          /*respuestaMostrada*/
          64) comentario_1_changes.comentario =
          /*respuestaMostrada*/
          ctx[6];
          comentario_1.$set(comentario_1_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(comentario_1.$$.fragment, local);

          if (local) {
            add_render_callback(() => {
              if (!div_transition) div_transition = create_bidirectional_transition(div, fly, {
                x: -50,
                duration: 150
              }, true);
              div_transition.run(1);
            });
          }

          current = true;
        },
        o: function outro(local) {
          transition_out(comentario_1.$$.fragment, local);

          if (local) {
            if (!div_transition) div_transition = create_bidirectional_transition(div, fly, {
              x: -50,
              duration: 150
            }, false);
            div_transition.run(0);
          }

          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
          destroy_component(comentario_1);
          if (detaching && div_transition) div_transition.end();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block$7.name,
        type: "if",
        source: "(320:4) {#if mostrandoRespuesta}",
        ctx
      });
      return block;
    }

    function create_fragment$9(ctx) {
      let div4;
      let t0;
      let div0;
      let div0_class_value;
      let t1;
      let div2;
      let t2;
      let span0;
      let t3_value = (
      /*comentario*/
      ctx[0].nombre || "Gordo") + "";
      let t3;
      let t4;
      let t5;
      let t6;
      let t7;
      let span1;
      let t8_value =
      /*comentario*/
      ctx[0].id + "";
      let t8;
      let t9;
      let span2;
      let tiempo;
      let t10;
      let div1;
      let current_block_type_index;
      let if_block6;
      let t11;
      let div3;
      let t12;
      let t13;
      let div4_class_value;
      let div4_r_id_value;
      let div4_id_value;
      let div4_style_value;
      let current;
      let mounted;
      let dispose;
      let if_block0 =
      /*comentario*/
      ctx[0].respuestas &&
      /*comentario*/
      ctx[0].respuestas.length > 0 && create_if_block_13$1(ctx);

      function select_block_type(ctx, dirty) {
        if (
        /*comentario*/
        ctx[0].dados != undefined &&
        /*comentario*/
        ctx[0].dados != -1) return create_if_block_11$1;
        if (
        /*comentario*/
        ctx[0].rango) return create_if_block_12$1;
        return create_else_block_2$1;
      }

      let current_block_type = select_block_type(ctx);
      let if_block1 = current_block_type(ctx);
      let if_block2 =
      /*comentario*/
      ctx[0].esOp && create_if_block_10$1(ctx);
      let if_block3 =
      /*comentario*/
      ctx[0].banderita && create_if_block_9$1(ctx);
      let if_block4 =
      /*comentario*/
      ctx[0].idUnico && create_if_block_8$1(ctx);
      let if_block5 =
      /*comentario*/
      ctx[0].usuarioId && create_if_block_7$1(ctx);
      tiempo = new Tiempo({
        props: {
          date:
          /*comentario*/
          ctx[0].creacion
        },
        $$inline: true
      });
      const if_block_creators = [create_if_block_4$1, create_else_block_1$1];
      const if_blocks = [];

      function select_block_type_1(ctx, dirty) {
        if (
        /*$globalStore*/
        ctx[10].usuario.esMod ||
        /*$globalStore*/
        ctx[10].usuario.esAuxiliar) return 0;
        return 1;
      }

      current_block_type_index = select_block_type_1(ctx);
      if_block6 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
      let if_block7 =
      /*visible*/
      ctx[8] && create_if_block_1$4(ctx);
      let if_block8 =
      /*mostrandoRespuesta*/
      ctx[5] && create_if_block$7(ctx);
      const block = {
        c: function create() {
          div4 = element("div");
          if (if_block0) if_block0.c();
          t0 = space();
          div0 = element("div");
          if_block1.c();
          t1 = space();
          div2 = element("div");
          if (if_block2) if_block2.c();
          t2 = space();
          span0 = element("span");
          t3 = text(t3_value);
          t4 = space();
          if (if_block3) if_block3.c();
          t5 = space();
          if (if_block4) if_block4.c();
          t6 = space();
          if (if_block5) if_block5.c();
          t7 = space();
          span1 = element("span");
          t8 = text(t8_value);
          t9 = space();
          span2 = element("span");
          create_component(tiempo.$$.fragment);
          t10 = space();
          div1 = element("div");
          if_block6.c();
          t11 = space();
          div3 = element("div");
          t12 = space();
          if (if_block7) if_block7.c();
          t13 = space();
          if (if_block8) if_block8.c();
          attr_dev(div0, "class", div0_class_value = "color color-" +
          /*comentario*/
          ctx[0].color + " ns" + " svelte-17xdt9k");
          toggle_class(div0, "dado",
          /*comentario*/
          ctx[0].dados != undefined &&
          /*comentario*/
          ctx[0].dados != -1);
          add_location(div0, file$9, 172, 4, 5750);
          attr_dev(span0, "class", "nick nombre cptr svelte-17xdt9k");
          toggle_class(span0, "nombreResaltado",
          /*comentario*/
          ctx[0].nombre);
          add_location(span0, file$9, 187, 8, 6334);
          attr_dev(span1, "class", "id tag ns svelte-17xdt9k");
          add_location(span1, file$9, 217, 8, 7469);
          attr_dev(span2, "class", "tiempo svelte-17xdt9k");
          add_location(span2, file$9, 220, 8, 7588);
          add_location(div1, file$9, 222, 8, 7665);
          attr_dev(div2, "class", "header svelte-17xdt9k");
          add_location(div2, file$9, 185, 4, 6228);
          attr_dev(div3, "class", "respuestas svelte-17xdt9k");
          add_location(div3, file$9, 305, 4, 11017);
          attr_dev(div4, "class", div4_class_value = "comentario " + (
          /*windowsWidh*/
          ctx[12] <= 400 ? "comentario-movil" : "") + " svelte-17xdt9k");
          attr_dev(div4, "r-id", div4_r_id_value =
          /*comentario*/
          ctx[0].id);
          attr_dev(div4, "id", div4_id_value = "" + (
          /*comentario*/
          ctx[0].id + (
          /*esRespuesta*/
          ctx[3] ? "-res" : "")));
          attr_dev(div4, "style", div4_style_value =
          /*comentario*/
          ctx[0].respuestas &&
          /*comentario*/
          ctx[0].respuestas.length > 0 ? "padding-bottom: 20px" : "");
          toggle_class(div4, "resaltado",
          /*comentario*/
          ctx[0].resaltado ||
          /*resaltado*/
          ctx[2] ||
          /*$selectorStore*/
          ctx[11].seleccionados.has(
          /*comentario*/
          ctx[0].id));
          toggle_class(div4, "eliminado",
          /*comentario*/
          ctx[0].estado == ComentarioEstado.eliminado);
          toggle_class(div4, "comentarioMod",
          /*comentario*/
          ctx[0].rango > CreacionRango.Auxliar);
          toggle_class(div4, "comentarioAuxiliar",
          /*comentario*/
          ctx[0].rango == CreacionRango.Auxliar);
          toggle_class(div4, "propio",
          /*comentario*/
          ctx[0].propio);
          add_location(div4, file$9, 135, 0, 4294);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, div4, anchor);
          if (if_block0) if_block0.m(div4, null);
          append_dev(div4, t0);
          append_dev(div4, div0);
          if_block1.m(div0, null);
          append_dev(div4, t1);
          append_dev(div4, div2);
          if (if_block2) if_block2.m(div2, null);
          append_dev(div2, t2);
          append_dev(div2, span0);
          append_dev(span0, t3);
          append_dev(div2, t4);
          if (if_block3) if_block3.m(div2, null);
          append_dev(div2, t5);
          if (if_block4) if_block4.m(div2, null);
          append_dev(div2, t6);
          if (if_block5) if_block5.m(div2, null);
          append_dev(div2, t7);
          append_dev(div2, span1);
          append_dev(span1, t8);
          append_dev(div2, t9);
          append_dev(div2, span2);
          mount_component(tiempo, span2, null);
          append_dev(div2, t10);
          append_dev(div2, div1);
          if_blocks[current_block_type_index].m(div1, null);
          append_dev(div4, t11);
          append_dev(div4, div3);
          append_dev(div4, t12);
          if (if_block7) if_block7.m(div4, null);
          append_dev(div4, t13);
          if (if_block8) if_block8.m(div4, null);
          /*div4_binding*/

          ctx[38](div4);
          current = true;

          if (!mounted) {
            dispose = [listen_dev(div0, "click",
            /*click_handler_1*/
            ctx[27], false, false, false), listen_dev(span0, "click",
            /*seleccionar*/
            ctx[17], false, false, false), listen_dev(span1, "click",
            /*click_handler_3*/
            ctx[29], false, false, false), listen_dev(div4, "contextmenu",
            /*onContexMenu*/
            ctx[21], false, false, false)];
            mounted = true;
          }
        },
        p: function update(ctx, dirty) {
          if (
          /*comentario*/
          ctx[0].respuestas &&
          /*comentario*/
          ctx[0].respuestas.length > 0) {
            if (if_block0) {
              if_block0.p(ctx, dirty);
            } else {
              if_block0 = create_if_block_13$1(ctx);
              if_block0.c();
              if_block0.m(div4, t0);
            }
          } else if (if_block0) {
            if_block0.d(1);
            if_block0 = null;
          }

          if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block1) {
            if_block1.p(ctx, dirty);
          } else {
            if_block1.d(1);
            if_block1 = current_block_type(ctx);

            if (if_block1) {
              if_block1.c();
              if_block1.m(div0, null);
            }
          }

          if (!current || dirty[0] &
          /*comentario*/
          1 && div0_class_value !== (div0_class_value = "color color-" +
          /*comentario*/
          ctx[0].color + " ns" + " svelte-17xdt9k")) {
            attr_dev(div0, "class", div0_class_value);
          }

          if (dirty[0] &
          /*comentario, comentario*/
          1) {
            toggle_class(div0, "dado",
            /*comentario*/
            ctx[0].dados != undefined &&
            /*comentario*/
            ctx[0].dados != -1);
          }

          if (
          /*comentario*/
          ctx[0].esOp) {
            if (if_block2) ; else {
              if_block2 = create_if_block_10$1(ctx);
              if_block2.c();
              if_block2.m(div2, t2);
            }
          } else if (if_block2) {
            if_block2.d(1);
            if_block2 = null;
          }

          if ((!current || dirty[0] &
          /*comentario*/
          1) && t3_value !== (t3_value = (
          /*comentario*/
          ctx[0].nombre || "Gordo") + "")) set_data_dev(t3, t3_value);

          if (dirty[0] &
          /*comentario*/
          1) {
            toggle_class(span0, "nombreResaltado",
            /*comentario*/
            ctx[0].nombre);
          }

          if (
          /*comentario*/
          ctx[0].banderita) {
            if (if_block3) {
              if_block3.p(ctx, dirty);
            } else {
              if_block3 = create_if_block_9$1(ctx);
              if_block3.c();
              if_block3.m(div2, t5);
            }
          } else if (if_block3) {
            if_block3.d(1);
            if_block3 = null;
          }

          if (
          /*comentario*/
          ctx[0].idUnico) {
            if (if_block4) {
              if_block4.p(ctx, dirty);

              if (dirty[0] &
              /*comentario*/
              1) {
                transition_in(if_block4, 1);
              }
            } else {
              if_block4 = create_if_block_8$1(ctx);
              if_block4.c();
              transition_in(if_block4, 1);
              if_block4.m(div2, t6);
            }
          } else if (if_block4) {
            group_outros();
            transition_out(if_block4, 1, 1, () => {
              if_block4 = null;
            });
            check_outros();
          }

          if (
          /*comentario*/
          ctx[0].usuarioId) {
            if (if_block5) {
              if_block5.p(ctx, dirty);
            } else {
              if_block5 = create_if_block_7$1(ctx);
              if_block5.c();
              if_block5.m(div2, t7);
            }
          } else if (if_block5) {
            if_block5.d(1);
            if_block5 = null;
          }

          if ((!current || dirty[0] &
          /*comentario*/
          1) && t8_value !== (t8_value =
          /*comentario*/
          ctx[0].id + "")) set_data_dev(t8, t8_value);
          const tiempo_changes = {};
          if (dirty[0] &
          /*comentario*/
          1) tiempo_changes.date =
          /*comentario*/
          ctx[0].creacion;
          tiempo.$set(tiempo_changes);
          let previous_block_index = current_block_type_index;
          current_block_type_index = select_block_type_1(ctx);

          if (current_block_type_index === previous_block_index) {
            if_blocks[current_block_type_index].p(ctx, dirty);
          } else {
            group_outros();
            transition_out(if_blocks[previous_block_index], 1, 1, () => {
              if_blocks[previous_block_index] = null;
            });
            check_outros();
            if_block6 = if_blocks[current_block_type_index];

            if (!if_block6) {
              if_block6 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
              if_block6.c();
            }

            transition_in(if_block6, 1);
            if_block6.m(div1, null);
          }

          if (
          /*visible*/
          ctx[8]) {
            if (if_block7) {
              if_block7.p(ctx, dirty);

              if (dirty[0] &
              /*visible*/
              256) {
                transition_in(if_block7, 1);
              }
            } else {
              if_block7 = create_if_block_1$4(ctx);
              if_block7.c();
              transition_in(if_block7, 1);
              if_block7.m(div4, t13);
            }
          } else if (if_block7) {
            group_outros();
            transition_out(if_block7, 1, 1, () => {
              if_block7 = null;
            });
            check_outros();
          }

          if (
          /*mostrandoRespuesta*/
          ctx[5]) {
            if (if_block8) {
              if_block8.p(ctx, dirty);

              if (dirty[0] &
              /*mostrandoRespuesta*/
              32) {
                transition_in(if_block8, 1);
              }
            } else {
              if_block8 = create_if_block$7(ctx);
              if_block8.c();
              transition_in(if_block8, 1);
              if_block8.m(div4, null);
            }
          } else if (if_block8) {
            group_outros();
            transition_out(if_block8, 1, 1, () => {
              if_block8 = null;
            });
            check_outros();
          }

          if (!current || dirty[0] &
          /*comentario*/
          1 && div4_r_id_value !== (div4_r_id_value =
          /*comentario*/
          ctx[0].id)) {
            attr_dev(div4, "r-id", div4_r_id_value);
          }

          if (!current || dirty[0] &
          /*comentario, esRespuesta*/
          9 && div4_id_value !== (div4_id_value = "" + (
          /*comentario*/
          ctx[0].id + (
          /*esRespuesta*/
          ctx[3] ? "-res" : "")))) {
            attr_dev(div4, "id", div4_id_value);
          }

          if (!current || dirty[0] &
          /*comentario*/
          1 && div4_style_value !== (div4_style_value =
          /*comentario*/
          ctx[0].respuestas &&
          /*comentario*/
          ctx[0].respuestas.length > 0 ? "padding-bottom: 20px" : "")) {
            attr_dev(div4, "style", div4_style_value);
          }

          if (dirty[0] &
          /*comentario, resaltado, $selectorStore*/
          2053) {
            toggle_class(div4, "resaltado",
            /*comentario*/
            ctx[0].resaltado ||
            /*resaltado*/
            ctx[2] ||
            /*$selectorStore*/
            ctx[11].seleccionados.has(
            /*comentario*/
            ctx[0].id));
          }

          if (dirty[0] &
          /*comentario*/
          1) {
            toggle_class(div4, "eliminado",
            /*comentario*/
            ctx[0].estado == ComentarioEstado.eliminado);
          }

          if (dirty[0] &
          /*comentario*/
          1) {
            toggle_class(div4, "comentarioMod",
            /*comentario*/
            ctx[0].rango > CreacionRango.Auxliar);
          }

          if (dirty[0] &
          /*comentario*/
          1) {
            toggle_class(div4, "comentarioAuxiliar",
            /*comentario*/
            ctx[0].rango == CreacionRango.Auxliar);
          }

          if (dirty[0] &
          /*comentario*/
          1) {
            toggle_class(div4, "propio",
            /*comentario*/
            ctx[0].propio);
          }
        },
        i: function intro(local) {
          if (current) return;
          transition_in(if_block4);
          transition_in(tiempo.$$.fragment, local);
          transition_in(if_block6);
          transition_in(if_block7);
          transition_in(if_block8);
          current = true;
        },
        o: function outro(local) {
          transition_out(if_block4);
          transition_out(tiempo.$$.fragment, local);
          transition_out(if_block6);
          transition_out(if_block7);
          transition_out(if_block8);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div4);
          if (if_block0) if_block0.d();
          if_block1.d();
          if (if_block2) if_block2.d();
          if (if_block3) if_block3.d();
          if (if_block4) if_block4.d();
          if (if_block5) if_block5.d();
          destroy_component(tiempo);
          if_blocks[current_block_type_index].d();
          if (if_block7) if_block7.d();
          if (if_block8) if_block8.d();
          /*div4_binding*/

          ctx[38](null);
          mounted = false;
          run_all(dispose);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$9.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }

    function instance$9($$self, $$props, $$invalidate) {
      let $globalStore;
      let $ajustesConfigStore;
      let $comentarioStore;
      let $selectorStore;
      validate_store(globalStore, "globalStore");
      component_subscribe($$self, globalStore, $$value => $$invalidate(10, $globalStore = $$value));
      validate_store(ajustesConfigStore, "ajustesConfigStore");
      component_subscribe($$self, ajustesConfigStore, $$value => $$invalidate(39, $ajustesConfigStore = $$value));
      validate_store(comentarioStore, "comentarioStore");
      component_subscribe($$self, comentarioStore, $$value => $$invalidate(40, $comentarioStore = $$value));
      validate_store(selectorStore, "selectorStore");
      component_subscribe($$self, selectorStore, $$value => $$invalidate(11, $selectorStore = $$value));
      let {
        $$slots: slots = {},
        $$scope
      } = $$props;
      validate_slots("Comentario", slots, []);
      let {
        comentario
      } = $$props;
      let {
        hilo = {
          id: null
        }
      } = $$props;
      let {
        comentariosDic = {}
      } = $$props;
      let {
        resaltado = false
      } = $$props;
      let {
        prevenirScroll = $globalStore.esCelular && !$ajustesConfigStore.tagClasico
      } = $$props;
      let {
        respuetasCompactas = false
      } = $$props;
      let {
        esRespuesta = false
      } = $$props;
      comentario.estado = comentario.estado || ComentarioEstado.normal;
      let el;
      let mostrandoRespuesta = false;
      let respuestaMostrada;
      let mediaExpandido = false;
      let windowsWidh = window.screen.width;
      let visible = !$globalStore.comentariosOcultos.has(comentario.id);
      let dispatch = createEventDispatcher();
      let mostrarMenu = false;
      onMount(() => {
        let respuestas = el.querySelectorAll(".restag");
        respuestas.forEach(r => {
          r.addEventListener("mouseover", () => mostrarRespuesta(r.getAttribute("r-id").trim()));
          r.addEventListener("mouseleave", ocultarRespuesta);
          r.addEventListener("click", e => {
            resaltarCliqueado(r.getAttribute("r-id").trim());

            if (prevenirScroll) {
              e.preventDefault();
            } else {
              irAComentario(r.getAttribute("r-id").trim());
            }
          });
        });
      });

      function mostrarRespuesta(id) {
        if (!comentariosDic[id]) return;
        $$invalidate(5, mostrandoRespuesta = true);
        $$invalidate(6, respuestaMostrada = comentariosDic[id]);
      }

      function resaltarCliqueado(id) {
        dispatch("tagClickeado", id);
      }

      function irAComentario(id) {
        dispatch("irAComentario", id);
      }

      function ocultarRespuesta() {
        $$invalidate(5, mostrandoRespuesta = false);
      }

      function toggle() {
        if (visible) {
          $globalStore.comentariosOcultos.set(comentario.id, true);
        } else {
          $globalStore.comentariosOcultos.delete(comentario.id);
        }

        globalStore.set($globalStore);
        $$invalidate(8, visible = !visible);
      }

      function seleccionar() {
        if (!$globalStore.usuario.esMod) return;
        selectorStore.selecionar(comentario.id);
      }

      if (!Array.isArray(comentario.respuestas)) comentario.respuestas = [];

      function tagear(id) {
        if (!$comentarioStore.includes(`>>${comentario.id}\n`)) set_store_value(comentarioStore, $comentarioStore += `>>${comentario.id}\n`, $comentarioStore);
      }

      function esOp(comentarioId) {
        let comentario = comentariosDic[comentarioId] || {
          esOp: false
        }; //??quitado

        return comentario.esOp;
      }

      function idUnicoColor() {
        let coloresPosibles = ["#7bd800", "#00d87e", "#006ad8", "#3500d8", "#8500d8", "#d80096", "#737679", "#5d130b", "#ec64e2", "#ff5722"];
        let n = comentario.idUnico.charCodeAt(0) + comentario.idUnico.charCodeAt(1) + comentario.idUnico.charCodeAt(2);
        return coloresPosibles[n % coloresPosibles.length - 1];
      }

      async function onContexMenu(e) {
        if (teclas.estaPresionada("x") && $globalStore.usuario.esMod) {
          e.preventDefault();
          RChanClient.eliminarComentarios([comentario.id]);
        }
      }

      const writable_props = ["comentario", "hilo", "comentariosDic", "resaltado", "prevenirScroll", "respuetasCompactas", "esRespuesta"];
      Object.keys($$props).forEach(key => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Comentario> was created with unknown prop '${key}'`);
      });

      const click_handler = () => dispatch("motrarRespuestas", comentario.id);

      const mouseover_handler = r => mostrarRespuesta(r);

      const click_handler_1 = () => dispatch("colorClick", comentario);

      const click_handler_2 = () => dispatch("idUnicoClickeado", comentario.idUnico);

      const click_handler_3 = () => tagear(comentario.id);

      const click_handler_4 = () => $$invalidate(9, mostrarMenu = !mostrarMenu);

      const click_handler_5 = () => toggle();

      const click_handler_6 = () => abrir.reporte(hilo.id || comentario.hiloId, comentario.id);

      const click_handler_7 = () => abrir.ban(hilo.id || comentario.hiloId, comentario.id);

      const click_handler_8 = () => abrir.eliminarComentarios([comentario.id]);

      const click_handler_9 = () => abrir.restaurarComentario(hilo.id || comentario.hiloId, comentario.id);

      const click_handler_10 = () => abrir.reporte(hilo.id || comentario.hiloId, comentario.id);

      function media_abierto_binding(value) {
        mediaExpandido = value;
        $$invalidate(7, mediaExpandido);
      }

      function div4_binding($$value) {
        binding_callbacks[$$value ? "unshift" : "push"](() => {
          el = $$value;
          $$invalidate(4, el);
        });
      }

      $$self.$$set = $$props => {
        if ("comentario" in $$props) $$invalidate(0, comentario = $$props.comentario);
        if ("hilo" in $$props) $$invalidate(1, hilo = $$props.hilo);
        if ("comentariosDic" in $$props) $$invalidate(22, comentariosDic = $$props.comentariosDic);
        if ("resaltado" in $$props) $$invalidate(2, resaltado = $$props.resaltado);
        if ("prevenirScroll" in $$props) $$invalidate(23, prevenirScroll = $$props.prevenirScroll);
        if ("respuetasCompactas" in $$props) $$invalidate(24, respuetasCompactas = $$props.respuetasCompactas);
        if ("esRespuesta" in $$props) $$invalidate(3, esRespuesta = $$props.esRespuesta);
      };

      $$self.$capture_state = () => ({
        onMount,
        createEventDispatcher,
        Menuitem: jn,
        Button: ye,
        Icon: Me,
        Ripple: he,
        Menu: Menu_1,
        comentarioStore,
        fly,
        ajustesConfigStore,
        Tiempo,
        globalStore,
        Media,
        abrir,
        ComentarioEstado,
        CreacionRango,
        selectorStore,
        teclas,
        RChanClient,
        Audio: Audio$1,
        comentario,
        hilo,
        comentariosDic,
        resaltado,
        prevenirScroll,
        respuetasCompactas,
        esRespuesta,
        el,
        mostrandoRespuesta,
        respuestaMostrada,
        mediaExpandido,
        windowsWidh,
        visible,
        dispatch,
        mostrarMenu,
        mostrarRespuesta,
        resaltarCliqueado,
        irAComentario,
        ocultarRespuesta,
        toggle,
        seleccionar,
        tagear,
        esOp,
        idUnicoColor,
        onContexMenu,
        $globalStore,
        $ajustesConfigStore,
        $comentarioStore,
        $selectorStore
      });

      $$self.$inject_state = $$props => {
        if ("comentario" in $$props) $$invalidate(0, comentario = $$props.comentario);
        if ("hilo" in $$props) $$invalidate(1, hilo = $$props.hilo);
        if ("comentariosDic" in $$props) $$invalidate(22, comentariosDic = $$props.comentariosDic);
        if ("resaltado" in $$props) $$invalidate(2, resaltado = $$props.resaltado);
        if ("prevenirScroll" in $$props) $$invalidate(23, prevenirScroll = $$props.prevenirScroll);
        if ("respuetasCompactas" in $$props) $$invalidate(24, respuetasCompactas = $$props.respuetasCompactas);
        if ("esRespuesta" in $$props) $$invalidate(3, esRespuesta = $$props.esRespuesta);
        if ("el" in $$props) $$invalidate(4, el = $$props.el);
        if ("mostrandoRespuesta" in $$props) $$invalidate(5, mostrandoRespuesta = $$props.mostrandoRespuesta);
        if ("respuestaMostrada" in $$props) $$invalidate(6, respuestaMostrada = $$props.respuestaMostrada);
        if ("mediaExpandido" in $$props) $$invalidate(7, mediaExpandido = $$props.mediaExpandido);
        if ("windowsWidh" in $$props) $$invalidate(12, windowsWidh = $$props.windowsWidh);
        if ("visible" in $$props) $$invalidate(8, visible = $$props.visible);
        if ("dispatch" in $$props) $$invalidate(13, dispatch = $$props.dispatch);
        if ("mostrarMenu" in $$props) $$invalidate(9, mostrarMenu = $$props.mostrarMenu);
      };

      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }

      return [comentario, hilo, resaltado, esRespuesta, el, mostrandoRespuesta, respuestaMostrada, mediaExpandido, visible, mostrarMenu, $globalStore, $selectorStore, windowsWidh, dispatch, mostrarRespuesta, ocultarRespuesta, toggle, seleccionar, tagear, esOp, idUnicoColor, onContexMenu, comentariosDic, prevenirScroll, respuetasCompactas, click_handler, mouseover_handler, click_handler_1, click_handler_2, click_handler_3, click_handler_4, click_handler_5, click_handler_6, click_handler_7, click_handler_8, click_handler_9, click_handler_10, media_abierto_binding, div4_binding];
    }

    class Comentario extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$9, create_fragment$9, safe_not_equal, {
          comentario: 0,
          hilo: 1,
          comentariosDic: 22,
          resaltado: 2,
          prevenirScroll: 23,
          respuetasCompactas: 24,
          esRespuesta: 3
        }, [-1, -1]);
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "Comentario",
          options,
          id: create_fragment$9.name
        });
        const {
          ctx
        } = this.$$;
        const props = options.props || {};

        if (
        /*comentario*/
        ctx[0] === undefined && !("comentario" in props)) {
          console.warn("<Comentario> was created without expected prop 'comentario'");
        }
      }

      get comentario() {
        throw new Error("<Comentario>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set comentario(value) {
        throw new Error("<Comentario>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get hilo() {
        throw new Error("<Comentario>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set hilo(value) {
        throw new Error("<Comentario>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get comentariosDic() {
        throw new Error("<Comentario>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set comentariosDic(value) {
        throw new Error("<Comentario>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get resaltado() {
        throw new Error("<Comentario>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set resaltado(value) {
        throw new Error("<Comentario>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get prevenirScroll() {
        throw new Error("<Comentario>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set prevenirScroll(value) {
        throw new Error("<Comentario>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get respuetasCompactas() {
        throw new Error("<Comentario>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set respuetasCompactas(value) {
        throw new Error("<Comentario>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get esRespuesta() {
        throw new Error("<Comentario>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set esRespuesta(value) {
        throw new Error("<Comentario>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

    }

    /* src\components\MediaInput.svelte generated by Svelte v3.29.0 */
    const file$a = "src\\components\\MediaInput.svelte"; // (158:4) {#if mediaType == MediaType.Video && media.archivo}

    function create_if_block_3$3(ctx) {
      let video;
      let video_src_value;
      const block = {
        c: function create() {
          video = element("video");
          if (video.src !== (video_src_value =
          /*archivoBlob*/
          ctx[3])) attr_dev(video, "src", video_src_value);
          attr_dev(video, "class", "svelte-1w0yc3o");
          add_location(video, file$a, 158, 8, 5246);
        },
        m: function mount(target, anchor) {
          insert_dev(target, video, anchor);
        },
        p: function update(ctx, dirty) {
          if (dirty &
          /*archivoBlob*/
          8 && video.src !== (video_src_value =
          /*archivoBlob*/
          ctx[3])) {
            attr_dev(video, "src", video_src_value);
          }
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(video);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_3$3.name,
        type: "if",
        source: "(158:4) {#if mediaType == MediaType.Video && media.archivo}",
        ctx
      });
      return block;
    } // (162:4) {#if estado == "importarLink"}


    function create_if_block_2$5(ctx) {
      let div;
      let input_1;
      let t;
      let buttongroup;
      let current;
      let mounted;
      let dispose;
      buttongroup = new $e({
        props: {
          $$slots: {
            default: [create_default_slot_4$3]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          div = element("div");
          input_1 = element("input");
          t = space();
          create_component(buttongroup.$$.fragment);
          attr_dev(input_1, "type", "text");
          attr_dev(input_1, "placeholder", "Importar video, imagen, link de youtube, bitchute, dailymotion o pornhub");
          add_location(input_1, file$a, 163, 12, 5370);
          attr_dev(div, "class", "link-input svelte-1w0yc3o");
          add_location(div, file$a, 162, 8, 5332);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          append_dev(div, input_1);
          set_input_value(input_1,
          /*inputLink*/
          ctx[7]);
          append_dev(div, t);
          mount_component(buttongroup, div, null);
          current = true;

          if (!mounted) {
            dispose = listen_dev(input_1, "input",
            /*input_1_input_handler*/
            ctx[13]);
            mounted = true;
          }
        },
        p: function update(ctx, dirty) {
          if (dirty &
          /*inputLink*/
          128 && input_1.value !==
          /*inputLink*/
          ctx[7]) {
            set_input_value(input_1,
            /*inputLink*/
            ctx[7]);
          }

          const buttongroup_changes = {};

          if (dirty &
          /*$$scope, estado*/
          2097408) {
            buttongroup_changes.$$scope = {
              dirty,
              ctx
            };
          }

          buttongroup.$set(buttongroup_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(buttongroup.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(buttongroup.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
          destroy_component(buttongroup);
          mounted = false;
          dispose();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_2$5.name,
        type: "if",
        source: "(162:4) {#if estado == \\\"importarLink\\\"}",
        ctx
      });
      return block;
    } // (170:16) <Button outlined shaped={true} on:click={importarVideo}>


    function create_default_slot_6$3(ctx) {
      let icon;
      const block = {
        c: function create() {
          icon = element("icon");
          icon.textContent = "OK";
          add_location(icon, file$a, 170, 20, 5688);
        },
        m: function mount(target, anchor) {
          insert_dev(target, icon, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(icon);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_6$3.name,
        type: "slot",
        source: "(170:16) <Button outlined shaped={true} on:click={importarVideo}>",
        ctx
      });
      return block;
    } // (173:16) <Button                      outlined                      shaped={true}                      on:click={() => (estado = "vacio")}                  >


    function create_default_slot_5$3(ctx) {
      let icon;
      const block = {
        c: function create() {
          icon = element("icon");
          icon.textContent = "x";
          add_location(icon, file$a, 177, 20, 5918);
        },
        m: function mount(target, anchor) {
          insert_dev(target, icon, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(icon);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_5$3.name,
        type: "slot",
        source: "(173:16) <Button                      outlined                      shaped={true}                      on:click={() => (estado = \\\"vacio\\\")}                  >",
        ctx
      });
      return block;
    } // (169:12) <ButtonGroup>


    function create_default_slot_4$3(ctx) {
      let button0;
      let t;
      let button1;
      let current;
      button0 = new ye({
        props: {
          outlined: true,
          shaped: true,
          $$slots: {
            default: [create_default_slot_6$3]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      button0.$on("click",
      /*importarVideo*/
      ctx[10]);
      button1 = new ye({
        props: {
          outlined: true,
          shaped: true,
          $$slots: {
            default: [create_default_slot_5$3]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      button1.$on("click",
      /*click_handler*/
      ctx[14]);
      const block = {
        c: function create() {
          create_component(button0.$$.fragment);
          t = space();
          create_component(button1.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(button0, target, anchor);
          insert_dev(target, t, anchor);
          mount_component(button1, target, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          const button0_changes = {};

          if (dirty &
          /*$$scope*/
          2097152) {
            button0_changes.$$scope = {
              dirty,
              ctx
            };
          }

          button0.$set(button0_changes);
          const button1_changes = {};

          if (dirty &
          /*$$scope*/
          2097152) {
            button1_changes.$$scope = {
              dirty,
              ctx
            };
          }

          button1.$set(button1_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(button0.$$.fragment, local);
          transition_in(button1.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(button0.$$.fragment, local);
          transition_out(button1.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(button0, detaching);
          if (detaching) detach_dev(t);
          destroy_component(button1, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_4$3.name,
        type: "slot",
        source: "(169:12) <ButtonGroup>",
        ctx
      });
      return block;
    } // (183:4) {#if !media.archivo && estado == "vacio"}


    function create_if_block_1$5(ctx) {
      let span;
      let t;
      let buttongroup;
      let current;
      buttongroup = new $e({
        props: {
          $$slots: {
            default: [create_default_slot_1$5]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          span = element("span");
          t = text("Agrega un archivo:\r\n            ");
          create_component(buttongroup.$$.fragment);
          attr_dev(span, "class", "opciones svelte-1w0yc3o");
          add_location(span, file$a, 183, 8, 6071);
        },
        m: function mount(target, anchor) {
          insert_dev(target, span, anchor);
          append_dev(span, t);
          mount_component(buttongroup, span, null);
          current = true;
        },
        p: function update(ctx, dirty) {
          const buttongroup_changes = {};

          if (dirty &
          /*$$scope, estado, input*/
          2097424) {
            buttongroup_changes.$$scope = {
              dirty,
              ctx
            };
          }

          buttongroup.$set(buttongroup_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(buttongroup.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(buttongroup.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(span);
          destroy_component(buttongroup);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_1$5.name,
        type: "if",
        source: "(183:4) {#if !media.archivo && estado == \\\"vacio\\\"}",
        ctx
      });
      return block;
    } // (187:16) <Button                      on:click={() => input.click()}                      icon                      outlined                      shaped={true}                      on:click={() => true}                  >


    function create_default_slot_3$5(ctx) {
      let icon;
      const block = {
        c: function create() {
          icon = element("icon");
          attr_dev(icon, "class", "fe fe-upload");
          add_location(icon, file$a, 193, 20, 6405);
        },
        m: function mount(target, anchor) {
          insert_dev(target, icon, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(icon);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_3$5.name,
        type: "slot",
        source: "(187:16) <Button                      on:click={() => input.click()}                      icon                      outlined                      shaped={true}                      on:click={() => true}                  >",
        ctx
      });
      return block;
    } // (196:16) <Button                      icon                      outlined                      shaped={true}                      on:click={() => (estado = "importarLink")}                  >


    function create_default_slot_2$5(ctx) {
      let icon;
      const block = {
        c: function create() {
          icon = element("icon");
          attr_dev(icon, "class", "fe fe-link-2");
          add_location(icon, file$a, 201, 20, 6682);
        },
        m: function mount(target, anchor) {
          insert_dev(target, icon, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(icon);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_2$5.name,
        type: "slot",
        source: "(196:16) <Button                      icon                      outlined                      shaped={true}                      on:click={() => (estado = \\\"importarLink\\\")}                  >",
        ctx
      });
      return block;
    } // (186:12) <ButtonGroup>


    function create_default_slot_1$5(ctx) {
      let button0;
      let t;
      let button1;
      let current;
      button0 = new ye({
        props: {
          icon: true,
          outlined: true,
          shaped: true,
          $$slots: {
            default: [create_default_slot_3$5]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      button0.$on("click",
      /*click_handler_1*/
      ctx[15]);
      button0.$on("click", click_handler_2);
      button1 = new ye({
        props: {
          icon: true,
          outlined: true,
          shaped: true,
          $$slots: {
            default: [create_default_slot_2$5]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      button1.$on("click",
      /*click_handler_3*/
      ctx[16]);
      const block = {
        c: function create() {
          create_component(button0.$$.fragment);
          t = space();
          create_component(button1.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(button0, target, anchor);
          insert_dev(target, t, anchor);
          mount_component(button1, target, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          const button0_changes = {};

          if (dirty &
          /*$$scope*/
          2097152) {
            button0_changes.$$scope = {
              dirty,
              ctx
            };
          }

          button0.$set(button0_changes);
          const button1_changes = {};

          if (dirty &
          /*$$scope*/
          2097152) {
            button1_changes.$$scope = {
              dirty,
              ctx
            };
          }

          button1.$set(button1_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(button0.$$.fragment, local);
          transition_in(button1.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(button0.$$.fragment, local);
          transition_out(button1.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(button0, detaching);
          if (detaching) detach_dev(t);
          destroy_component(button1, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_1$5.name,
        type: "slot",
        source: "(186:12) <ButtonGroup>",
        ctx
      });
      return block;
    } // (207:4) {#if media.archivo || media.link}


    function create_if_block$8(ctx) {
      let button;
      let current;
      button = new ye({
        props: {
          class: "cancelar",
          icon: true,
          outlined: true,
          shaped: true,
          $$slots: {
            default: [create_default_slot$6]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      button.$on("click",
      /*removerArchivo*/
      ctx[2]);
      button.$on("click", click_handler_4);
      const block = {
        c: function create() {
          create_component(button.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(button, target, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          const button_changes = {};

          if (dirty &
          /*$$scope*/
          2097152) {
            button_changes.$$scope = {
              dirty,
              ctx
            };
          }

          button.$set(button_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(button.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(button.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(button, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block$8.name,
        type: "if",
        source: "(207:4) {#if media.archivo || media.link}",
        ctx
      });
      return block;
    } // (208:8) <Button              class="cancelar"              on:click={removerArchivo}              icon              outlined              shaped={true}              on:click={() => true}          >


    function create_default_slot$6(ctx) {
      let icon;
      const block = {
        c: function create() {
          icon = element("icon");
          attr_dev(icon, "class", "fe fe-x");
          add_location(icon, file$a, 215, 12, 7046);
        },
        m: function mount(target, anchor) {
          insert_dev(target, icon, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(icon);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot$6.name,
        type: "slot",
        source: "(208:8) <Button              class=\\\"cancelar\\\"              on:click={removerArchivo}              icon              outlined              shaped={true}              on:click={() => true}          >",
        ctx
      });
      return block;
    }

    function create_fragment$a(ctx) {
      let input_1;
      let t0;
      let div;
      let t1;
      let t2;
      let t3;
      let div_style_value;
      let current;
      let mounted;
      let dispose;
      let if_block0 =
      /*mediaType*/
      ctx[5] == MediaType.Video &&
      /*media*/
      ctx[0].archivo && create_if_block_3$3(ctx);
      let if_block1 =
      /*estado*/
      ctx[8] == "importarLink" && create_if_block_2$5(ctx);
      let if_block2 = !
      /*media*/
      ctx[0].archivo &&
      /*estado*/
      ctx[8] == "vacio" && create_if_block_1$5(ctx);
      let if_block3 = (
      /*media*/
      ctx[0].archivo ||
      /*media*/
      ctx[0].link) && create_if_block$8(ctx);
      const block = {
        c: function create() {
          input_1 = element("input");
          t0 = space();
          div = element("div");
          if (if_block0) if_block0.c();
          t1 = space();
          if (if_block1) if_block1.c();
          t2 = space();
          if (if_block2) if_block2.c();
          t3 = space();
          if (if_block3) if_block3.c();
          attr_dev(input_1, "name", "archivo");
          attr_dev(input_1, "type", "file");
          attr_dev(input_1, "id", "hilo-input");
          set_style(input_1, "position", "absolute");
          set_style(input_1, "top", "-1000px");
          add_location(input_1, file$a, 141, 0, 4702);
          attr_dev(div, "class", "video-preview media-input svelte-1w0yc3o");
          attr_dev(div, "style", div_style_value = "" + (((
          /*media*/
          ctx[0].archivo ||
          /*media*/
          ctx[0].link) &&
          /*mediaType*/
          ctx[5] != MediaType.Video ? `background-image:url(${
      /*archivoBlob*/
      ctx[3] ||
      /*media*/
      ctx[0]})!important` : "background-image:url(/imagenes/rose2.jpg)") + ";overflow:hidden;"));
          toggle_class(div, "compacto",
          /*compacto*/
          ctx[1]);
          add_location(div, file$a, 149, 0, 4875);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, input_1, anchor);
          /*input_1_binding*/

          ctx[12](input_1);
          insert_dev(target, t0, anchor);
          insert_dev(target, div, anchor);
          if (if_block0) if_block0.m(div, null);
          append_dev(div, t1);
          if (if_block1) if_block1.m(div, null);
          append_dev(div, t2);
          if (if_block2) if_block2.m(div, null);
          append_dev(div, t3);
          if (if_block3) if_block3.m(div, null);
          /*div_binding*/

          ctx[17](div);
          current = true;

          if (!mounted) {
            dispose = listen_dev(input_1, "change",
            /*actualizarArchivo*/
            ctx[9], false, false, false);
            mounted = true;
          }
        },
        p: function update(ctx, [dirty]) {
          if (
          /*mediaType*/
          ctx[5] == MediaType.Video &&
          /*media*/
          ctx[0].archivo) {
            if (if_block0) {
              if_block0.p(ctx, dirty);
            } else {
              if_block0 = create_if_block_3$3(ctx);
              if_block0.c();
              if_block0.m(div, t1);
            }
          } else if (if_block0) {
            if_block0.d(1);
            if_block0 = null;
          }

          if (
          /*estado*/
          ctx[8] == "importarLink") {
            if (if_block1) {
              if_block1.p(ctx, dirty);

              if (dirty &
              /*estado*/
              256) {
                transition_in(if_block1, 1);
              }
            } else {
              if_block1 = create_if_block_2$5(ctx);
              if_block1.c();
              transition_in(if_block1, 1);
              if_block1.m(div, t2);
            }
          } else if (if_block1) {
            group_outros();
            transition_out(if_block1, 1, 1, () => {
              if_block1 = null;
            });
            check_outros();
          }

          if (!
          /*media*/
          ctx[0].archivo &&
          /*estado*/
          ctx[8] == "vacio") {
            if (if_block2) {
              if_block2.p(ctx, dirty);

              if (dirty &
              /*media, estado*/
              257) {
                transition_in(if_block2, 1);
              }
            } else {
              if_block2 = create_if_block_1$5(ctx);
              if_block2.c();
              transition_in(if_block2, 1);
              if_block2.m(div, t3);
            }
          } else if (if_block2) {
            group_outros();
            transition_out(if_block2, 1, 1, () => {
              if_block2 = null;
            });
            check_outros();
          }

          if (
          /*media*/
          ctx[0].archivo ||
          /*media*/
          ctx[0].link) {
            if (if_block3) {
              if_block3.p(ctx, dirty);

              if (dirty &
              /*media*/
              1) {
                transition_in(if_block3, 1);
              }
            } else {
              if_block3 = create_if_block$8(ctx);
              if_block3.c();
              transition_in(if_block3, 1);
              if_block3.m(div, null);
            }
          } else if (if_block3) {
            group_outros();
            transition_out(if_block3, 1, 1, () => {
              if_block3 = null;
            });
            check_outros();
          }

          if (!current || dirty &
          /*media, mediaType, archivoBlob*/
          41 && div_style_value !== (div_style_value = "" + (((
          /*media*/
          ctx[0].archivo ||
          /*media*/
          ctx[0].link) &&
          /*mediaType*/
          ctx[5] != MediaType.Video ? `background-image:url(${
      /*archivoBlob*/
      ctx[3] ||
      /*media*/
      ctx[0]})!important` : "background-image:url(/imagenes/rose2.jpg)") + ";overflow:hidden;"))) {
            attr_dev(div, "style", div_style_value);
          }

          if (dirty &
          /*compacto*/
          2) {
            toggle_class(div, "compacto",
            /*compacto*/
            ctx[1]);
          }
        },
        i: function intro(local) {
          if (current) return;
          transition_in(if_block1);
          transition_in(if_block2);
          transition_in(if_block3);
          current = true;
        },
        o: function outro(local) {
          transition_out(if_block1);
          transition_out(if_block2);
          transition_out(if_block3);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(input_1);
          /*input_1_binding*/

          ctx[12](null);
          if (detaching) detach_dev(t0);
          if (detaching) detach_dev(div);
          if (if_block0) if_block0.d();
          if (if_block1) if_block1.d();
          if (if_block2) if_block2.d();
          if (if_block3) if_block3.d();
          /*div_binding*/

          ctx[17](null);
          mounted = false;
          dispose();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$a.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }

    const youtubeRegex = /(?:youtube\.com\/\S*(?:(?:\/e(?:mbed))?\/|watch\?(?:\S*?&?v\=))|youtu\.be\/)([a-zA-Z0-9_-]{6,12})/;
    const bitchuteRegex = /(?:bitchute\.com\/\S*(?:(?:\/e(?:mbed))?\/|video\?(?:\S*?&?v\=)))([a-zA-Z0-9_-]{6,12})/;
    const dailyMotionRegex = /(?:(?:dailymotion\.com\/(?:embed\/)?video\/)|(?:dai\.ly\/))([a-zA-Z0-9_-]{6,12})/;
    const pornhubRegex = /(?:pornhub.com\/(?:(?:view_video\.php\?viewkey=)|(?:embed\/)))([a-zA-Z0-9_-]{10,20})/;

    async function getBlobFromInput(input) {
      return new Promise((resolve, reject) => {
        if (!(input.files && input.files[0])) return null;
        let blob;
        let reader = new FileReader();

        reader.onload = function (e) {
          blob = e.target.result;
          resolve(blob);
        };

        reader.readAsDataURL(input.files[0]);
      });
    }

    const click_handler_2 = () => true;

    const click_handler_4 = () => true;

    function instance$a($$self, $$props, $$invalidate) {
      let {
        $$slots: slots = {},
        $$scope
      } = $$props;
      validate_slots("MediaInput", slots, []);
      let {
        compacto = false
      } = $$props;
      let {
        media = {
          archivo: null,
          link: ""
        }
      } = $$props;
      let {
        videoUrl = null
      } = $$props;
      let vistaPreviaYoutube = "";
      let menuLink = false;
      let archivoBlob = null;
      let input = null;
      let mediaType = MediaType.Imagen;
      let el;
      let inputLink = "";
      let estado = "vacio"; // importarLink | cargado

      async function actualizarArchivo() {
        if (input.files && input.files[0]) {
          $$invalidate(3, archivoBlob = await getBlobFromInput(input));
          $$invalidate(0, media.archivo = input.files[0], media);

          if (input.files[0].type.indexOf("image") != -1) {
            $$invalidate(5, mediaType = MediaType.Imagen);
          } else if (input.files[0].type.indexOf("video") != -1) {
            $$invalidate(5, mediaType = MediaType.Video);
          }
        }
      }

      async function importarVideo() {
        let id = inputLink.match(youtubeRegex);

        if (id) {
          $$invalidate(5, mediaType = MediaType.Youtube);
          vistaPreviaYoutube = `https://img.youtube.com/vi/${id[1]}/hqdefault.jpg`;
          $$invalidate(11, videoUrl = inputLink);
          $$invalidate(3, archivoBlob = `https://img.youtube.com/vi/${id[1]}/hqdefault.jpg`);
          $$invalidate(0, media.link = videoUrl, media);
          $$invalidate(8, estado = "cargado");
          return;
        }

        id = inputLink.match(bitchuteRegex);

        if (id) {
          $$invalidate(5, mediaType = MediaType.Bitchute);
          $$invalidate(11, videoUrl = inputLink);
          $$invalidate(3, archivoBlob = `https://www.bitchute.com/static/v133/images/logo-full-day.png`);
          $$invalidate(0, media.link = videoUrl, media);
          $$invalidate(8, estado = "cargado");
          return;
        }

        id = inputLink.match(dailyMotionRegex);

        if (id) {
          $$invalidate(5, mediaType = MediaType.DailyMotion);
          $$invalidate(11, videoUrl = inputLink);
          $$invalidate(3, archivoBlob = `https://www.dailymotion.com/thumbnail/video/${id[1]}`);
          $$invalidate(0, media.link = videoUrl, media);
          $$invalidate(8, estado = "cargado");
          return;
        }

        id = inputLink.match(pornhubRegex);

        if (id) {
          $$invalidate(5, mediaType = MediaType.PornHub);
          $$invalidate(11, videoUrl = inputLink);
          $$invalidate(3, archivoBlob = `https://ei.phncdn.com/www-static/images/pornhub_logo_straight.png`);
          $$invalidate(0, media.link = videoUrl, media);
          $$invalidate(8, estado = "cargado");
          return;
        }

        importarArchivo();
        return;
      }

      async function importarArchivo() {
        let match = inputLink.match(/(http(s)?:\/\/.)?(www\.)?[-a-zA-Z0-9@:%._\+~#=]{2,256}\.[a-z]{2,6}\b([-a-zA-Z0-9@:%_\+.~#?&//=]*)/gi);

        if (!match || match.length == 0) {
          $$invalidate(7, inputLink = "Link invalido");
          return;
        } // Chekear si el link es valido


        if (inputLink.includes(".webm") || inputLink.includes("mp4")) $$invalidate(5, mediaType = MediaType.Video);else $$invalidate(5, mediaType = MediaType.Imagen);
        $$invalidate(3, archivoBlob = inputLink);
        $$invalidate(0, media.link = inputLink, media);
        $$invalidate(0, media.archivo = inputLink, media);
        $$invalidate(8, estado = "cargado");
      }

      function removerArchivo() {
        $$invalidate(0, media.archivo = null, media);
        $$invalidate(0, media.link = "", media);
        $$invalidate(3, archivoBlob = null);
        $$invalidate(4, input.value = "", input);
        $$invalidate(7, inputLink = "");
        $$invalidate(5, mediaType = MediaType.Imagen);
        $$invalidate(8, estado = "vacio");
        $$invalidate(7, inputLink = "");
      }

      onDestroy(() => {
        $$invalidate(0, media.archivo = null, media);
        $$invalidate(3, archivoBlob = null);
      });
      onMount(() => {
        window.addEventListener("paste", e => {
          $$invalidate(4, input.files = e.clipboardData.files, input);
          actualizarArchivo();
        });
      });
      const writable_props = ["compacto", "media", "videoUrl"];
      Object.keys($$props).forEach(key => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<MediaInput> was created with unknown prop '${key}'`);
      });

      function input_1_binding($$value) {
        binding_callbacks[$$value ? "unshift" : "push"](() => {
          input = $$value;
          $$invalidate(4, input);
        });
      }

      function input_1_input_handler() {
        inputLink = this.value;
        $$invalidate(7, inputLink);
      }

      const click_handler = () => $$invalidate(8, estado = "vacio");

      const click_handler_1 = () => input.click();

      const click_handler_3 = () => $$invalidate(8, estado = "importarLink");

      function div_binding($$value) {
        binding_callbacks[$$value ? "unshift" : "push"](() => {
          el = $$value;
          $$invalidate(6, el);
        });
      }

      $$self.$$set = $$props => {
        if ("compacto" in $$props) $$invalidate(1, compacto = $$props.compacto);
        if ("media" in $$props) $$invalidate(0, media = $$props.media);
        if ("videoUrl" in $$props) $$invalidate(11, videoUrl = $$props.videoUrl);
      };

      $$self.$capture_state = () => ({
        MediaType,
        Button: ye,
        ButtonGroup: $e,
        Icon: Me,
        onDestroy,
        onMount,
        compacto,
        media,
        videoUrl,
        vistaPreviaYoutube,
        menuLink,
        archivoBlob,
        input,
        mediaType,
        el,
        inputLink,
        estado,
        youtubeRegex,
        bitchuteRegex,
        dailyMotionRegex,
        pornhubRegex,
        actualizarArchivo,
        getBlobFromInput,
        importarVideo,
        importarArchivo,
        removerArchivo
      });

      $$self.$inject_state = $$props => {
        if ("compacto" in $$props) $$invalidate(1, compacto = $$props.compacto);
        if ("media" in $$props) $$invalidate(0, media = $$props.media);
        if ("videoUrl" in $$props) $$invalidate(11, videoUrl = $$props.videoUrl);
        if ("vistaPreviaYoutube" in $$props) vistaPreviaYoutube = $$props.vistaPreviaYoutube;
        if ("menuLink" in $$props) menuLink = $$props.menuLink;
        if ("archivoBlob" in $$props) $$invalidate(3, archivoBlob = $$props.archivoBlob);
        if ("input" in $$props) $$invalidate(4, input = $$props.input);
        if ("mediaType" in $$props) $$invalidate(5, mediaType = $$props.mediaType);
        if ("el" in $$props) $$invalidate(6, el = $$props.el);
        if ("inputLink" in $$props) $$invalidate(7, inputLink = $$props.inputLink);
        if ("estado" in $$props) $$invalidate(8, estado = $$props.estado);
      };

      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }

      return [media, compacto, removerArchivo, archivoBlob, input, mediaType, el, inputLink, estado, actualizarArchivo, importarVideo, videoUrl, input_1_binding, input_1_input_handler, click_handler, click_handler_1, click_handler_3, div_binding];
    }

    class MediaInput extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$a, create_fragment$a, safe_not_equal, {
          compacto: 1,
          media: 0,
          videoUrl: 11,
          removerArchivo: 2
        });
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "MediaInput",
          options,
          id: create_fragment$a.name
        });
      }

      get compacto() {
        throw new Error("<MediaInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set compacto(value) {
        throw new Error("<MediaInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get media() {
        throw new Error("<MediaInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set media(value) {
        throw new Error("<MediaInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get videoUrl() {
        throw new Error("<MediaInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set videoUrl(value) {
        throw new Error("<MediaInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get removerArchivo() {
        return this.$$.ctx[2];
      }

      set removerArchivo(value) {
        throw new Error("<MediaInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

    }

    /* src\components\Spinner.svelte generated by Svelte v3.29.0 */
    const file$b = "src\\components\\Spinner.svelte"; // (9:4) {:else}

    function create_else_block$2(ctx) {
      let current;
      const default_slot_template =
      /*#slots*/
      ctx[2].default;
      const default_slot = create_slot(default_slot_template, ctx,
      /*$$scope*/
      ctx[1], null);
      const block = {
        c: function create() {
          if (default_slot) default_slot.c();
        },
        m: function mount(target, anchor) {
          if (default_slot) {
            default_slot.m(target, anchor);
          }

          current = true;
        },
        p: function update(ctx, dirty) {
          if (default_slot) {
            if (default_slot.p && dirty &
            /*$$scope*/
            2) {
              update_slot(default_slot, default_slot_template, ctx,
              /*$$scope*/
              ctx[1], dirty, null, null);
            }
          }
        },
        i: function intro(local) {
          if (current) return;
          transition_in(default_slot, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(default_slot, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (default_slot) default_slot.d(detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_else_block$2.name,
        type: "else",
        source: "(9:4) {:else}",
        ctx
      });
      return block;
    } // (5:0) {#if cargando}


    function create_if_block$9(ctx) {
      let div;
      let span;
      const block = {
        c: function create() {
          div = element("div");
          span = element("span");
          span.textContent = "R";
          attr_dev(span, "class", "svelte-1ukl4v4");
          add_location(span, file$b, 6, 8, 100);
          attr_dev(div, "class", "loader svelte-1ukl4v4");
          add_location(div, file$b, 5, 4, 71);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          append_dev(div, span);
        },
        p: noop,
        i: noop,
        o: noop,
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block$9.name,
        type: "if",
        source: "(5:0) {#if cargando}",
        ctx
      });
      return block;
    }

    function create_fragment$b(ctx) {
      let current_block_type_index;
      let if_block;
      let if_block_anchor;
      let current;
      const if_block_creators = [create_if_block$9, create_else_block$2];
      const if_blocks = [];

      function select_block_type(ctx, dirty) {
        if (
        /*cargando*/
        ctx[0]) return 0;
        return 1;
      }

      current_block_type_index = select_block_type(ctx);
      if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
      const block = {
        c: function create() {
          if_block.c();
          if_block_anchor = empty();
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          if_blocks[current_block_type_index].m(target, anchor);
          insert_dev(target, if_block_anchor, anchor);
          current = true;
        },
        p: function update(ctx, [dirty]) {
          let previous_block_index = current_block_type_index;
          current_block_type_index = select_block_type(ctx);

          if (current_block_type_index === previous_block_index) {
            if_blocks[current_block_type_index].p(ctx, dirty);
          } else {
            group_outros();
            transition_out(if_blocks[previous_block_index], 1, 1, () => {
              if_blocks[previous_block_index] = null;
            });
            check_outros();
            if_block = if_blocks[current_block_type_index];

            if (!if_block) {
              if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
              if_block.c();
            }

            transition_in(if_block, 1);
            if_block.m(if_block_anchor.parentNode, if_block_anchor);
          }
        },
        i: function intro(local) {
          if (current) return;
          transition_in(if_block);
          current = true;
        },
        o: function outro(local) {
          transition_out(if_block);
          current = false;
        },
        d: function destroy(detaching) {
          if_blocks[current_block_type_index].d(detaching);
          if (detaching) detach_dev(if_block_anchor);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$b.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }

    function instance$b($$self, $$props, $$invalidate) {
      let {
        $$slots: slots = {},
        $$scope
      } = $$props;
      validate_slots("Spinner", slots, ['default']);
      let {
        cargando = false
      } = $$props;
      const writable_props = ["cargando"];
      Object.keys($$props).forEach(key => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Spinner> was created with unknown prop '${key}'`);
      });

      $$self.$$set = $$props => {
        if ("cargando" in $$props) $$invalidate(0, cargando = $$props.cargando);
        if ("$$scope" in $$props) $$invalidate(1, $$scope = $$props.$$scope);
      };

      $$self.$capture_state = () => ({
        cargando
      });

      $$self.$inject_state = $$props => {
        if ("cargando" in $$props) $$invalidate(0, cargando = $$props.cargando);
      };

      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }

      return [cargando, $$scope, slots];
    }

    class Spinner extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$b, create_fragment$b, safe_not_equal, {
          cargando: 0
        });
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "Spinner",
          options,
          id: create_fragment$b.name
        });
      }

      get cargando() {
        throw new Error("<Spinner>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set cargando(value) {
        throw new Error("<Spinner>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

    }

    /* src\components\AudioInput.svelte generated by Svelte v3.29.0 */
    const {
      console: console_1$2
    } = globals;
    const file$c = "src\\components\\AudioInput.svelte";

    function get_each_context$5(ctx, list, i) {
      const child_ctx = ctx.slice();
      child_ctx[26] = list[i];
      return child_ctx;
    } // (161:4) {:else}


    function create_else_block$3(ctx) {
      let current_block_type_index;
      let if_block0;
      let t0;
      let div;
      let t1;
      let div_style_value;
      let t2;
      let current_block_type_index_1;
      let if_block1;
      let if_block1_anchor;
      let current;
      const if_block_creators = [create_if_block_2$6, create_else_block_2$2];
      const if_blocks = [];

      function select_block_type_1(ctx, dirty) {
        if (!
        /*$globalStore*/
        ctx[7].usuario.estaAutenticado) return 0;
        return 1;
      }

      current_block_type_index = select_block_type_1(ctx);
      if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
      const if_block_creators_1 = [create_if_block_1$6, create_else_block_1$2];
      const if_blocks_1 = [];

      function select_block_type_2(ctx, dirty) {
        if (
        /*estado*/
        ctx[4]) return 0;
        return 1;
      }

      current_block_type_index_1 = select_block_type_2(ctx);
      if_block1 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);
      const block = {
        c: function create() {
          if_block0.c();
          t0 = space();
          div = element("div");
          t1 = text(
          /*duracion*/
          ctx[2]);
          t2 = space();
          if_block1.c();
          if_block1_anchor = empty();
          attr_dev(div, "class", "controls svelte-1igjk86");
          attr_dev(div, "style", div_style_value =
          /*estado*/
          ctx[4] ? "color: green;" : "");
          attr_dev(div, "id", "duracion");
          add_location(div, file$c, 189, 8, 6627);
        },
        m: function mount(target, anchor) {
          if_blocks[current_block_type_index].m(target, anchor);
          insert_dev(target, t0, anchor);
          insert_dev(target, div, anchor);
          append_dev(div, t1);
          insert_dev(target, t2, anchor);
          if_blocks_1[current_block_type_index_1].m(target, anchor);
          insert_dev(target, if_block1_anchor, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          let previous_block_index = current_block_type_index;
          current_block_type_index = select_block_type_1(ctx);

          if (current_block_type_index === previous_block_index) {
            if_blocks[current_block_type_index].p(ctx, dirty);
          } else {
            group_outros();
            transition_out(if_blocks[previous_block_index], 1, 1, () => {
              if_blocks[previous_block_index] = null;
            });
            check_outros();
            if_block0 = if_blocks[current_block_type_index];

            if (!if_block0) {
              if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
              if_block0.c();
            }

            transition_in(if_block0, 1);
            if_block0.m(t0.parentNode, t0);
          }

          if (!current || dirty &
          /*duracion*/
          4) set_data_dev(t1,
          /*duracion*/
          ctx[2]);

          if (!current || dirty &
          /*estado*/
          16 && div_style_value !== (div_style_value =
          /*estado*/
          ctx[4] ? "color: green;" : "")) {
            attr_dev(div, "style", div_style_value);
          }

          let previous_block_index_1 = current_block_type_index_1;
          current_block_type_index_1 = select_block_type_2(ctx);

          if (current_block_type_index_1 === previous_block_index_1) {
            if_blocks_1[current_block_type_index_1].p(ctx, dirty);
          } else {
            group_outros();
            transition_out(if_blocks_1[previous_block_index_1], 1, 1, () => {
              if_blocks_1[previous_block_index_1] = null;
            });
            check_outros();
            if_block1 = if_blocks_1[current_block_type_index_1];

            if (!if_block1) {
              if_block1 = if_blocks_1[current_block_type_index_1] = if_block_creators_1[current_block_type_index_1](ctx);
              if_block1.c();
            }

            transition_in(if_block1, 1);
            if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
          }
        },
        i: function intro(local) {
          if (current) return;
          transition_in(if_block0);
          transition_in(if_block1);
          current = true;
        },
        o: function outro(local) {
          transition_out(if_block0);
          transition_out(if_block1);
          current = false;
        },
        d: function destroy(detaching) {
          if_blocks[current_block_type_index].d(detaching);
          if (detaching) detach_dev(t0);
          if (detaching) detach_dev(div);
          if (detaching) detach_dev(t2);
          if_blocks_1[current_block_type_index_1].d(detaching);
          if (detaching) detach_dev(if_block1_anchor);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_else_block$3.name,
        type: "else",
        source: "(161:4) {:else}",
        ctx
      });
      return block;
    } // (144:4) {#if urlBlobAudio}


    function create_if_block$a(ctx) {
      let button;
      let t;
      let audio;
      let source;
      let source_src_value;
      let current;
      button = new ye({
        props: {
          icon: true,
          color: "red",
          class: "record",
          title: "Descartar audio",
          $$slots: {
            default: [create_default_slot_2$6]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      button.$on("click",
      /*removerArchivo*/
      ctx[0]);
      const block = {
        c: function create() {
          create_component(button.$$.fragment);
          t = space();
          audio = element("audio");
          source = element("source");
          if (source.src !== (source_src_value =
          /*urlBlobAudio*/
          ctx[5])) attr_dev(source, "src", source_src_value);
          attr_dev(source, "type", "audio/mp3");
          add_location(source, file$c, 158, 12, 5556);
          attr_dev(audio, "class", "controls svelte-1igjk86");
          audio.controls = "controls";
          set_style(audio, "height", "32px");
          set_style(audio, "border-radius", "16px");
          add_location(audio, file$c, 153, 8, 5411);
        },
        m: function mount(target, anchor) {
          mount_component(button, target, anchor);
          insert_dev(target, t, anchor);
          insert_dev(target, audio, anchor);
          append_dev(audio, source);
          current = true;
        },
        p: function update(ctx, dirty) {
          const button_changes = {};

          if (dirty &
          /*$$scope*/
          536870912) {
            button_changes.$$scope = {
              dirty,
              ctx
            };
          }

          button.$set(button_changes);

          if (!current || dirty &
          /*urlBlobAudio*/
          32 && source.src !== (source_src_value =
          /*urlBlobAudio*/
          ctx[5])) {
            attr_dev(source, "src", source_src_value);
          }
        },
        i: function intro(local) {
          if (current) return;
          transition_in(button.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(button.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(button, detaching);
          if (detaching) detach_dev(t);
          if (detaching) detach_dev(audio);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block$a.name,
        type: "if",
        source: "(144:4) {#if urlBlobAudio}",
        ctx
      });
      return block;
    } // (173:8) {:else}


    function create_else_block_2$2(ctx) {
      let button;
      let current;
      button = new ye({
        props: {
          icon: true,
          color: "green",
          class: "record",
          title: "Mantener presionado para grabar",
          $$slots: {
            default: [create_default_slot_5$4]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      button.$on("mousedown",
      /*comenzarAGrabar*/
      ctx[8]);
      button.$on("mouseup",
      /*detenerGrabacion*/
      ctx[9]);
      button.$on("mouseout",
      /*mouseout_handler*/
      ctx[13]);
      button.$on("touchstart",
      /*comenzarAGrabar*/
      ctx[8]);
      button.$on("touchend",
      /*detenerGrabacion*/
      ctx[9]);
      const block = {
        c: function create() {
          create_component(button.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(button, target, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          const button_changes = {};

          if (dirty &
          /*$$scope*/
          536870912) {
            button_changes.$$scope = {
              dirty,
              ctx
            };
          }

          button.$set(button_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(button.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(button.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(button, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_else_block_2$2.name,
        type: "else",
        source: "(173:8) {:else}",
        ctx
      });
      return block;
    } // (162:8) {#if !$globalStore.usuario.estaAutenticado}


    function create_if_block_2$6(ctx) {
      let button;
      let current;
      button = new ye({
        props: {
          icon: true,
          color: "green",
          class: "record",
          title: "Mantener presionado para grabar",
          $$slots: {
            default: [create_default_slot_4$4]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      button.$on("mousedown",
      /*mousedown_handler*/
      ctx[11]);
      button.$on("touchstart",
      /*touchstart_handler*/
      ctx[12]);
      const block = {
        c: function create() {
          create_component(button.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(button, target, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          const button_changes = {};

          if (dirty &
          /*$$scope*/
          536870912) {
            button_changes.$$scope = {
              dirty,
              ctx
            };
          }

          button.$set(button_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(button.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(button.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(button, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_2$6.name,
        type: "if",
        source: "(162:8) {#if !$globalStore.usuario.estaAutenticado}",
        ctx
      });
      return block;
    } // (174:12) <Button                 icon                 color="green"                 class="record"                 on:mousedown={comenzarAGrabar}                 on:mouseup={detenerGrabacion}                 on:mouseout={() => {                     if (estado) detenerGrabacion();                 }}                 on:touchstart={comenzarAGrabar}                 on:touchend={detenerGrabacion}                 title="Mantener presionado para grabar"             >


    function create_default_slot_5$4(ctx) {
      let icon;
      const block = {
        c: function create() {
          icon = element("icon");
          attr_dev(icon, "class", "fe fe-mic");
          add_location(icon, file$c, 186, 16, 6556);
        },
        m: function mount(target, anchor) {
          insert_dev(target, icon, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(icon);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_5$4.name,
        type: "slot",
        source: "(174:12) <Button                 icon                 color=\\\"green\\\"                 class=\\\"record\\\"                 on:mousedown={comenzarAGrabar}                 on:mouseup={detenerGrabacion}                 on:mouseout={() => {                     if (estado) detenerGrabacion();                 }}                 on:touchstart={comenzarAGrabar}                 on:touchend={detenerGrabacion}                 title=\\\"Mantener presionado para grabar\\\"             >",
        ctx
      });
      return block;
    } // (163:12) <Button                 icon                 color="green"                 class="record"                 on:mousedown={() => (window.location = "/Inicio")}                 on:touchstart={() => (window.location = "/Inicio")}                 title="Mantener presionado para grabar"             >


    function create_default_slot_4$4(ctx) {
      let icon;
      const block = {
        c: function create() {
          icon = element("icon");
          attr_dev(icon, "class", "fe fe-mic");
          add_location(icon, file$c, 170, 16, 6007);
        },
        m: function mount(target, anchor) {
          insert_dev(target, icon, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(icon);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_4$4.name,
        type: "slot",
        source: "(163:12) <Button                 icon                 color=\\\"green\\\"                 class=\\\"record\\\"                 on:mousedown={() => (window.location = \\\"/Inicio\\\")}                 on:touchstart={() => (window.location = \\\"/Inicio\\\")}                 title=\\\"Mantener presionado para grabar\\\"             >",
        ctx
      });
      return block;
    } // (201:8) {:else}


    function create_else_block_1$2(ctx) {
      let button;
      let current;
      button = new ye({
        props: {
          icon: true,
          color: "grey",
          class: "settings",
          title: "Configuración",
          $$slots: {
            default: [create_default_slot_3$6]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      button.$on("click",
      /*click_handler*/
      ctx[14]);
      const block = {
        c: function create() {
          create_component(button.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(button, target, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          const button_changes = {};

          if (dirty &
          /*$$scope*/
          536870912) {
            button_changes.$$scope = {
              dirty,
              ctx
            };
          }

          button.$set(button_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(button.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(button.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(button, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_else_block_1$2.name,
        type: "else",
        source: "(201:8) {:else}",
        ctx
      });
      return block;
    } // (197:8) {#if estado}


    function create_if_block_1$6(ctx) {
      let div;
      let icon;
      const block = {
        c: function create() {
          div = element("div");
          icon = element("icon");
          attr_dev(icon, "class", "fe fe-voicemail");
          add_location(icon, file$c, 198, 16, 6863);
          attr_dev(div, "class", "controls shake svelte-1igjk86");
          add_location(div, file$c, 197, 12, 6818);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          append_dev(div, icon);
        },
        p: noop,
        i: noop,
        o: noop,
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_1$6.name,
        type: "if",
        source: "(197:8) {#if estado}",
        ctx
      });
      return block;
    } // (202:12) <Button                 icon                 color="grey"                 class="settings"                 on:click={() => (visible = true)}                 title="Configuración"             >


    function create_default_slot_3$6(ctx) {
      let icon;
      const block = {
        c: function create() {
          icon = element("icon");
          attr_dev(icon, "class", "fe fe-settings");
          add_location(icon, file$c, 208, 16, 7152);
        },
        m: function mount(target, anchor) {
          insert_dev(target, icon, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(icon);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_3$6.name,
        type: "slot",
        source: "(202:12) <Button                 icon                 color=\\\"grey\\\"                 class=\\\"settings\\\"                 on:click={() => (visible = true)}                 title=\\\"Configuración\\\"             >",
        ctx
      });
      return block;
    } // (145:8) <Button             icon             color="red"             class="record"             on:click={removerArchivo}             title="Descartar audio"         >


    function create_default_slot_2$6(ctx) {
      let icon;
      const block = {
        c: function create() {
          icon = element("icon");
          attr_dev(icon, "class", "fe fe-x");
          add_location(icon, file$c, 151, 12, 5360);
        },
        m: function mount(target, anchor) {
          insert_dev(target, icon, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(icon);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_2$6.name,
        type: "slot",
        source: "(145:8) <Button             icon             color=\\\"red\\\"             class=\\\"record\\\"             on:click={removerArchivo}             title=\\\"Descartar audio\\\"         >",
        ctx
      });
      return block;
    } // (216:4) <div slot="title">


    function create_title_slot$1(ctx) {
      let div;
      const block = {
        c: function create() {
          div = element("div");
          div.textContent = "Seleccionar dispositivo";
          attr_dev(div, "slot", "title");
          add_location(div, file$c, 215, 4, 7276);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_title_slot$1.name,
        type: "slot",
        source: "(216:4) <div slot=\\\"title\\\">",
        ctx
      });
      return block;
    } // (218:8) {#each listaDeDispositivos as opcion (opcion.value)}


    function create_each_block$5(key_1, ctx) {
      let option;
      let t_value =
      /*opcion*/
      ctx[26].text + "";
      let t;
      let option_value_value;
      const block = {
        key: key_1,
        first: null,
        c: function create() {
          option = element("option");
          t = text(t_value);
          option.__value = option_value_value =
          /*opcion*/
          ctx[26].value;
          option.value = option.__value;
          add_location(option, file$c, 218, 12, 7462);
          this.first = option;
        },
        m: function mount(target, anchor) {
          insert_dev(target, option, anchor);
          append_dev(option, t);
        },
        p: function update(ctx, dirty) {
          if (dirty &
          /*listaDeDispositivos*/
          2 && t_value !== (t_value =
          /*opcion*/
          ctx[26].text + "")) set_data_dev(t, t_value);

          if (dirty &
          /*listaDeDispositivos*/
          2 && option_value_value !== (option_value_value =
          /*opcion*/
          ctx[26].value)) {
            prop_dev(option, "__value", option_value_value);
            option.value = option.__value;
          }
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(option);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_each_block$5.name,
        type: "each",
        source: "(218:8) {#each listaDeDispositivos as opcion (opcion.value)}",
        ctx
      });
      return block;
    } // (223:8) <Button color="primary" on:click={() => (visible = false)}>


    function create_default_slot_1$6(ctx) {
      let t;
      const block = {
        c: function create() {
          t = text("OK");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_1$6.name,
        type: "slot",
        source: "(223:8) <Button color=\\\"primary\\\" on:click={() => (visible = false)}>",
        ctx
      });
      return block;
    } // (222:4) <div slot="actions" class="actions center">


    function create_actions_slot$1(ctx) {
      let div;
      let button;
      let current;
      button = new ye({
        props: {
          color: "primary",
          $$slots: {
            default: [create_default_slot_1$6]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      button.$on("click",
      /*click_handler_1*/
      ctx[16]);
      const block = {
        c: function create() {
          div = element("div");
          create_component(button.$$.fragment);
          attr_dev(div, "slot", "actions");
          attr_dev(div, "class", "actions center");
          add_location(div, file$c, 221, 4, 7548);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          mount_component(button, div, null);
          current = true;
        },
        p: function update(ctx, dirty) {
          const button_changes = {};

          if (dirty &
          /*$$scope*/
          536870912) {
            button_changes.$$scope = {
              dirty,
              ctx
            };
          }

          button.$set(button_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(button.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(button.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
          destroy_component(button);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_actions_slot$1.name,
        type: "slot",
        source: "(222:4) <div slot=\\\"actions\\\" class=\\\"actions center\\\">",
        ctx
      });
      return block;
    } // (215:0) <Dialog width="320" bind:visible>


    function create_default_slot$7(ctx) {
      let t0;
      let select;
      let each_blocks = [];
      let each_1_lookup = new Map();
      let t1;
      let mounted;
      let dispose;
      let each_value =
      /*listaDeDispositivos*/
      ctx[1];
      validate_each_argument(each_value);

      const get_key = ctx =>
      /*opcion*/
      ctx[26].value;

      validate_each_keys(ctx, each_value, get_each_context$5, get_key);

      for (let i = 0; i < each_value.length; i += 1) {
        let child_ctx = get_each_context$5(ctx, each_value, i);
        let key = get_key(child_ctx);
        each_1_lookup.set(key, each_blocks[i] = create_each_block$5(key, child_ctx));
      }

      const block = {
        c: function create() {
          t0 = space();
          select = element("select");

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].c();
          }

          t1 = space();
          attr_dev(select, "name", "listaDeDispositivos");
          if (
          /*dispositivo*/
          ctx[3] === void 0) add_render_callback(() =>
          /*select_change_handler*/
          ctx[15].call(select));
          add_location(select, file$c, 216, 4, 7328);
        },
        m: function mount(target, anchor) {
          insert_dev(target, t0, anchor);
          insert_dev(target, select, anchor);

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].m(select, null);
          }

          select_option(select,
          /*dispositivo*/
          ctx[3]);
          insert_dev(target, t1, anchor);

          if (!mounted) {
            dispose = listen_dev(select, "change",
            /*select_change_handler*/
            ctx[15]);
            mounted = true;
          }
        },
        p: function update(ctx, dirty) {
          if (dirty &
          /*listaDeDispositivos*/
          2) {
            const each_value =
            /*listaDeDispositivos*/
            ctx[1];
            validate_each_argument(each_value);
            validate_each_keys(ctx, each_value, get_each_context$5, get_key);
            each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, select, destroy_block, create_each_block$5, null, get_each_context$5);
          }

          if (dirty &
          /*dispositivo, listaDeDispositivos*/
          10) {
            select_option(select,
            /*dispositivo*/
            ctx[3]);
          }
        },
        i: noop,
        o: noop,
        d: function destroy(detaching) {
          if (detaching) detach_dev(t0);
          if (detaching) detach_dev(select);

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].d();
          }

          if (detaching) detach_dev(t1);
          mounted = false;
          dispose();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot$7.name,
        type: "slot",
        source: "(215:0) <Dialog width=\\\"320\\\" bind:visible>",
        ctx
      });
      return block;
    }

    function create_fragment$c(ctx) {
      let div;
      let current_block_type_index;
      let if_block;
      let t;
      let dialog;
      let updating_visible;
      let current;
      const if_block_creators = [create_if_block$a, create_else_block$3];
      const if_blocks = [];

      function select_block_type(ctx, dirty) {
        if (
        /*urlBlobAudio*/
        ctx[5]) return 0;
        return 1;
      }

      current_block_type_index = select_block_type(ctx);
      if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

      function dialog_visible_binding(value) {
        /*dialog_visible_binding*/
        ctx[17].call(null, value);
      }

      let dialog_props = {
        width: "320",
        $$slots: {
          default: [create_default_slot$7],
          actions: [create_actions_slot$1],
          title: [create_title_slot$1]
        },
        $$scope: {
          ctx
        }
      };

      if (
      /*visible*/
      ctx[6] !== void 0) {
        dialog_props.visible =
        /*visible*/
        ctx[6];
      }

      dialog = new pn({
        props: dialog_props,
        $$inline: true
      });
      binding_callbacks.push(() => bind(dialog, "visible", dialog_visible_binding));
      const block = {
        c: function create() {
          div = element("div");
          if_block.c();
          t = space();
          create_component(dialog.$$.fragment);
          attr_dev(div, "class", "recording svelte-1igjk86");
          add_location(div, file$c, 142, 0, 5133);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          if_blocks[current_block_type_index].m(div, null);
          insert_dev(target, t, anchor);
          mount_component(dialog, target, anchor);
          current = true;
        },
        p: function update(ctx, [dirty]) {
          let previous_block_index = current_block_type_index;
          current_block_type_index = select_block_type(ctx);

          if (current_block_type_index === previous_block_index) {
            if_blocks[current_block_type_index].p(ctx, dirty);
          } else {
            group_outros();
            transition_out(if_blocks[previous_block_index], 1, 1, () => {
              if_blocks[previous_block_index] = null;
            });
            check_outros();
            if_block = if_blocks[current_block_type_index];

            if (!if_block) {
              if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
              if_block.c();
            }

            transition_in(if_block, 1);
            if_block.m(div, null);
          }

          const dialog_changes = {};

          if (dirty &
          /*$$scope, visible, dispositivo, listaDeDispositivos*/
          536870986) {
            dialog_changes.$$scope = {
              dirty,
              ctx
            };
          }

          if (!updating_visible && dirty &
          /*visible*/
          64) {
            updating_visible = true;
            dialog_changes.visible =
            /*visible*/
            ctx[6];
            add_flush_callback(() => updating_visible = false);
          }

          dialog.$set(dialog_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(if_block);
          transition_in(dialog.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(if_block);
          transition_out(dialog.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
          if_blocks[current_block_type_index].d();
          if (detaching) detach_dev(t);
          destroy_component(dialog, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$c.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }

    function instance$c($$self, $$props, $$invalidate) {
      let $globalStore;
      validate_store(globalStore, "globalStore");
      component_subscribe($$self, globalStore, $$value => $$invalidate(7, $globalStore = $$value));
      let {
        $$slots: slots = {},
        $$scope
      } = $$props;
      validate_slots("AudioInput", slots, []);

      const segundosATiempo = numeroDeSegundos => {
        let horas = Math.floor(numeroDeSegundos / 60 / 60);
        numeroDeSegundos -= horas * 60 * 60;
        let minutos = Math.floor(numeroDeSegundos / 60);
        numeroDeSegundos -= minutos * 60;
        numeroDeSegundos = parseInt(numeroDeSegundos);
        if (horas < 10) horas = "0" + horas;
        if (minutos < 10) minutos = "0" + minutos;
        if (numeroDeSegundos < 10) numeroDeSegundos = "0" + numeroDeSegundos;
        return `${horas}:${minutos}:${numeroDeSegundos}`;
      };

      let listaDeDispositivos = [];
      let duracion = segundosATiempo(0),
          tiempoInicio,
          mediaRecorder,
          idIntervalo;

      const refrescar = () => {
        let tiempo = (Date.now() - tiempoInicio) / 1000;
        $$invalidate(2, duracion = segundosATiempo(tiempo));

        if (tiempo > 300) {
          detenerGrabacion();
        }
      }; // Consulta la lista de dispositivos de entrada de audio y llena el select


      const llenarLista = () => {
        navigator.mediaDevices.enumerateDevices().then(dispositivos => {
          $$invalidate(1, listaDeDispositivos = []);
          dispositivos.forEach((dispositivo, indice) => {
            if (dispositivo.kind === "audioinput") {
              let opcion = {
                text: dispositivo.label || `Dispositivo ${indice + 1}`,
                value: dispositivo.deviceId
              };
              listaDeDispositivos.push(opcion);
            }
          });
        });
      }; // Ayudante para la duración; no ayuda en nada pero muestra algo informativo


      const comenzarAContar = () => {
        tiempoInicio = Date.now();
        idIntervalo = setInterval(refrescar, 500);
      };

      let dispositivo;
      let estado = false;
      let {
        blobAudio
      } = $$props;
      let urlBlobAudio; // Comienza a grabar el audio con el dispositivo seleccionado

      const comenzarAGrabar = () => {
        if (!listaDeDispositivos.length) return alert("No hay dispositivos"); // No permitir que se grabe doblemente

        if (mediaRecorder) {
          detenerGrabacion();
          return;
        }

        navigator.mediaDevices.getUserMedia({
          audio: {
            deviceId: dispositivo
          }
        }).then(stream => {
          // Comenzar a grabar con el stream
          $$invalidate(4, estado = true);
          $$invalidate(10, blobAudio = null);
          $$invalidate(5, urlBlobAudio = null);
          mediaRecorder = new MediaRecorder(stream, {
            mimeType: "audio/webm"
          });
          mediaRecorder.start();
          comenzarAContar(); // En el arreglo pondremos los datos que traiga el evento dataavailable

          const fragmentosDeAudio = []; // Escuchar cuando haya datos disponibles

          mediaRecorder.addEventListener("dataavailable", evento => {
            // Y agregarlos a los fragmentos
            fragmentosDeAudio.push(evento.data);
          }); // Cuando se detenga (haciendo click en el botón) se ejecuta esto

          mediaRecorder.addEventListener("stop", () => {
            // Detener el stream
            stream.getTracks().forEach(track => track.stop()); // Detener la cuenta regresiva

            detenerConteo(); // Convertir los fragmentos a un objeto binario

            $$invalidate(10, blobAudio = new Blob(fragmentosDeAudio));
            $$invalidate(5, urlBlobAudio = URL.createObjectURL(blobAudio));
          });
        }).catch(error => {
          // Aquí maneja el error, tal vez no dieron permiso
          $$invalidate(4, estado = false);
          console.log(error);
        });
      };

      const detenerConteo = () => {
        clearInterval(idIntervalo);
        tiempoInicio = null;
        $$invalidate(2, duracion = segundosATiempo(0));
      };

      const detenerGrabacion = () => {
        if (!mediaRecorder) return alert("No se está grabando");
        mediaRecorder.stop();
        mediaRecorder = null;
        $$invalidate(4, estado = false);
      };

      function removerArchivo() {
        $$invalidate(10, blobAudio = null);
        $$invalidate(5, urlBlobAudio = null);
        $$invalidate(2, duracion = segundosATiempo(0));
      } // Cuando ya hemos configurado lo necesario allá arriba llenamos la lista


      onMount(() => {
        const tieneSoporteUserMedia = () => !!navigator.mediaDevices.getUserMedia({
          audio: true
        }); // Si no soporta...
        // Amable aviso para que el mundo comience a usar navegadores decentes ;)


        if (typeof MediaRecorder === "undefined" || !tieneSoporteUserMedia()) alert("Tu navegador web no cumple los requisitos; por favor, actualiza a un navegador decente como Firefox o Google Chrome");
        llenarLista();
      });
      let visible = false;
      const writable_props = ["blobAudio"];
      Object.keys($$props).forEach(key => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$2.warn(`<AudioInput> was created with unknown prop '${key}'`);
      });

      const mousedown_handler = () => window.location = "/Inicio";

      const touchstart_handler = () => window.location = "/Inicio";

      const mouseout_handler = () => {
        if (estado) detenerGrabacion();
      };

      const click_handler = () => $$invalidate(6, visible = true);

      function select_change_handler() {
        dispositivo = select_value(this);
        $$invalidate(3, dispositivo);
        $$invalidate(1, listaDeDispositivos);
      }

      const click_handler_1 = () => $$invalidate(6, visible = false);

      function dialog_visible_binding(value) {
        visible = value;
        $$invalidate(6, visible);
      }

      $$self.$$set = $$props => {
        if ("blobAudio" in $$props) $$invalidate(10, blobAudio = $$props.blobAudio);
      };

      $$self.$capture_state = () => ({
        onMount,
        Button: ye,
        Dialog: pn,
        globalStore,
        segundosATiempo,
        listaDeDispositivos,
        duracion,
        tiempoInicio,
        mediaRecorder,
        idIntervalo,
        refrescar,
        llenarLista,
        comenzarAContar,
        dispositivo,
        estado,
        blobAudio,
        urlBlobAudio,
        comenzarAGrabar,
        detenerConteo,
        detenerGrabacion,
        removerArchivo,
        visible,
        $globalStore
      });

      $$self.$inject_state = $$props => {
        if ("listaDeDispositivos" in $$props) $$invalidate(1, listaDeDispositivos = $$props.listaDeDispositivos);
        if ("duracion" in $$props) $$invalidate(2, duracion = $$props.duracion);
        if ("tiempoInicio" in $$props) tiempoInicio = $$props.tiempoInicio;
        if ("mediaRecorder" in $$props) mediaRecorder = $$props.mediaRecorder;
        if ("idIntervalo" in $$props) idIntervalo = $$props.idIntervalo;
        if ("dispositivo" in $$props) $$invalidate(3, dispositivo = $$props.dispositivo);
        if ("estado" in $$props) $$invalidate(4, estado = $$props.estado);
        if ("blobAudio" in $$props) $$invalidate(10, blobAudio = $$props.blobAudio);
        if ("urlBlobAudio" in $$props) $$invalidate(5, urlBlobAudio = $$props.urlBlobAudio);
        if ("visible" in $$props) $$invalidate(6, visible = $$props.visible);
      };

      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }

      return [removerArchivo, listaDeDispositivos, duracion, dispositivo, estado, urlBlobAudio, visible, $globalStore, comenzarAGrabar, detenerGrabacion, blobAudio, mousedown_handler, touchstart_handler, mouseout_handler, click_handler, select_change_handler, click_handler_1, dialog_visible_binding];
    }

    class AudioInput extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$c, create_fragment$c, safe_not_equal, {
          blobAudio: 10,
          removerArchivo: 0
        });
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "AudioInput",
          options,
          id: create_fragment$c.name
        });
        const {
          ctx
        } = this.$$;
        const props = options.props || {};

        if (
        /*blobAudio*/
        ctx[10] === undefined && !("blobAudio" in props)) {
          console_1$2.warn("<AudioInput> was created without expected prop 'blobAudio'");
        }
      }

      get blobAudio() {
        throw new Error("<AudioInput>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set blobAudio(value) {
        throw new Error("<AudioInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get removerArchivo() {
        return this.$$.ctx[0];
      }

      set removerArchivo(value) {
        throw new Error("<AudioInput>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

    }

    /* src\components\Comentarios\Formulario.svelte generated by Svelte v3.29.0 */
    const file$d = "src\\components\\Comentarios\\Formulario.svelte"; // (106:4) {#if hilo.audios}

    function create_if_block_2$7(ctx) {
      let audioinput;
      let updating_blobAudio;
      let current;

      function audioinput_blobAudio_binding(value) {
        /*audioinput_blobAudio_binding*/
        ctx[19].call(null, value);
      }

      let audioinput_props = {};

      if (
      /*audio*/
      ctx[4] !== void 0) {
        audioinput_props.blobAudio =
        /*audio*/
        ctx[4];
      }

      audioinput = new AudioInput({
        props: audioinput_props,
        $$inline: true
      });
      /*audioinput_binding*/

      ctx[18](audioinput);
      binding_callbacks.push(() => bind(audioinput, "blobAudio", audioinput_blobAudio_binding));
      const block = {
        c: function create() {
          create_component(audioinput.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(audioinput, target, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          const audioinput_changes = {};

          if (!updating_blobAudio && dirty &
          /*audio*/
          16) {
            updating_blobAudio = true;
            audioinput_changes.blobAudio =
            /*audio*/
            ctx[4];
            add_flush_callback(() => updating_blobAudio = false);
          }

          audioinput.$set(audioinput_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(audioinput.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(audioinput.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          /*audioinput_binding*/
          ctx[18](null);
          destroy_component(audioinput, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_2$7.name,
        type: "if",
        source: "(106:4) {#if hilo.audios}",
        ctx
      });
      return block;
    } // (120:17) <Checkbox bind:checked={hide_flag} right>


    function create_default_slot_4$5(ctx) {
      let t;
      const block = {
        c: function create() {
          t = text("Hide");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_4$5.name,
        type: "slot",
        source: "(120:17) <Checkbox bind:checked={hide_flag} right>",
        ctx
      });
      return block;
    } // (123:8) {#if $globalStore.usuario.esMod || ($globalStore.usuario.esAuxiliar && config.general.modoSerenito)}


    function create_if_block$b(ctx) {
      let div;
      let span;
      let checkbox;
      let updating_checked;
      let t;
      let current;

      function checkbox_checked_binding_1(value) {
        /*checkbox_checked_binding_1*/
        ctx[22].call(null, value);
      }

      let checkbox_props = {
        right: true,
        $$slots: {
          default: [create_default_slot_3$7]
        },
        $$scope: {
          ctx
        }
      };

      if (
      /*mostrarRango*/
      ctx[6] !== void 0) {
        checkbox_props.checked =
        /*mostrarRango*/
        ctx[6];
      }

      checkbox = new Ne({
        props: checkbox_props,
        $$inline: true
      });
      binding_callbacks.push(() => bind(checkbox, "checked", checkbox_checked_binding_1));
      let if_block =
      /*$globalStore*/
      ctx[12].usuario.esAdmin && create_if_block_1$7(ctx);
      const block = {
        c: function create() {
          div = element("div");
          span = element("span");
          create_component(checkbox.$$.fragment);
          t = space();
          if (if_block) if_block.c();
          set_style(span, "width", "fit-content");
          set_style(span, "margin-right", "auto");
          add_location(span, file$d, 124, 16, 3915);
          set_style(div, "flex-direction", "row");
          set_style(div, "display", "flex");
          set_style(div, "flex-wrap", "wrap");
          add_location(div, file$d, 123, 12, 3832);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          append_dev(div, span);
          mount_component(checkbox, span, null);
          append_dev(div, t);
          if (if_block) if_block.m(div, null);
          current = true;
        },
        p: function update(ctx, dirty) {
          const checkbox_changes = {};

          if (dirty &
          /*$$scope*/
          67108864) {
            checkbox_changes.$$scope = {
              dirty,
              ctx
            };
          }

          if (!updating_checked && dirty &
          /*mostrarRango*/
          64) {
            updating_checked = true;
            checkbox_changes.checked =
            /*mostrarRango*/
            ctx[6];
            add_flush_callback(() => updating_checked = false);
          }

          checkbox.$set(checkbox_changes);

          if (
          /*$globalStore*/
          ctx[12].usuario.esAdmin) {
            if (if_block) {
              if_block.p(ctx, dirty);

              if (dirty &
              /*$globalStore*/
              4096) {
                transition_in(if_block, 1);
              }
            } else {
              if_block = create_if_block_1$7(ctx);
              if_block.c();
              transition_in(if_block, 1);
              if_block.m(div, null);
            }
          } else if (if_block) {
            group_outros();
            transition_out(if_block, 1, 1, () => {
              if_block = null;
            });
            check_outros();
          }
        },
        i: function intro(local) {
          if (current) return;
          transition_in(checkbox.$$.fragment, local);
          transition_in(if_block);
          current = true;
        },
        o: function outro(local) {
          transition_out(checkbox.$$.fragment, local);
          transition_out(if_block);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
          destroy_component(checkbox);
          if (if_block) if_block.d();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block$b.name,
        type: "if",
        source: "(123:8) {#if $globalStore.usuario.esMod || ($globalStore.usuario.esAuxiliar && config.general.modoSerenito)}",
        ctx
      });
      return block;
    } // (126:21) <Checkbox bind:checked={mostrarRango} right                          >


    function create_default_slot_3$7(ctx) {
      let t;
      const block = {
        c: function create() {
          t = text("Lucesitas");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_3$7.name,
        type: "slot",
        source: "(126:21) <Checkbox bind:checked={mostrarRango} right                          >",
        ctx
      });
      return block;
    } // (130:16) {#if $globalStore.usuario.esAdmin}


    function create_if_block_1$7(ctx) {
      let span;
      let checkbox;
      let updating_checked;
      let current;

      function checkbox_checked_binding_2(value) {
        /*checkbox_checked_binding_2*/
        ctx[23].call(null, value);
      }

      let checkbox_props = {
        right: true,
        $$slots: {
          default: [create_default_slot_2$7]
        },
        $$scope: {
          ctx
        }
      };

      if (
      /*mostrarNombre*/
      ctx[7] !== void 0) {
        checkbox_props.checked =
        /*mostrarNombre*/
        ctx[7];
      }

      checkbox = new Ne({
        props: checkbox_props,
        $$inline: true
      });
      binding_callbacks.push(() => bind(checkbox, "checked", checkbox_checked_binding_2));
      const block = {
        c: function create() {
          span = element("span");
          create_component(checkbox.$$.fragment);
          set_style(span, "width", "fit-content");
          set_style(span, "margin-right", "auto");
          add_location(span, file$d, 130, 20, 4201);
        },
        m: function mount(target, anchor) {
          insert_dev(target, span, anchor);
          mount_component(checkbox, span, null);
          current = true;
        },
        p: function update(ctx, dirty) {
          const checkbox_changes = {};

          if (dirty &
          /*$$scope*/
          67108864) {
            checkbox_changes.$$scope = {
              dirty,
              ctx
            };
          }

          if (!updating_checked && dirty &
          /*mostrarNombre*/
          128) {
            updating_checked = true;
            checkbox_changes.checked =
            /*mostrarNombre*/
            ctx[7];
            add_flush_callback(() => updating_checked = false);
          }

          checkbox.$set(checkbox_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(checkbox.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(checkbox.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(span);
          destroy_component(checkbox);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_1$7.name,
        type: "if",
        source: "(130:16) {#if $globalStore.usuario.esAdmin}",
        ctx
      });
      return block;
    } // (132:25) <Checkbox bind:checked={mostrarNombre} right                              >


    function create_default_slot_2$7(ctx) {
      let t;
      const block = {
        c: function create() {
          t = text("Nombre");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_2$7.name,
        type: "slot",
        source: "(132:25) <Checkbox bind:checked={mostrarNombre} right                              >",
        ctx
      });
      return block;
    } // (145:12) <Spinner {cargando}>


    function create_default_slot_1$7(ctx) {
      let t_value = (
      /*espera*/
      ctx[8] == 0 ? "Responder" :
      /*espera*/
      ctx[8]) + "";
      let t;
      const block = {
        c: function create() {
          t = text(t_value);
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        p: function update(ctx, dirty) {
          if (dirty &
          /*espera*/
          256 && t_value !== (t_value = (
          /*espera*/
          ctx[8] == 0 ? "Responder" :
          /*espera*/
          ctx[8]) + "")) set_data_dev(t, t_value);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_1$7.name,
        type: "slot",
        source: "(145:12) <Spinner {cargando}>",
        ctx
      });
      return block;
    } // (139:8) <Button              disabled={cargando}              color="primary"              class="mra"              on:click={crearComentario}          >


    function create_default_slot$8(ctx) {
      let spinner;
      let current;
      spinner = new Spinner({
        props: {
          cargando:
          /*cargando*/
          ctx[1],
          $$slots: {
            default: [create_default_slot_1$7]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          create_component(spinner.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(spinner, target, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          const spinner_changes = {};
          if (dirty &
          /*cargando*/
          2) spinner_changes.cargando =
          /*cargando*/
          ctx[1];

          if (dirty &
          /*$$scope, espera*/
          67109120) {
            spinner_changes.$$scope = {
              dirty,
              ctx
            };
          }

          spinner.$set(spinner_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(spinner.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(spinner.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(spinner, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot$8.name,
        type: "slot",
        source: "(139:8) <Button              disabled={cargando}              color=\\\"primary\\\"              class=\\\"mra\\\"              on:click={crearComentario}          >",
        ctx
      });
      return block;
    }

    function create_fragment$d(ctx) {
      let form;
      let errorvalidacion;
      let t0;
      let mediainput;
      let updating_media;
      let t1;
      let t2;
      let textarea;
      let t3;
      let div1;
      let div0;
      let span;
      let checkbox;
      let updating_checked;
      let t4;
      let t5;
      let button;
      let current;
      let mounted;
      let dispose;
      errorvalidacion = new ErrorValidacion({
        props: {
          error:
          /*error*/
          ctx[9]
        },
        $$inline: true
      });

      function mediainput_media_binding(value) {
        /*mediainput_media_binding*/
        ctx[17].call(null, value);
      }

      let mediainput_props = {
        compacto: true
      };

      if (
      /*media*/
      ctx[2] !== void 0) {
        mediainput_props.media =
        /*media*/
        ctx[2];
      }

      mediainput = new MediaInput({
        props: mediainput_props,
        $$inline: true
      });
      /*mediainput_binding*/

      ctx[16](mediainput);
      binding_callbacks.push(() => bind(mediainput, "media", mediainput_media_binding));
      let if_block0 =
      /*hilo*/
      ctx[0].audios && create_if_block_2$7(ctx);

      function checkbox_checked_binding(value) {
        /*checkbox_checked_binding*/
        ctx[21].call(null, value);
      }

      let checkbox_props = {
        right: true,
        $$slots: {
          default: [create_default_slot_4$5]
        },
        $$scope: {
          ctx
        }
      };

      if (
      /*hide_flag*/
      ctx[10] !== void 0) {
        checkbox_props.checked =
        /*hide_flag*/
        ctx[10];
      }

      checkbox = new Ne({
        props: checkbox_props,
        $$inline: true
      });
      binding_callbacks.push(() => bind(checkbox, "checked", checkbox_checked_binding));
      let if_block1 = (
      /*$globalStore*/
      ctx[12].usuario.esMod ||
      /*$globalStore*/
      ctx[12].usuario.esAuxiliar && config.general.modoSerenito) && create_if_block$b(ctx);
      button = new ye({
        props: {
          disabled:
          /*cargando*/
          ctx[1],
          color: "primary",
          class: "mra",
          $$slots: {
            default: [create_default_slot$8]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      button.$on("click",
      /*crearComentario*/
      ctx[13]);
      const block = {
        c: function create() {
          form = element("form");
          create_component(errorvalidacion.$$.fragment);
          t0 = space();
          create_component(mediainput.$$.fragment);
          t1 = space();
          if (if_block0) if_block0.c();
          t2 = space();
          textarea = element("textarea");
          t3 = space();
          div1 = element("div");
          div0 = element("div");
          span = element("span");
          create_component(checkbox.$$.fragment);
          t4 = space();
          if (if_block1) if_block1.c();
          t5 = space();
          create_component(button.$$.fragment);
          attr_dev(textarea, "cols", "30");
          attr_dev(textarea, "rows", "10");
          attr_dev(textarea, "placeholder", "Que dificil discutir con pibes...");
          add_location(textarea, file$d, 108, 4, 3246);
          set_style(span, "width", "fit-content");
          set_style(span, "margin-right", "auto");
          add_location(span, file$d, 118, 12, 3544);
          set_style(div0, "flex-direction", "row");
          set_style(div0, "display", "flex");
          set_style(div0, "flex-wrap", "wrap");
          add_location(div0, file$d, 117, 8, 3465);
          attr_dev(div1, "class", "acciones svelte-llyggc");
          add_location(div1, file$d, 116, 4, 3433);
          attr_dev(form, "id", "form-comentario");
          attr_dev(form, "class", "form-comentario panel svelte-llyggc");
          add_location(form, file$d, 97, 0, 2897);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, form, anchor);
          mount_component(errorvalidacion, form, null);
          append_dev(form, t0);
          mount_component(mediainput, form, null);
          append_dev(form, t1);
          if (if_block0) if_block0.m(form, null);
          append_dev(form, t2);
          append_dev(form, textarea);
          set_input_value(textarea,
          /*$comentarioStore*/
          ctx[11]);
          append_dev(form, t3);
          append_dev(form, div1);
          append_dev(div1, div0);
          append_dev(div0, span);
          mount_component(checkbox, span, null);
          append_dev(div1, t4);
          if (if_block1) if_block1.m(div1, null);
          append_dev(div1, t5);
          mount_component(button, div1, null);
          current = true;

          if (!mounted) {
            dispose = [listen_dev(textarea, "focus",
            /*onFocus*/
            ctx[14], false, false, false), listen_dev(textarea, "input",
            /*textarea_input_handler*/
            ctx[20]), listen_dev(form, "submit", prevent_default(
            /*submit_handler*/
            ctx[15]), false, true, false), listen_dev(form, "blur",
            /*blur_handler*/
            ctx[24], false, false, false)];
            mounted = true;
          }
        },
        p: function update(ctx, [dirty]) {
          const errorvalidacion_changes = {};
          if (dirty &
          /*error*/
          512) errorvalidacion_changes.error =
          /*error*/
          ctx[9];
          errorvalidacion.$set(errorvalidacion_changes);
          const mediainput_changes = {};

          if (!updating_media && dirty &
          /*media*/
          4) {
            updating_media = true;
            mediainput_changes.media =
            /*media*/
            ctx[2];
            add_flush_callback(() => updating_media = false);
          }

          mediainput.$set(mediainput_changes);

          if (
          /*hilo*/
          ctx[0].audios) {
            if (if_block0) {
              if_block0.p(ctx, dirty);

              if (dirty &
              /*hilo*/
              1) {
                transition_in(if_block0, 1);
              }
            } else {
              if_block0 = create_if_block_2$7(ctx);
              if_block0.c();
              transition_in(if_block0, 1);
              if_block0.m(form, t2);
            }
          } else if (if_block0) {
            group_outros();
            transition_out(if_block0, 1, 1, () => {
              if_block0 = null;
            });
            check_outros();
          }

          if (dirty &
          /*$comentarioStore*/
          2048) {
            set_input_value(textarea,
            /*$comentarioStore*/
            ctx[11]);
          }

          const checkbox_changes = {};

          if (dirty &
          /*$$scope*/
          67108864) {
            checkbox_changes.$$scope = {
              dirty,
              ctx
            };
          }

          if (!updating_checked && dirty &
          /*hide_flag*/
          1024) {
            updating_checked = true;
            checkbox_changes.checked =
            /*hide_flag*/
            ctx[10];
            add_flush_callback(() => updating_checked = false);
          }

          checkbox.$set(checkbox_changes);

          if (
          /*$globalStore*/
          ctx[12].usuario.esMod ||
          /*$globalStore*/
          ctx[12].usuario.esAuxiliar && config.general.modoSerenito) {
            if (if_block1) {
              if_block1.p(ctx, dirty);

              if (dirty &
              /*$globalStore*/
              4096) {
                transition_in(if_block1, 1);
              }
            } else {
              if_block1 = create_if_block$b(ctx);
              if_block1.c();
              transition_in(if_block1, 1);
              if_block1.m(div1, t5);
            }
          } else if (if_block1) {
            group_outros();
            transition_out(if_block1, 1, 1, () => {
              if_block1 = null;
            });
            check_outros();
          }

          const button_changes = {};
          if (dirty &
          /*cargando*/
          2) button_changes.disabled =
          /*cargando*/
          ctx[1];

          if (dirty &
          /*$$scope, cargando, espera*/
          67109122) {
            button_changes.$$scope = {
              dirty,
              ctx
            };
          }

          button.$set(button_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(errorvalidacion.$$.fragment, local);
          transition_in(mediainput.$$.fragment, local);
          transition_in(if_block0);
          transition_in(checkbox.$$.fragment, local);
          transition_in(if_block1);
          transition_in(button.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(errorvalidacion.$$.fragment, local);
          transition_out(mediainput.$$.fragment, local);
          transition_out(if_block0);
          transition_out(checkbox.$$.fragment, local);
          transition_out(if_block1);
          transition_out(button.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(form);
          destroy_component(errorvalidacion);
          /*mediainput_binding*/

          ctx[16](null);
          destroy_component(mediainput);
          if (if_block0) if_block0.d();
          destroy_component(checkbox);
          if (if_block1) if_block1.d();
          destroy_component(button);
          mounted = false;
          run_all(dispose);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$d.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }

    function instance$d($$self, $$props, $$invalidate) {
      let $comentarioStore;
      let $globalStore;
      validate_store(comentarioStore, "comentarioStore");
      component_subscribe($$self, comentarioStore, $$value => $$invalidate(11, $comentarioStore = $$value));
      validate_store(globalStore, "globalStore");
      component_subscribe($$self, globalStore, $$value => $$invalidate(12, $globalStore = $$value));
      let {
        $$slots: slots = {},
        $$scope
      } = $$props;
      validate_slots("Formulario", slots, []);
      let dispatch = createEventDispatcher();
      let {
        hilo
      } = $$props;
      let cargando = false;
      let media;
      let mediaInput;
      let audio = null;
      let audioInput;
      let mostrarRango = false;
      let mostrarNombre = false;
      let espera = 0;
      let error = null;
      let hide_flag = false;

      async function crearComentario() {
        if (espera != 0 || cargando) return;

        try {
          $$invalidate(1, cargando = true);
          var comentarioConFlag = $comentarioStore;

          if (comentarioConFlag != "") {
            comentarioConFlag += "\n";
          }

          comentarioConFlag += hide_flag ? ">hide\n" : "";

          if ($globalStore.usuario.esMod || $globalStore.usuario.esAuxiliar && config.general.modoSerenito) {
            await RChanClient.crearComentario(hilo.id, comentarioConFlag, media.archivo, media.link, audio, "", mostrarNombre && $globalStore.usuario.esAdmin, mostrarRango);
          } else {
            await RChanClient.crearComentario(hilo.id, comentarioConFlag, media.archivo, media.link, audio);
          }

          if (!$globalStore.usuario.esMod) {
            $$invalidate(8, espera = config.general.tiempoEntreComentarios);
          }

          if (hide_flag) {
            $$invalidate(10, hide_flag = false);
          }

          mediaInput.removerArchivo();
          if (hilo.audios) audioInput.removerArchivo();
          dispatch("comentarioCreado");
        } catch (e) {
          $$invalidate(9, error = e.response.data);
          $$invalidate(1, cargando = false);
          return;
        }

        $$invalidate(1, cargando = false);
        set_store_value(comentarioStore, $comentarioStore = "", $comentarioStore);
        $$invalidate(2, media.archivo = null, media);
        $$invalidate(9, error = null);
      }

      function onFocus() {
        $$invalidate(9, error = null);

        if (!$globalStore.usuario.estaAutenticado) {
          window.location = "/Inicio";
        }
      }

      const writable_props = ["hilo"];
      Object.keys($$props).forEach(key => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Formulario> was created with unknown prop '${key}'`);
      });

      function submit_handler(event) {
        bubble($$self, event);
      }

      function mediainput_binding($$value) {
        binding_callbacks[$$value ? "unshift" : "push"](() => {
          mediaInput = $$value;
          $$invalidate(3, mediaInput);
        });
      }

      function mediainput_media_binding(value) {
        media = value;
        $$invalidate(2, media);
      }

      function audioinput_binding($$value) {
        binding_callbacks[$$value ? "unshift" : "push"](() => {
          audioInput = $$value;
          $$invalidate(5, audioInput);
        });
      }

      function audioinput_blobAudio_binding(value) {
        audio = value;
        $$invalidate(4, audio);
      }

      function textarea_input_handler() {
        $comentarioStore = this.value;
        comentarioStore.set($comentarioStore);
      }

      function checkbox_checked_binding(value) {
        hide_flag = value;
        $$invalidate(10, hide_flag);
      }

      function checkbox_checked_binding_1(value) {
        mostrarRango = value;
        $$invalidate(6, mostrarRango);
      }

      function checkbox_checked_binding_2(value) {
        mostrarNombre = value;
        $$invalidate(7, mostrarNombre);
      }

      const blur_handler = () => focus = false;

      $$self.$$set = $$props => {
        if ("hilo" in $$props) $$invalidate(0, hilo = $$props.hilo);
      };

      $$self.$capture_state = () => ({
        createEventDispatcher,
        Button: ye,
        Checkbox: Ne,
        comentarioStore,
        RChanClient,
        ErrorValidacion,
        MediaInput,
        Spinner,
        config,
        globalStore,
        AudioInput,
        dispatch,
        hilo,
        cargando,
        media,
        mediaInput,
        audio,
        audioInput,
        mostrarRango,
        mostrarNombre,
        espera,
        error,
        hide_flag,
        crearComentario,
        onFocus,
        $comentarioStore,
        $globalStore
      });

      $$self.$inject_state = $$props => {
        if ("dispatch" in $$props) dispatch = $$props.dispatch;
        if ("hilo" in $$props) $$invalidate(0, hilo = $$props.hilo);
        if ("cargando" in $$props) $$invalidate(1, cargando = $$props.cargando);
        if ("media" in $$props) $$invalidate(2, media = $$props.media);
        if ("mediaInput" in $$props) $$invalidate(3, mediaInput = $$props.mediaInput);
        if ("audio" in $$props) $$invalidate(4, audio = $$props.audio);
        if ("audioInput" in $$props) $$invalidate(5, audioInput = $$props.audioInput);
        if ("mostrarRango" in $$props) $$invalidate(6, mostrarRango = $$props.mostrarRango);
        if ("mostrarNombre" in $$props) $$invalidate(7, mostrarNombre = $$props.mostrarNombre);
        if ("espera" in $$props) $$invalidate(8, espera = $$props.espera);
        if ("error" in $$props) $$invalidate(9, error = $$props.error);
        if ("hide_flag" in $$props) $$invalidate(10, hide_flag = $$props.hide_flag);
      };

      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }

      $$self.$$.update = () => {
        if ($$self.$$.dirty &
        /*espera*/
        256) {
           if (espera != 0) {
            setTimeout(() => $$invalidate(8, espera--, espera), 1000);
          }
        }
      };

      return [hilo, cargando, media, mediaInput, audio, audioInput, mostrarRango, mostrarNombre, espera, error, hide_flag, $comentarioStore, $globalStore, crearComentario, onFocus, submit_handler, mediainput_binding, mediainput_media_binding, audioinput_binding, audioinput_blobAudio_binding, textarea_input_handler, checkbox_checked_binding, checkbox_checked_binding_1, checkbox_checked_binding_2, blur_handler];
    }

    class Formulario extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$d, create_fragment$d, safe_not_equal, {
          hilo: 0
        });
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "Formulario",
          options,
          id: create_fragment$d.name
        });
        const {
          ctx
        } = this.$$;
        const props = options.props || {};

        if (
        /*hilo*/
        ctx[0] === undefined && !("hilo" in props)) {
          console.warn("<Formulario> was created without expected prop 'hilo'");
        }
      }

      get hilo() {
        throw new Error("<Formulario>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set hilo(value) {
        throw new Error("<Formulario>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

    }

    /* src\components\Comentarios\CarpetaMedia.svelte generated by Svelte v3.29.0 */
    const file$e = "src\\components\\Comentarios\\CarpetaMedia.svelte";

    function get_each_context$6(ctx, list, i) {
      const child_ctx = ctx.slice();
      child_ctx[6] = list[i];
      return child_ctx;
    } // (20:0) {#if visible}


    function create_if_block$c(ctx) {
      let div;
      let section;
      let h3;
      let t1;
      let ul;
      let div_transition;
      let current;
      let mounted;
      let dispose;
      let each_value =
      /*comentarios*/
      ctx[1];
      validate_each_argument(each_value);
      let each_blocks = [];

      for (let i = 0; i < each_value.length; i += 1) {
        each_blocks[i] = create_each_block$6(get_each_context$6(ctx, each_value, i));
      }

      const out = i => transition_out(each_blocks[i], 1, 1, () => {
        each_blocks[i] = null;
      });

      const block = {
        c: function create() {
          div = element("div");
          section = element("section");
          h3 = element("h3");
          h3.textContent = "Archivos del roz";
          t1 = space();
          ul = element("ul");

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].c();
          }

          attr_dev(h3, "class", "svelte-11ravkn");
          add_location(h3, file$e, 27, 12, 688);
          attr_dev(ul, "class", "svelte-11ravkn");
          add_location(ul, file$e, 28, 12, 727);
          attr_dev(section, "class", "carpeta-media panel svelte-11ravkn");
          add_location(section, file$e, 26, 8, 637);
          attr_dev(div, "class", "fondo svelte-11ravkn");
          set_style(div, "z-index", "20");
          add_location(div, file$e, 20, 4, 476);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          append_dev(div, section);
          append_dev(section, h3);
          append_dev(section, t1);
          append_dev(section, ul);

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].m(ul, null);
          }

          current = true;

          if (!mounted) {
            dispose = listen_dev(div, "click",
            /*click_handler*/
            ctx[3], false, false, false);
            mounted = true;
          }
        },
        p: function update(ctx, dirty) {
          if (dirty &
          /*comentarios, onMediaClick*/
          6) {
            each_value =
            /*comentarios*/
            ctx[1];
            validate_each_argument(each_value);
            let i;

            for (i = 0; i < each_value.length; i += 1) {
              const child_ctx = get_each_context$6(ctx, each_value, i);

              if (each_blocks[i]) {
                each_blocks[i].p(child_ctx, dirty);
                transition_in(each_blocks[i], 1);
              } else {
                each_blocks[i] = create_each_block$6(child_ctx);
                each_blocks[i].c();
                transition_in(each_blocks[i], 1);
                each_blocks[i].m(ul, null);
              }
            }

            group_outros();

            for (i = each_value.length; i < each_blocks.length; i += 1) {
              out(i);
            }

            check_outros();
          }
        },
        i: function intro(local) {
          if (current) return;

          for (let i = 0; i < each_value.length; i += 1) {
            transition_in(each_blocks[i]);
          }

          add_render_callback(() => {
            if (!div_transition) div_transition = create_bidirectional_transition(div, fade, {
              duration: 150
            }, true);
            div_transition.run(1);
          });
          current = true;
        },
        o: function outro(local) {
          each_blocks = each_blocks.filter(Boolean);

          for (let i = 0; i < each_blocks.length; i += 1) {
            transition_out(each_blocks[i]);
          }

          if (!div_transition) div_transition = create_bidirectional_transition(div, fade, {
            duration: 150
          }, false);
          div_transition.run(0);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
          destroy_each(each_blocks, detaching);
          if (detaching && div_transition) div_transition.end();
          mounted = false;
          dispose();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block$c.name,
        type: "if",
        source: "(20:0) {#if visible}",
        ctx
      });
      return block;
    } // (31:20) {#if c.media}


    function create_if_block_1$8(ctx) {
      let li;
      let media;
      let t0;
      let a;
      let a_href_value;
      let t1;
      let li_r_id_value;
      let current;
      let mounted;
      let dispose;
      media = new Media({
        props: {
          media:
          /*c*/
          ctx[6].media,
          modoCuadrado: true
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          li = element("li");
          create_component(media.$$.fragment);
          t0 = space();
          a = element("a");
          t1 = space();
          attr_dev(a, "href", a_href_value = "#" +
          /*c*/
          ctx[6].id);
          attr_dev(a, "class", "click-area svelte-11ravkn");
          add_location(a, file$e, 33, 28, 955);
          attr_dev(li, "r-id", li_r_id_value =
          /*c*/
          ctx[6].id);
          attr_dev(li, "class", "svelte-11ravkn");
          add_location(li, file$e, 31, 24, 834);
        },
        m: function mount(target, anchor) {
          insert_dev(target, li, anchor);
          mount_component(media, li, null);
          append_dev(li, t0);
          append_dev(li, a);
          append_dev(li, t1);
          current = true;

          if (!mounted) {
            dispose = listen_dev(a, "click", function () {
              if (is_function(
              /*onMediaClick*/
              ctx[2](
              /*c*/
              ctx[6].id)))
                /*onMediaClick*/
                ctx[2](
                /*c*/
                ctx[6].id).apply(this, arguments);
            }, false, false, false);
            mounted = true;
          }
        },
        p: function update(new_ctx, dirty) {
          ctx = new_ctx;
          const media_changes = {};
          if (dirty &
          /*comentarios*/
          2) media_changes.media =
          /*c*/
          ctx[6].media;
          media.$set(media_changes);

          if (!current || dirty &
          /*comentarios*/
          2 && a_href_value !== (a_href_value = "#" +
          /*c*/
          ctx[6].id)) {
            attr_dev(a, "href", a_href_value);
          }

          if (!current || dirty &
          /*comentarios*/
          2 && li_r_id_value !== (li_r_id_value =
          /*c*/
          ctx[6].id)) {
            attr_dev(li, "r-id", li_r_id_value);
          }
        },
        i: function intro(local) {
          if (current) return;
          transition_in(media.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(media.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(li);
          destroy_component(media);
          mounted = false;
          dispose();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_1$8.name,
        type: "if",
        source: "(31:20) {#if c.media}",
        ctx
      });
      return block;
    } // (30:16) {#each comentarios as c}


    function create_each_block$6(ctx) {
      let if_block_anchor;
      let current;
      let if_block =
      /*c*/
      ctx[6].media && create_if_block_1$8(ctx);
      const block = {
        c: function create() {
          if (if_block) if_block.c();
          if_block_anchor = empty();
        },
        m: function mount(target, anchor) {
          if (if_block) if_block.m(target, anchor);
          insert_dev(target, if_block_anchor, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          if (
          /*c*/
          ctx[6].media) {
            if (if_block) {
              if_block.p(ctx, dirty);

              if (dirty &
              /*comentarios*/
              2) {
                transition_in(if_block, 1);
              }
            } else {
              if_block = create_if_block_1$8(ctx);
              if_block.c();
              transition_in(if_block, 1);
              if_block.m(if_block_anchor.parentNode, if_block_anchor);
            }
          } else if (if_block) {
            group_outros();
            transition_out(if_block, 1, 1, () => {
              if_block = null;
            });
            check_outros();
          }
        },
        i: function intro(local) {
          if (current) return;
          transition_in(if_block);
          current = true;
        },
        o: function outro(local) {
          transition_out(if_block);
          current = false;
        },
        d: function destroy(detaching) {
          if (if_block) if_block.d(detaching);
          if (detaching) detach_dev(if_block_anchor);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_each_block$6.name,
        type: "each",
        source: "(30:16) {#each comentarios as c}",
        ctx
      });
      return block;
    }

    function create_fragment$e(ctx) {
      let if_block_anchor;
      let current;
      let if_block =
      /*visible*/
      ctx[0] && create_if_block$c(ctx);
      const block = {
        c: function create() {
          if (if_block) if_block.c();
          if_block_anchor = empty();
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          if (if_block) if_block.m(target, anchor);
          insert_dev(target, if_block_anchor, anchor);
          current = true;
        },
        p: function update(ctx, [dirty]) {
          if (
          /*visible*/
          ctx[0]) {
            if (if_block) {
              if_block.p(ctx, dirty);

              if (dirty &
              /*visible*/
              1) {
                transition_in(if_block, 1);
              }
            } else {
              if_block = create_if_block$c(ctx);
              if_block.c();
              transition_in(if_block, 1);
              if_block.m(if_block_anchor.parentNode, if_block_anchor);
            }
          } else if (if_block) {
            group_outros();
            transition_out(if_block, 1, 1, () => {
              if_block = null;
            });
            check_outros();
          }
        },
        i: function intro(local) {
          if (current) return;
          transition_in(if_block);
          current = true;
        },
        o: function outro(local) {
          transition_out(if_block);
          current = false;
        },
        d: function destroy(detaching) {
          if (if_block) if_block.d(detaching);
          if (detaching) detach_dev(if_block_anchor);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$e.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }

    function instance$e($$self, $$props, $$invalidate) {
      let {
        $$slots: slots = {},
        $$scope
      } = $$props;
      validate_slots("CarpetaMedia", slots, []);
      let {
        comentarios = []
      } = $$props;
      let {
        visible = true
      } = $$props;
      let dispatch = createEventDispatcher();

      function onMediaClick(id) {
        $$invalidate(0, visible = false);
        irAComentario(id);
      }

      function irAComentario(id) {
        dispatch("irAComentario", id);
      }

      const writable_props = ["comentarios", "visible"];
      Object.keys($$props).forEach(key => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<CarpetaMedia> was created with unknown prop '${key}'`);
      });

      const click_handler = () => $$invalidate(0, visible = false);

      $$self.$$set = $$props => {
        if ("comentarios" in $$props) $$invalidate(1, comentarios = $$props.comentarios);
        if ("visible" in $$props) $$invalidate(0, visible = $$props.visible);
      };

      $$self.$capture_state = () => ({
        Media,
        fade,
        createEventDispatcher,
        comentarios,
        visible,
        dispatch,
        onMediaClick,
        irAComentario
      });

      $$self.$inject_state = $$props => {
        if ("comentarios" in $$props) $$invalidate(1, comentarios = $$props.comentarios);
        if ("visible" in $$props) $$invalidate(0, visible = $$props.visible);
        if ("dispatch" in $$props) dispatch = $$props.dispatch;
      };

      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }

      return [visible, comentarios, onMediaClick, click_handler];
    }

    class CarpetaMedia extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$e, create_fragment$e, safe_not_equal, {
          comentarios: 1,
          visible: 0
        });
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "CarpetaMedia",
          options,
          id: create_fragment$e.name
        });
      }

      get comentarios() {
        throw new Error("<CarpetaMedia>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set comentarios(value) {
        throw new Error("<CarpetaMedia>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get visible() {
        throw new Error("<CarpetaMedia>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set visible(value) {
        throw new Error("<CarpetaMedia>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

    }

    /* src\components\Comentarios\PilaRespuestas.svelte generated by Svelte v3.29.0 */
    const {
      Map: Map_1,
      Object: Object_1$3
    } = globals;
    const file$f = "src\\components\\Comentarios\\PilaRespuestas.svelte";

    function get_each_context$7(ctx, list, i) {
      const child_ctx = ctx.slice();
      child_ctx[11] = list[i];
      return child_ctx;
    } // (26:0) {#if historial.length != 0}


    function create_if_block$d(ctx) {
      let div2;
      let div1;
      let div0;
      let button0;
      let t0;
      let button1;
      let t1;
      let ul;
      let each_blocks = [];
      let each_1_lookup = new Map_1();
      let div1_transition;
      let current;
      let mounted;
      let dispose;
      button0 = new ye({
        props: {
          $$slots: {
            default: [create_default_slot_1$8]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      button0.$on("click",
      /*atras*/
      ctx[3]);
      button1 = new ye({
        props: {
          $$slots: {
            default: [create_default_slot$9]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      button1.$on("click",
      /*click_handler_1*/
      ctx[8]);
      let each_value =
      /*historial*/
      ctx[0][
      /*historial*/
      ctx[0].length - 1];
      validate_each_argument(each_value);

      const get_key = ctx =>
      /*c*/
      ctx[11].id;

      validate_each_keys(ctx, each_value, get_each_context$7, get_key);

      for (let i = 0; i < each_value.length; i += 1) {
        let child_ctx = get_each_context$7(ctx, each_value, i);
        let key = get_key(child_ctx);
        each_1_lookup.set(key, each_blocks[i] = create_each_block$7(key, child_ctx));
      }

      const block = {
        c: function create() {
          div2 = element("div");
          div1 = element("div");
          div0 = element("div");
          create_component(button0.$$.fragment);
          t0 = space();
          create_component(button1.$$.fragment);
          t1 = space();
          ul = element("ul");

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].c();
          }

          attr_dev(div0, "class", "acciones svelte-sjrmrq");
          add_location(div0, file$f, 28, 12, 988);
          attr_dev(ul, "class", "svelte-sjrmrq");
          add_location(ul, file$f, 32, 12, 1170);
          attr_dev(div1, "class", "pila-respuestas svelte-sjrmrq");
          add_location(div1, file$f, 27, 8, 882);
          attr_dev(div2, "class", "fondo svelte-sjrmrq");
          add_location(div2, file$f, 26, 4, 837);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div2, anchor);
          append_dev(div2, div1);
          append_dev(div1, div0);
          mount_component(button0, div0, null);
          append_dev(div0, t0);
          mount_component(button1, div0, null);
          append_dev(div1, t1);
          append_dev(div1, ul);

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].m(ul, null);
          }

          current = true;

          if (!mounted) {
            dispose = [listen_dev(div1, "click", stop_propagation(
            /*click_handler*/
            ctx[7]), false, false, true), listen_dev(div2, "click",
            /*atras*/
            ctx[3], false, false, false)];
            mounted = true;
          }
        },
        p: function update(ctx, dirty) {
          const button0_changes = {};

          if (dirty &
          /*$$scope*/
          16384) {
            button0_changes.$$scope = {
              dirty,
              ctx
            };
          }

          button0.$set(button0_changes);
          const button1_changes = {};

          if (dirty &
          /*$$scope*/
          16384) {
            button1_changes.$$scope = {
              dirty,
              ctx
            };
          }

          button1.$set(button1_changes);

          if (dirty &
          /*historial, agregarComentariosAPila, diccionarioComentariosMap, diccionarioRespuestasMap*/
          23) {
            const each_value =
            /*historial*/
            ctx[0][
            /*historial*/
            ctx[0].length - 1];
            validate_each_argument(each_value);
            group_outros();
            validate_each_keys(ctx, each_value, get_each_context$7, get_key);
            each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, ul, outro_and_destroy_block, create_each_block$7, null, get_each_context$7);
            check_outros();
          }
        },
        i: function intro(local) {
          if (current) return;
          transition_in(button0.$$.fragment, local);
          transition_in(button1.$$.fragment, local);

          for (let i = 0; i < each_value.length; i += 1) {
            transition_in(each_blocks[i]);
          }

          add_render_callback(() => {
            if (!div1_transition) div1_transition = create_bidirectional_transition(div1, fly, {
              duration: 200,
              x: 100
            }, true);
            div1_transition.run(1);
          });
          current = true;
        },
        o: function outro(local) {
          transition_out(button0.$$.fragment, local);
          transition_out(button1.$$.fragment, local);

          for (let i = 0; i < each_blocks.length; i += 1) {
            transition_out(each_blocks[i]);
          }

          if (!div1_transition) div1_transition = create_bidirectional_transition(div1, fly, {
            duration: 200,
            x: 100
          }, false);
          div1_transition.run(0);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div2);
          destroy_component(button0);
          destroy_component(button1);

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].d();
          }

          if (detaching && div1_transition) div1_transition.end();
          mounted = false;
          run_all(dispose);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block$d.name,
        type: "if",
        source: "(26:0) {#if historial.length != 0}",
        ctx
      });
      return block;
    } // (30:16) <Button on:click={atras}>


    function create_default_slot_1$8(ctx) {
      let t;
      const block = {
        c: function create() {
          t = text("Atras");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_1$8.name,
        type: "slot",
        source: "(30:16) <Button on:click={atras}>",
        ctx
      });
      return block;
    } // (31:16) <Button on:click={() => historial = []}>


    function create_default_slot$9(ctx) {
      let t;
      const block = {
        c: function create() {
          t = text("Cerrar");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot$9.name,
        type: "slot",
        source: "(31:16) <Button on:click={() => historial = []}>",
        ctx
      });
      return block;
    } // (34:16) {#each historial[historial.length - 1] as c (c.id)}


    function create_each_block$7(key_1, ctx) {
      let li;
      let comentario;
      let t;
      let current;
      comentario = new Comentario({
        props: {
          prevenirScroll: true,
          comentario:
          /*c*/
          ctx[11],
          respuetasCompactas: true
        },
        $$inline: true
      });
      comentario.$on("tagClickeado",
      /*tagClickeado_handler*/
      ctx[9]);
      comentario.$on("motrarRespuestas",
      /*motrarRespuestas_handler*/
      ctx[10]);
      const block = {
        key: key_1,
        first: null,
        c: function create() {
          li = element("li");
          create_component(comentario.$$.fragment);
          t = space();
          add_location(li, file$f, 34, 20, 1263);
          this.first = li;
        },
        m: function mount(target, anchor) {
          insert_dev(target, li, anchor);
          mount_component(comentario, li, null);
          append_dev(li, t);
          current = true;
        },
        p: function update(ctx, dirty) {
          const comentario_changes = {};
          if (dirty &
          /*historial*/
          1) comentario_changes.comentario =
          /*c*/
          ctx[11];
          comentario.$set(comentario_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(comentario.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(comentario.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(li);
          destroy_component(comentario);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_each_block$7.name,
        type: "each",
        source: "(34:16) {#each historial[historial.length - 1] as c (c.id)}",
        ctx
      });
      return block;
    }

    function create_fragment$f(ctx) {
      let if_block_anchor;
      let current;
      let if_block =
      /*historial*/
      ctx[0].length != 0 && create_if_block$d(ctx);
      const block = {
        c: function create() {
          if (if_block) if_block.c();
          if_block_anchor = empty();
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          if (if_block) if_block.m(target, anchor);
          insert_dev(target, if_block_anchor, anchor);
          current = true;
        },
        p: function update(ctx, [dirty]) {
          if (
          /*historial*/
          ctx[0].length != 0) {
            if (if_block) {
              if_block.p(ctx, dirty);

              if (dirty &
              /*historial*/
              1) {
                transition_in(if_block, 1);
              }
            } else {
              if_block = create_if_block$d(ctx);
              if_block.c();
              transition_in(if_block, 1);
              if_block.m(if_block_anchor.parentNode, if_block_anchor);
            }
          } else if (if_block) {
            group_outros();
            transition_out(if_block, 1, 1, () => {
              if_block = null;
            });
            check_outros();
          }
        },
        i: function intro(local) {
          if (current) return;
          transition_in(if_block);
          current = true;
        },
        o: function outro(local) {
          transition_out(if_block);
          current = false;
        },
        d: function destroy(detaching) {
          if (if_block) if_block.d(detaching);
          if (detaching) detach_dev(if_block_anchor);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$f.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }

    function instance$f($$self, $$props, $$invalidate) {
      let {
        $$slots: slots = {},
        $$scope
      } = $$props;
      validate_slots("PilaRespuestas", slots, []);
      let {
        diccionarioRespuestas = {}
      } = $$props;
      let {
        diccionarioComentarios = {}
      } = $$props;
      let diccionarioComentariosMap = new Map(Object.keys(diccionarioComentarios).map(k => [k, diccionarioComentarios[k]]));
      let diccionarioRespuestasMap = new Map(Object.keys(diccionarioRespuestas).map(k => [k, diccionarioRespuestas[k]]));
      let {
        historial = []
      } = $$props;

      function atras() {
        historial.pop();
        $$invalidate(0, historial);
      }

      function agregarComentariosAPila(comentarios) {
        comentarios = comentarios.filter(c => c && c.id);
        comentarios = [...new Set(comentarios)];
        $$invalidate(0, historial = [...historial, comentarios]);
      }

      const writable_props = ["diccionarioRespuestas", "diccionarioComentarios", "historial"];
      Object_1$3.keys($$props).forEach(key => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<PilaRespuestas> was created with unknown prop '${key}'`);
      });

      function click_handler(event) {
        bubble($$self, event);
      }

      const click_handler_1 = () => $$invalidate(0, historial = []);

      const tagClickeado_handler = e => agregarComentariosAPila([diccionarioComentariosMap.get(e.detail)]);

      const motrarRespuestas_handler = e => agregarComentariosAPila(diccionarioRespuestasMap.get(e.detail).map(id => diccionarioComentariosMap.get(id)));

      $$self.$$set = $$props => {
        if ("diccionarioRespuestas" in $$props) $$invalidate(5, diccionarioRespuestas = $$props.diccionarioRespuestas);
        if ("diccionarioComentarios" in $$props) $$invalidate(6, diccionarioComentarios = $$props.diccionarioComentarios);
        if ("historial" in $$props) $$invalidate(0, historial = $$props.historial);
      };

      $$self.$capture_state = () => ({
        Comentario,
        fly,
        Button: ye,
        diccionarioRespuestas,
        diccionarioComentarios,
        diccionarioComentariosMap,
        diccionarioRespuestasMap,
        historial,
        atras,
        agregarComentariosAPila
      });

      $$self.$inject_state = $$props => {
        if ("diccionarioRespuestas" in $$props) $$invalidate(5, diccionarioRespuestas = $$props.diccionarioRespuestas);
        if ("diccionarioComentarios" in $$props) $$invalidate(6, diccionarioComentarios = $$props.diccionarioComentarios);
        if ("diccionarioComentariosMap" in $$props) $$invalidate(1, diccionarioComentariosMap = $$props.diccionarioComentariosMap);
        if ("diccionarioRespuestasMap" in $$props) $$invalidate(2, diccionarioRespuestasMap = $$props.diccionarioRespuestasMap);
        if ("historial" in $$props) $$invalidate(0, historial = $$props.historial);
      };

      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }

      return [historial, diccionarioComentariosMap, diccionarioRespuestasMap, atras, agregarComentariosAPila, diccionarioRespuestas, diccionarioComentarios, click_handler, click_handler_1, tagClickeado_handler, motrarRespuestas_handler];
    }

    class PilaRespuestas extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$f, create_fragment$f, safe_not_equal, {
          diccionarioRespuestas: 5,
          diccionarioComentarios: 6,
          historial: 0
        });
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "PilaRespuestas",
          options,
          id: create_fragment$f.name
        });
      }

      get diccionarioRespuestas() {
        throw new Error("<PilaRespuestas>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set diccionarioRespuestas(value) {
        throw new Error("<PilaRespuestas>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get diccionarioComentarios() {
        throw new Error("<PilaRespuestas>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set diccionarioComentarios(value) {
        throw new Error("<PilaRespuestas>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get historial() {
        throw new Error("<PilaRespuestas>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set historial(value) {
        throw new Error("<PilaRespuestas>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

    }

    /* src\components\SpamList.svelte generated by Svelte v3.29.0 */
    const file$g = "src\\components\\SpamList.svelte";

    function get_each_context$8(ctx, list, i) {
      const child_ctx = ctx.slice();
      child_ctx[1] = list[i];
      return child_ctx;
    } // (6:4) {#each spams as spam (spam.id)}


    function create_each_block$8(key_1, ctx) {
      let a;
      let li;
      let t;
      let a_href_value;
      const block = {
        key: key_1,
        first: null,
        c: function create() {
          a = element("a");
          li = element("li");
          t = space();
          attr_dev(li, "class", "rozpam svelte-1qpmrpw");
          set_style(li, "background-image", "url(" +
          /*spam*/
          ctx[1].urlImagen + ")");
          add_location(li, file$g, 7, 8, 167);
          attr_dev(a, "href", a_href_value =
          /*spam*/
          ctx[1].link);
          attr_dev(a, "rel", "nofollow");
          attr_dev(a, "target", "_black");
          add_location(a, file$g, 6, 4, 107);
          this.first = a;
        },
        m: function mount(target, anchor) {
          insert_dev(target, a, anchor);
          append_dev(a, li);
          append_dev(a, t);
        },
        p: function update(ctx, dirty) {
          if (dirty &
          /*spams*/
          1) {
            set_style(li, "background-image", "url(" +
            /*spam*/
            ctx[1].urlImagen + ")");
          }

          if (dirty &
          /*spams*/
          1 && a_href_value !== (a_href_value =
          /*spam*/
          ctx[1].link)) {
            attr_dev(a, "href", a_href_value);
          }
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(a);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_each_block$8.name,
        type: "each",
        source: "(6:4) {#each spams as spam (spam.id)}",
        ctx
      });
      return block;
    }

    function create_fragment$g(ctx) {
      let ul;
      let each_blocks = [];
      let each_1_lookup = new Map();
      let each_value =
      /*spams*/
      ctx[0];
      validate_each_argument(each_value);

      const get_key = ctx =>
      /*spam*/
      ctx[1].id;

      validate_each_keys(ctx, each_value, get_each_context$8, get_key);

      for (let i = 0; i < each_value.length; i += 1) {
        let child_ctx = get_each_context$8(ctx, each_value, i);
        let key = get_key(child_ctx);
        each_1_lookup.set(key, each_blocks[i] = create_each_block$8(key, child_ctx));
      }

      const block = {
        c: function create() {
          ul = element("ul");

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].c();
          }

          attr_dev(ul, "class", "rozpams svelte-1qpmrpw");
          add_location(ul, file$g, 4, 0, 46);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, ul, anchor);

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].m(ul, null);
          }
        },
        p: function update(ctx, [dirty]) {
          if (dirty &
          /*spams*/
          1) {
            const each_value =
            /*spams*/
            ctx[0];
            validate_each_argument(each_value);
            validate_each_keys(ctx, each_value, get_each_context$8, get_key);
            each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, ul, destroy_block, create_each_block$8, null, get_each_context$8);
          }
        },
        i: noop,
        o: noop,
        d: function destroy(detaching) {
          if (detaching) detach_dev(ul);

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].d();
          }
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$g.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }

    function instance$g($$self, $$props, $$invalidate) {
      let {
        $$slots: slots = {},
        $$scope
      } = $$props;
      validate_slots("SpamList", slots, []);
      let {
        spams = []
      } = $$props;
      const writable_props = ["spams"];
      Object.keys($$props).forEach(key => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<SpamList> was created with unknown prop '${key}'`);
      });

      $$self.$$set = $$props => {
        if ("spams" in $$props) $$invalidate(0, spams = $$props.spams);
      };

      $$self.$capture_state = () => ({
        spams
      });

      $$self.$inject_state = $$props => {
        if ("spams" in $$props) $$invalidate(0, spams = $$props.spams);
      };

      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }

      return [spams];
    }

    class SpamList extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$g, create_fragment$g, safe_not_equal, {
          spams: 0
        });
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "SpamList",
          options,
          id: create_fragment$g.name
        });
      }

      get spams() {
        throw new Error("<SpamList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set spams(value) {
        throw new Error("<SpamList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

    }

    /* node_modules\svelte-infinite-loading\src\Spinner.svelte generated by Svelte v3.29.0 */
    const file$h = "node_modules\\svelte-infinite-loading\\src\\Spinner.svelte"; // (49:0) {:else}

    function create_else_block$4(ctx) {
      let i;
      const block = {
        c: function create() {
          i = element("i");
          attr_dev(i, "class", "loading-default svelte-10h86fq");
          add_location(i, file$h, 51, 1, 1184);
        },
        m: function mount(target, anchor) {
          insert_dev(target, i, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(i);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_else_block$4.name,
        type: "else",
        source: "(49:0) {:else}",
        ctx
      });
      return block;
    } // (38:33) 


    function create_if_block_3$4(ctx) {
      let span5;
      let span0;
      let t0;
      let span1;
      let t1;
      let span2;
      let t2;
      let span3;
      let t3;
      let span4;
      const block = {
        c: function create() {
          span5 = element("span");
          span0 = element("span");
          t0 = space();
          span1 = element("span");
          t1 = space();
          span2 = element("span");
          t2 = space();
          span3 = element("span");
          t3 = space();
          span4 = element("span");
          attr_dev(span0, "class", "wave-item svelte-10h86fq");
          add_location(span0, file$h, 41, 2, 978);
          attr_dev(span1, "class", "wave-item svelte-10h86fq");
          add_location(span1, file$h, 42, 2, 1012);
          attr_dev(span2, "class", "wave-item svelte-10h86fq");
          add_location(span2, file$h, 43, 2, 1046);
          attr_dev(span3, "class", "wave-item svelte-10h86fq");
          add_location(span3, file$h, 44, 2, 1080);
          attr_dev(span4, "class", "wave-item svelte-10h86fq");
          add_location(span4, file$h, 45, 2, 1114);
          attr_dev(span5, "class", "loading-wave-dots svelte-10h86fq");
          add_location(span5, file$h, 40, 1, 943);
        },
        m: function mount(target, anchor) {
          insert_dev(target, span5, anchor);
          append_dev(span5, span0);
          append_dev(span5, t0);
          append_dev(span5, span1);
          append_dev(span5, t1);
          append_dev(span5, span2);
          append_dev(span5, t2);
          append_dev(span5, span3);
          append_dev(span5, t3);
          append_dev(span5, span4);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(span5);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_3$4.name,
        type: "if",
        source: "(38:33) ",
        ctx
      });
      return block;
    } // (33:31) 


    function create_if_block_2$8(ctx) {
      let i;
      const block = {
        c: function create() {
          i = element("i");
          attr_dev(i, "class", "loading-spiral svelte-10h86fq");
          add_location(i, file$h, 35, 1, 856);
        },
        m: function mount(target, anchor) {
          insert_dev(target, i, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(i);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_2$8.name,
        type: "if",
        source: "(33:31) ",
        ctx
      });
      return block;
    } // (19:32) 


    function create_if_block_1$9(ctx) {
      let span8;
      let span0;
      let t0;
      let span1;
      let t1;
      let span2;
      let t2;
      let span3;
      let t3;
      let span4;
      let t4;
      let span5;
      let t5;
      let span6;
      let t6;
      let span7;
      const block = {
        c: function create() {
          span8 = element("span");
          span0 = element("span");
          t0 = space();
          span1 = element("span");
          t1 = space();
          span2 = element("span");
          t2 = space();
          span3 = element("span");
          t3 = space();
          span4 = element("span");
          t4 = space();
          span5 = element("span");
          t5 = space();
          span6 = element("span");
          t6 = space();
          span7 = element("span");
          attr_dev(span0, "class", "circle-item svelte-10h86fq");
          add_location(span0, file$h, 22, 2, 509);
          attr_dev(span1, "class", "circle-item svelte-10h86fq");
          add_location(span1, file$h, 23, 2, 545);
          attr_dev(span2, "class", "circle-item svelte-10h86fq");
          add_location(span2, file$h, 24, 2, 581);
          attr_dev(span3, "class", "circle-item svelte-10h86fq");
          add_location(span3, file$h, 25, 2, 617);
          attr_dev(span4, "class", "circle-item svelte-10h86fq");
          add_location(span4, file$h, 26, 2, 653);
          attr_dev(span5, "class", "circle-item svelte-10h86fq");
          add_location(span5, file$h, 27, 2, 689);
          attr_dev(span6, "class", "circle-item svelte-10h86fq");
          add_location(span6, file$h, 28, 2, 725);
          attr_dev(span7, "class", "circle-item svelte-10h86fq");
          add_location(span7, file$h, 29, 2, 761);
          attr_dev(span8, "class", "loading-circles svelte-10h86fq");
          add_location(span8, file$h, 21, 1, 476);
        },
        m: function mount(target, anchor) {
          insert_dev(target, span8, anchor);
          append_dev(span8, span0);
          append_dev(span8, t0);
          append_dev(span8, span1);
          append_dev(span8, t1);
          append_dev(span8, span2);
          append_dev(span8, t2);
          append_dev(span8, span3);
          append_dev(span8, t3);
          append_dev(span8, span4);
          append_dev(span8, t4);
          append_dev(span8, span5);
          append_dev(span8, t5);
          append_dev(span8, span6);
          append_dev(span8, t6);
          append_dev(span8, span7);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(span8);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_1$9.name,
        type: "if",
        source: "(19:32) ",
        ctx
      });
      return block;
    } // (5:0) {#if spinner === 'bubbles'}


    function create_if_block$e(ctx) {
      let span8;
      let span0;
      let t0;
      let span1;
      let t1;
      let span2;
      let t2;
      let span3;
      let t3;
      let span4;
      let t4;
      let span5;
      let t5;
      let span6;
      let t6;
      let span7;
      const block = {
        c: function create() {
          span8 = element("span");
          span0 = element("span");
          t0 = space();
          span1 = element("span");
          t1 = space();
          span2 = element("span");
          t2 = space();
          span3 = element("span");
          t3 = space();
          span4 = element("span");
          t4 = space();
          span5 = element("span");
          t5 = space();
          span6 = element("span");
          t6 = space();
          span7 = element("span");
          attr_dev(span0, "class", "bubble-item svelte-10h86fq");
          add_location(span0, file$h, 8, 2, 127);
          attr_dev(span1, "class", "bubble-item svelte-10h86fq");
          add_location(span1, file$h, 9, 2, 163);
          attr_dev(span2, "class", "bubble-item svelte-10h86fq");
          add_location(span2, file$h, 10, 2, 199);
          attr_dev(span3, "class", "bubble-item svelte-10h86fq");
          add_location(span3, file$h, 11, 2, 235);
          attr_dev(span4, "class", "bubble-item svelte-10h86fq");
          add_location(span4, file$h, 12, 2, 271);
          attr_dev(span5, "class", "bubble-item svelte-10h86fq");
          add_location(span5, file$h, 13, 2, 307);
          attr_dev(span6, "class", "bubble-item svelte-10h86fq");
          add_location(span6, file$h, 14, 2, 343);
          attr_dev(span7, "class", "bubble-item svelte-10h86fq");
          add_location(span7, file$h, 15, 2, 379);
          attr_dev(span8, "class", "loading-bubbles svelte-10h86fq");
          add_location(span8, file$h, 7, 1, 94);
        },
        m: function mount(target, anchor) {
          insert_dev(target, span8, anchor);
          append_dev(span8, span0);
          append_dev(span8, t0);
          append_dev(span8, span1);
          append_dev(span8, t1);
          append_dev(span8, span2);
          append_dev(span8, t2);
          append_dev(span8, span3);
          append_dev(span8, t3);
          append_dev(span8, span4);
          append_dev(span8, t4);
          append_dev(span8, span5);
          append_dev(span8, t5);
          append_dev(span8, span6);
          append_dev(span8, t6);
          append_dev(span8, span7);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(span8);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block$e.name,
        type: "if",
        source: "(5:0) {#if spinner === 'bubbles'}",
        ctx
      });
      return block;
    }

    function create_fragment$h(ctx) {
      let if_block_anchor;

      function select_block_type(ctx, dirty) {
        if (
        /*spinner*/
        ctx[0] === "bubbles") return create_if_block$e;
        if (
        /*spinner*/
        ctx[0] === "circles") return create_if_block_1$9;
        if (
        /*spinner*/
        ctx[0] === "spiral") return create_if_block_2$8;
        if (
        /*spinner*/
        ctx[0] === "wavedots") return create_if_block_3$4;
        return create_else_block$4;
      }

      let current_block_type = select_block_type(ctx);
      let if_block = current_block_type(ctx);
      const block = {
        c: function create() {
          if_block.c();
          if_block_anchor = empty();
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          if_block.m(target, anchor);
          insert_dev(target, if_block_anchor, anchor);
        },
        p: function update(ctx, [dirty]) {
          if (current_block_type !== (current_block_type = select_block_type(ctx))) {
            if_block.d(1);
            if_block = current_block_type(ctx);

            if (if_block) {
              if_block.c();
              if_block.m(if_block_anchor.parentNode, if_block_anchor);
            }
          }
        },
        i: noop,
        o: noop,
        d: function destroy(detaching) {
          if_block.d(detaching);
          if (detaching) detach_dev(if_block_anchor);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$h.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }

    function instance$h($$self, $$props, $$invalidate) {
      let {
        $$slots: slots = {},
        $$scope
      } = $$props;
      validate_slots("Spinner", slots, []);
      let {
        spinner = ""
      } = $$props;
      const writable_props = ["spinner"];
      Object.keys($$props).forEach(key => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Spinner> was created with unknown prop '${key}'`);
      });

      $$self.$$set = $$props => {
        if ("spinner" in $$props) $$invalidate(0, spinner = $$props.spinner);
      };

      $$self.$capture_state = () => ({
        spinner
      });

      $$self.$inject_state = $$props => {
        if ("spinner" in $$props) $$invalidate(0, spinner = $$props.spinner);
      };

      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }

      return [spinner];
    }

    class Spinner$1 extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$h, create_fragment$h, safe_not_equal, {
          spinner: 0
        });
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "Spinner",
          options,
          id: create_fragment$h.name
        });
      }

      get spinner() {
        throw new Error("<Spinner>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set spinner(value) {
        throw new Error("<Spinner>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

    }

    /* node_modules\svelte-infinite-loading\src\InfiniteLoading.svelte generated by Svelte v3.29.0 */
    const {
      Object: Object_1$4,
      console: console_1$3
    } = globals;
    const file$i = "node_modules\\svelte-infinite-loading\\src\\InfiniteLoading.svelte";

    const get_error_slot_changes = dirty => ({});

    const get_error_slot_context = ctx => ({
      attemptLoad:
      /*attemptLoad*/
      ctx[7]
    });

    const get_noMore_slot_changes = dirty => ({});

    const get_noMore_slot_context = ctx => ({});

    const get_noResults_slot_changes = dirty => ({});

    const get_noResults_slot_context = ctx => ({});

    const get_spinner_slot_changes = dirty => ({
      isFirstLoad: dirty &
      /*isFirstLoad*/
      2
    });

    const get_spinner_slot_context = ctx => ({
      isFirstLoad:
      /*isFirstLoad*/
      ctx[1]
    }); // (323:1) {#if showSpinner}


    function create_if_block_3$5(ctx) {
      let div;
      let current;
      const spinner_slot_template =
      /*#slots*/
      ctx[13].spinner;
      const spinner_slot = create_slot(spinner_slot_template, ctx,
      /*$$scope*/
      ctx[12], get_spinner_slot_context);
      const spinner_slot_or_fallback = spinner_slot || fallback_block_3(ctx);
      const block = {
        c: function create() {
          div = element("div");
          if (spinner_slot_or_fallback) spinner_slot_or_fallback.c();
          attr_dev(div, "class", "infinite-status-prompt");
          add_location(div, file$i, 323, 2, 8082);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);

          if (spinner_slot_or_fallback) {
            spinner_slot_or_fallback.m(div, null);
          }

          current = true;
        },
        p: function update(ctx, dirty) {
          if (spinner_slot) {
            if (spinner_slot.p && dirty &
            /*$$scope, isFirstLoad*/
            4098) {
              update_slot(spinner_slot, spinner_slot_template, ctx,
              /*$$scope*/
              ctx[12], dirty, get_spinner_slot_changes, get_spinner_slot_context);
            }
          } else {
            if (spinner_slot_or_fallback && spinner_slot_or_fallback.p && dirty &
            /*spinner*/
            1) {
              spinner_slot_or_fallback.p(ctx, dirty);
            }
          }
        },
        i: function intro(local) {
          if (current) return;
          transition_in(spinner_slot_or_fallback, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(spinner_slot_or_fallback, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
          if (spinner_slot_or_fallback) spinner_slot_or_fallback.d(detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_3$5.name,
        type: "if",
        source: "(323:1) {#if showSpinner}",
        ctx
      });
      return block;
    } // (325:38)      


    function fallback_block_3(ctx) {
      let spinner_1;
      let current;
      spinner_1 = new Spinner$1({
        props: {
          spinner:
          /*spinner*/
          ctx[0]
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          create_component(spinner_1.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(spinner_1, target, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          const spinner_1_changes = {};
          if (dirty &
          /*spinner*/
          1) spinner_1_changes.spinner =
          /*spinner*/
          ctx[0];
          spinner_1.$set(spinner_1_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(spinner_1.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(spinner_1.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(spinner_1, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: fallback_block_3.name,
        type: "fallback",
        source: "(325:38)      ",
        ctx
      });
      return block;
    } // (331:1) {#if showNoResults}


    function create_if_block_2$9(ctx) {
      let div;
      let current;
      const noResults_slot_template =
      /*#slots*/
      ctx[13].noResults;
      const noResults_slot = create_slot(noResults_slot_template, ctx,
      /*$$scope*/
      ctx[12], get_noResults_slot_context);
      const noResults_slot_or_fallback = noResults_slot || fallback_block_2(ctx);
      const block = {
        c: function create() {
          div = element("div");
          if (noResults_slot_or_fallback) noResults_slot_or_fallback.c();
          attr_dev(div, "class", "infinite-status-prompt");
          add_location(div, file$i, 331, 2, 8235);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);

          if (noResults_slot_or_fallback) {
            noResults_slot_or_fallback.m(div, null);
          }

          current = true;
        },
        p: function update(ctx, dirty) {
          if (noResults_slot) {
            if (noResults_slot.p && dirty &
            /*$$scope*/
            4096) {
              update_slot(noResults_slot, noResults_slot_template, ctx,
              /*$$scope*/
              ctx[12], dirty, get_noResults_slot_changes, get_noResults_slot_context);
            }
          }
        },
        i: function intro(local) {
          if (current) return;
          transition_in(noResults_slot_or_fallback, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(noResults_slot_or_fallback, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
          if (noResults_slot_or_fallback) noResults_slot_or_fallback.d(detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_2$9.name,
        type: "if",
        source: "(331:1) {#if showNoResults}",
        ctx
      });
      return block;
    } // (333:26)      No results :(    


    function fallback_block_2(ctx) {
      let t;
      const block = {
        c: function create() {
          t = text("No results :(");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: fallback_block_2.name,
        type: "fallback",
        source: "(333:26)      No results :(    ",
        ctx
      });
      return block;
    } // (339:1) {#if showNoMore}


    function create_if_block_1$a(ctx) {
      let div;
      let current;
      const noMore_slot_template =
      /*#slots*/
      ctx[13].noMore;
      const noMore_slot = create_slot(noMore_slot_template, ctx,
      /*$$scope*/
      ctx[12], get_noMore_slot_context);
      const noMore_slot_or_fallback = noMore_slot || fallback_block_1$1(ctx);
      const block = {
        c: function create() {
          div = element("div");
          if (noMore_slot_or_fallback) noMore_slot_or_fallback.c();
          attr_dev(div, "class", "infinite-status-prompt");
          add_location(div, file$i, 339, 2, 8365);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);

          if (noMore_slot_or_fallback) {
            noMore_slot_or_fallback.m(div, null);
          }

          current = true;
        },
        p: function update(ctx, dirty) {
          if (noMore_slot) {
            if (noMore_slot.p && dirty &
            /*$$scope*/
            4096) {
              update_slot(noMore_slot, noMore_slot_template, ctx,
              /*$$scope*/
              ctx[12], dirty, get_noMore_slot_changes, get_noMore_slot_context);
            }
          }
        },
        i: function intro(local) {
          if (current) return;
          transition_in(noMore_slot_or_fallback, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(noMore_slot_or_fallback, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
          if (noMore_slot_or_fallback) noMore_slot_or_fallback.d(detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_1$a.name,
        type: "if",
        source: "(339:1) {#if showNoMore}",
        ctx
      });
      return block;
    } // (341:23)      No more data :)    


    function fallback_block_1$1(ctx) {
      let t;
      const block = {
        c: function create() {
          t = text("No more data :)");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: fallback_block_1$1.name,
        type: "fallback",
        source: "(341:23)      No more data :)    ",
        ctx
      });
      return block;
    } // (347:1) {#if showError}


    function create_if_block$f(ctx) {
      let div;
      let current;
      const error_slot_template =
      /*#slots*/
      ctx[13].error;
      const error_slot = create_slot(error_slot_template, ctx,
      /*$$scope*/
      ctx[12], get_error_slot_context);
      const error_slot_or_fallback = error_slot || fallback_block(ctx);
      const block = {
        c: function create() {
          div = element("div");
          if (error_slot_or_fallback) error_slot_or_fallback.c();
          attr_dev(div, "class", "infinite-status-prompt");
          add_location(div, file$i, 347, 2, 8493);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);

          if (error_slot_or_fallback) {
            error_slot_or_fallback.m(div, null);
          }

          current = true;
        },
        p: function update(ctx, dirty) {
          if (error_slot) {
            if (error_slot.p && dirty &
            /*$$scope*/
            4096) {
              update_slot(error_slot, error_slot_template, ctx,
              /*$$scope*/
              ctx[12], dirty, get_error_slot_changes, get_error_slot_context);
            }
          }
        },
        i: function intro(local) {
          if (current) return;
          transition_in(error_slot_or_fallback, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(error_slot_or_fallback, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
          if (error_slot_or_fallback) error_slot_or_fallback.d(detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block$f.name,
        type: "if",
        source: "(347:1) {#if showError}",
        ctx
      });
      return block;
    } // (349:36)      Oops, something went wrong :(     


    function fallback_block(ctx) {
      let t0;
      let br;
      let t1;
      let button;
      let mounted;
      let dispose;
      const block = {
        c: function create() {
          t0 = text("Oops, something went wrong :(\n\t\t\t\t");
          br = element("br");
          t1 = space();
          button = element("button");
          button.textContent = "Retry";
          add_location(br, file$i, 350, 4, 8605);
          attr_dev(button, "class", "btn-try-infinite svelte-o3w4bf");
          add_location(button, file$i, 351, 4, 8614);
        },
        m: function mount(target, anchor) {
          insert_dev(target, t0, anchor);
          insert_dev(target, br, anchor);
          insert_dev(target, t1, anchor);
          insert_dev(target, button, anchor);

          if (!mounted) {
            dispose = listen_dev(button, "click",
            /*attemptLoad*/
            ctx[7], false, false, false);
            mounted = true;
          }
        },
        p: noop,
        d: function destroy(detaching) {
          if (detaching) detach_dev(t0);
          if (detaching) detach_dev(br);
          if (detaching) detach_dev(t1);
          if (detaching) detach_dev(button);
          mounted = false;
          dispose();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: fallback_block.name,
        type: "fallback",
        source: "(349:36)      Oops, something went wrong :(     ",
        ctx
      });
      return block;
    }

    function create_fragment$i(ctx) {
      let div;
      let t0;
      let t1;
      let t2;
      let current;
      let if_block0 =
      /*showSpinner*/
      ctx[3] && create_if_block_3$5(ctx);
      let if_block1 =
      /*showNoResults*/
      ctx[5] && create_if_block_2$9(ctx);
      let if_block2 =
      /*showNoMore*/
      ctx[6] && create_if_block_1$a(ctx);
      let if_block3 =
      /*showError*/
      ctx[4] && create_if_block$f(ctx);
      const block = {
        c: function create() {
          div = element("div");
          if (if_block0) if_block0.c();
          t0 = space();
          if (if_block1) if_block1.c();
          t1 = space();
          if (if_block2) if_block2.c();
          t2 = space();
          if (if_block3) if_block3.c();
          attr_dev(div, "class", "infinite-loading-container svelte-o3w4bf");
          add_location(div, file$i, 321, 0, 7996);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          if (if_block0) if_block0.m(div, null);
          append_dev(div, t0);
          if (if_block1) if_block1.m(div, null);
          append_dev(div, t1);
          if (if_block2) if_block2.m(div, null);
          append_dev(div, t2);
          if (if_block3) if_block3.m(div, null);
          /*div_binding*/

          ctx[14](div);
          current = true;
        },
        p: function update(ctx, [dirty]) {
          if (
          /*showSpinner*/
          ctx[3]) {
            if (if_block0) {
              if_block0.p(ctx, dirty);

              if (dirty &
              /*showSpinner*/
              8) {
                transition_in(if_block0, 1);
              }
            } else {
              if_block0 = create_if_block_3$5(ctx);
              if_block0.c();
              transition_in(if_block0, 1);
              if_block0.m(div, t0);
            }
          } else if (if_block0) {
            group_outros();
            transition_out(if_block0, 1, 1, () => {
              if_block0 = null;
            });
            check_outros();
          }

          if (
          /*showNoResults*/
          ctx[5]) {
            if (if_block1) {
              if_block1.p(ctx, dirty);

              if (dirty &
              /*showNoResults*/
              32) {
                transition_in(if_block1, 1);
              }
            } else {
              if_block1 = create_if_block_2$9(ctx);
              if_block1.c();
              transition_in(if_block1, 1);
              if_block1.m(div, t1);
            }
          } else if (if_block1) {
            group_outros();
            transition_out(if_block1, 1, 1, () => {
              if_block1 = null;
            });
            check_outros();
          }

          if (
          /*showNoMore*/
          ctx[6]) {
            if (if_block2) {
              if_block2.p(ctx, dirty);

              if (dirty &
              /*showNoMore*/
              64) {
                transition_in(if_block2, 1);
              }
            } else {
              if_block2 = create_if_block_1$a(ctx);
              if_block2.c();
              transition_in(if_block2, 1);
              if_block2.m(div, t2);
            }
          } else if (if_block2) {
            group_outros();
            transition_out(if_block2, 1, 1, () => {
              if_block2 = null;
            });
            check_outros();
          }

          if (
          /*showError*/
          ctx[4]) {
            if (if_block3) {
              if_block3.p(ctx, dirty);

              if (dirty &
              /*showError*/
              16) {
                transition_in(if_block3, 1);
              }
            } else {
              if_block3 = create_if_block$f(ctx);
              if_block3.c();
              transition_in(if_block3, 1);
              if_block3.m(div, null);
            }
          } else if (if_block3) {
            group_outros();
            transition_out(if_block3, 1, 1, () => {
              if_block3 = null;
            });
            check_outros();
          }
        },
        i: function intro(local) {
          if (current) return;
          transition_in(if_block0);
          transition_in(if_block1);
          transition_in(if_block2);
          transition_in(if_block3);
          current = true;
        },
        o: function outro(local) {
          transition_out(if_block0);
          transition_out(if_block1);
          transition_out(if_block2);
          transition_out(if_block3);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
          if (if_block0) if_block0.d();
          if (if_block1) if_block1.d();
          if (if_block2) if_block2.d();
          if (if_block3) if_block3.d();
          /*div_binding*/

          ctx[14](null);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$i.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }

    const STATUS = {
      READY: 0,
      LOADING: 1,
      COMPLETE: 2,
      ERROR: 3
    };
    const THROTTLE_LIMIT = 50;
    const LOOP_CHECK_TIMEOUT = 1000;
    const LOOP_CHECK_MAX_CALLS = 10;
    const ERROR_INFINITE_LOOP = [`executed the callback function more than ${LOOP_CHECK_MAX_CALLS} times for a short time, it looks like searched a wrong scroll wrapper that doest not has fixed height or maximum height, please check it. If you want to force to set a element as scroll wrapper rather than automatic searching, you can do this:`, "<!-- add a special attribute for the real scroll wrapper (can also be data-infinite-wrapper) -->", "<div infinite-wrapper>", "  ...", "  <!-- set forceUseInfiniteWrapper -->", "  <InfiniteLoading forceUseInfiniteWrapper>", "</div>", "or", "<div class=\"infinite-wrapper\">", "  ...", "  <!-- set forceUseInfiniteWrapper as css selector of the real scroll wrapper -->", "  <InfiniteLoading forceUseInfiniteWrapper=\".infinite-wrapper\" />", "</div>"].join("\n");
    /**
     * the third argument for event bundler
     * @see https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md
     */

    const thirdEventArg = (() => {
      let result = false;

      try {
        const arg = Object.defineProperty({}, "passive", {
          get() {
            result = {
              passive: true
            };
            return true;
          }

        });
        window.addEventListener("testpassive", arg, arg);
        window.remove("testpassive", arg, arg);
      } catch (e) {}
      /* */


      return result;
    })();

    const throttler = {
      timers: [],
      caches: [],

      throttle(fn) {
        if (this.caches.indexOf(fn) === -1) {
          // cache current handler
          this.caches.push(fn); // save timer for current handler

          this.timers.push(setTimeout(() => {
            fn(); // empty cache and timer

            this.caches.splice(this.caches.indexOf(fn), 1);
            this.timers.shift();
          }, THROTTLE_LIMIT));
        }
      },

      reset() {
        // reset all timers
        this.timers.forEach(timer => {
          clearTimeout(timer);
        });
        this.timers.length = 0; // empty caches

        this.caches = [];
      }

    };
    const loopTracker = {
      isChecked: false,
      timer: null,
      times: 0,

      track() {
        // record track times
        this.times += 1; // try to mark check status

        clearTimeout(this.timer);
        this.timer = setTimeout(() => {
          this.isChecked = true;
        }, LOOP_CHECK_TIMEOUT); // throw warning if the times of continuous calls large than the maximum times

        if (this.times > LOOP_CHECK_MAX_CALLS) {
          console.error(ERROR_INFINITE_LOOP);
          this.isChecked = true;
        }
      }

    };
    const scrollBarStorage = {
      key: "_infiniteScrollHeight",

      getScrollElement(element) {
        return element === window ? document.documentElement : element;
      },

      save(element) {
        const target = this.getScrollElement(element); // save scroll height on the scroll parent

        target[this.key] = target.scrollHeight;
      },

      restore(element) {
        const target = this.getScrollElement(element);
        /* istanbul ignore else */

        if (typeof target[this.key] === "number") {
          target.scrollTop = target.scrollHeight - target[this.key] + target.scrollTop;
        }

        this.remove(target);
      },

      remove(element) {
        if (element[this.key] !== undefined) {
          // remove scroll height
          delete element[this.key]; // eslint-disable-line no-param-reassign
        }
      }

    };

    function isVisible(element) {
      return element.offsetWidth + element.offsetHeight > 0;
    }

    function instance$i($$self, $$props, $$invalidate) {
      let {
        $$slots: slots = {},
        $$scope
      } = $$props;
      validate_slots("InfiniteLoading", slots, ['spinner', 'noResults', 'noMore', 'error']);
      const dispatch = createEventDispatcher();
      let {
        distance = 100
      } = $$props;
      let {
        spinner = ""
      } = $$props;
      let {
        direction = "bottom"
      } = $$props;
      let {
        forceUseInfiniteWrapper = false
      } = $$props;
      let {
        identifier = +new Date()
      } = $$props;
      let isFirstLoad = true; // save the current loading whether it is the first loading

      let status = STATUS.READY;
      let mounted = false;
      let thisElement;
      let scrollParent;
      const stateChanger = {
        loaded: async () => {
          $$invalidate(1, isFirstLoad = false);

          if (direction === "top") {
            // wait for DOM updated
            await tick();
            scrollBarStorage.restore(scrollParent);
          }

          if (status === STATUS.LOADING) {
            await tick();
            await attemptLoad(true);
          }
        },
        complete: async () => {
          $$invalidate(15, status = STATUS.COMPLETE); // force re-complation computed properties to fix the problem of get slot text delay

          await tick();
          scrollParent.removeEventListener("scroll", scrollHandler, thirdEventArg);
        },
        reset: async () => {
          $$invalidate(15, status = STATUS.READY);
          $$invalidate(1, isFirstLoad = true);
          scrollBarStorage.remove(scrollParent);
          scrollParent.addEventListener("scroll", scrollHandler, thirdEventArg); // wait for list to be empty and the empty action may trigger a scroll event

          setTimeout(() => {
            throttler.reset();
            scrollHandler();
          }, 1);
        },
        error: () => {
          $$invalidate(15, status = STATUS.ERROR);
          throttler.reset();
        }
      };

      function scrollHandler(event) {
        if (status === STATUS.READY) {
          if (event && event.constructor === Event && isVisible(thisElement)) {
            throttler.throttle(attemptLoad);
          } else {
            attemptLoad();
          }
        }
      } // Attempt to trigger load


      async function attemptLoad(isContinuousCall) {
        if (status !== STATUS.COMPLETE && isVisible(thisElement) && getCurrentDistance() <= distance) {
          $$invalidate(15, status = STATUS.LOADING);

          if (direction === "top") {
            // wait for spinner display
            await tick();
            scrollBarStorage.save(scrollParent);
          }

          dispatch("infinite", stateChanger);

          if (isContinuousCall && !forceUseInfiniteWrapper && !loopTracker.isChecked) {
            // check this component whether be in an infinite loop if it is not checked
            loopTracker.track();
          }
        } else if (status === STATUS.LOADING) {
          $$invalidate(15, status = STATUS.READY);
        }
      } // Get current distance from the specified direction


      function getCurrentDistance() {
        let distance;

        if (direction === "top") {
          distance = typeof scrollParent.scrollTop === "number" ? scrollParent.scrollTop : scrollParent.pageYOffset;
        } else {
          const infiniteElementOffsetTopFromBottom = thisElement.getBoundingClientRect().top;
          const scrollElementOffsetTopFromBottom = scrollParent === window ? window.innerHeight : scrollParent.getBoundingClientRect().bottom;
          distance = infiniteElementOffsetTopFromBottom - scrollElementOffsetTopFromBottom;
        }

        return distance;
      } // Get the first scroll parent of an element


      function getScrollParent(element = thisElement) {
        let result;

        if (typeof forceUseInfiniteWrapper === "string") {
          result = document.querySelector(forceUseInfiniteWrapper);
        }

        if (!result) {
          if (element.tagName === "BODY") {
            result = window;
          } else if (!forceUseInfiniteWrapper && ["scroll", "auto"].indexOf(getComputedStyle(element).overflowY) > -1) {
            result = element;
          } else if (element.hasAttribute("infinite-wrapper") || element.hasAttribute("data-infinite-wrapper")) {
            result = element;
          }
        }

        return result || getScrollParent(element.parentNode);
      }

      function updateScrollParent() {
        if (mounted) scrollParent = getScrollParent();
      }

      function identifierUpdated() {
        if (mounted) stateChanger.reset();
      }

      onMount(async () => {
        $$invalidate(16, mounted = true);
        setTimeout(() => {
          scrollHandler();
          scrollParent.addEventListener("scroll", scrollHandler, thirdEventArg);
        }, 1);
      });
      onDestroy(() => {
        if (mounted && status !== STATUS.COMPLETE) {
          throttler.reset();
          scrollBarStorage.remove(scrollParent);
          scrollParent.removeEventListener("scroll", scrollHandler, thirdEventArg);
        }
      });
      const writable_props = ["distance", "spinner", "direction", "forceUseInfiniteWrapper", "identifier"];
      Object_1$4.keys($$props).forEach(key => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$3.warn(`<InfiniteLoading> was created with unknown prop '${key}'`);
      });

      function div_binding($$value) {
        binding_callbacks[$$value ? "unshift" : "push"](() => {
          thisElement = $$value;
          $$invalidate(2, thisElement);
        });
      }

      $$self.$$set = $$props => {
        if ("distance" in $$props) $$invalidate(8, distance = $$props.distance);
        if ("spinner" in $$props) $$invalidate(0, spinner = $$props.spinner);
        if ("direction" in $$props) $$invalidate(9, direction = $$props.direction);
        if ("forceUseInfiniteWrapper" in $$props) $$invalidate(10, forceUseInfiniteWrapper = $$props.forceUseInfiniteWrapper);
        if ("identifier" in $$props) $$invalidate(11, identifier = $$props.identifier);
        if ("$$scope" in $$props) $$invalidate(12, $$scope = $$props.$$scope);
      };

      $$self.$capture_state = () => ({
        STATUS,
        THROTTLE_LIMIT,
        LOOP_CHECK_TIMEOUT,
        LOOP_CHECK_MAX_CALLS,
        ERROR_INFINITE_LOOP,
        thirdEventArg,
        throttler,
        loopTracker,
        scrollBarStorage,
        isVisible,
        onMount,
        onDestroy,
        tick,
        createEventDispatcher,
        Spinner: Spinner$1,
        dispatch,
        distance,
        spinner,
        direction,
        forceUseInfiniteWrapper,
        identifier,
        isFirstLoad,
        status,
        mounted,
        thisElement,
        scrollParent,
        stateChanger,
        scrollHandler,
        attemptLoad,
        getCurrentDistance,
        getScrollParent,
        updateScrollParent,
        identifierUpdated,
        showSpinner,
        showError,
        showNoResults,
        showNoMore
      });

      $$self.$inject_state = $$props => {
        if ("distance" in $$props) $$invalidate(8, distance = $$props.distance);
        if ("spinner" in $$props) $$invalidate(0, spinner = $$props.spinner);
        if ("direction" in $$props) $$invalidate(9, direction = $$props.direction);
        if ("forceUseInfiniteWrapper" in $$props) $$invalidate(10, forceUseInfiniteWrapper = $$props.forceUseInfiniteWrapper);
        if ("identifier" in $$props) $$invalidate(11, identifier = $$props.identifier);
        if ("isFirstLoad" in $$props) $$invalidate(1, isFirstLoad = $$props.isFirstLoad);
        if ("status" in $$props) $$invalidate(15, status = $$props.status);
        if ("mounted" in $$props) $$invalidate(16, mounted = $$props.mounted);
        if ("thisElement" in $$props) $$invalidate(2, thisElement = $$props.thisElement);
        if ("scrollParent" in $$props) scrollParent = $$props.scrollParent;
        if ("showSpinner" in $$props) $$invalidate(3, showSpinner = $$props.showSpinner);
        if ("showError" in $$props) $$invalidate(4, showError = $$props.showError);
        if ("showNoResults" in $$props) $$invalidate(5, showNoResults = $$props.showNoResults);
        if ("showNoMore" in $$props) $$invalidate(6, showNoMore = $$props.showNoMore);
      };

      let showSpinner;
      let showError;
      let showNoResults;
      let showNoMore;

      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }

      $$self.$$.update = () => {
        if ($$self.$$.dirty &
        /*status*/
        32768) {
           $$invalidate(3, showSpinner = status === STATUS.LOADING);
        }

        if ($$self.$$.dirty &
        /*status*/
        32768) {
           $$invalidate(4, showError = status === STATUS.ERROR);
        }

        if ($$self.$$.dirty &
        /*status, isFirstLoad*/
        32770) {
           $$invalidate(5, showNoResults = status === STATUS.COMPLETE && isFirstLoad);
        }

        if ($$self.$$.dirty &
        /*status, isFirstLoad*/
        32770) {
           $$invalidate(6, showNoMore = status === STATUS.COMPLETE && !isFirstLoad);
        }

        if ($$self.$$.dirty &
        /*forceUseInfiniteWrapper, mounted*/
        66560) {
          // Watch forceUseInfiniteWrapper and mounted
           updateScrollParent();
        }

        if ($$self.$$.dirty &
        /*identifier, mounted*/
        67584) {
          // Watch identifier and mounted
           identifierUpdated();
        }
      };

      return [spinner, isFirstLoad, thisElement, showSpinner, showError, showNoResults, showNoMore, attemptLoad, distance, direction, forceUseInfiniteWrapper, identifier, $$scope, slots, div_binding];
    }

    class InfiniteLoading extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$i, create_fragment$i, safe_not_equal, {
          distance: 8,
          spinner: 0,
          direction: 9,
          forceUseInfiniteWrapper: 10,
          identifier: 11
        });
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "InfiniteLoading",
          options,
          id: create_fragment$i.name
        });
      }

      get distance() {
        throw new Error("<InfiniteLoading>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set distance(value) {
        throw new Error("<InfiniteLoading>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get spinner() {
        throw new Error("<InfiniteLoading>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set spinner(value) {
        throw new Error("<InfiniteLoading>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get direction() {
        throw new Error("<InfiniteLoading>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set direction(value) {
        throw new Error("<InfiniteLoading>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get forceUseInfiniteWrapper() {
        throw new Error("<InfiniteLoading>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set forceUseInfiniteWrapper(value) {
        throw new Error("<InfiniteLoading>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get identifier() {
        throw new Error("<InfiniteLoading>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set identifier(value) {
        throw new Error("<InfiniteLoading>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

    }

    var skinsPorDefecto = [{
      nombre: 'Classic',
      style: ``
    }, {
      nombre: 'Porche',
      style: `body {
            --color5: orangered;
            --color2: white;
            --color-texto1: black;
            --color-texto2: orangered;
            --color4: orangered;
            --color7: #ffc253ed;
        }
        
        .media-input {
            background: orangered !important;
        }
        
        .comentario .id {
            background: black !important;
        }
        
        .crear-hilo-boton, .categoria, .comentario .tag, comentario, .media-input, .cuerpo, .respuestas-compactas {
            color: white !important;
        }
        
        .comentario {
            background: #ffffffdb;
        }
        .comentario:hover {
            background: #ffeaeadb !important;
        }
        
        .menu-principal-header {
            background: #fff;
        }
        .menu-principal,
        .menu-principal h1,
        .menu-principal-header {
            color: orangered;
        }
        
        #fondo-global {
            background-image: url(https://www.carpixel.net/w/4ea482b90e147057f9d64b18d765772e/porsche-911-gt3-r-hybrid-wallpaper-hd-49401.jpg) !important;
            
        }

        .media-input, .menu-principal-header {
            background-image: url(https://www.carpixel.net/w/4ea482b90e147057f9d64b18d765772e/porsche-911-gt3-r-hybrid-wallpaper-hd-49401.jpg) !important;
            background-size: cover !important;
        }
        textarea {
            border: 2px solid var(--color5);
            background: white !important
        }
        .cuerpo {
            color:black !important;
        }`
    }, {
      nombre: 'Legacy',
      style: `body {
            --color2: #2c3e50;
            --color5: #256587;
        }
        #fondo-global {
            background: #1e2c38;
        }
        
        .comentarios, .side-panel{
            background: #213140 !important;
        }
        .comentario {
            background: #213140
        }
        .sticky-info {
            background: var(--color6) !important;
        }
        
        .comentario:hover {
            background: #2c3b4a !important
        }`
    }, {
      nombre: 'Romed',
      style: `body {
            --color5: #db9124;
            --color2: #6c1108;
            --color-texto1: #db9124;
            --color-texto2: #db9124;
            --color4: #a62416;
            --color7: #e9e3d6;
        
        }
        
        .media-input, .menu-principal-header {
            background: url(https://wallpaperaccess.com/full/308552.jpg) !important;
            background-size: cover !important;
            
        }
        #crear-hilo-form .media-input {
            background-position-x: -120px !important;
        }
         .menu-principal-header {
            background: url(https://wallpaperaccess.com/full/308552.jpg) !important;
            background-size: cover !important;
            
        }
        
        .comentario .id, .favorita {
            background: #6c1108 !important;
        }
        
        .crear-hilo-boton, .categoria, .comentario .tag, comentario, .media-input, .cuerpo {
            color: white !important;
        }
        
        .comentario {
            background: #c7c0b1;
            color: black
        }
        .comentario:hover {
            background: #e3dccc !important;
        }
        
        .menu-principal-header, .nav-principal {
            background-size: 100%;
            background-position-y: -500px;
        }
        .menu-principal,
        .menu-principal h1,
        .menu-principal-header {
            color: #db9124;
        }
        
        #fondo-global {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: url(https://wallpaperaccess.com/full/308552.jpg);
            background-size: cover;
            background-position-x: -500px;
            z-index: -1;
        }
        
        textarea {
            border: 2px solid var(--color5);
            background: #c7c0b1 !important;
            color: black
        }
        
        .nav-principal h3, .crear-hilo-boton, .cuerpo h1, .version {
            font-family:serif !important;
            text-transform: uppercase  !important;
            font-weight: 800;
        }
        .noti-cont {
            color: white
        }`
    }, {
      nombre: 'Skin de usuario 1',
      style: ``
    }, {
      nombre: 'Skin de usuario 2',
      style: ``
    }, {
      nombre: 'Skin de usuario 3',
      style: ``
    }, {
      nombre: 'Skin de usuario 4',
      style: ``
    }, {
      nombre: 'Skin de usuario 5',
      style: ``
    }];

    let store$1 = localStore("skins", {
      activo: 'Classic',
      skins: skinsPorDefecto
    });

    store$1.applicarEstilo = function aplicarEstilo() {
      store$1.update(skins => {
        document.getElementById("skin").innerHTML = skins.skins.filter(s => s.nombre == skins.activo)[0].style;
        return skins;
      });
    };

    store$1.restaurarSkins = function restaurarSkins() {
      store$1.update(skins => {
        skins = {
          activo: 'Classic',
          skins: skinsPorDefecto
        };
        console.log(skins);
        document.getElementById("skin").innerHTML = skins.skins.filter(s => s.nombre == skins.activo)[0].style;
        return skins;
      });
    };

    /* src\components\Personalizacion\Skins.svelte generated by Svelte v3.29.0 */
    const file$j = "src\\components\\Personalizacion\\Skins.svelte";

    function get_each_context$9(ctx, list, i) {
      const child_ctx = ctx.slice();
      child_ctx[7] = list[i];
      child_ctx[8] = list;
      child_ctx[9] = i;
      return child_ctx;
    } // (18:16) <Button icon dense title="Editar" on:click={() => editandoSkin = true}>


    function create_default_slot_3$8(ctx) {
      let span;
      const block = {
        c: function create() {
          span = element("span");
          attr_dev(span, "class", "fe fe-edit");
          add_location(span, file$j, 17, 87, 600);
        },
        m: function mount(target, anchor) {
          insert_dev(target, span, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(span);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_3$8.name,
        type: "slot",
        source: "(18:16) <Button icon dense title=\\\"Editar\\\" on:click={() => editandoSkin = true}>",
        ctx
      });
      return block;
    } // (21:8) {#if $skinsStore.activo == s.nombre}


    function create_if_block$g(ctx) {
      let dialog;
      let updating_visible;
      let current;

      function dialog_visible_binding(value) {
        /*dialog_visible_binding*/
        ctx[6].call(null, value);
      }

      let dialog_props = {
        width: "500",
        $$slots: {
          default: [create_default_slot_1$9],
          actions: [create_actions_slot$2],
          title: [create_title_slot$2]
        },
        $$scope: {
          ctx
        }
      };

      if (
      /*editandoSkin*/
      ctx[0] !== void 0) {
        dialog_props.visible =
        /*editandoSkin*/
        ctx[0];
      }

      dialog = new pn({
        props: dialog_props,
        $$inline: true
      });
      binding_callbacks.push(() => bind(dialog, "visible", dialog_visible_binding));
      const block = {
        c: function create() {
          create_component(dialog.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(dialog, target, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          const dialog_changes = {};

          if (dirty &
          /*$$scope, editandoSkin, $skinsStore*/
          1027) {
            dialog_changes.$$scope = {
              dirty,
              ctx
            };
          }

          if (!updating_visible && dirty &
          /*editandoSkin*/
          1) {
            updating_visible = true;
            dialog_changes.visible =
            /*editandoSkin*/
            ctx[0];
            add_flush_callback(() => updating_visible = false);
          }

          dialog.$set(dialog_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(dialog.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(dialog.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(dialog, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block$g.name,
        type: "if",
        source: "(21:8) {#if $skinsStore.activo == s.nombre}",
        ctx
      });
      return block;
    } // (23:16) <div slot="title">


    function create_title_slot$2(ctx) {
      let div;
      const block = {
        c: function create() {
          div = element("div");
          div.textContent = "Ajustes";
          attr_dev(div, "slot", "title");
          add_location(div, file$j, 22, 16, 809);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_title_slot$2.name,
        type: "slot",
        source: "(23:16) <div slot=\\\"title\\\">",
        ctx
      });
      return block;
    } // (32:20) <Button color="primary" on:click={() => editandoSkin = false}>


    function create_default_slot_2$8(ctx) {
      let t;
      const block = {
        c: function create() {
          t = text("Ta bien");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_2$8.name,
        type: "slot",
        source: "(32:20) <Button color=\\\"primary\\\" on:click={() => editandoSkin = false}>",
        ctx
      });
      return block;
    } // (31:16) <div slot="actions" class="actions center">


    function create_actions_slot$2(ctx) {
      let div;
      let button;
      let current;
      button = new ye({
        props: {
          color: "primary",
          $$slots: {
            default: [create_default_slot_2$8]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      button.$on("click",
      /*click_handler_2*/
      ctx[5]);
      const block = {
        c: function create() {
          div = element("div");
          create_component(button.$$.fragment);
          attr_dev(div, "slot", "actions");
          attr_dev(div, "class", "actions center");
          add_location(div, file$j, 30, 16, 1133);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          mount_component(button, div, null);
          current = true;
        },
        p: function update(ctx, dirty) {
          const button_changes = {};

          if (dirty &
          /*$$scope*/
          1024) {
            button_changes.$$scope = {
              dirty,
              ctx
            };
          }

          button.$set(button_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(button.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(button.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
          destroy_component(button);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_actions_slot$2.name,
        type: "slot",
        source: "(31:16) <div slot=\\\"actions\\\" class=\\\"actions center\\\">",
        ctx
      });
      return block;
    } // (22:12) <Dialog width="500" bind:visible={editandoSkin} >


    function create_default_slot_1$9(ctx) {
      let t0;
      let textarea;
      let textarea_placeholder_value;
      let t1;
      let t2;
      let mounted;
      let dispose;

      function textarea_input_handler() {
        /*textarea_input_handler*/
        ctx[4].call(textarea,
        /*each_value*/
        ctx[8],
        /*s_index*/
        ctx[9]);
      }

      const block = {
        c: function create() {
          t0 = space();
          textarea = element("textarea");
          t1 = space();
          t2 = space();
          set_style(textarea, "background", "var(--color3)");
          attr_dev(textarea, "spellcheck", "false");
          attr_dev(textarea, "placeholder", textarea_placeholder_value = "Ej " + "h1 {color: red;}" + " ");
          attr_dev(textarea, "cols", "30");
          attr_dev(textarea, "rows", "10");
          add_location(textarea, file$j, 24, 16, 858);
        },
        m: function mount(target, anchor) {
          insert_dev(target, t0, anchor);
          insert_dev(target, textarea, anchor);
          set_input_value(textarea,
          /*s*/
          ctx[7].style);
          insert_dev(target, t1, anchor);
          insert_dev(target, t2, anchor);

          if (!mounted) {
            dispose = listen_dev(textarea, "input", textarea_input_handler);
            mounted = true;
          }
        },
        p: function update(new_ctx, dirty) {
          ctx = new_ctx;

          if (dirty &
          /*$skinsStore*/
          2) {
            set_input_value(textarea,
            /*s*/
            ctx[7].style);
          }
        },
        i: noop,
        o: noop,
        d: function destroy(detaching) {
          if (detaching) detach_dev(t0);
          if (detaching) detach_dev(textarea);
          if (detaching) detach_dev(t1);
          if (detaching) detach_dev(t2);
          mounted = false;
          dispose();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_1$9.name,
        type: "slot",
        source: "(22:12) <Dialog width=\\\"500\\\" bind:visible={editandoSkin} >",
        ctx
      });
      return block;
    } // (15:4) {#each $skinsStore.skins as s }


    function create_each_block$9(ctx) {
      let li;
      let t0_value =
      /*s*/
      ctx[7].nombre + "";
      let t0;
      let t1;
      let span;
      let button;
      let t2;
      let ripple;
      let t3;
      let if_block_anchor;
      let current;
      let mounted;
      let dispose;
      button = new ye({
        props: {
          icon: true,
          dense: true,
          title: "Editar",
          $$slots: {
            default: [create_default_slot_3$8]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      button.$on("click",
      /*click_handler*/
      ctx[2]);
      ripple = new he({
        $$inline: true
      });

      function click_handler_1(...args) {
        return (
          /*click_handler_1*/
          ctx[3](
          /*s*/
          ctx[7], ...args)
        );
      }

      let if_block =
      /*$skinsStore*/
      ctx[1].activo ==
      /*s*/
      ctx[7].nombre && create_if_block$g(ctx);
      const block = {
        c: function create() {
          li = element("li");
          t0 = text(t0_value);
          t1 = space();
          span = element("span");
          create_component(button.$$.fragment);
          t2 = space();
          create_component(ripple.$$.fragment);
          t3 = space();
          if (if_block) if_block.c();
          if_block_anchor = empty();
          set_style(span, "margin-left", "auto");
          add_location(span, file$j, 16, 12, 480);
          attr_dev(li, "class", "svelte-7her2b");
          toggle_class(li, "selecionado",
          /*$skinsStore*/
          ctx[1].activo ==
          /*s*/
          ctx[7].nombre);
          add_location(li, file$j, 15, 8, 355);
        },
        m: function mount(target, anchor) {
          insert_dev(target, li, anchor);
          append_dev(li, t0);
          append_dev(li, t1);
          append_dev(li, span);
          mount_component(button, span, null);
          append_dev(span, t2);
          mount_component(ripple, span, null);
          insert_dev(target, t3, anchor);
          if (if_block) if_block.m(target, anchor);
          insert_dev(target, if_block_anchor, anchor);
          current = true;

          if (!mounted) {
            dispose = listen_dev(li, "click", click_handler_1, false, false, false);
            mounted = true;
          }
        },
        p: function update(new_ctx, dirty) {
          ctx = new_ctx;
          if ((!current || dirty &
          /*$skinsStore*/
          2) && t0_value !== (t0_value =
          /*s*/
          ctx[7].nombre + "")) set_data_dev(t0, t0_value);
          const button_changes = {};

          if (dirty &
          /*$$scope*/
          1024) {
            button_changes.$$scope = {
              dirty,
              ctx
            };
          }

          button.$set(button_changes);

          if (dirty &
          /*$skinsStore*/
          2) {
            toggle_class(li, "selecionado",
            /*$skinsStore*/
            ctx[1].activo ==
            /*s*/
            ctx[7].nombre);
          }

          if (
          /*$skinsStore*/
          ctx[1].activo ==
          /*s*/
          ctx[7].nombre) {
            if (if_block) {
              if_block.p(ctx, dirty);

              if (dirty &
              /*$skinsStore*/
              2) {
                transition_in(if_block, 1);
              }
            } else {
              if_block = create_if_block$g(ctx);
              if_block.c();
              transition_in(if_block, 1);
              if_block.m(if_block_anchor.parentNode, if_block_anchor);
            }
          } else if (if_block) {
            group_outros();
            transition_out(if_block, 1, 1, () => {
              if_block = null;
            });
            check_outros();
          }
        },
        i: function intro(local) {
          if (current) return;
          transition_in(button.$$.fragment, local);
          transition_in(ripple.$$.fragment, local);
          transition_in(if_block);
          current = true;
        },
        o: function outro(local) {
          transition_out(button.$$.fragment, local);
          transition_out(ripple.$$.fragment, local);
          transition_out(if_block);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(li);
          destroy_component(button);
          destroy_component(ripple);
          if (detaching) detach_dev(t3);
          if (if_block) if_block.d(detaching);
          if (detaching) detach_dev(if_block_anchor);
          mounted = false;
          dispose();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_each_block$9.name,
        type: "each",
        source: "(15:4) {#each $skinsStore.skins as s }",
        ctx
      });
      return block;
    } // (38:0) <Button color="primary" on:click={skinsStore.restaurarSkins}>


    function create_default_slot$a(ctx) {
      let t;
      const block = {
        c: function create() {
          t = text("Restaurar skins");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot$a.name,
        type: "slot",
        source: "(38:0) <Button color=\\\"primary\\\" on:click={skinsStore.restaurarSkins}>",
        ctx
      });
      return block;
    }

    function create_fragment$j(ctx) {
      let ul;
      let t;
      let button;
      let current;
      let each_value =
      /*$skinsStore*/
      ctx[1].skins;
      validate_each_argument(each_value);
      let each_blocks = [];

      for (let i = 0; i < each_value.length; i += 1) {
        each_blocks[i] = create_each_block$9(get_each_context$9(ctx, each_value, i));
      }

      const out = i => transition_out(each_blocks[i], 1, 1, () => {
        each_blocks[i] = null;
      });

      button = new ye({
        props: {
          color: "primary",
          $$slots: {
            default: [create_default_slot$a]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      button.$on("click", store$1.restaurarSkins);
      const block = {
        c: function create() {
          ul = element("ul");

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].c();
          }

          t = space();
          create_component(button.$$.fragment);
          add_location(ul, file$j, 13, 0, 306);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, ul, anchor);

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].m(ul, null);
          }

          insert_dev(target, t, anchor);
          mount_component(button, target, anchor);
          current = true;
        },
        p: function update(ctx, [dirty]) {
          if (dirty &
          /*editandoSkin, $skinsStore*/
          3) {
            each_value =
            /*$skinsStore*/
            ctx[1].skins;
            validate_each_argument(each_value);
            let i;

            for (i = 0; i < each_value.length; i += 1) {
              const child_ctx = get_each_context$9(ctx, each_value, i);

              if (each_blocks[i]) {
                each_blocks[i].p(child_ctx, dirty);
                transition_in(each_blocks[i], 1);
              } else {
                each_blocks[i] = create_each_block$9(child_ctx);
                each_blocks[i].c();
                transition_in(each_blocks[i], 1);
                each_blocks[i].m(ul, null);
              }
            }

            group_outros();

            for (i = each_value.length; i < each_blocks.length; i += 1) {
              out(i);
            }

            check_outros();
          }

          const button_changes = {};

          if (dirty &
          /*$$scope*/
          1024) {
            button_changes.$$scope = {
              dirty,
              ctx
            };
          }

          button.$set(button_changes);
        },
        i: function intro(local) {
          if (current) return;

          for (let i = 0; i < each_value.length; i += 1) {
            transition_in(each_blocks[i]);
          }

          transition_in(button.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          each_blocks = each_blocks.filter(Boolean);

          for (let i = 0; i < each_blocks.length; i += 1) {
            transition_out(each_blocks[i]);
          }

          transition_out(button.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(ul);
          destroy_each(each_blocks, detaching);
          if (detaching) detach_dev(t);
          destroy_component(button, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$j.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }

    function instance$j($$self, $$props, $$invalidate) {
      let $skinsStore;
      validate_store(store$1, "skinsStore");
      component_subscribe($$self, store$1, $$value => $$invalidate(1, $skinsStore = $$value));
      let {
        $$slots: slots = {},
        $$scope
      } = $$props;
      validate_slots("Skins", slots, []);
      let editandoSkin = false;
      store$1.applicarEstilo();
      const writable_props = [];
      Object.keys($$props).forEach(key => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Skins> was created with unknown prop '${key}'`);
      });

      const click_handler = () => $$invalidate(0, editandoSkin = true);

      const click_handler_1 = s => set_store_value(store$1, $skinsStore.activo = s.nombre, $skinsStore);

      function textarea_input_handler(each_value, s_index) {
        each_value[s_index].style = this.value;
        store$1.set($skinsStore);
      }

      const click_handler_2 = () => $$invalidate(0, editandoSkin = false);

      function dialog_visible_binding(value) {
        editandoSkin = value;
        $$invalidate(0, editandoSkin);
      }

      $$self.$capture_state = () => ({
        Dialog: pn,
        Button: ye,
        Checkbox: Ne,
        ExpansionPanel: bn,
        Ripple: he,
        localStore,
        skinsStore: store$1,
        editandoSkin,
        $skinsStore
      });

      $$self.$inject_state = $$props => {
        if ("editandoSkin" in $$props) $$invalidate(0, editandoSkin = $$props.editandoSkin);
      };

      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }

      $$self.$$.update = () => {
        if ($$self.$$.dirty &
        /*$skinsStore*/
        2) {
           if ($skinsStore) store$1.applicarEstilo();
        }
      };

      return [editandoSkin, $skinsStore, click_handler, click_handler_1, textarea_input_handler, click_handler_2, dialog_visible_binding];
    }

    class Skins extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$j, create_fragment$j, safe_not_equal, {});
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "Skins",
          options,
          id: create_fragment$j.name
        });
      }

    }

    const ajustesConfigMod = localStore("ajustesConfigMod", {
      mutearDenuncias: false,
      autoDesplegarDenuncias: true
    });

    /* src\components\Dialogos\Ajustes.svelte generated by Svelte v3.29.0 */
    const file$k = "src\\components\\Dialogos\\Ajustes.svelte"; // (58:8) <div slot="title">

    function create_title_slot$3(ctx) {
      let div;
      const block = {
        c: function create() {
          div = element("div");
          div.textContent = "Ajustes";
          attr_dev(div, "slot", "title");
          add_location(div, file$k, 57, 8, 1805);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_title_slot$3.name,
        type: "slot",
        source: "(58:8) <div slot=\\\"title\\\">",
        ctx
      });
      return block;
    } // (60:12) <Checkbox  bind:checked={$ajustesConfigStore.scrollAncho} right>


    function create_default_slot_13(ctx) {
      let t;
      const block = {
        c: function create() {
          t = text("Scroll ancho");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_13.name,
        type: "slot",
        source: "(60:12) <Checkbox  bind:checked={$ajustesConfigStore.scrollAncho} right>",
        ctx
      });
      return block;
    } // (61:12) <Checkbox  bind:checked={$ajustesConfigStore.tagClasico} right>


    function create_default_slot_12(ctx) {
      let t;
      const block = {
        c: function create() {
          t = text("Tag clasico");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_12.name,
        type: "slot",
        source: "(61:12) <Checkbox  bind:checked={$ajustesConfigStore.tagClasico} right>",
        ctx
      });
      return block;
    } // (63:12) <Checkbox  bind:checked={$ajustesConfigStore.fondoAburrido} right>


    function create_default_slot_11(ctx) {
      let t;
      const block = {
        c: function create() {
          t = text("Fondo personalizado");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_11.name,
        type: "slot",
        source: "(63:12) <Checkbox  bind:checked={$ajustesConfigStore.fondoAburrido} right>",
        ctx
      });
      return block;
    } // (64:12) {#if $ajustesConfigStore.fondoAburrido}


    function create_if_block_4$2(ctx) {
      let checkbox;
      let updating_checked;
      let current;

      function checkbox_checked_binding(value) {
        /*checkbox_checked_binding*/
        ctx[9].call(null, value);
      }

      let checkbox_props = {
        right: true,
        $$slots: {
          default: [create_default_slot_10$1]
        },
        $$scope: {
          ctx
        }
      };

      if (
      /*$ajustesConfigStore*/
      ctx[2].usarImagen !== void 0) {
        checkbox_props.checked =
        /*$ajustesConfigStore*/
        ctx[2].usarImagen;
      }

      checkbox = new Ne({
        props: checkbox_props,
        $$inline: true
      });
      binding_callbacks.push(() => bind(checkbox, "checked", checkbox_checked_binding));
      const block = {
        c: function create() {
          create_component(checkbox.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(checkbox, target, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          const checkbox_changes = {};

          if (dirty &
          /*$$scope*/
          16777216) {
            checkbox_changes.$$scope = {
              dirty,
              ctx
            };
          }

          if (!updating_checked && dirty &
          /*$ajustesConfigStore*/
          4) {
            updating_checked = true;
            checkbox_changes.checked =
            /*$ajustesConfigStore*/
            ctx[2].usarImagen;
            add_flush_callback(() => updating_checked = false);
          }

          checkbox.$set(checkbox_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(checkbox.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(checkbox.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(checkbox, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_4$2.name,
        type: "if",
        source: "(64:12) {#if $ajustesConfigStore.fondoAburrido}",
        ctx
      });
      return block;
    } // (65:16) <Checkbox  bind:checked={$ajustesConfigStore.usarImagen} right>


    function create_default_slot_10$1(ctx) {
      let t;
      const block = {
        c: function create() {
          t = text("Usar imagen");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_10$1.name,
        type: "slot",
        source: "(65:16) <Checkbox  bind:checked={$ajustesConfigStore.usarImagen} right>",
        ctx
      });
      return block;
    } // (67:16) {#if $ajustesConfigStore.fondoAburrido && !$ajustesConfigStore.usarImagen}


    function create_if_block_3$6(ctx) {
      let div;
      let label;
      let t1;
      let input;
      let mounted;
      let dispose;
      const block = {
        c: function create() {
          div = element("div");
          label = element("label");
          label.textContent = "Color Fondo:";
          t1 = space();
          input = element("input");
          attr_dev(label, "for", "color-fondo");
          add_location(label, file$k, 68, 20, 2555);
          attr_dev(input, "class", "colorpicker svelte-4d7af8");
          attr_dev(input, "type", "color");
          attr_dev(input, "name", "color-fondo");
          add_location(input, file$k, 69, 20, 2624);
          set_style(div, "display", "flex");
          add_location(div, file$k, 67, 16, 2507);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          append_dev(div, label);
          append_dev(div, t1);
          append_dev(div, input);
          set_input_value(input,
          /*$ajustesConfigStore*/
          ctx[2].colorFondo);

          if (!mounted) {
            dispose = listen_dev(input, "input",
            /*input_input_handler*/
            ctx[10]);
            mounted = true;
          }
        },
        p: function update(ctx, dirty) {
          if (dirty &
          /*$ajustesConfigStore*/
          4) {
            set_input_value(input,
            /*$ajustesConfigStore*/
            ctx[2].colorFondo);
          }
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
          mounted = false;
          dispose();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_3$6.name,
        type: "if",
        source: "(67:16) {#if $ajustesConfigStore.fondoAburrido && !$ajustesConfigStore.usarImagen}",
        ctx
      });
      return block;
    } // (73:16) {#if $ajustesConfigStore.fondoAburrido && $ajustesConfigStore.usarImagen}


    function create_if_block_2$a(ctx) {
      let div;
      let label;
      let t1;
      let input;
      let t2;
      let checkbox;
      let updating_checked;
      let current;
      let mounted;
      let dispose;

      function checkbox_checked_binding_1(value) {
        /*checkbox_checked_binding_1*/
        ctx[12].call(null, value);
      }

      let checkbox_props = {
        right: true,
        $$slots: {
          default: [create_default_slot_9$2]
        },
        $$scope: {
          ctx
        }
      };

      if (
      /*$ajustesConfigStore*/
      ctx[2].modoCover !== void 0) {
        checkbox_props.checked =
        /*$ajustesConfigStore*/
        ctx[2].modoCover;
      }

      checkbox = new Ne({
        props: checkbox_props,
        $$inline: true
      });
      binding_callbacks.push(() => bind(checkbox, "checked", checkbox_checked_binding_1));
      const block = {
        c: function create() {
          div = element("div");
          label = element("label");
          label.textContent = "Imagen:";
          t1 = space();
          input = element("input");
          t2 = space();
          create_component(checkbox.$$.fragment);
          attr_dev(label, "for", "imagen");
          add_location(label, file$k, 74, 20, 2960);
          set_style(input, "background", "var(--color4)");
          attr_dev(input, "type", "text");
          attr_dev(input, "name", "imagen");
          add_location(input, file$k, 75, 20, 3019);
          set_style(div, "display", "flex");
          set_style(div, "align-items", "baseline");
          set_style(div, "gap", "10px");
          add_location(div, file$k, 73, 16, 2880);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          append_dev(div, label);
          append_dev(div, t1);
          append_dev(div, input);
          set_input_value(input,
          /*$ajustesConfigStore*/
          ctx[2].imagen);
          insert_dev(target, t2, anchor);
          mount_component(checkbox, target, anchor);
          current = true;

          if (!mounted) {
            dispose = listen_dev(input, "input",
            /*input_input_handler_1*/
            ctx[11]);
            mounted = true;
          }
        },
        p: function update(ctx, dirty) {
          if (dirty &
          /*$ajustesConfigStore*/
          4 && input.value !==
          /*$ajustesConfigStore*/
          ctx[2].imagen) {
            set_input_value(input,
            /*$ajustesConfigStore*/
            ctx[2].imagen);
          }

          const checkbox_changes = {};

          if (dirty &
          /*$$scope*/
          16777216) {
            checkbox_changes.$$scope = {
              dirty,
              ctx
            };
          }

          if (!updating_checked && dirty &
          /*$ajustesConfigStore*/
          4) {
            updating_checked = true;
            checkbox_changes.checked =
            /*$ajustesConfigStore*/
            ctx[2].modoCover;
            add_flush_callback(() => updating_checked = false);
          }

          checkbox.$set(checkbox_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(checkbox.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(checkbox.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
          if (detaching) detach_dev(t2);
          destroy_component(checkbox, detaching);
          mounted = false;
          dispose();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_2$a.name,
        type: "if",
        source: "(73:16) {#if $ajustesConfigStore.fondoAburrido && $ajustesConfigStore.usarImagen}",
        ctx
      });
      return block;
    } // (78:16) <Checkbox  bind:checked={$ajustesConfigStore.modoCover} right>


    function create_default_slot_9$2(ctx) {
      let t;
      const block = {
        c: function create() {
          t = text("Modo Cover");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_9$2.name,
        type: "slot",
        source: "(78:16) <Checkbox  bind:checked={$ajustesConfigStore.modoCover} right>",
        ctx
      });
      return block;
    } // (81:12) <Checkbox  bind:checked={$ajustesConfigStore.usarColorPersonalizado} right>


    function create_default_slot_8$2(ctx) {
      let t;
      const block = {
        c: function create() {
          t = text("Color personalizado");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_8$2.name,
        type: "slot",
        source: "(81:12) <Checkbox  bind:checked={$ajustesConfigStore.usarColorPersonalizado} right>",
        ctx
      });
      return block;
    } // (82:12) {#if $ajustesConfigStore.usarColorPersonalizado}


    function create_if_block_1$b(ctx) {
      let div;
      let label;
      let t1;
      let input;
      let mounted;
      let dispose;
      const block = {
        c: function create() {
          div = element("div");
          label = element("label");
          label.textContent = "Color Personalizado:";
          t1 = space();
          input = element("input");
          attr_dev(label, "for", "");
          add_location(label, file$k, 83, 20, 3538);
          attr_dev(input, "class", "colorpicker svelte-4d7af8");
          attr_dev(input, "name", "color");
          attr_dev(input, "type", "color");
          add_location(input, file$k, 84, 20, 3602);
          attr_dev(div, "class", "");
          set_style(div, "display", "flex");
          add_location(div, file$k, 82, 16, 3482);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          append_dev(div, label);
          append_dev(div, t1);
          append_dev(div, input);
          set_input_value(input,
          /*$ajustesConfigStore*/
          ctx[2].colorPersonalizado);

          if (!mounted) {
            dispose = listen_dev(input, "input",
            /*input_input_handler_2*/
            ctx[14]);
            mounted = true;
          }
        },
        p: function update(ctx, dirty) {
          if (dirty &
          /*$ajustesConfigStore*/
          4) {
            set_input_value(input,
            /*$ajustesConfigStore*/
            ctx[2].colorPersonalizado);
          }
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
          mounted = false;
          dispose();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_1$b.name,
        type: "if",
        source: "(82:12) {#if $ajustesConfigStore.usarColorPersonalizado}",
        ctx
      });
      return block;
    } // (59:8) <ExpansionPanel bind:group name="Personalizacion">


    function create_default_slot_7$2(ctx) {
      let checkbox0;
      let updating_checked;
      let t0;
      let checkbox1;
      let updating_checked_1;
      let t1;
      let hr0;
      let t2;
      let checkbox2;
      let updating_checked_2;
      let t3;
      let t4;
      let t5;
      let t6;
      let hr1;
      let t7;
      let checkbox3;
      let updating_checked_3;
      let t8;
      let if_block3_anchor;
      let current;

      function checkbox0_checked_binding(value) {
        /*checkbox0_checked_binding*/
        ctx[6].call(null, value);
      }

      let checkbox0_props = {
        right: true,
        $$slots: {
          default: [create_default_slot_13]
        },
        $$scope: {
          ctx
        }
      };

      if (
      /*$ajustesConfigStore*/
      ctx[2].scrollAncho !== void 0) {
        checkbox0_props.checked =
        /*$ajustesConfigStore*/
        ctx[2].scrollAncho;
      }

      checkbox0 = new Ne({
        props: checkbox0_props,
        $$inline: true
      });
      binding_callbacks.push(() => bind(checkbox0, "checked", checkbox0_checked_binding));

      function checkbox1_checked_binding(value) {
        /*checkbox1_checked_binding*/
        ctx[7].call(null, value);
      }

      let checkbox1_props = {
        right: true,
        $$slots: {
          default: [create_default_slot_12]
        },
        $$scope: {
          ctx
        }
      };

      if (
      /*$ajustesConfigStore*/
      ctx[2].tagClasico !== void 0) {
        checkbox1_props.checked =
        /*$ajustesConfigStore*/
        ctx[2].tagClasico;
      }

      checkbox1 = new Ne({
        props: checkbox1_props,
        $$inline: true
      });
      binding_callbacks.push(() => bind(checkbox1, "checked", checkbox1_checked_binding));

      function checkbox2_checked_binding(value) {
        /*checkbox2_checked_binding*/
        ctx[8].call(null, value);
      }

      let checkbox2_props = {
        right: true,
        $$slots: {
          default: [create_default_slot_11]
        },
        $$scope: {
          ctx
        }
      };

      if (
      /*$ajustesConfigStore*/
      ctx[2].fondoAburrido !== void 0) {
        checkbox2_props.checked =
        /*$ajustesConfigStore*/
        ctx[2].fondoAburrido;
      }

      checkbox2 = new Ne({
        props: checkbox2_props,
        $$inline: true
      });
      binding_callbacks.push(() => bind(checkbox2, "checked", checkbox2_checked_binding));
      let if_block0 =
      /*$ajustesConfigStore*/
      ctx[2].fondoAburrido && create_if_block_4$2(ctx);
      let if_block1 =
      /*$ajustesConfigStore*/
      ctx[2].fondoAburrido && !
      /*$ajustesConfigStore*/
      ctx[2].usarImagen && create_if_block_3$6(ctx);
      let if_block2 =
      /*$ajustesConfigStore*/
      ctx[2].fondoAburrido &&
      /*$ajustesConfigStore*/
      ctx[2].usarImagen && create_if_block_2$a(ctx);

      function checkbox3_checked_binding(value) {
        /*checkbox3_checked_binding*/
        ctx[13].call(null, value);
      }

      let checkbox3_props = {
        right: true,
        $$slots: {
          default: [create_default_slot_8$2]
        },
        $$scope: {
          ctx
        }
      };

      if (
      /*$ajustesConfigStore*/
      ctx[2].usarColorPersonalizado !== void 0) {
        checkbox3_props.checked =
        /*$ajustesConfigStore*/
        ctx[2].usarColorPersonalizado;
      }

      checkbox3 = new Ne({
        props: checkbox3_props,
        $$inline: true
      });
      binding_callbacks.push(() => bind(checkbox3, "checked", checkbox3_checked_binding));
      let if_block3 =
      /*$ajustesConfigStore*/
      ctx[2].usarColorPersonalizado && create_if_block_1$b(ctx);
      const block = {
        c: function create() {
          create_component(checkbox0.$$.fragment);
          t0 = space();
          create_component(checkbox1.$$.fragment);
          t1 = space();
          hr0 = element("hr");
          t2 = space();
          create_component(checkbox2.$$.fragment);
          t3 = space();
          if (if_block0) if_block0.c();
          t4 = space();
          if (if_block1) if_block1.c();
          t5 = space();
          if (if_block2) if_block2.c();
          t6 = space();
          hr1 = element("hr");
          t7 = space();
          create_component(checkbox3.$$.fragment);
          t8 = space();
          if (if_block3) if_block3.c();
          if_block3_anchor = empty();
          attr_dev(hr0, "class", "svelte-4d7af8");
          add_location(hr0, file$k, 61, 12, 2110);
          attr_dev(hr1, "class", "svelte-4d7af8");
          add_location(hr1, file$k, 79, 12, 3282);
        },
        m: function mount(target, anchor) {
          mount_component(checkbox0, target, anchor);
          insert_dev(target, t0, anchor);
          mount_component(checkbox1, target, anchor);
          insert_dev(target, t1, anchor);
          insert_dev(target, hr0, anchor);
          insert_dev(target, t2, anchor);
          mount_component(checkbox2, target, anchor);
          insert_dev(target, t3, anchor);
          if (if_block0) if_block0.m(target, anchor);
          insert_dev(target, t4, anchor);
          if (if_block1) if_block1.m(target, anchor);
          insert_dev(target, t5, anchor);
          if (if_block2) if_block2.m(target, anchor);
          insert_dev(target, t6, anchor);
          insert_dev(target, hr1, anchor);
          insert_dev(target, t7, anchor);
          mount_component(checkbox3, target, anchor);
          insert_dev(target, t8, anchor);
          if (if_block3) if_block3.m(target, anchor);
          insert_dev(target, if_block3_anchor, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          const checkbox0_changes = {};

          if (dirty &
          /*$$scope*/
          16777216) {
            checkbox0_changes.$$scope = {
              dirty,
              ctx
            };
          }

          if (!updating_checked && dirty &
          /*$ajustesConfigStore*/
          4) {
            updating_checked = true;
            checkbox0_changes.checked =
            /*$ajustesConfigStore*/
            ctx[2].scrollAncho;
            add_flush_callback(() => updating_checked = false);
          }

          checkbox0.$set(checkbox0_changes);
          const checkbox1_changes = {};

          if (dirty &
          /*$$scope*/
          16777216) {
            checkbox1_changes.$$scope = {
              dirty,
              ctx
            };
          }

          if (!updating_checked_1 && dirty &
          /*$ajustesConfigStore*/
          4) {
            updating_checked_1 = true;
            checkbox1_changes.checked =
            /*$ajustesConfigStore*/
            ctx[2].tagClasico;
            add_flush_callback(() => updating_checked_1 = false);
          }

          checkbox1.$set(checkbox1_changes);
          const checkbox2_changes = {};

          if (dirty &
          /*$$scope*/
          16777216) {
            checkbox2_changes.$$scope = {
              dirty,
              ctx
            };
          }

          if (!updating_checked_2 && dirty &
          /*$ajustesConfigStore*/
          4) {
            updating_checked_2 = true;
            checkbox2_changes.checked =
            /*$ajustesConfigStore*/
            ctx[2].fondoAburrido;
            add_flush_callback(() => updating_checked_2 = false);
          }

          checkbox2.$set(checkbox2_changes);

          if (
          /*$ajustesConfigStore*/
          ctx[2].fondoAburrido) {
            if (if_block0) {
              if_block0.p(ctx, dirty);

              if (dirty &
              /*$ajustesConfigStore*/
              4) {
                transition_in(if_block0, 1);
              }
            } else {
              if_block0 = create_if_block_4$2(ctx);
              if_block0.c();
              transition_in(if_block0, 1);
              if_block0.m(t4.parentNode, t4);
            }
          } else if (if_block0) {
            group_outros();
            transition_out(if_block0, 1, 1, () => {
              if_block0 = null;
            });
            check_outros();
          }

          if (
          /*$ajustesConfigStore*/
          ctx[2].fondoAburrido && !
          /*$ajustesConfigStore*/
          ctx[2].usarImagen) {
            if (if_block1) {
              if_block1.p(ctx, dirty);
            } else {
              if_block1 = create_if_block_3$6(ctx);
              if_block1.c();
              if_block1.m(t5.parentNode, t5);
            }
          } else if (if_block1) {
            if_block1.d(1);
            if_block1 = null;
          }

          if (
          /*$ajustesConfigStore*/
          ctx[2].fondoAburrido &&
          /*$ajustesConfigStore*/
          ctx[2].usarImagen) {
            if (if_block2) {
              if_block2.p(ctx, dirty);

              if (dirty &
              /*$ajustesConfigStore*/
              4) {
                transition_in(if_block2, 1);
              }
            } else {
              if_block2 = create_if_block_2$a(ctx);
              if_block2.c();
              transition_in(if_block2, 1);
              if_block2.m(t6.parentNode, t6);
            }
          } else if (if_block2) {
            group_outros();
            transition_out(if_block2, 1, 1, () => {
              if_block2 = null;
            });
            check_outros();
          }

          const checkbox3_changes = {};

          if (dirty &
          /*$$scope*/
          16777216) {
            checkbox3_changes.$$scope = {
              dirty,
              ctx
            };
          }

          if (!updating_checked_3 && dirty &
          /*$ajustesConfigStore*/
          4) {
            updating_checked_3 = true;
            checkbox3_changes.checked =
            /*$ajustesConfigStore*/
            ctx[2].usarColorPersonalizado;
            add_flush_callback(() => updating_checked_3 = false);
          }

          checkbox3.$set(checkbox3_changes);

          if (
          /*$ajustesConfigStore*/
          ctx[2].usarColorPersonalizado) {
            if (if_block3) {
              if_block3.p(ctx, dirty);
            } else {
              if_block3 = create_if_block_1$b(ctx);
              if_block3.c();
              if_block3.m(if_block3_anchor.parentNode, if_block3_anchor);
            }
          } else if (if_block3) {
            if_block3.d(1);
            if_block3 = null;
          }
        },
        i: function intro(local) {
          if (current) return;
          transition_in(checkbox0.$$.fragment, local);
          transition_in(checkbox1.$$.fragment, local);
          transition_in(checkbox2.$$.fragment, local);
          transition_in(if_block0);
          transition_in(if_block2);
          transition_in(checkbox3.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(checkbox0.$$.fragment, local);
          transition_out(checkbox1.$$.fragment, local);
          transition_out(checkbox2.$$.fragment, local);
          transition_out(if_block0);
          transition_out(if_block2);
          transition_out(checkbox3.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(checkbox0, detaching);
          if (detaching) detach_dev(t0);
          destroy_component(checkbox1, detaching);
          if (detaching) detach_dev(t1);
          if (detaching) detach_dev(hr0);
          if (detaching) detach_dev(t2);
          destroy_component(checkbox2, detaching);
          if (detaching) detach_dev(t3);
          if (if_block0) if_block0.d(detaching);
          if (detaching) detach_dev(t4);
          if (if_block1) if_block1.d(detaching);
          if (detaching) detach_dev(t5);
          if (if_block2) if_block2.d(detaching);
          if (detaching) detach_dev(t6);
          if (detaching) detach_dev(hr1);
          if (detaching) detach_dev(t7);
          destroy_component(checkbox3, detaching);
          if (detaching) detach_dev(t8);
          if (if_block3) if_block3.d(detaching);
          if (detaching) detach_dev(if_block3_anchor);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_7$2.name,
        type: "slot",
        source: "(59:8) <ExpansionPanel bind:group name=\\\"Personalizacion\\\">",
        ctx
      });
      return block;
    } // (90:8) <ExpansionPanel bind:group name="Auto censura">


    function create_default_slot_6$4(ctx) {
      let textarea;
      let mounted;
      let dispose;
      const block = {
        c: function create() {
          textarea = element("textarea");
          set_style(textarea, "background", "var(--color3)");
          attr_dev(textarea, "spellcheck", "false");
          attr_dev(textarea, "placeholder", "Podes usar palabras y frases(palabras separadas guion bajo en vez de espacios). Ej sidoca huele tengo_un_video minubi insta se_le_da, etc");
          attr_dev(textarea, "cols", "30");
          attr_dev(textarea, "rows", "10");
          add_location(textarea, file$k, 90, 12, 3849);
        },
        m: function mount(target, anchor) {
          insert_dev(target, textarea, anchor);
          set_input_value(textarea,
          /*$ajustesConfigStore*/
          ctx[2].palabrasHideadas);

          if (!mounted) {
            dispose = listen_dev(textarea, "input",
            /*textarea_input_handler*/
            ctx[16]);
            mounted = true;
          }
        },
        p: function update(ctx, dirty) {
          if (dirty &
          /*$ajustesConfigStore*/
          4) {
            set_input_value(textarea,
            /*$ajustesConfigStore*/
            ctx[2].palabrasHideadas);
          }
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(textarea);
          mounted = false;
          dispose();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_6$4.name,
        type: "slot",
        source: "(90:8) <ExpansionPanel bind:group name=\\\"Auto censura\\\">",
        ctx
      });
      return block;
    } // (98:8) <ExpansionPanel bind:group name="Skins">


    function create_default_slot_5$5(ctx) {
      let skins;
      let current;
      skins = new Skins({
        $$inline: true
      });
      const block = {
        c: function create() {
          create_component(skins.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(skins, target, anchor);
          current = true;
        },
        i: function intro(local) {
          if (current) return;
          transition_in(skins.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(skins.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(skins, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_5$5.name,
        type: "slot",
        source: "(98:8) <ExpansionPanel bind:group name=\\\"Skins\\\">",
        ctx
      });
      return block;
    } // (102:8) {#if $globalStore.usuario.esAuxiliar}


    function create_if_block$h(ctx) {
      let expansionpanel;
      let updating_group;
      let current;

      function expansionpanel_group_binding(value) {
        /*expansionpanel_group_binding*/
        ctx[21].call(null, value);
      }

      let expansionpanel_props = {
        name: "Mod",
        $$slots: {
          default: [create_default_slot_2$9]
        },
        $$scope: {
          ctx
        }
      };

      if (
      /*group*/
      ctx[1] !== void 0) {
        expansionpanel_props.group =
        /*group*/
        ctx[1];
      }

      expansionpanel = new bn({
        props: expansionpanel_props,
        $$inline: true
      });
      binding_callbacks.push(() => bind(expansionpanel, "group", expansionpanel_group_binding));
      const block = {
        c: function create() {
          create_component(expansionpanel.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(expansionpanel, target, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          const expansionpanel_changes = {};

          if (dirty &
          /*$$scope, $ajustesConfigModStore*/
          16777232) {
            expansionpanel_changes.$$scope = {
              dirty,
              ctx
            };
          }

          if (!updating_group && dirty &
          /*group*/
          2) {
            updating_group = true;
            expansionpanel_changes.group =
            /*group*/
            ctx[1];
            add_flush_callback(() => updating_group = false);
          }

          expansionpanel.$set(expansionpanel_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(expansionpanel.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(expansionpanel.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(expansionpanel, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block$h.name,
        type: "if",
        source: "(102:8) {#if $globalStore.usuario.esAuxiliar}",
        ctx
      });
      return block;
    } // (104:16) <Checkbox  bind:checked={$ajustesConfigModStore.mutearDenuncias} right>


    function create_default_slot_4$6(ctx) {
      let t;
      const block = {
        c: function create() {
          t = text("Mutear denuncias");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_4$6.name,
        type: "slot",
        source: "(104:16) <Checkbox  bind:checked={$ajustesConfigModStore.mutearDenuncias} right>",
        ctx
      });
      return block;
    } // (105:16) <Checkbox  bind:checked={$ajustesConfigModStore.autoDesplegarDenuncias} right>


    function create_default_slot_3$9(ctx) {
      let t;
      const block = {
        c: function create() {
          t = text("Auto desplegar denuncias");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_3$9.name,
        type: "slot",
        source: "(105:16) <Checkbox  bind:checked={$ajustesConfigModStore.autoDesplegarDenuncias} right>",
        ctx
      });
      return block;
    } // (103:12) <ExpansionPanel bind:group name="Mod">


    function create_default_slot_2$9(ctx) {
      let checkbox0;
      let updating_checked;
      let t;
      let checkbox1;
      let updating_checked_1;
      let current;

      function checkbox0_checked_binding_1(value) {
        /*checkbox0_checked_binding_1*/
        ctx[19].call(null, value);
      }

      let checkbox0_props = {
        right: true,
        $$slots: {
          default: [create_default_slot_4$6]
        },
        $$scope: {
          ctx
        }
      };

      if (
      /*$ajustesConfigModStore*/
      ctx[4].mutearDenuncias !== void 0) {
        checkbox0_props.checked =
        /*$ajustesConfigModStore*/
        ctx[4].mutearDenuncias;
      }

      checkbox0 = new Ne({
        props: checkbox0_props,
        $$inline: true
      });
      binding_callbacks.push(() => bind(checkbox0, "checked", checkbox0_checked_binding_1));

      function checkbox1_checked_binding_1(value) {
        /*checkbox1_checked_binding_1*/
        ctx[20].call(null, value);
      }

      let checkbox1_props = {
        right: true,
        $$slots: {
          default: [create_default_slot_3$9]
        },
        $$scope: {
          ctx
        }
      };

      if (
      /*$ajustesConfigModStore*/
      ctx[4].autoDesplegarDenuncias !== void 0) {
        checkbox1_props.checked =
        /*$ajustesConfigModStore*/
        ctx[4].autoDesplegarDenuncias;
      }

      checkbox1 = new Ne({
        props: checkbox1_props,
        $$inline: true
      });
      binding_callbacks.push(() => bind(checkbox1, "checked", checkbox1_checked_binding_1));
      const block = {
        c: function create() {
          create_component(checkbox0.$$.fragment);
          t = space();
          create_component(checkbox1.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(checkbox0, target, anchor);
          insert_dev(target, t, anchor);
          mount_component(checkbox1, target, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          const checkbox0_changes = {};

          if (dirty &
          /*$$scope*/
          16777216) {
            checkbox0_changes.$$scope = {
              dirty,
              ctx
            };
          }

          if (!updating_checked && dirty &
          /*$ajustesConfigModStore*/
          16) {
            updating_checked = true;
            checkbox0_changes.checked =
            /*$ajustesConfigModStore*/
            ctx[4].mutearDenuncias;
            add_flush_callback(() => updating_checked = false);
          }

          checkbox0.$set(checkbox0_changes);
          const checkbox1_changes = {};

          if (dirty &
          /*$$scope*/
          16777216) {
            checkbox1_changes.$$scope = {
              dirty,
              ctx
            };
          }

          if (!updating_checked_1 && dirty &
          /*$ajustesConfigModStore*/
          16) {
            updating_checked_1 = true;
            checkbox1_changes.checked =
            /*$ajustesConfigModStore*/
            ctx[4].autoDesplegarDenuncias;
            add_flush_callback(() => updating_checked_1 = false);
          }

          checkbox1.$set(checkbox1_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(checkbox0.$$.fragment, local);
          transition_in(checkbox1.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(checkbox0.$$.fragment, local);
          transition_out(checkbox1.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(checkbox0, detaching);
          if (detaching) detach_dev(t);
          destroy_component(checkbox1, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_2$9.name,
        type: "slot",
        source: "(103:12) <ExpansionPanel bind:group name=\\\"Mod\\\">",
        ctx
      });
      return block;
    } // (110:12) <Button color="primary" on:click={actualizarYCerrar}>


    function create_default_slot_1$a(ctx) {
      let t;
      const block = {
        c: function create() {
          t = text("Lito");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_1$a.name,
        type: "slot",
        source: "(110:12) <Button color=\\\"primary\\\" on:click={actualizarYCerrar}>",
        ctx
      });
      return block;
    } // (109:8) <div slot="actions" class="actions center">


    function create_actions_slot$3(ctx) {
      let div;
      let button;
      let current;
      button = new ye({
        props: {
          color: "primary",
          $$slots: {
            default: [create_default_slot_1$a]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      button.$on("click",
      /*actualizarYCerrar*/
      ctx[5]);
      const block = {
        c: function create() {
          div = element("div");
          create_component(button.$$.fragment);
          attr_dev(div, "slot", "actions");
          attr_dev(div, "class", "actions center");
          add_location(div, file$k, 108, 8, 4759);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          mount_component(button, div, null);
          current = true;
        },
        p: function update(ctx, dirty) {
          const button_changes = {};

          if (dirty &
          /*$$scope*/
          16777216) {
            button_changes.$$scope = {
              dirty,
              ctx
            };
          }

          button.$set(button_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(button.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(button.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
          destroy_component(button);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_actions_slot$3.name,
        type: "slot",
        source: "(109:8) <div slot=\\\"actions\\\" class=\\\"actions center\\\">",
        ctx
      });
      return block;
    } // (57:4) <Dialog  width="500" bind:visible={visible}>


    function create_default_slot$b(ctx) {
      let t0;
      let expansionpanel0;
      let updating_group;
      let t1;
      let expansionpanel1;
      let updating_group_1;
      let t2;
      let expansionpanel2;
      let updating_group_2;
      let t3;
      let t4;
      let current;

      function expansionpanel0_group_binding(value) {
        /*expansionpanel0_group_binding*/
        ctx[15].call(null, value);
      }

      let expansionpanel0_props = {
        name: "Personalizacion",
        $$slots: {
          default: [create_default_slot_7$2]
        },
        $$scope: {
          ctx
        }
      };

      if (
      /*group*/
      ctx[1] !== void 0) {
        expansionpanel0_props.group =
        /*group*/
        ctx[1];
      }

      expansionpanel0 = new bn({
        props: expansionpanel0_props,
        $$inline: true
      });
      binding_callbacks.push(() => bind(expansionpanel0, "group", expansionpanel0_group_binding));

      function expansionpanel1_group_binding(value) {
        /*expansionpanel1_group_binding*/
        ctx[17].call(null, value);
      }

      let expansionpanel1_props = {
        name: "Auto censura",
        $$slots: {
          default: [create_default_slot_6$4]
        },
        $$scope: {
          ctx
        }
      };

      if (
      /*group*/
      ctx[1] !== void 0) {
        expansionpanel1_props.group =
        /*group*/
        ctx[1];
      }

      expansionpanel1 = new bn({
        props: expansionpanel1_props,
        $$inline: true
      });
      binding_callbacks.push(() => bind(expansionpanel1, "group", expansionpanel1_group_binding));

      function expansionpanel2_group_binding(value) {
        /*expansionpanel2_group_binding*/
        ctx[18].call(null, value);
      }

      let expansionpanel2_props = {
        name: "Skins",
        $$slots: {
          default: [create_default_slot_5$5]
        },
        $$scope: {
          ctx
        }
      };

      if (
      /*group*/
      ctx[1] !== void 0) {
        expansionpanel2_props.group =
        /*group*/
        ctx[1];
      }

      expansionpanel2 = new bn({
        props: expansionpanel2_props,
        $$inline: true
      });
      binding_callbacks.push(() => bind(expansionpanel2, "group", expansionpanel2_group_binding));
      let if_block =
      /*$globalStore*/
      ctx[3].usuario.esAuxiliar && create_if_block$h(ctx);
      const block = {
        c: function create() {
          t0 = space();
          create_component(expansionpanel0.$$.fragment);
          t1 = space();
          create_component(expansionpanel1.$$.fragment);
          t2 = space();
          create_component(expansionpanel2.$$.fragment);
          t3 = space();
          if (if_block) if_block.c();
          t4 = space();
        },
        m: function mount(target, anchor) {
          insert_dev(target, t0, anchor);
          mount_component(expansionpanel0, target, anchor);
          insert_dev(target, t1, anchor);
          mount_component(expansionpanel1, target, anchor);
          insert_dev(target, t2, anchor);
          mount_component(expansionpanel2, target, anchor);
          insert_dev(target, t3, anchor);
          if (if_block) if_block.m(target, anchor);
          insert_dev(target, t4, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          const expansionpanel0_changes = {};

          if (dirty &
          /*$$scope, $ajustesConfigStore*/
          16777220) {
            expansionpanel0_changes.$$scope = {
              dirty,
              ctx
            };
          }

          if (!updating_group && dirty &
          /*group*/
          2) {
            updating_group = true;
            expansionpanel0_changes.group =
            /*group*/
            ctx[1];
            add_flush_callback(() => updating_group = false);
          }

          expansionpanel0.$set(expansionpanel0_changes);
          const expansionpanel1_changes = {};

          if (dirty &
          /*$$scope, $ajustesConfigStore*/
          16777220) {
            expansionpanel1_changes.$$scope = {
              dirty,
              ctx
            };
          }

          if (!updating_group_1 && dirty &
          /*group*/
          2) {
            updating_group_1 = true;
            expansionpanel1_changes.group =
            /*group*/
            ctx[1];
            add_flush_callback(() => updating_group_1 = false);
          }

          expansionpanel1.$set(expansionpanel1_changes);
          const expansionpanel2_changes = {};

          if (dirty &
          /*$$scope*/
          16777216) {
            expansionpanel2_changes.$$scope = {
              dirty,
              ctx
            };
          }

          if (!updating_group_2 && dirty &
          /*group*/
          2) {
            updating_group_2 = true;
            expansionpanel2_changes.group =
            /*group*/
            ctx[1];
            add_flush_callback(() => updating_group_2 = false);
          }

          expansionpanel2.$set(expansionpanel2_changes);

          if (
          /*$globalStore*/
          ctx[3].usuario.esAuxiliar) {
            if (if_block) {
              if_block.p(ctx, dirty);

              if (dirty &
              /*$globalStore*/
              8) {
                transition_in(if_block, 1);
              }
            } else {
              if_block = create_if_block$h(ctx);
              if_block.c();
              transition_in(if_block, 1);
              if_block.m(t4.parentNode, t4);
            }
          } else if (if_block) {
            group_outros();
            transition_out(if_block, 1, 1, () => {
              if_block = null;
            });
            check_outros();
          }
        },
        i: function intro(local) {
          if (current) return;
          transition_in(expansionpanel0.$$.fragment, local);
          transition_in(expansionpanel1.$$.fragment, local);
          transition_in(expansionpanel2.$$.fragment, local);
          transition_in(if_block);
          current = true;
        },
        o: function outro(local) {
          transition_out(expansionpanel0.$$.fragment, local);
          transition_out(expansionpanel1.$$.fragment, local);
          transition_out(expansionpanel2.$$.fragment, local);
          transition_out(if_block);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(t0);
          destroy_component(expansionpanel0, detaching);
          if (detaching) detach_dev(t1);
          destroy_component(expansionpanel1, detaching);
          if (detaching) detach_dev(t2);
          destroy_component(expansionpanel2, detaching);
          if (detaching) detach_dev(t3);
          if (if_block) if_block.d(detaching);
          if (detaching) detach_dev(t4);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot$b.name,
        type: "slot",
        source: "(57:4) <Dialog  width=\\\"500\\\" bind:visible={visible}>",
        ctx
      });
      return block;
    }

    function create_fragment$k(ctx) {
      let div;
      let dialog;
      let updating_visible;
      let current;

      function dialog_visible_binding(value) {
        /*dialog_visible_binding*/
        ctx[22].call(null, value);
      }

      let dialog_props = {
        width: "500",
        $$slots: {
          default: [create_default_slot$b],
          actions: [create_actions_slot$3],
          title: [create_title_slot$3]
        },
        $$scope: {
          ctx
        }
      };

      if (
      /*visible*/
      ctx[0] !== void 0) {
        dialog_props.visible =
        /*visible*/
        ctx[0];
      }

      dialog = new pn({
        props: dialog_props,
        $$inline: true
      });
      binding_callbacks.push(() => bind(dialog, "visible", dialog_visible_binding));
      const block = {
        c: function create() {
          div = element("div");
          create_component(dialog.$$.fragment);
          attr_dev(div, "class", "ajustes svelte-4d7af8");
          add_location(div, file$k, 55, 0, 1726);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          mount_component(dialog, div, null);
          current = true;
        },
        p: function update(ctx, [dirty]) {
          const dialog_changes = {};

          if (dirty &
          /*$$scope, group, $ajustesConfigModStore, $globalStore, $ajustesConfigStore*/
          16777246) {
            dialog_changes.$$scope = {
              dirty,
              ctx
            };
          }

          if (!updating_visible && dirty &
          /*visible*/
          1) {
            updating_visible = true;
            dialog_changes.visible =
            /*visible*/
            ctx[0];
            add_flush_callback(() => updating_visible = false);
          }

          dialog.$set(dialog_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(dialog.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(dialog.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
          destroy_component(dialog);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$k.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }

    function instance$k($$self, $$props, $$invalidate) {
      let $ajustesConfigStore;
      let $globalStore;
      let $ajustesConfigModStore;
      validate_store(ajustesConfigStore, "ajustesConfigStore");
      component_subscribe($$self, ajustesConfigStore, $$value => $$invalidate(2, $ajustesConfigStore = $$value));
      validate_store(globalStore, "globalStore");
      component_subscribe($$self, globalStore, $$value => $$invalidate(3, $globalStore = $$value));
      validate_store(ajustesConfigMod, "ajustesConfigModStore");
      component_subscribe($$self, ajustesConfigMod, $$value => $$invalidate(4, $ajustesConfigModStore = $$value));
      let {
        $$slots: slots = {},
        $$scope
      } = $$props;
      validate_slots("Ajustes", slots, []);
      let {
        visible = true
      } = $$props;
      setTimeout(actualizarConfiguracion, 1);

      function actualizarConfiguracion() {
        let css = `
            #fondo-global {
                ${$ajustesConfigStore.usarImagen ? `background-image: url(${$ajustesConfigStore.imagen})` : `background:${$ajustesConfigStore.colorFondo}`};
                background-size:${$ajustesConfigStore.modoCover ? "cover" : "auto"} ;
            }
        `;

        if (!$ajustesConfigStore.fondoAburrido) {
          css = `
            #fondo-global {
                background-image: url(/imagenes/rosed.png) ;
                background-size:auto ;
            }
        `;
        }

        let style = window.document.styleSheets[0];
        style.insertRule(css, style.cssRules.length);

        if ($ajustesConfigStore.scrollAncho) {
          style.insertRule(`
            ::-webkit-scrollbar {
                width: 10px !important;
            }`, style.cssRules.length);
        }

        if ($ajustesConfigStore.usarColorPersonalizado) {
          style.insertRule(`
            body {
                --color5: ${$ajustesConfigStore.colorPersonalizado} !important;
            }`, style.cssRules.length);
        }
      }

      function actualizarYCerrar() {
        actualizarConfiguracion();
        $$invalidate(0, visible = false);
      }

      let group = "";
      const writable_props = ["visible"];
      Object.keys($$props).forEach(key => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Ajustes> was created with unknown prop '${key}'`);
      });

      function checkbox0_checked_binding(value) {
        $ajustesConfigStore.scrollAncho = value;
        ajustesConfigStore.set($ajustesConfigStore);
      }

      function checkbox1_checked_binding(value) {
        $ajustesConfigStore.tagClasico = value;
        ajustesConfigStore.set($ajustesConfigStore);
      }

      function checkbox2_checked_binding(value) {
        $ajustesConfigStore.fondoAburrido = value;
        ajustesConfigStore.set($ajustesConfigStore);
      }

      function checkbox_checked_binding(value) {
        $ajustesConfigStore.usarImagen = value;
        ajustesConfigStore.set($ajustesConfigStore);
      }

      function input_input_handler() {
        $ajustesConfigStore.colorFondo = this.value;
        ajustesConfigStore.set($ajustesConfigStore);
      }

      function input_input_handler_1() {
        $ajustesConfigStore.imagen = this.value;
        ajustesConfigStore.set($ajustesConfigStore);
      }

      function checkbox_checked_binding_1(value) {
        $ajustesConfigStore.modoCover = value;
        ajustesConfigStore.set($ajustesConfigStore);
      }

      function checkbox3_checked_binding(value) {
        $ajustesConfigStore.usarColorPersonalizado = value;
        ajustesConfigStore.set($ajustesConfigStore);
      }

      function input_input_handler_2() {
        $ajustesConfigStore.colorPersonalizado = this.value;
        ajustesConfigStore.set($ajustesConfigStore);
      }

      function expansionpanel0_group_binding(value) {
        group = value;
        $$invalidate(1, group);
      }

      function textarea_input_handler() {
        $ajustesConfigStore.palabrasHideadas = this.value;
        ajustesConfigStore.set($ajustesConfigStore);
      }

      function expansionpanel1_group_binding(value) {
        group = value;
        $$invalidate(1, group);
      }

      function expansionpanel2_group_binding(value) {
        group = value;
        $$invalidate(1, group);
      }

      function checkbox0_checked_binding_1(value) {
        $ajustesConfigModStore.mutearDenuncias = value;
        ajustesConfigMod.set($ajustesConfigModStore);
      }

      function checkbox1_checked_binding_1(value) {
        $ajustesConfigModStore.autoDesplegarDenuncias = value;
        ajustesConfigMod.set($ajustesConfigModStore);
      }

      function expansionpanel_group_binding(value) {
        group = value;
        $$invalidate(1, group);
      }

      function dialog_visible_binding(value) {
        visible = value;
        $$invalidate(0, visible);
      }

      $$self.$$set = $$props => {
        if ("visible" in $$props) $$invalidate(0, visible = $$props.visible);
      };

      $$self.$capture_state = () => ({
        Dialog: pn,
        Button: ye,
        Checkbox: Ne,
        ExpansionPanel: bn,
        Ripple: he,
        globalStore,
        Skins,
        ajustesConfigStore,
        ajustesConfigModStore: ajustesConfigMod,
        visible,
        actualizarConfiguracion,
        actualizarYCerrar,
        group,
        $ajustesConfigStore,
        $globalStore,
        $ajustesConfigModStore
      });

      $$self.$inject_state = $$props => {
        if ("visible" in $$props) $$invalidate(0, visible = $$props.visible);
        if ("group" in $$props) $$invalidate(1, group = $$props.group);
      };

      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }

      $$self.$$.update = () => {
        if ($$self.$$.dirty &
        /*$ajustesConfigStore*/
        4) {
           if ($ajustesConfigStore) actualizarConfiguracion();
        }
      };

      return [visible, group, $ajustesConfigStore, $globalStore, $ajustesConfigModStore, actualizarYCerrar, checkbox0_checked_binding, checkbox1_checked_binding, checkbox2_checked_binding, checkbox_checked_binding, input_input_handler, input_input_handler_1, checkbox_checked_binding_1, checkbox3_checked_binding, input_input_handler_2, expansionpanel0_group_binding, textarea_input_handler, expansionpanel1_group_binding, expansionpanel2_group_binding, checkbox0_checked_binding_1, checkbox1_checked_binding_1, expansionpanel_group_binding, dialog_visible_binding];
    }

    class Ajustes extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$k, create_fragment$k, safe_not_equal, {
          visible: 0
        });
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "Ajustes",
          options,
          id: create_fragment$k.name
        });
      }

      get visible() {
        throw new Error("<Ajustes>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set visible(value) {
        throw new Error("<Ajustes>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

    }

    /* src\components\Comentarios\Comentarios.svelte generated by Svelte v3.29.0 */
    const {
      setTimeout: setTimeout_1,
      window: window_1
    } = globals;
    const file$l = "src\\components\\Comentarios\\Comentarios.svelte";

    function get_each_context$a(ctx, list, i) {
      const child_ctx = ctx.slice();
      child_ctx[46] = list[i];
      child_ctx[47] = list;
      child_ctx[48] = i;
      return child_ctx;
    } // (204:4) {#if !$configStore.general.modoMessi || $globalStore.usuario.esMod}


    function create_if_block_5$2(ctx) {
      let formulario;
      let current;
      formulario = new Formulario({
        props: {
          hilo:
          /*hilo*/
          ctx[1]
        },
        $$inline: true
      });
      formulario.$on("comentarioCreado",
      /*cargarNuevosComentarios*/
      ctx[20]);
      const block = {
        c: function create() {
          create_component(formulario.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(formulario, target, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          const formulario_changes = {};
          if (dirty[0] &
          /*hilo*/
          2) formulario_changes.hilo =
          /*hilo*/
          ctx[1];
          formulario.$set(formulario_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(formulario.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(formulario.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(formulario, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_5$2.name,
        type: "if",
        source: "(204:4) {#if !$configStore.general.modoMessi || $globalStore.usuario.esMod}",
        ctx
      });
      return block;
    } // (212:8) {#if nuevosComentarios.length != 0}


    function create_if_block_4$3(ctx) {
      let div;
      let span;
      let t0;
      let t1_value =
      /*nuevosComentarios*/
      ctx[3].length + "";
      let t1;
      let mounted;
      let dispose;
      const block = {
        c: function create() {
          div = element("div");
          span = element("span");
          t0 = text("+ ");
          t1 = text(t1_value);
          add_location(span, file$l, 216, 16, 7925);
          attr_dev(div, "class", "badge");
          set_style(div, "font-size", "18px");
          set_style(div, "height", "auto");
          set_style(div, "cursor", "pointer");
          add_location(div, file$l, 212, 12, 7782);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          append_dev(div, span);
          append_dev(span, t0);
          append_dev(span, t1);

          if (!mounted) {
            dispose = listen_dev(span, "click",
            /*cargarNuevosComentarios*/
            ctx[20], false, false, false);
            mounted = true;
          }
        },
        p: function update(ctx, dirty) {
          if (dirty[0] &
          /*nuevosComentarios*/
          8 && t1_value !== (t1_value =
          /*nuevosComentarios*/
          ctx[3].length + "")) set_data_dev(t1, t1_value);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
          mounted = false;
          dispose();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_4$3.name,
        type: "if",
        source: "(212:8) {#if nuevosComentarios.length != 0}",
        ctx
      });
      return block;
    } // (224:12) <Button                  on:click={() =>                      ($comentariosStore.modoVivo = !$comentariosStore.modoVivo)}                  title="Comentarios en vivo (se cargan automaticamente)"                  dense                  icon              >


    function create_default_slot_5$6(ctx) {
      let div;
      let div_style_value;
      const block = {
        c: function create() {
          div = element("div");
          attr_dev(div, "class", "boton-modo-vivo svelte-qfw9k3");
          attr_dev(div, "style", div_style_value =
          /*$comentariosStore*/
          ctx[15].modoVivo ? "background:var(--color5);" : "background:white");
          add_location(div, file$l, 230, 16, 8502);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
        },
        p: function update(ctx, dirty) {
          if (dirty[0] &
          /*$comentariosStore*/
          32768 && div_style_value !== (div_style_value =
          /*$comentariosStore*/
          ctx[15].modoVivo ? "background:var(--color5);" : "background:white")) {
            attr_dev(div, "style", div_style_value);
          }
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_5$6.name,
        type: "slot",
        source: "(224:12) <Button                  on:click={() =>                      ($comentariosStore.modoVivo = !$comentariosStore.modoVivo)}                  title=\\\"Comentarios en vivo (se cargan automaticamente)\\\"                  dense                  icon              >",
        ctx
      });
      return block;
    } // (238:12) {#if comentarios.length > limite}


    function create_if_block_3$7(ctx) {
      let button;
      let current;
      button = new ye({
        props: {
          title: "Limitar a " +
          /*bloque*/
          ctx[19] + " comentarios mostrados (evita el lag)",
          dense: true,
          icon: true,
          $$slots: {
            default: [create_default_slot_4$7]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      button.$on("click",
      /*click_handler_1*/
      ctx[29]);
      const block = {
        c: function create() {
          create_component(button.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(button, target, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          const button_changes = {};

          if (dirty[1] &
          /*$$scope*/
          262144) {
            button_changes.$$scope = {
              dirty,
              ctx
            };
          }

          button.$set(button_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(button.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(button.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(button, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_3$7.name,
        type: "if",
        source: "(238:12) {#if comentarios.length > limite}",
        ctx
      });
      return block;
    } // (239:16) <Button                      on:click={() => {                          spinnerAcciones = true;                          setTimeout(() => {                              limite = bloque;                              infLoadActivo = false;                              tick().then(() => {                                  infLoadActivo = comentarios.length >= limite;                                  spinnerAcciones = false;                              });                          }, 60);                      }}                      title="Limitar a {bloque} comentarios mostrados (evita el lag)"                      dense                      icon                      >


    function create_default_slot_4$7(ctx) {
      let icon;
      const block = {
        c: function create() {
          icon = element("icon");
          attr_dev(icon, "class", "fe fe-slash");
          add_location(icon, file$l, 253, 21, 9490);
        },
        m: function mount(target, anchor) {
          insert_dev(target, icon, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(icon);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_4$7.name,
        type: "slot",
        source: "(239:16) <Button                      on:click={() => {                          spinnerAcciones = true;                          setTimeout(() => {                              limite = bloque;                              infLoadActivo = false;                              tick().then(() => {                                  infLoadActivo = comentarios.length >= limite;                                  spinnerAcciones = false;                              });                          }, 60);                      }}                      title=\\\"Limitar a {bloque} comentarios mostrados (evita el lag)\\\"                      dense                      icon                      >",
        ctx
      });
      return block;
    } // (257:12) <Button on:click={() => (carpetaMedia = !carpetaMedia)} dense icon                  >


    function create_default_slot_3$a(ctx) {
      let icon;
      const block = {
        c: function create() {
          icon = element("icon");
          attr_dev(icon, "class", "fe fe-folder");
          add_location(icon, file$l, 257, 17, 9663);
        },
        m: function mount(target, anchor) {
          insert_dev(target, icon, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(icon);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_3$a.name,
        type: "slot",
        source: "(257:12) <Button on:click={() => (carpetaMedia = !carpetaMedia)} dense icon                  >",
        ctx
      });
      return block;
    } // (260:12) {#if comentarios.length > 0}


    function create_if_block_2$b(ctx) {
      let button;
      let t;
      let spinner;
      let current;
      button = new ye({
        props: {
          dense: true,
          icon: true,
          $$slots: {
            default: [create_default_slot_2$a]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      button.$on("click",
      /*click_handler_3*/
      ctx[31]);
      spinner = new Spinner({
        props: {
          cargando:
          /*spinnerAcciones*/
          ctx[13]
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          create_component(button.$$.fragment);
          t = space();
          create_component(spinner.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(button, target, anchor);
          insert_dev(target, t, anchor);
          mount_component(spinner, target, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          const button_changes = {};

          if (dirty[1] &
          /*$$scope*/
          262144) {
            button_changes.$$scope = {
              dirty,
              ctx
            };
          }

          button.$set(button_changes);
          const spinner_changes = {};
          if (dirty[0] &
          /*spinnerAcciones*/
          8192) spinner_changes.cargando =
          /*spinnerAcciones*/
          ctx[13];
          spinner.$set(spinner_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(button.$$.fragment, local);
          transition_in(spinner.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(button.$$.fragment, local);
          transition_out(spinner.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(button, detaching);
          if (detaching) detach_dev(t);
          destroy_component(spinner, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_2$b.name,
        type: "if",
        source: "(260:12) {#if comentarios.length > 0}",
        ctx
      });
      return block;
    } // (261:16) <Button                      on:click={() => {                          spinnerAcciones = true;                          setTimeout(() => {                              irAComentario(                                  comentarios[comentarios.length - 1].id                              ).then(() => {                                  spinnerAcciones = false;                              });                          }, 60);                      }}                      dense                      icon                      >


    function create_default_slot_2$a(ctx) {
      let icon;
      const block = {
        c: function create() {
          icon = element("icon");
          attr_dev(icon, "class", "fe fe-arrow-down");
          add_location(icon, file$l, 273, 21, 10298);
        },
        m: function mount(target, anchor) {
          insert_dev(target, icon, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(icon);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_2$a.name,
        type: "slot",
        source: "(261:16) <Button                      on:click={() => {                          spinnerAcciones = true;                          setTimeout(() => {                              irAComentario(                                  comentarios[comentarios.length - 1].id                              ).then(() => {                                  spinnerAcciones = false;                              });                          }, 60);                      }}                      dense                      icon                      >",
        ctx
      });
      return block;
    } // (282:12) {#each comentarios.slice(0, limite) as comentario (comentario.id)}


    function create_each_block$a(key_1, ctx) {
      let li;
      let comentario;
      let updating_comentario;
      let updating_comentariosDic;
      let li_transition;
      let current;

      function comentario_comentario_binding(value) {
        /*comentario_comentario_binding*/
        ctx[32].call(null, value,
        /*comentario*/
        ctx[46],
        /*each_value*/
        ctx[47],
        /*comentario_index*/
        ctx[48]);
      }

      function comentario_comentariosDic_binding(value) {
        /*comentario_comentariosDic_binding*/
        ctx[33].call(null, value);
      }

      let comentario_props = {
        hilo:
        /*hilo*/
        ctx[1],
        respuetasCompactas:
        /*modoTelefono*/
        ctx[17]
      };

      if (
      /*comentario*/
      ctx[46] !== void 0) {
        comentario_props.comentario =
        /*comentario*/
        ctx[46];
      }

      if (
      /*diccionarioComentarios*/
      ctx[7] !== void 0) {
        comentario_props.comentariosDic =
        /*diccionarioComentarios*/
        ctx[7];
      }

      comentario = new Comentario({
        props: comentario_props,
        $$inline: true
      });
      binding_callbacks.push(() => bind(comentario, "comentario", comentario_comentario_binding));
      binding_callbacks.push(() => bind(comentario, "comentariosDic", comentario_comentariosDic_binding));
      comentario.$on("colorClick",
      /*colorClick_handler*/
      ctx[34]);
      comentario.$on("tagClickeado",
      /*tagCliqueado*/
      ctx[22]);
      comentario.$on("idUnicoClickeado",
      /*idUnicoClickeado*/
      ctx[24]);
      comentario.$on("irAComentario",
      /*irAComentario*/
      ctx[23]);
      comentario.$on("motrarRespuestas",
      /*motrarRespuestas_handler*/
      ctx[35]);
      const block = {
        key: key_1,
        first: null,
        c: function create() {
          li = element("li");
          create_component(comentario.$$.fragment);
          add_location(li, file$l, 282, 16, 10645);
          this.first = li;
        },
        m: function mount(target, anchor) {
          insert_dev(target, li, anchor);
          mount_component(comentario, li, null);
          current = true;
        },
        p: function update(new_ctx, dirty) {
          ctx = new_ctx;
          const comentario_changes = {};
          if (dirty[0] &
          /*hilo*/
          2) comentario_changes.hilo =
          /*hilo*/
          ctx[1];

          if (!updating_comentario && dirty[0] &
          /*comentarios, limite*/
          17) {
            updating_comentario = true;
            comentario_changes.comentario =
            /*comentario*/
            ctx[46];
            add_flush_callback(() => updating_comentario = false);
          }

          if (!updating_comentariosDic && dirty[0] &
          /*diccionarioComentarios*/
          128) {
            updating_comentariosDic = true;
            comentario_changes.comentariosDic =
            /*diccionarioComentarios*/
            ctx[7];
            add_flush_callback(() => updating_comentariosDic = false);
          }

          comentario.$set(comentario_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(comentario.$$.fragment, local);

          if (local) {
            add_render_callback(() => {
              if (!li_transition) li_transition = create_bidirectional_transition(li, fly, {
                y: -50,
                duration: 250
              }, true);
              li_transition.run(1);
            });
          }

          current = true;
        },
        o: function outro(local) {
          transition_out(comentario.$$.fragment, local);

          if (local) {
            if (!li_transition) li_transition = create_bidirectional_transition(li, fly, {
              y: -50,
              duration: 250
            }, false);
            li_transition.run(0);
          }

          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(li);
          destroy_component(comentario);
          if (detaching && li_transition) li_transition.end();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_each_block$a.name,
        type: "each",
        source: "(282:12) {#each comentarios.slice(0, limite) as comentario (comentario.id)}",
        ctx
      });
      return block;
    } // (305:12) {#if mostrarFormularioFlotante && !$globalStore.esCelular && scrollY > 300}


    function create_if_block_1$c(ctx) {
      let div1;
      let formulario;
      let t;
      let div0;
      let span;
      let div1_transition;
      let current;
      let mounted;
      let dispose;
      formulario = new Formulario({
        props: {
          hilo:
          /*hilo*/
          ctx[1]
        },
        $$inline: true
      });
      formulario.$on("comentarioCreado",
      /*cargarNuevosComentarios*/
      ctx[20]);
      const block = {
        c: function create() {
          div1 = element("div");
          create_component(formulario.$$.fragment);
          t = space();
          div0 = element("div");
          span = element("span");
          attr_dev(span, "class", "fe fe-x");
          add_location(span, file$l, 317, 24, 12317);
          attr_dev(div0, "class", "cerrar-comentario-flotante cpt svelte-qfw9k3");
          add_location(div0, file$l, 313, 20, 12122);
          attr_dev(div1, "class", "formulario-flotante svelte-qfw9k3");
          add_location(div1, file$l, 305, 16, 11798);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div1, anchor);
          mount_component(formulario, div1, null);
          append_dev(div1, t);
          append_dev(div1, div0);
          append_dev(div0, span);
          current = true;

          if (!mounted) {
            dispose = listen_dev(div0, "click",
            /*click_handler_4*/
            ctx[36], false, false, false);
            mounted = true;
          }
        },
        p: function update(ctx, dirty) {
          const formulario_changes = {};
          if (dirty[0] &
          /*hilo*/
          2) formulario_changes.hilo =
          /*hilo*/
          ctx[1];
          formulario.$set(formulario_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(formulario.$$.fragment, local);

          if (local) {
            add_render_callback(() => {
              if (!div1_transition) div1_transition = create_bidirectional_transition(div1, fly, {
                x: -50,
                duration: 100
              }, true);
              div1_transition.run(1);
            });
          }

          current = true;
        },
        o: function outro(local) {
          transition_out(formulario.$$.fragment, local);

          if (local) {
            if (!div1_transition) div1_transition = create_bidirectional_transition(div1, fly, {
              x: -50,
              duration: 100
            }, false);
            div1_transition.run(0);
          }

          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div1);
          destroy_component(formulario);
          if (detaching && div1_transition) div1_transition.end();
          mounted = false;
          dispose();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_1$c.name,
        type: "if",
        source: "(305:12) {#if mostrarFormularioFlotante && !$globalStore.esCelular && scrollY > 300}",
        ctx
      });
      return block;
    } // (323:8) {#if infLoadActivo}


    function create_if_block$i(ctx) {
      let infiniteloading;
      let current;
      infiniteloading = new InfiniteLoading({
        props: {
          distance: "600",
          $$slots: {
            default: [create_default_slot_1$b],
            spinner: [create_spinner_slot],
            noResults: [create_noResults_slot],
            noMore: [create_noMore_slot]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      infiniteloading.$on("infinite",
      /*cargarViejos*/
      ctx[25]);
      const block = {
        c: function create() {
          create_component(infiniteloading.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(infiniteloading, target, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          const infiniteloading_changes = {};

          if (dirty[1] &
          /*$$scope*/
          262144) {
            infiniteloading_changes.$$scope = {
              dirty,
              ctx
            };
          }

          infiniteloading.$set(infiniteloading_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(infiniteloading.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(infiniteloading.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(infiniteloading, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block$i.name,
        type: "if",
        source: "(323:8) {#if infLoadActivo}",
        ctx
      });
      return block;
    } // (325:16) <div style="text-align:center" slot="noMore" />


    function create_noMore_slot(ctx) {
      let div;
      const block = {
        c: function create() {
          div = element("div");
          set_style(div, "text-align", "center");
          attr_dev(div, "slot", "noMore");
          add_location(div, file$l, 324, 16, 12548);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_noMore_slot.name,
        type: "slot",
        source: "(325:16) <div style=\\\"text-align:center\\\" slot=\\\"noMore\\\" />",
        ctx
      });
      return block;
    } // (326:16) <div style="text-align:center" slot="noResults" />


    function create_noResults_slot(ctx) {
      let div;
      const block = {
        c: function create() {
          div = element("div");
          set_style(div, "text-align", "center");
          attr_dev(div, "slot", "noResults");
          add_location(div, file$l, 325, 16, 12613);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_noResults_slot.name,
        type: "slot",
        source: "(326:16) <div style=\\\"text-align:center\\\" slot=\\\"noResults\\\" />",
        ctx
      });
      return block;
    } // (327:16) <div slot="spinner">


    function create_spinner_slot(ctx) {
      let div;
      let spinner;
      let current;
      spinner = new Spinner({
        props: {
          cargando: "true"
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          div = element("div");
          create_component(spinner.$$.fragment);
          attr_dev(div, "slot", "spinner");
          add_location(div, file$l, 326, 16, 12681);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          mount_component(spinner, div, null);
          current = true;
        },
        p: noop,
        i: function intro(local) {
          if (current) return;
          transition_in(spinner.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(spinner.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
          destroy_component(spinner);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_spinner_slot.name,
        type: "slot",
        source: "(327:16) <div slot=\\\"spinner\\\">",
        ctx
      });
      return block;
    } // (324:12) <InfiniteLoading on:infinite={cargarViejos} distance="600">


    function create_default_slot_1$b(ctx) {
      let t0;
      let t1;
      const block = {
        c: function create() {
          t0 = space();
          t1 = space();
        },
        m: function mount(target, anchor) {
          insert_dev(target, t0, anchor);
          insert_dev(target, t1, anchor);
        },
        p: noop,
        i: noop,
        o: noop,
        d: function destroy(detaching) {
          if (detaching) detach_dev(t0);
          if (detaching) detach_dev(t1);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_1$b.name,
        type: "slot",
        source: "(324:12) <InfiniteLoading on:infinite={cargarViejos} distance=\\\"600\\\">",
        ctx
      });
      return block;
    } // (280:4) <Spinner cargando={!cargarComentarios}>


    function create_default_slot$c(ctx) {
      let div0;
      let each_blocks = [];
      let each_1_lookup = new Map();
      let t0;
      let t1;
      let t2;
      let div1;
      let current;
      let each_value =
      /*comentarios*/
      ctx[0].slice(0,
      /*limite*/
      ctx[4]);
      validate_each_argument(each_value);

      const get_key = ctx =>
      /*comentario*/
      ctx[46].id;

      validate_each_keys(ctx, each_value, get_each_context$a, get_key);

      for (let i = 0; i < each_value.length; i += 1) {
        let child_ctx = get_each_context$a(ctx, each_value, i);
        let key = get_key(child_ctx);
        each_1_lookup.set(key, each_blocks[i] = create_each_block$a(key, child_ctx));
      }

      let if_block0 =
      /*mostrarFormularioFlotante*/
      ctx[11] && !
      /*$globalStore*/
      ctx[14].esCelular &&
      /*scrollY*/
      ctx[12] > 300 && create_if_block_1$c(ctx);
      let if_block1 =
      /*infLoadActivo*/
      ctx[5] && create_if_block$i(ctx);
      const block = {
        c: function create() {
          div0 = element("div");

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].c();
          }

          t0 = space();
          if (if_block0) if_block0.c();
          t1 = space();
          if (if_block1) if_block1.c();
          t2 = space();
          div1 = element("div");
          attr_dev(div0, "class", "lista-comentarios");
          add_location(div0, file$l, 280, 8, 10516);
          attr_dev(div1, "class", "espacio-vacio svelte-qfw9k3");
          add_location(div1, file$l, 331, 8, 12831);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div0, anchor);

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].m(div0, null);
          }

          append_dev(div0, t0);
          if (if_block0) if_block0.m(div0, null);
          insert_dev(target, t1, anchor);
          if (if_block1) if_block1.m(target, anchor);
          insert_dev(target, t2, anchor);
          insert_dev(target, div1, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          if (dirty[0] &
          /*hilo, modoTelefono, comentarios, limite, diccionarioComentarios, resaltarComentariosDeUsuario, tagCliqueado, idUnicoClickeado, irAComentario, historialRespuestas, diccionarioRespuestas*/
          31589075) {
            const each_value =
            /*comentarios*/
            ctx[0].slice(0,
            /*limite*/
            ctx[4]);
            validate_each_argument(each_value);
            group_outros();
            validate_each_keys(ctx, each_value, get_each_context$a, get_key);
            each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, div0, outro_and_destroy_block, create_each_block$a, t0, get_each_context$a);
            check_outros();
          }

          if (
          /*mostrarFormularioFlotante*/
          ctx[11] && !
          /*$globalStore*/
          ctx[14].esCelular &&
          /*scrollY*/
          ctx[12] > 300) {
            if (if_block0) {
              if_block0.p(ctx, dirty);

              if (dirty[0] &
              /*mostrarFormularioFlotante, $globalStore, scrollY*/
              22528) {
                transition_in(if_block0, 1);
              }
            } else {
              if_block0 = create_if_block_1$c(ctx);
              if_block0.c();
              transition_in(if_block0, 1);
              if_block0.m(div0, null);
            }
          } else if (if_block0) {
            group_outros();
            transition_out(if_block0, 1, 1, () => {
              if_block0 = null;
            });
            check_outros();
          }

          if (
          /*infLoadActivo*/
          ctx[5]) {
            if (if_block1) {
              if_block1.p(ctx, dirty);

              if (dirty[0] &
              /*infLoadActivo*/
              32) {
                transition_in(if_block1, 1);
              }
            } else {
              if_block1 = create_if_block$i(ctx);
              if_block1.c();
              transition_in(if_block1, 1);
              if_block1.m(t2.parentNode, t2);
            }
          } else if (if_block1) {
            group_outros();
            transition_out(if_block1, 1, 1, () => {
              if_block1 = null;
            });
            check_outros();
          }
        },
        i: function intro(local) {
          if (current) return;

          for (let i = 0; i < each_value.length; i += 1) {
            transition_in(each_blocks[i]);
          }

          transition_in(if_block0);
          transition_in(if_block1);
          current = true;
        },
        o: function outro(local) {
          for (let i = 0; i < each_blocks.length; i += 1) {
            transition_out(each_blocks[i]);
          }

          transition_out(if_block0);
          transition_out(if_block1);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div0);

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].d();
          }

          if (if_block0) if_block0.d();
          if (detaching) detach_dev(t1);
          if (if_block1) if_block1.d(detaching);
          if (detaching) detach_dev(t2);
          if (detaching) detach_dev(div1);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot$c.name,
        type: "slot",
        source: "(280:4) <Spinner cargando={!cargarComentarios}>",
        ctx
      });
      return block;
    }

    function create_fragment$l(ctx) {
      let scrolling = false;

      let clear_scrolling = () => {
        scrolling = false;
      };

      let scrolling_timeout;
      let carpetamedia;
      let updating_visible;
      let t0;
      let div2;
      let pilarespuestas;
      let t1;
      let t2;
      let spamlist;
      let t3;
      let div1;
      let h3;
      let t4;
      let t5_value =
      /*comentarios*/
      ctx[0].length + "";
      let t5;
      let t6;
      let t7;
      let t8;
      let div0;
      let button0;
      let t9;
      let t10;
      let button1;
      let t11;
      let t12;
      let spinner;
      let current;
      let mounted;
      let dispose;
      add_render_callback(
      /*onwindowscroll*/
      ctx[26]);

      function carpetamedia_visible_binding(value) {
        /*carpetamedia_visible_binding*/
        ctx[27].call(null, value);
      }

      let carpetamedia_props = {
        comentarios:
        /*comentarios*/
        ctx[0]
      };

      if (
      /*carpetaMedia*/
      ctx[8] !== void 0) {
        carpetamedia_props.visible =
        /*carpetaMedia*/
        ctx[8];
      }

      carpetamedia = new CarpetaMedia({
        props: carpetamedia_props,
        $$inline: true
      });
      binding_callbacks.push(() => bind(carpetamedia, "visible", carpetamedia_visible_binding));
      carpetamedia.$on("irAComentario",
      /*irAComentario*/
      ctx[23]);
      pilarespuestas = new PilaRespuestas({
        props: {
          diccionarioComentarios:
          /*diccionarioComentarios*/
          ctx[7],
          diccionarioRespuestas:
          /*diccionarioRespuestas*/
          ctx[6],
          historial:
          /*historialRespuestas*/
          ctx[9]
        },
        $$inline: true
      });
      let if_block0 = (!
      /*$configStore*/
      ctx[16].general.modoMessi ||
      /*$globalStore*/
      ctx[14].usuario.esMod) && create_if_block_5$2(ctx);
      spamlist = new SpamList({
        props: {
          spams:
          /*spams*/
          ctx[2]
        },
        $$inline: true
      });
      let if_block1 =
      /*nuevosComentarios*/
      ctx[3].length != 0 && create_if_block_4$3(ctx);
      button0 = new ye({
        props: {
          title: "Comentarios en vivo (se cargan automaticamente)",
          dense: true,
          icon: true,
          $$slots: {
            default: [create_default_slot_5$6]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      button0.$on("click",
      /*click_handler*/
      ctx[28]);
      let if_block2 =
      /*comentarios*/
      ctx[0].length >
      /*limite*/
      ctx[4] && create_if_block_3$7(ctx);
      button1 = new ye({
        props: {
          dense: true,
          icon: true,
          $$slots: {
            default: [create_default_slot_3$a]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      button1.$on("click",
      /*click_handler_2*/
      ctx[30]);
      let if_block3 =
      /*comentarios*/
      ctx[0].length > 0 && create_if_block_2$b(ctx);
      spinner = new Spinner({
        props: {
          cargando: !
          /*cargarComentarios*/
          ctx[10],
          $$slots: {
            default: [create_default_slot$c]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          create_component(carpetamedia.$$.fragment);
          t0 = space();
          div2 = element("div");
          create_component(pilarespuestas.$$.fragment);
          t1 = space();
          if (if_block0) if_block0.c();
          t2 = space();
          create_component(spamlist.$$.fragment);
          t3 = space();
          div1 = element("div");
          h3 = element("h3");
          t4 = text("Comentarios (");
          t5 = text(t5_value);
          t6 = text(")");
          t7 = space();
          if (if_block1) if_block1.c();
          t8 = space();
          div0 = element("div");
          create_component(button0.$$.fragment);
          t9 = space();
          if (if_block2) if_block2.c();
          t10 = space();
          create_component(button1.$$.fragment);
          t11 = space();
          if (if_block3) if_block3.c();
          t12 = space();
          create_component(spinner.$$.fragment);
          add_location(h3, file$l, 210, 8, 7680);
          attr_dev(div0, "class", "acciones-comentario");
          add_location(div0, file$l, 221, 8, 8086);
          attr_dev(div1, "class", "contador-comentarios panel");
          add_location(div1, file$l, 209, 4, 7630);
          attr_dev(div2, "class", "comentarios");
          add_location(div2, file$l, 197, 0, 7271);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          mount_component(carpetamedia, target, anchor);
          insert_dev(target, t0, anchor);
          insert_dev(target, div2, anchor);
          mount_component(pilarespuestas, div2, null);
          append_dev(div2, t1);
          if (if_block0) if_block0.m(div2, null);
          append_dev(div2, t2);
          mount_component(spamlist, div2, null);
          append_dev(div2, t3);
          append_dev(div2, div1);
          append_dev(div1, h3);
          append_dev(h3, t4);
          append_dev(h3, t5);
          append_dev(h3, t6);
          append_dev(div1, t7);
          if (if_block1) if_block1.m(div1, null);
          append_dev(div1, t8);
          append_dev(div1, div0);
          mount_component(button0, div0, null);
          append_dev(div0, t9);
          if (if_block2) if_block2.m(div0, null);
          append_dev(div0, t10);
          mount_component(button1, div0, null);
          append_dev(div0, t11);
          if (if_block3) if_block3.m(div0, null);
          append_dev(div2, t12);
          mount_component(spinner, div2, null);
          current = true;

          if (!mounted) {
            dispose = listen_dev(window_1, "scroll", () => {
              scrolling = true;
              clearTimeout(scrolling_timeout);
              scrolling_timeout = setTimeout_1(clear_scrolling, 100);
              /*onwindowscroll*/

              ctx[26]();
            });
            mounted = true;
          }
        },
        p: function update(ctx, dirty) {
          if (dirty[0] &
          /*scrollY*/
          4096 && !scrolling) {
            scrolling = true;
            clearTimeout(scrolling_timeout);
            scrollTo(window_1.pageXOffset,
            /*scrollY*/
            ctx[12]);
            scrolling_timeout = setTimeout_1(clear_scrolling, 100);
          }

          const carpetamedia_changes = {};
          if (dirty[0] &
          /*comentarios*/
          1) carpetamedia_changes.comentarios =
          /*comentarios*/
          ctx[0];

          if (!updating_visible && dirty[0] &
          /*carpetaMedia*/
          256) {
            updating_visible = true;
            carpetamedia_changes.visible =
            /*carpetaMedia*/
            ctx[8];
            add_flush_callback(() => updating_visible = false);
          }

          carpetamedia.$set(carpetamedia_changes);
          const pilarespuestas_changes = {};
          if (dirty[0] &
          /*diccionarioComentarios*/
          128) pilarespuestas_changes.diccionarioComentarios =
          /*diccionarioComentarios*/
          ctx[7];
          if (dirty[0] &
          /*diccionarioRespuestas*/
          64) pilarespuestas_changes.diccionarioRespuestas =
          /*diccionarioRespuestas*/
          ctx[6];
          if (dirty[0] &
          /*historialRespuestas*/
          512) pilarespuestas_changes.historial =
          /*historialRespuestas*/
          ctx[9];
          pilarespuestas.$set(pilarespuestas_changes);

          if (!
          /*$configStore*/
          ctx[16].general.modoMessi ||
          /*$globalStore*/
          ctx[14].usuario.esMod) {
            if (if_block0) {
              if_block0.p(ctx, dirty);

              if (dirty[0] &
              /*$configStore, $globalStore*/
              81920) {
                transition_in(if_block0, 1);
              }
            } else {
              if_block0 = create_if_block_5$2(ctx);
              if_block0.c();
              transition_in(if_block0, 1);
              if_block0.m(div2, t2);
            }
          } else if (if_block0) {
            group_outros();
            transition_out(if_block0, 1, 1, () => {
              if_block0 = null;
            });
            check_outros();
          }

          const spamlist_changes = {};
          if (dirty[0] &
          /*spams*/
          4) spamlist_changes.spams =
          /*spams*/
          ctx[2];
          spamlist.$set(spamlist_changes);
          if ((!current || dirty[0] &
          /*comentarios*/
          1) && t5_value !== (t5_value =
          /*comentarios*/
          ctx[0].length + "")) set_data_dev(t5, t5_value);

          if (
          /*nuevosComentarios*/
          ctx[3].length != 0) {
            if (if_block1) {
              if_block1.p(ctx, dirty);
            } else {
              if_block1 = create_if_block_4$3(ctx);
              if_block1.c();
              if_block1.m(div1, t8);
            }
          } else if (if_block1) {
            if_block1.d(1);
            if_block1 = null;
          }

          const button0_changes = {};

          if (dirty[0] &
          /*$comentariosStore*/
          32768 | dirty[1] &
          /*$$scope*/
          262144) {
            button0_changes.$$scope = {
              dirty,
              ctx
            };
          }

          button0.$set(button0_changes);

          if (
          /*comentarios*/
          ctx[0].length >
          /*limite*/
          ctx[4]) {
            if (if_block2) {
              if_block2.p(ctx, dirty);

              if (dirty[0] &
              /*comentarios, limite*/
              17) {
                transition_in(if_block2, 1);
              }
            } else {
              if_block2 = create_if_block_3$7(ctx);
              if_block2.c();
              transition_in(if_block2, 1);
              if_block2.m(div0, t10);
            }
          } else if (if_block2) {
            group_outros();
            transition_out(if_block2, 1, 1, () => {
              if_block2 = null;
            });
            check_outros();
          }

          const button1_changes = {};

          if (dirty[1] &
          /*$$scope*/
          262144) {
            button1_changes.$$scope = {
              dirty,
              ctx
            };
          }

          button1.$set(button1_changes);

          if (
          /*comentarios*/
          ctx[0].length > 0) {
            if (if_block3) {
              if_block3.p(ctx, dirty);

              if (dirty[0] &
              /*comentarios*/
              1) {
                transition_in(if_block3, 1);
              }
            } else {
              if_block3 = create_if_block_2$b(ctx);
              if_block3.c();
              transition_in(if_block3, 1);
              if_block3.m(div0, null);
            }
          } else if (if_block3) {
            group_outros();
            transition_out(if_block3, 1, 1, () => {
              if_block3 = null;
            });
            check_outros();
          }

          const spinner_changes = {};
          if (dirty[0] &
          /*cargarComentarios*/
          1024) spinner_changes.cargando = !
          /*cargarComentarios*/
          ctx[10];

          if (dirty[0] &
          /*infLoadActivo, mostrarFormularioFlotante, hilo, $globalStore, scrollY, comentarios, limite, diccionarioComentarios, historialRespuestas, diccionarioRespuestas*/
          23283 | dirty[1] &
          /*$$scope*/
          262144) {
            spinner_changes.$$scope = {
              dirty,
              ctx
            };
          }

          spinner.$set(spinner_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(carpetamedia.$$.fragment, local);
          transition_in(pilarespuestas.$$.fragment, local);
          transition_in(if_block0);
          transition_in(spamlist.$$.fragment, local);
          transition_in(button0.$$.fragment, local);
          transition_in(if_block2);
          transition_in(button1.$$.fragment, local);
          transition_in(if_block3);
          transition_in(spinner.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(carpetamedia.$$.fragment, local);
          transition_out(pilarespuestas.$$.fragment, local);
          transition_out(if_block0);
          transition_out(spamlist.$$.fragment, local);
          transition_out(button0.$$.fragment, local);
          transition_out(if_block2);
          transition_out(button1.$$.fragment, local);
          transition_out(if_block3);
          transition_out(spinner.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(carpetamedia, detaching);
          if (detaching) detach_dev(t0);
          if (detaching) detach_dev(div2);
          destroy_component(pilarespuestas);
          if (if_block0) if_block0.d();
          destroy_component(spamlist);
          if (if_block1) if_block1.d();
          destroy_component(button0);
          if (if_block2) if_block2.d();
          destroy_component(button1);
          if (if_block3) if_block3.d();
          destroy_component(spinner);
          mounted = false;
          dispose();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$l.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }

    function instance$l($$self, $$props, $$invalidate) {
      let $globalStore;
      let $comentariosStore;
      let $selectorStore;
      let $ajustesConfigStore;
      let $comentarioStore;
      let $configStore;
      validate_store(globalStore, "globalStore");
      component_subscribe($$self, globalStore, $$value => $$invalidate(14, $globalStore = $$value));
      validate_store(selectorStore, "selectorStore");
      component_subscribe($$self, selectorStore, $$value => $$invalidate(39, $selectorStore = $$value));
      validate_store(ajustesConfigStore, "ajustesConfigStore");
      component_subscribe($$self, ajustesConfigStore, $$value => $$invalidate(40, $ajustesConfigStore = $$value));
      validate_store(comentarioStore, "comentarioStore");
      component_subscribe($$self, comentarioStore, $$value => $$invalidate(41, $comentarioStore = $$value));
      validate_store(configStore, "configStore");
      component_subscribe($$self, configStore, $$value => $$invalidate(16, $configStore = $$value));
      let {
        $$slots: slots = {},
        $$scope
      } = $$props;
      validate_slots("Comentarios", slots, []);
      let {
        hilo
      } = $$props;
      let {
        comentarios
      } = $$props;
      let {
        spams
      } = $$props;
      let modoTelefono = $globalStore.esCelular;
      let nuevosComentarios = [];
      let comentariosStore = localStore("Comentarios", {
        modoVivo: false
      });
      validate_store(comentariosStore, "comentariosStore");
      component_subscribe($$self, comentariosStore, value => $$invalidate(15, $comentariosStore = value));
      let bloque = 100;
      let limite = bloque;
      let infLoadActivo = true;

      function cargarNuevosComentarios() {
        $$invalidate(0, comentarios = [...nuevosComentarios, ...comentarios]);
        $$invalidate(3, nuevosComentarios = []);
        comentarios.forEach(agregarComentarioADiccionario);
        comentarios.forEach(cargarRespuestas); // Añadir el restag a los comentarios tageados por este comentario

        $$invalidate(0, comentarios);
        $$invalidate(5, infLoadActivo = comentarios.length >= limite);
      }

      let diccionarioRespuestas = {};
      let diccionarioComentarios = {};

      function agregarComentarioADiccionario(comentario) {
        $$invalidate(7, diccionarioComentarios[comentario.id] = comentario, diccionarioComentarios);
        let tags = comentario.contenido.match(/#([A-Z0-9]{8})/g);
        if (!tags) return;
        let id = comentario.id;

        for (const tag of tags) {
          let otraId = tag.slice(1, 9);
          if (!diccionarioRespuestas[otraId]) $$invalidate(6, diccionarioRespuestas[otraId] = [], diccionarioRespuestas);
          diccionarioRespuestas[otraId].push(id);
          $$invalidate(6, diccionarioRespuestas);
        }

        $$invalidate(6, diccionarioRespuestas);
      }

      function cargarRespuestas(comentario) {
        if (diccionarioRespuestas[comentario.id]) comentario.respuestas = [...diccionarioRespuestas[comentario.id]];else comentario.respuestas = [];
        comentario.respuestas = Array.from(new Set(comentario.respuestas));
      }

      comentarios.forEach(agregarComentarioADiccionario);
      comentarios.forEach(cargarRespuestas);

      function onComentarioCreado(comentario) {
        $$invalidate(3, nuevosComentarios = [comentario, ...nuevosComentarios]);
        comentario.respuestas = [];
        if ($comentariosStore.modoVivo) cargarNuevosComentarios();
      }

      Signal.coneccion.on("NuevoComentario", onComentarioCreado);
      Signal.subscribirseAHilo(hilo.id);
      Signal.coneccion.on("ComentariosEliminados", ids => {
        if (!$globalStore.usuario.esMod) {
          $$invalidate(0, comentarios = comentarios.filter(c => !ids.includes(c.id)));
          $$invalidate(3, nuevosComentarios = nuevosComentarios.filter(c => !ids.includes(c.id)));
        } else {
          if (ids.length == 0) return;
          $$invalidate(0, comentarios = comentarios.map(c => {
            if (ids.includes(c.id)) c.estado = ComentarioEstado.eliminado;
            return c;
          }));
          $$invalidate(3, nuevosComentarios = nuevosComentarios.map(c => {
            if (ids.includes(c.id)) c.estado = ComentarioEstado.eliminado;
            return c;
          }));
        }
      });
      let resaltando = false;

      function resaltarComentariosDeUsuario(usuarioId) {
        if (!$globalStore.usuario.esMod) return;

        if (resaltando) {
          // comentarios.forEach(c => c.resaltado = false)
          // comentarios = comentarios
          resaltando = false;
          set_store_value(selectorStore, $selectorStore.seleccionados = new Set(), $selectorStore);
          return;
        }

        comentarios.forEach(c => {
          if (c.usuarioId == usuarioId) {
            resaltando = true;
            $selectorStore.seleccionados.add(c.id);
            selectorStore.set($selectorStore);
          }
        }); // c.resaltado = usuarioId == c.usuarioId

        $$invalidate(0, comentarios);
      }

      function tagCliqueado(e) {
        if (!diccionarioComentarios[e.detail]) return;

        if (modoTelefono && !$ajustesConfigStore.tagClasico) {
          e.preventDefault();
          $$invalidate(9, historialRespuestas = [[diccionarioComentarios[e.detail]]]);
        }

        comentarios.forEach(c => c.resaltado = false);
        $$invalidate(0, comentarios);
        $$invalidate(7, diccionarioComentarios[e.detail].resaltado = true, diccionarioComentarios);
      }

      let comentarioUrl = window.location.hash.replace("#", "");

      async function irAComentario(comentarioId) {
        if (typeof comentarioId != "string") comentarioId = comentarioId.detail;
        if (!diccionarioComentarios[comentarioId]) return;
        let pos = comentarios.findIndex(c => c.id == comentarioId);
        if (pos - limite > 0) $$invalidate(4, limite = Math.ceil(pos / bloque) * bloque);
        await tick();
        $$invalidate(7, diccionarioComentarios[comentarioId].resaltado = true, diccionarioComentarios);
        let comentarioDOM = document.getElementById(comentarioId);
        if (comentarioDOM) comentarioDOM.scrollIntoView({
          block: "center"
        });
      }

      onMount(() => irAComentario(comentarioUrl));
      irAComentario(comentarioUrl);
      let resaltadoIdUnico = false;

      function idUnicoClickeado(e) {
        comentarios.forEach(c => {
          if (!resaltadoIdUnico) {
            c.resaltado = c.idUnico == e.detail;
          } else {
            c.resaltado = false;
          }
        });
        $$invalidate(0, comentarios);
        resaltadoIdUnico = !resaltadoIdUnico;
      }

      let carpetaMedia = false;
      let historialRespuestas = [];
      let cargarComentarios = false;
      onMount(async () => {
        setTimeout(async () => {
          $$invalidate(10, cargarComentarios = true);
          await tick();
          irAComentario(comentarioUrl);
        }, 120);
      });
      let mostrarFormularioFlotante = false;
      let scrollY = 0;
      let spinnerAcciones = false;

      function cargarViejos({
        detail: {
          loaded,
          complete
        }
      }) {
        if (limite > comentarios.length) {
          complete();
        } else {
          setTimeout(() => {
            $$invalidate(4, limite = limite + bloque);
            loaded();
          }, 60);
        }
      }

      const writable_props = ["hilo", "comentarios", "spams"];
      Object.keys($$props).forEach(key => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Comentarios> was created with unknown prop '${key}'`);
      });

      function onwindowscroll() {
        $$invalidate(12, scrollY = window_1.pageYOffset);
      }

      function carpetamedia_visible_binding(value) {
        carpetaMedia = value;
        $$invalidate(8, carpetaMedia);
      }

      const click_handler = () => set_store_value(comentariosStore, $comentariosStore.modoVivo = !$comentariosStore.modoVivo, $comentariosStore);

      const click_handler_1 = () => {
        $$invalidate(13, spinnerAcciones = true);
        setTimeout(() => {
          $$invalidate(4, limite = bloque);
          $$invalidate(5, infLoadActivo = false);
          tick().then(() => {
            $$invalidate(5, infLoadActivo = comentarios.length >= limite);
            $$invalidate(13, spinnerAcciones = false);
          });
        }, 60);
      };

      const click_handler_2 = () => $$invalidate(8, carpetaMedia = !carpetaMedia);

      const click_handler_3 = () => {
        $$invalidate(13, spinnerAcciones = true);
        setTimeout(() => {
          irAComentario(comentarios[comentarios.length - 1].id).then(() => {
            $$invalidate(13, spinnerAcciones = false);
          });
        }, 60);
      };

      function comentario_comentario_binding(value, comentario, each_value, comentario_index) {
        each_value[comentario_index] = value;
        $$invalidate(0, comentarios);
      }

      function comentario_comentariosDic_binding(value) {
        diccionarioComentarios = value;
        $$invalidate(7, diccionarioComentarios);
      }

      const colorClick_handler = e => resaltarComentariosDeUsuario(e.detail.usuarioId || "");

      const motrarRespuestas_handler = e => $$invalidate(9, historialRespuestas = [diccionarioRespuestas[e.detail].map(c => diccionarioComentarios[c])]);

      const click_handler_4 = () => $$invalidate(11, mostrarFormularioFlotante = false);

      $$self.$$set = $$props => {
        if ("hilo" in $$props) $$invalidate(1, hilo = $$props.hilo);
        if ("comentarios" in $$props) $$invalidate(0, comentarios = $$props.comentarios);
        if ("spams" in $$props) $$invalidate(2, spams = $$props.spams);
      };

      $$self.$capture_state = () => ({
        fly,
        Button: ye,
        Comentario,
        Formulario,
        globalStore,
        DialogoReporte,
        Signal,
        CarpetaMedia,
        onMount,
        tick,
        PilaRespuestas,
        config,
        configStore,
        ajustesConfigStore,
        Spinner,
        localStore,
        comentarioStore,
        SpamList,
        selectorStore,
        ComentarioEstado,
        InfiniteLoading,
        Ajustes,
        hilo,
        comentarios,
        spams,
        modoTelefono,
        nuevosComentarios,
        comentariosStore,
        bloque,
        limite,
        infLoadActivo,
        cargarNuevosComentarios,
        diccionarioRespuestas,
        diccionarioComentarios,
        agregarComentarioADiccionario,
        cargarRespuestas,
        onComentarioCreado,
        resaltando,
        resaltarComentariosDeUsuario,
        tagCliqueado,
        comentarioUrl,
        irAComentario,
        resaltadoIdUnico,
        idUnicoClickeado,
        carpetaMedia,
        historialRespuestas,
        cargarComentarios,
        mostrarFormularioFlotante,
        scrollY,
        spinnerAcciones,
        cargarViejos,
        $globalStore,
        $comentariosStore,
        $selectorStore,
        $ajustesConfigStore,
        $comentarioStore,
        $configStore
      });

      $$self.$inject_state = $$props => {
        if ("hilo" in $$props) $$invalidate(1, hilo = $$props.hilo);
        if ("comentarios" in $$props) $$invalidate(0, comentarios = $$props.comentarios);
        if ("spams" in $$props) $$invalidate(2, spams = $$props.spams);
        if ("modoTelefono" in $$props) $$invalidate(17, modoTelefono = $$props.modoTelefono);
        if ("nuevosComentarios" in $$props) $$invalidate(3, nuevosComentarios = $$props.nuevosComentarios);
        if ("comentariosStore" in $$props) $$invalidate(18, comentariosStore = $$props.comentariosStore);
        if ("bloque" in $$props) $$invalidate(19, bloque = $$props.bloque);
        if ("limite" in $$props) $$invalidate(4, limite = $$props.limite);
        if ("infLoadActivo" in $$props) $$invalidate(5, infLoadActivo = $$props.infLoadActivo);
        if ("diccionarioRespuestas" in $$props) $$invalidate(6, diccionarioRespuestas = $$props.diccionarioRespuestas);
        if ("diccionarioComentarios" in $$props) $$invalidate(7, diccionarioComentarios = $$props.diccionarioComentarios);
        if ("resaltando" in $$props) resaltando = $$props.resaltando;
        if ("comentarioUrl" in $$props) comentarioUrl = $$props.comentarioUrl;
        if ("resaltadoIdUnico" in $$props) resaltadoIdUnico = $$props.resaltadoIdUnico;
        if ("carpetaMedia" in $$props) $$invalidate(8, carpetaMedia = $$props.carpetaMedia);
        if ("historialRespuestas" in $$props) $$invalidate(9, historialRespuestas = $$props.historialRespuestas);
        if ("cargarComentarios" in $$props) $$invalidate(10, cargarComentarios = $$props.cargarComentarios);
        if ("mostrarFormularioFlotante" in $$props) $$invalidate(11, mostrarFormularioFlotante = $$props.mostrarFormularioFlotante);
        if ("scrollY" in $$props) $$invalidate(12, scrollY = $$props.scrollY);
        if ("spinnerAcciones" in $$props) $$invalidate(13, spinnerAcciones = $$props.spinnerAcciones);
      };

      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }

      $$self.$$.update = () => {
        if ($$self.$$.dirty[1] &
        /*$comentarioStore*/
        1024) {
           $$invalidate(11, mostrarFormularioFlotante = $comentarioStore && comentarioStore.length != 0);
        }
      };

      return [comentarios, hilo, spams, nuevosComentarios, limite, infLoadActivo, diccionarioRespuestas, diccionarioComentarios, carpetaMedia, historialRespuestas, cargarComentarios, mostrarFormularioFlotante, scrollY, spinnerAcciones, $globalStore, $comentariosStore, $configStore, modoTelefono, comentariosStore, bloque, cargarNuevosComentarios, resaltarComentariosDeUsuario, tagCliqueado, irAComentario, idUnicoClickeado, cargarViejos, onwindowscroll, carpetamedia_visible_binding, click_handler, click_handler_1, click_handler_2, click_handler_3, comentario_comentario_binding, comentario_comentariosDic_binding, colorClick_handler, motrarRespuestas_handler, click_handler_4];
    }

    class Comentarios extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$l, create_fragment$l, safe_not_equal, {
          hilo: 1,
          comentarios: 0,
          spams: 2
        }, [-1, -1]);
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "Comentarios",
          options,
          id: create_fragment$l.name
        });
        const {
          ctx
        } = this.$$;
        const props = options.props || {};

        if (
        /*hilo*/
        ctx[1] === undefined && !("hilo" in props)) {
          console.warn("<Comentarios> was created without expected prop 'hilo'");
        }

        if (
        /*comentarios*/
        ctx[0] === undefined && !("comentarios" in props)) {
          console.warn("<Comentarios> was created without expected prop 'comentarios'");
        }

        if (
        /*spams*/
        ctx[2] === undefined && !("spams" in props)) {
          console.warn("<Comentarios> was created without expected prop 'spams'");
        }
      }

      get hilo() {
        throw new Error("<Comentarios>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set hilo(value) {
        throw new Error("<Comentarios>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get comentarios() {
        throw new Error("<Comentarios>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set comentarios(value) {
        throw new Error("<Comentarios>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get spams() {
        throw new Error("<Comentarios>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set spams(value) {
        throw new Error("<Comentarios>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

    }

    /* src\components\Acciones.svelte generated by Svelte v3.29.0 */
    const file$m = "src\\components\\Acciones.svelte"; // (27:4) <Button bind:active={acciones.seguido} on:click={seguir} color={acciones.seguido?'var(--color5)':'var(--color-texto2)'}  shaped  >

    function create_default_slot_4$8(ctx) {
      let i;
      let t;
      const block = {
        c: function create() {
          i = element("i");
          t = text("Seg");
          attr_dev(i, "class", "fe fe-eye");
          add_location(i, file$m, 26, 134, 936);
        },
        m: function mount(target, anchor) {
          insert_dev(target, i, anchor);
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(i);
          if (detaching) detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_4$8.name,
        type: "slot",
        source: "(27:4) <Button bind:active={acciones.seguido} on:click={seguir} color={acciones.seguido?'var(--color5)':'var(--color-texto2)'}  shaped  >",
        ctx
      });
      return block;
    } // (28:4) <Button bind:active={acciones.favorito} on:click={favoritear} color={acciones.favorito?'var(--color5)':'var(--color-texto2)'}  shaped  >


    function create_default_slot_3$b(ctx) {
      let i;
      let t;
      const block = {
        c: function create() {
          i = element("i");
          t = text("Fav");
          attr_dev(i, "class", "fe fe-star");
          add_location(i, file$m, 27, 140, 1114);
        },
        m: function mount(target, anchor) {
          insert_dev(target, i, anchor);
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(i);
          if (detaching) detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_3$b.name,
        type: "slot",
        source: "(28:4) <Button bind:active={acciones.favorito} on:click={favoritear} color={acciones.favorito?'var(--color5)':'var(--color-texto2)'}  shaped  >",
        ctx
      });
      return block;
    } // (29:4) <Button bind:active={acciones.hideado} on:click={ocultar} color={acciones.hideado?'var(--color5)':'var(--color-texto2)'}  shaped  >


    function create_default_slot_2$b(ctx) {
      let i;
      let t;
      const block = {
        c: function create() {
          i = element("i");
          t = text("Hide");
          attr_dev(i, "class", "fe fe-eye-off");
          add_location(i, file$m, 28, 135, 1288);
        },
        m: function mount(target, anchor) {
          insert_dev(target, i, anchor);
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(i);
          if (detaching) detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_2$b.name,
        type: "slot",
        source: "(29:4) <Button bind:active={acciones.hideado} on:click={ocultar} color={acciones.hideado?'var(--color5)':'var(--color-texto2)'}  shaped  >",
        ctx
      });
      return block;
    } // (31:4) <Button  on:click={() => mostrarReporte = true} shaped color="red" >


    function create_default_slot_1$c(ctx) {
      let i;
      let t;
      const block = {
        c: function create() {
          i = element("i");
          t = text("Denunciar");
          attr_dev(i, "class", "fe fe-flag");
          add_location(i, file$m, 30, 72, 1404);
        },
        m: function mount(target, anchor) {
          insert_dev(target, i, anchor);
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(i);
          if (detaching) detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_1$c.name,
        type: "slot",
        source: "(31:4) <Button  on:click={() => mostrarReporte = true} shaped color=\\\"red\\\" >",
        ctx
      });
      return block;
    } // (32:4) <Button  color="var(--color-texto1)"  shaped  disabled >


    function create_default_slot$d(ctx) {
      let i;
      let tiempo;
      let current;
      tiempo = new Tiempo({
        props: {
          date:
          /*hilo*/
          ctx[1].creacion
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          i = element("i");
          create_component(tiempo.$$.fragment);
          attr_dev(i, "class", "fe fe-clock");
          add_location(i, file$m, 31, 60, 1509);
        },
        m: function mount(target, anchor) {
          insert_dev(target, i, anchor);
          mount_component(tiempo, target, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          const tiempo_changes = {};
          if (dirty &
          /*hilo*/
          2) tiempo_changes.date =
          /*hilo*/
          ctx[1].creacion;
          tiempo.$set(tiempo_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(tiempo.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(tiempo.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(i);
          destroy_component(tiempo, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot$d.name,
        type: "slot",
        source: "(32:4) <Button  color=\\\"var(--color-texto1)\\\"  shaped  disabled >",
        ctx
      });
      return block;
    } // (34:4) {#if hilo.rango > CreacionRango.Anon || hilo.nombre}


    function create_if_block$j(ctx) {
      let span;
      let t;
      let if_block0 =
      /*hilo*/
      ctx[1].rango > CreacionRango.Anon && create_if_block_2$c(ctx);
      let if_block1 =
      /*hilo*/
      ctx[1].nombre && create_if_block_1$d(ctx);
      const block = {
        c: function create() {
          span = element("span");
          if (if_block0) if_block0.c();
          t = space();
          if (if_block1) if_block1.c();
          attr_dev(span, "class", "mod svelte-q7w7pq");
          add_location(span, file$m, 34, 8, 1643);
        },
        m: function mount(target, anchor) {
          insert_dev(target, span, anchor);
          if (if_block0) if_block0.m(span, null);
          append_dev(span, t);
          if (if_block1) if_block1.m(span, null);
        },
        p: function update(ctx, dirty) {
          if (
          /*hilo*/
          ctx[1].rango > CreacionRango.Anon) {
            if (if_block0) {
              if_block0.p(ctx, dirty);
            } else {
              if_block0 = create_if_block_2$c(ctx);
              if_block0.c();
              if_block0.m(span, t);
            }
          } else if (if_block0) {
            if_block0.d(1);
            if_block0 = null;
          }

          if (
          /*hilo*/
          ctx[1].nombre) {
            if (if_block1) {
              if_block1.p(ctx, dirty);
            } else {
              if_block1 = create_if_block_1$d(ctx);
              if_block1.c();
              if_block1.m(span, null);
            }
          } else if (if_block1) {
            if_block1.d(1);
            if_block1 = null;
          }
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(span);
          if (if_block0) if_block0.d();
          if (if_block1) if_block1.d();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block$j.name,
        type: "if",
        source: "(34:4) {#if hilo.rango > CreacionRango.Anon || hilo.nombre}",
        ctx
      });
      return block;
    } // (36:12) {#if hilo.rango > CreacionRango.Anon}


    function create_if_block_2$c(ctx) {
      let t_value = CreacionRango.aString(
      /*hilo*/
      ctx[1].rango).toUpperCase() + "";
      let t;
      const block = {
        c: function create() {
          t = text(t_value);
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        p: function update(ctx, dirty) {
          if (dirty &
          /*hilo*/
          2 && t_value !== (t_value = CreacionRango.aString(
          /*hilo*/
          ctx[1].rango).toUpperCase() + "")) set_data_dev(t, t_value);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_2$c.name,
        type: "if",
        source: "(36:12) {#if hilo.rango > CreacionRango.Anon}",
        ctx
      });
      return block;
    } // (40:12) {#if hilo.nombre}


    function create_if_block_1$d(ctx) {
      let t_value =
      /*hilo*/
      ctx[1].nombre + "";
      let t;
      const block = {
        c: function create() {
          t = text(t_value);
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        p: function update(ctx, dirty) {
          if (dirty &
          /*hilo*/
          2 && t_value !== (t_value =
          /*hilo*/
          ctx[1].nombre + "")) set_data_dev(t, t_value);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_1$d.name,
        type: "if",
        source: "(40:12) {#if hilo.nombre}",
        ctx
      });
      return block;
    }

    function create_fragment$m(ctx) {
      let div;
      let button0;
      let updating_active;
      let t0;
      let button1;
      let updating_active_1;
      let t1;
      let button2;
      let updating_active_2;
      let t2;
      let button3;
      let t3;
      let button4;
      let t4;
      let t5;
      let dialogoreporte;
      let updating_visible;
      let current;

      function button0_active_binding(value) {
        /*button0_active_binding*/
        ctx[6].call(null, value);
      }

      let button0_props = {
        color:
        /*acciones*/
        ctx[0].seguido ? "var(--color5)" : "var(--color-texto2)",
        shaped: true,
        $$slots: {
          default: [create_default_slot_4$8]
        },
        $$scope: {
          ctx
        }
      };

      if (
      /*acciones*/
      ctx[0].seguido !== void 0) {
        button0_props.active =
        /*acciones*/
        ctx[0].seguido;
      }

      button0 = new ye({
        props: button0_props,
        $$inline: true
      });
      binding_callbacks.push(() => bind(button0, "active", button0_active_binding));
      button0.$on("click",
      /*seguir*/
      ctx[3]);

      function button1_active_binding(value) {
        /*button1_active_binding*/
        ctx[7].call(null, value);
      }

      let button1_props = {
        color:
        /*acciones*/
        ctx[0].favorito ? "var(--color5)" : "var(--color-texto2)",
        shaped: true,
        $$slots: {
          default: [create_default_slot_3$b]
        },
        $$scope: {
          ctx
        }
      };

      if (
      /*acciones*/
      ctx[0].favorito !== void 0) {
        button1_props.active =
        /*acciones*/
        ctx[0].favorito;
      }

      button1 = new ye({
        props: button1_props,
        $$inline: true
      });
      binding_callbacks.push(() => bind(button1, "active", button1_active_binding));
      button1.$on("click",
      /*favoritear*/
      ctx[5]);

      function button2_active_binding(value) {
        /*button2_active_binding*/
        ctx[8].call(null, value);
      }

      let button2_props = {
        color:
        /*acciones*/
        ctx[0].hideado ? "var(--color5)" : "var(--color-texto2)",
        shaped: true,
        $$slots: {
          default: [create_default_slot_2$b]
        },
        $$scope: {
          ctx
        }
      };

      if (
      /*acciones*/
      ctx[0].hideado !== void 0) {
        button2_props.active =
        /*acciones*/
        ctx[0].hideado;
      }

      button2 = new ye({
        props: button2_props,
        $$inline: true
      });
      binding_callbacks.push(() => bind(button2, "active", button2_active_binding));
      button2.$on("click",
      /*ocultar*/
      ctx[4]);
      button3 = new ye({
        props: {
          shaped: true,
          color: "red",
          $$slots: {
            default: [create_default_slot_1$c]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      button3.$on("click",
      /*click_handler*/
      ctx[9]);
      button4 = new ye({
        props: {
          color: "var(--color-texto1)",
          shaped: true,
          disabled: true,
          $$slots: {
            default: [create_default_slot$d]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      let if_block = (
      /*hilo*/
      ctx[1].rango > CreacionRango.Anon ||
      /*hilo*/
      ctx[1].nombre) && create_if_block$j(ctx);

      function dialogoreporte_visible_binding(value) {
        /*dialogoreporte_visible_binding*/
        ctx[10].call(null, value);
      }

      let dialogoreporte_props = {
        tipo: "hilo",
        hiloId:
        /*hilo*/
        ctx[1].id
      };

      if (
      /*mostrarReporte*/
      ctx[2] !== void 0) {
        dialogoreporte_props.visible =
        /*mostrarReporte*/
        ctx[2];
      }

      dialogoreporte = new DialogoReporte({
        props: dialogoreporte_props,
        $$inline: true
      });
      binding_callbacks.push(() => bind(dialogoreporte, "visible", dialogoreporte_visible_binding));
      const block = {
        c: function create() {
          div = element("div");
          create_component(button0.$$.fragment);
          t0 = space();
          create_component(button1.$$.fragment);
          t1 = space();
          create_component(button2.$$.fragment);
          t2 = space();
          create_component(button3.$$.fragment);
          t3 = space();
          create_component(button4.$$.fragment);
          t4 = space();
          if (if_block) if_block.c();
          t5 = space();
          create_component(dialogoreporte.$$.fragment);
          attr_dev(div, "class", "panel acciones svelte-q7w7pq");
          add_location(div, file$m, 25, 0, 773);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          mount_component(button0, div, null);
          append_dev(div, t0);
          mount_component(button1, div, null);
          append_dev(div, t1);
          mount_component(button2, div, null);
          append_dev(div, t2);
          mount_component(button3, div, null);
          append_dev(div, t3);
          mount_component(button4, div, null);
          append_dev(div, t4);
          if (if_block) if_block.m(div, null);
          insert_dev(target, t5, anchor);
          mount_component(dialogoreporte, target, anchor);
          current = true;
        },
        p: function update(ctx, [dirty]) {
          const button0_changes = {};
          if (dirty &
          /*acciones*/
          1) button0_changes.color =
          /*acciones*/
          ctx[0].seguido ? "var(--color5)" : "var(--color-texto2)";

          if (dirty &
          /*$$scope*/
          2048) {
            button0_changes.$$scope = {
              dirty,
              ctx
            };
          }

          if (!updating_active && dirty &
          /*acciones*/
          1) {
            updating_active = true;
            button0_changes.active =
            /*acciones*/
            ctx[0].seguido;
            add_flush_callback(() => updating_active = false);
          }

          button0.$set(button0_changes);
          const button1_changes = {};
          if (dirty &
          /*acciones*/
          1) button1_changes.color =
          /*acciones*/
          ctx[0].favorito ? "var(--color5)" : "var(--color-texto2)";

          if (dirty &
          /*$$scope*/
          2048) {
            button1_changes.$$scope = {
              dirty,
              ctx
            };
          }

          if (!updating_active_1 && dirty &
          /*acciones*/
          1) {
            updating_active_1 = true;
            button1_changes.active =
            /*acciones*/
            ctx[0].favorito;
            add_flush_callback(() => updating_active_1 = false);
          }

          button1.$set(button1_changes);
          const button2_changes = {};
          if (dirty &
          /*acciones*/
          1) button2_changes.color =
          /*acciones*/
          ctx[0].hideado ? "var(--color5)" : "var(--color-texto2)";

          if (dirty &
          /*$$scope*/
          2048) {
            button2_changes.$$scope = {
              dirty,
              ctx
            };
          }

          if (!updating_active_2 && dirty &
          /*acciones*/
          1) {
            updating_active_2 = true;
            button2_changes.active =
            /*acciones*/
            ctx[0].hideado;
            add_flush_callback(() => updating_active_2 = false);
          }

          button2.$set(button2_changes);
          const button3_changes = {};

          if (dirty &
          /*$$scope*/
          2048) {
            button3_changes.$$scope = {
              dirty,
              ctx
            };
          }

          button3.$set(button3_changes);
          const button4_changes = {};

          if (dirty &
          /*$$scope, hilo*/
          2050) {
            button4_changes.$$scope = {
              dirty,
              ctx
            };
          }

          button4.$set(button4_changes);

          if (
          /*hilo*/
          ctx[1].rango > CreacionRango.Anon ||
          /*hilo*/
          ctx[1].nombre) {
            if (if_block) {
              if_block.p(ctx, dirty);
            } else {
              if_block = create_if_block$j(ctx);
              if_block.c();
              if_block.m(div, null);
            }
          } else if (if_block) {
            if_block.d(1);
            if_block = null;
          }

          const dialogoreporte_changes = {};
          if (dirty &
          /*hilo*/
          2) dialogoreporte_changes.hiloId =
          /*hilo*/
          ctx[1].id;

          if (!updating_visible && dirty &
          /*mostrarReporte*/
          4) {
            updating_visible = true;
            dialogoreporte_changes.visible =
            /*mostrarReporte*/
            ctx[2];
            add_flush_callback(() => updating_visible = false);
          }

          dialogoreporte.$set(dialogoreporte_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(button0.$$.fragment, local);
          transition_in(button1.$$.fragment, local);
          transition_in(button2.$$.fragment, local);
          transition_in(button3.$$.fragment, local);
          transition_in(button4.$$.fragment, local);
          transition_in(dialogoreporte.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(button0.$$.fragment, local);
          transition_out(button1.$$.fragment, local);
          transition_out(button2.$$.fragment, local);
          transition_out(button3.$$.fragment, local);
          transition_out(button4.$$.fragment, local);
          transition_out(dialogoreporte.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
          destroy_component(button0);
          destroy_component(button1);
          destroy_component(button2);
          destroy_component(button3);
          destroy_component(button4);
          if (if_block) if_block.d();
          if (detaching) detach_dev(t5);
          destroy_component(dialogoreporte, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$m.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }

    function instance$m($$self, $$props, $$invalidate) {
      let {
        $$slots: slots = {},
        $$scope
      } = $$props;
      validate_slots("Acciones", slots, []);
      let {
        hilo
      } = $$props;
      let {
        acciones
      } = $$props;
      let mostrarReporte = false;

      async function seguir() {
        await RChanClient.agregar("seguidos", hilo.id);
        $$invalidate(0, acciones.seguido = !acciones.seguido, acciones);
      }

      async function ocultar() {
        await RChanClient.agregar("ocultos", hilo.id);
        $$invalidate(0, acciones.hideado = !acciones.hideado, acciones);
      }

      async function favoritear() {
        await RChanClient.agregar("favoritos", hilo.id);
        $$invalidate(0, acciones.favorito = !acciones.favorito, acciones);
      }

      const writable_props = ["hilo", "acciones"];
      Object.keys($$props).forEach(key => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Acciones> was created with unknown prop '${key}'`);
      });

      function button0_active_binding(value) {
        acciones.seguido = value;
        $$invalidate(0, acciones);
      }

      function button1_active_binding(value) {
        acciones.favorito = value;
        $$invalidate(0, acciones);
      }

      function button2_active_binding(value) {
        acciones.hideado = value;
        $$invalidate(0, acciones);
      }

      const click_handler = () => $$invalidate(2, mostrarReporte = true);

      function dialogoreporte_visible_binding(value) {
        mostrarReporte = value;
        $$invalidate(2, mostrarReporte);
      }

      $$self.$$set = $$props => {
        if ("hilo" in $$props) $$invalidate(1, hilo = $$props.hilo);
        if ("acciones" in $$props) $$invalidate(0, acciones = $$props.acciones);
      };

      $$self.$capture_state = () => ({
        Tiempo,
        RChanClient,
        DialogoReporte,
        Button: ye,
        ButtonGroup: $e,
        CreacionRango,
        hilo,
        acciones,
        mostrarReporte,
        seguir,
        ocultar,
        favoritear
      });

      $$self.$inject_state = $$props => {
        if ("hilo" in $$props) $$invalidate(1, hilo = $$props.hilo);
        if ("acciones" in $$props) $$invalidate(0, acciones = $$props.acciones);
        if ("mostrarReporte" in $$props) $$invalidate(2, mostrarReporte = $$props.mostrarReporte);
      };

      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }

      return [acciones, hilo, mostrarReporte, seguir, ocultar, favoritear, button0_active_binding, button1_active_binding, button2_active_binding, click_handler, dialogoreporte_visible_binding];
    }

    class Acciones extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$m, create_fragment$m, safe_not_equal, {
          hilo: 1,
          acciones: 0
        });
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "Acciones",
          options,
          id: create_fragment$m.name
        });
        const {
          ctx
        } = this.$$;
        const props = options.props || {};

        if (
        /*hilo*/
        ctx[1] === undefined && !("hilo" in props)) {
          console.warn("<Acciones> was created without expected prop 'hilo'");
        }

        if (
        /*acciones*/
        ctx[0] === undefined && !("acciones" in props)) {
          console.warn("<Acciones> was created without expected prop 'acciones'");
        }
      }

      get hilo() {
        throw new Error("<Acciones>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set hilo(value) {
        throw new Error("<Acciones>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get acciones() {
        throw new Error("<Acciones>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set acciones(value) {
        throw new Error("<Acciones>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

    }

    /* src\components\Hilos\HiloCuerpo.svelte generated by Svelte v3.29.0 */
    const file$n = "src\\components\\Hilos\\HiloCuerpo.svelte"; // (11:4) {#if hilo.audio}

    function create_if_block$k(ctx) {
      let audio;
      let current;
      audio = new Audio$1({
        props: {
          urlBlobAudio:
          /*hilo*/
          ctx[0].audio.url
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          create_component(audio.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(audio, target, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          const audio_changes = {};
          if (dirty &
          /*hilo*/
          1) audio_changes.urlBlobAudio =
          /*hilo*/
          ctx[0].audio.url;
          audio.$set(audio_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(audio.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(audio.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(audio, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block$k.name,
        type: "if",
        source: "(11:4) {#if hilo.audio}",
        ctx
      });
      return block;
    }

    function create_fragment$n(ctx) {
      let div1;
      let media;
      let updating_abierto;
      let t0;
      let t1;
      let h1;
      let t2_value =
      /*hilo*/
      ctx[0].titulo + "";
      let t2;
      let t3;
      let div0;
      let raw_value =
      /*hilo*/
      ctx[0].contenido + "";
      let current;

      function media_abierto_binding(value) {
        /*media_abierto_binding*/
        ctx[2].call(null, value);
      }

      let media_props = {
        media:
        /*hilo*/
        ctx[0].media
      };

      if (
      /*mediaExpandido*/
      ctx[1] !== void 0) {
        media_props.abierto =
        /*mediaExpandido*/
        ctx[1];
      }

      media = new Media({
        props: media_props,
        $$inline: true
      });
      binding_callbacks.push(() => bind(media, "abierto", media_abierto_binding));
      let if_block =
      /*hilo*/
      ctx[0].audio && create_if_block$k(ctx);
      const block = {
        c: function create() {
          div1 = element("div");
          create_component(media.$$.fragment);
          t0 = space();
          if (if_block) if_block.c();
          t1 = space();
          h1 = element("h1");
          t2 = text(t2_value);
          t3 = space();
          div0 = element("div");
          set_style(h1, "margin-bottom", "16px");
          attr_dev(h1, "class", "svelte-1itfsjk");
          add_location(h1, file$n, 13, 4, 365);
          attr_dev(div0, "class", "texto svelte-1itfsjk");
          set_style(div0, "white-space", "pre-wrap");
          set_style(div0, "word-break", "break-word");
          add_location(div0, file$n, 14, 4, 419);
          attr_dev(div1, "class", "cuerpo markdown-body svelte-1itfsjk");
          toggle_class(div1, "mediaExpandido",
          /*mediaExpandido*/
          ctx[1]);
          add_location(div1, file$n, 8, 0, 163);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, div1, anchor);
          mount_component(media, div1, null);
          append_dev(div1, t0);
          if (if_block) if_block.m(div1, null);
          append_dev(div1, t1);
          append_dev(div1, h1);
          append_dev(h1, t2);
          append_dev(div1, t3);
          append_dev(div1, div0);
          div0.innerHTML = raw_value;
          current = true;
        },
        p: function update(ctx, [dirty]) {
          const media_changes = {};
          if (dirty &
          /*hilo*/
          1) media_changes.media =
          /*hilo*/
          ctx[0].media;

          if (!updating_abierto && dirty &
          /*mediaExpandido*/
          2) {
            updating_abierto = true;
            media_changes.abierto =
            /*mediaExpandido*/
            ctx[1];
            add_flush_callback(() => updating_abierto = false);
          }

          media.$set(media_changes);

          if (
          /*hilo*/
          ctx[0].audio) {
            if (if_block) {
              if_block.p(ctx, dirty);

              if (dirty &
              /*hilo*/
              1) {
                transition_in(if_block, 1);
              }
            } else {
              if_block = create_if_block$k(ctx);
              if_block.c();
              transition_in(if_block, 1);
              if_block.m(div1, t1);
            }
          } else if (if_block) {
            group_outros();
            transition_out(if_block, 1, 1, () => {
              if_block = null;
            });
            check_outros();
          }

          if ((!current || dirty &
          /*hilo*/
          1) && t2_value !== (t2_value =
          /*hilo*/
          ctx[0].titulo + "")) set_data_dev(t2, t2_value);
          if ((!current || dirty &
          /*hilo*/
          1) && raw_value !== (raw_value =
          /*hilo*/
          ctx[0].contenido + "")) div0.innerHTML = raw_value;

          if (dirty &
          /*mediaExpandido*/
          2) {
            toggle_class(div1, "mediaExpandido",
            /*mediaExpandido*/
            ctx[1]);
          }
        },
        i: function intro(local) {
          if (current) return;
          transition_in(media.$$.fragment, local);
          transition_in(if_block);
          current = true;
        },
        o: function outro(local) {
          transition_out(media.$$.fragment, local);
          transition_out(if_block);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div1);
          destroy_component(media);
          if (if_block) if_block.d();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$n.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }

    function instance$n($$self, $$props, $$invalidate) {
      let {
        $$slots: slots = {},
        $$scope
      } = $$props;
      validate_slots("HiloCuerpo", slots, []);
      let {
        hilo = null
      } = $$props;
      let mediaExpandido = false;
      const writable_props = ["hilo"];
      Object.keys($$props).forEach(key => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<HiloCuerpo> was created with unknown prop '${key}'`);
      });

      function media_abierto_binding(value) {
        mediaExpandido = value;
        $$invalidate(1, mediaExpandido);
      }

      $$self.$$set = $$props => {
        if ("hilo" in $$props) $$invalidate(0, hilo = $$props.hilo);
      };

      $$self.$capture_state = () => ({
        Media,
        Audio: Audio$1,
        hilo,
        mediaExpandido
      });

      $$self.$inject_state = $$props => {
        if ("hilo" in $$props) $$invalidate(0, hilo = $$props.hilo);
        if ("mediaExpandido" in $$props) $$invalidate(1, mediaExpandido = $$props.mediaExpandido);
      };

      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }

      return [hilo, mediaExpandido, media_abierto_binding];
    }

    class HiloCuerpo extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$n, create_fragment$n, safe_not_equal, {
          hilo: 0
        });
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "HiloCuerpo",
          options,
          id: create_fragment$n.name
        });
      }

      get hilo() {
        throw new Error("<HiloCuerpo>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set hilo(value) {
        throw new Error("<HiloCuerpo>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

    }

    /* src\components\Hilos\Encuesta.svelte generated by Svelte v3.29.0 */
    const file$o = "src\\components\\Hilos\\Encuesta.svelte";

    function get_each_context$b(ctx, list, i) {
      const child_ctx = ctx.slice();
      child_ctx[15] = list[i];
      return child_ctx;
    }

    function get_each_context_1$3(ctx, list, i) {
      const child_ctx = ctx.slice();
      child_ctx[15] = list[i];
      return child_ctx;
    }

    function get_each_context_2$2(ctx, list, i) {
      const child_ctx = ctx.slice();
      child_ctx[15] = list[i];
      return child_ctx;
    } // (63:4) {#if encuesta}


    function create_if_block$l(ctx) {
      let div;
      let ripple;
      let t0;
      let t1;
      let t2;
      let if_block1_anchor;
      let current;
      let mounted;
      let dispose;
      ripple = new he({
        props: {
          color: "var(--color5)"
        },
        $$inline: true
      });
      let each_value_2 =
      /*encuesta*/
      ctx[0].opciones;
      validate_each_argument(each_value_2);
      let each_blocks = [];

      for (let i = 0; i < each_value_2.length; i += 1) {
        each_blocks[i] = create_each_block_2$2(get_each_context_2$2(ctx, each_value_2, i));
      }

      let if_block0 =
      /*estado*/
      ctx[2] == 1 && create_if_block_2$d(ctx);
      let if_block1 =
      /*estado*/
      ctx[2] == 3 && create_if_block_1$e(ctx);
      const block = {
        c: function create() {
          div = element("div");
          create_component(ripple.$$.fragment);
          t0 = space();

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].c();
          }

          t1 = space();
          if (if_block0) if_block0.c();
          t2 = space();
          if (if_block1) if_block1.c();
          if_block1_anchor = empty();
          attr_dev(div, "class", "preview svelte-84kkio");
          add_location(div, file$o, 63, 8, 1826);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          mount_component(ripple, div, null);
          append_dev(div, t0);

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].m(div, null);
          }

          insert_dev(target, t1, anchor);
          if (if_block0) if_block0.m(target, anchor);
          insert_dev(target, t2, anchor);
          if (if_block1) if_block1.m(target, anchor);
          insert_dev(target, if_block1_anchor, anchor);
          current = true;

          if (!mounted) {
            dispose = listen_dev(div, "click",
            /*abrirEncuesta*/
            ctx[4], false, false, false);
            mounted = true;
          }
        },
        p: function update(ctx, dirty) {
          if (dirty &
          /*calcularPorcentaje, encuesta, estado*/
          133) {
            each_value_2 =
            /*encuesta*/
            ctx[0].opciones;
            validate_each_argument(each_value_2);
            let i;

            for (i = 0; i < each_value_2.length; i += 1) {
              const child_ctx = get_each_context_2$2(ctx, each_value_2, i);

              if (each_blocks[i]) {
                each_blocks[i].p(child_ctx, dirty);
              } else {
                each_blocks[i] = create_each_block_2$2(child_ctx);
                each_blocks[i].c();
                each_blocks[i].m(div, null);
              }
            }

            for (; i < each_blocks.length; i += 1) {
              each_blocks[i].d(1);
            }

            each_blocks.length = each_value_2.length;
          }

          if (
          /*estado*/
          ctx[2] == 1) {
            if (if_block0) {
              if_block0.p(ctx, dirty);

              if (dirty &
              /*estado*/
              4) {
                transition_in(if_block0, 1);
              }
            } else {
              if_block0 = create_if_block_2$d(ctx);
              if_block0.c();
              transition_in(if_block0, 1);
              if_block0.m(t2.parentNode, t2);
            }
          } else if (if_block0) {
            group_outros();
            transition_out(if_block0, 1, 1, () => {
              if_block0 = null;
            });
            check_outros();
          }

          if (
          /*estado*/
          ctx[2] == 3) {
            if (if_block1) {
              if_block1.p(ctx, dirty);

              if (dirty &
              /*estado*/
              4) {
                transition_in(if_block1, 1);
              }
            } else {
              if_block1 = create_if_block_1$e(ctx);
              if_block1.c();
              transition_in(if_block1, 1);
              if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
            }
          } else if (if_block1) {
            group_outros();
            transition_out(if_block1, 1, 1, () => {
              if_block1 = null;
            });
            check_outros();
          }
        },
        i: function intro(local) {
          if (current) return;
          transition_in(ripple.$$.fragment, local);
          transition_in(if_block0);
          transition_in(if_block1);
          current = true;
        },
        o: function outro(local) {
          transition_out(ripple.$$.fragment, local);
          transition_out(if_block0);
          transition_out(if_block1);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
          destroy_component(ripple);
          destroy_each(each_blocks, detaching);
          if (detaching) detach_dev(t1);
          if (if_block0) if_block0.d(detaching);
          if (detaching) detach_dev(t2);
          if (if_block1) if_block1.d(detaching);
          if (detaching) detach_dev(if_block1_anchor);
          mounted = false;
          dispose();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block$l.name,
        type: "if",
        source: "(63:4) {#if encuesta}",
        ctx
      });
      return block;
    } // (66:12) {#each encuesta.opciones as o}


    function create_each_block_2$2(ctx) {
      let div;
      let span;
      let t0_value =
      /*o*/
      ctx[15].nombre + "";
      let t0;
      let t1;
      let div_title_value;
      const block = {
        c: function create() {
          div = element("div");
          span = element("span");
          t0 = text(t0_value);
          t1 = space();
          add_location(span, file$o, 71, 20, 2194);
          attr_dev(div, "class", "opcion svelte-84kkio");
          attr_dev(div, "title", div_title_value = "" + (
          /*calcularPorcentaje*/
          ctx[7](
          /*o*/
          ctx[15].nombre) + "% " +
          /*o*/
          ctx[15].nombre));
          set_style(div, "flex",
          /*estado*/
          ctx[2] < 2 ? 1 :
          /*o*/
          ctx[15].votos);
          add_location(div, file$o, 66, 16, 1980);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          append_dev(div, span);
          append_dev(span, t0);
          append_dev(div, t1);
        },
        p: function update(ctx, dirty) {
          if (dirty &
          /*encuesta*/
          1 && t0_value !== (t0_value =
          /*o*/
          ctx[15].nombre + "")) set_data_dev(t0, t0_value);

          if (dirty &
          /*encuesta*/
          1 && div_title_value !== (div_title_value = "" + (
          /*calcularPorcentaje*/
          ctx[7](
          /*o*/
          ctx[15].nombre) + "% " +
          /*o*/
          ctx[15].nombre))) {
            attr_dev(div, "title", div_title_value);
          }

          if (dirty &
          /*estado, encuesta*/
          5) {
            set_style(div, "flex",
            /*estado*/
            ctx[2] < 2 ? 1 :
            /*o*/
            ctx[15].votos);
          }
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_each_block_2$2.name,
        type: "each",
        source: "(66:12) {#each encuesta.opciones as o}",
        ctx
      });
      return block;
    } // (79:8) {#if estado == 1}


    function create_if_block_2$d(ctx) {
      let dialog;
      let current;
      dialog = new pn({
        props: {
          visible: true,
          modal: true,
          $$slots: {
            default: [create_default_slot_2$c],
            actions: [create_actions_slot_1],
            title: [create_title_slot_1]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          create_component(dialog.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(dialog, target, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          const dialog_changes = {};

          if (dirty &
          /*$$scope, votando, encuesta*/
          4194307) {
            dialog_changes.$$scope = {
              dirty,
              ctx
            };
          }

          dialog.$set(dialog_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(dialog.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(dialog.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(dialog, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_2$d.name,
        type: "if",
        source: "(79:8) {#if estado == 1}",
        ctx
      });
      return block;
    } // (81:16) <div slot="title">


    function create_title_slot_1(ctx) {
      let div;
      const block = {
        c: function create() {
          div = element("div");
          div.textContent = "Elija una opcion padre";
          attr_dev(div, "slot", "title");
          add_location(div, file$o, 80, 16, 2423);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_title_slot_1.name,
        type: "slot",
        source: "(81:16) <div slot=\\\"title\\\">",
        ctx
      });
      return block;
    } // (84:24) {#each encuesta.opciones as o}


    function create_each_block_1$3(ctx) {
      let li;
      let t0_value =
      /*o*/
      ctx[15].nombre + "";
      let t0;
      let t1;
      let ripple;
      let t2;
      let current;
      let mounted;
      let dispose;
      ripple = new he({
        $$inline: true
      });

      function click_handler(...args) {
        return (
          /*click_handler*/
          ctx[9](
          /*o*/
          ctx[15], ...args)
        );
      }

      const block = {
        c: function create() {
          li = element("li");
          t0 = text(t0_value);
          t1 = space();
          create_component(ripple.$$.fragment);
          t2 = space();
          attr_dev(li, "class", "svelte-84kkio");
          add_location(li, file$o, 84, 28, 2627);
        },
        m: function mount(target, anchor) {
          insert_dev(target, li, anchor);
          append_dev(li, t0);
          append_dev(li, t1);
          mount_component(ripple, li, null);
          append_dev(li, t2);
          current = true;

          if (!mounted) {
            dispose = listen_dev(li, "click", click_handler, false, false, false);
            mounted = true;
          }
        },
        p: function update(new_ctx, dirty) {
          ctx = new_ctx;
          if ((!current || dirty &
          /*encuesta*/
          1) && t0_value !== (t0_value =
          /*o*/
          ctx[15].nombre + "")) set_data_dev(t0, t0_value);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(ripple.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(ripple.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(li);
          destroy_component(ripple);
          mounted = false;
          dispose();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_each_block_1$3.name,
        type: "each",
        source: "(84:24) {#each encuesta.opciones as o}",
        ctx
      });
      return block;
    } // (83:20) <Spinner cargando={votando}>


    function create_default_slot_4$9(ctx) {
      let each_1_anchor;
      let current;
      let each_value_1 =
      /*encuesta*/
      ctx[0].opciones;
      validate_each_argument(each_value_1);
      let each_blocks = [];

      for (let i = 0; i < each_value_1.length; i += 1) {
        each_blocks[i] = create_each_block_1$3(get_each_context_1$3(ctx, each_value_1, i));
      }

      const out = i => transition_out(each_blocks[i], 1, 1, () => {
        each_blocks[i] = null;
      });

      const block = {
        c: function create() {
          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].c();
          }

          each_1_anchor = empty();
        },
        m: function mount(target, anchor) {
          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].m(target, anchor);
          }

          insert_dev(target, each_1_anchor, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          if (dirty &
          /*votar, encuesta*/
          33) {
            each_value_1 =
            /*encuesta*/
            ctx[0].opciones;
            validate_each_argument(each_value_1);
            let i;

            for (i = 0; i < each_value_1.length; i += 1) {
              const child_ctx = get_each_context_1$3(ctx, each_value_1, i);

              if (each_blocks[i]) {
                each_blocks[i].p(child_ctx, dirty);
                transition_in(each_blocks[i], 1);
              } else {
                each_blocks[i] = create_each_block_1$3(child_ctx);
                each_blocks[i].c();
                transition_in(each_blocks[i], 1);
                each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
              }
            }

            group_outros();

            for (i = each_value_1.length; i < each_blocks.length; i += 1) {
              out(i);
            }

            check_outros();
          }
        },
        i: function intro(local) {
          if (current) return;

          for (let i = 0; i < each_value_1.length; i += 1) {
            transition_in(each_blocks[i]);
          }

          current = true;
        },
        o: function outro(local) {
          each_blocks = each_blocks.filter(Boolean);

          for (let i = 0; i < each_blocks.length; i += 1) {
            transition_out(each_blocks[i]);
          }

          current = false;
        },
        d: function destroy(detaching) {
          destroy_each(each_blocks, detaching);
          if (detaching) detach_dev(each_1_anchor);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_4$9.name,
        type: "slot",
        source: "(83:20) <Spinner cargando={votando}>",
        ctx
      });
      return block;
    } // (93:20) <Button color="primary" on:click={() => cerrar()}                          >


    function create_default_slot_3$c(ctx) {
      let t;
      const block = {
        c: function create() {
          t = text("Cerrar");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_3$c.name,
        type: "slot",
        source: "(93:20) <Button color=\\\"primary\\\" on:click={() => cerrar()}                          >",
        ctx
      });
      return block;
    } // (92:16) <div slot="actions" class="actions center">


    function create_actions_slot_1(ctx) {
      let div;
      let button;
      let current;
      button = new ye({
        props: {
          color: "primary",
          $$slots: {
            default: [create_default_slot_3$c]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      button.$on("click",
      /*click_handler_1*/
      ctx[10]);
      const block = {
        c: function create() {
          div = element("div");
          create_component(button.$$.fragment);
          attr_dev(div, "slot", "actions");
          attr_dev(div, "class", "actions center");
          add_location(div, file$o, 91, 16, 2893);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          mount_component(button, div, null);
          current = true;
        },
        p: function update(ctx, dirty) {
          const button_changes = {};

          if (dirty &
          /*$$scope*/
          4194304) {
            button_changes.$$scope = {
              dirty,
              ctx
            };
          }

          button.$set(button_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(button.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(button.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
          destroy_component(button);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_actions_slot_1.name,
        type: "slot",
        source: "(92:16) <div slot=\\\"actions\\\" class=\\\"actions center\\\">",
        ctx
      });
      return block;
    } // (80:12) <Dialog visible={true} modal={true}>


    function create_default_slot_2$c(ctx) {
      let t0;
      let ul;
      let spinner;
      let t1;
      let current;
      spinner = new Spinner({
        props: {
          cargando:
          /*votando*/
          ctx[1],
          $$slots: {
            default: [create_default_slot_4$9]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          t0 = space();
          ul = element("ul");
          create_component(spinner.$$.fragment);
          t1 = space();
          add_location(ul, file$o, 81, 16, 2487);
        },
        m: function mount(target, anchor) {
          insert_dev(target, t0, anchor);
          insert_dev(target, ul, anchor);
          mount_component(spinner, ul, null);
          insert_dev(target, t1, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          const spinner_changes = {};
          if (dirty &
          /*votando*/
          2) spinner_changes.cargando =
          /*votando*/
          ctx[1];

          if (dirty &
          /*$$scope, encuesta*/
          4194305) {
            spinner_changes.$$scope = {
              dirty,
              ctx
            };
          }

          spinner.$set(spinner_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(spinner.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(spinner.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(t0);
          if (detaching) detach_dev(ul);
          destroy_component(spinner);
          if (detaching) detach_dev(t1);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_2$c.name,
        type: "slot",
        source: "(80:12) <Dialog visible={true} modal={true}>",
        ctx
      });
      return block;
    } // (99:8) {#if estado == 3}


    function create_if_block_1$e(ctx) {
      let dialog;
      let current;
      dialog = new pn({
        props: {
          visible: true,
          modal: true,
          $$slots: {
            default: [create_default_slot$e],
            actions: [create_actions_slot$4],
            title: [create_title_slot$4]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          create_component(dialog.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(dialog, target, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          const dialog_changes = {};

          if (dirty &
          /*$$scope, estado, encuesta, totalDeVotos*/
          4194317) {
            dialog_changes.$$scope = {
              dirty,
              ctx
            };
          }

          dialog.$set(dialog_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(dialog.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(dialog.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(dialog, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_1$e.name,
        type: "if",
        source: "(99:8) {#if estado == 3}",
        ctx
      });
      return block;
    } // (101:16) <div slot="title">


    function create_title_slot$4(ctx) {
      let div;
      let t0;
      let t1;
      let t2;
      let t3_value = (
      /*totalDeVotos*/
      ctx[3] != 1 ? "votos" : "voto") + "";
      let t3;
      let t4;
      const block = {
        c: function create() {
          div = element("div");
          t0 = text("Resultados (");
          t1 = text(
          /*totalDeVotos*/
          ctx[3]);
          t2 = space();
          t3 = text(t3_value);
          t4 = text(")");
          attr_dev(div, "slot", "title");
          add_location(div, file$o, 100, 16, 3228);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          append_dev(div, t0);
          append_dev(div, t1);
          append_dev(div, t2);
          append_dev(div, t3);
          append_dev(div, t4);
        },
        p: function update(ctx, dirty) {
          if (dirty &
          /*totalDeVotos*/
          8) set_data_dev(t1,
          /*totalDeVotos*/
          ctx[3]);
          if (dirty &
          /*totalDeVotos*/
          8 && t3_value !== (t3_value = (
          /*totalDeVotos*/
          ctx[3] != 1 ? "votos" : "voto") + "")) set_data_dev(t3, t3_value);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_title_slot$4.name,
        type: "slot",
        source: "(101:16) <div slot=\\\"title\\\">",
        ctx
      });
      return block;
    } // (106:20) {#each encuesta.opciones as o}


    function create_each_block$b(ctx) {
      let li;
      let t0_value =
      /*calcularPorcentaje*/
      ctx[7](
      /*o*/
      ctx[15].nombre) + "";
      let t0;
      let t1;
      let t2_value =
      /*o*/
      ctx[15].nombre + "";
      let t2;
      const block = {
        c: function create() {
          li = element("li");
          t0 = text(t0_value);
          t1 = text("% ");
          t2 = text(t2_value);
          attr_dev(li, "class", "svelte-84kkio");
          add_location(li, file$o, 106, 24, 3479);
        },
        m: function mount(target, anchor) {
          insert_dev(target, li, anchor);
          append_dev(li, t0);
          append_dev(li, t1);
          append_dev(li, t2);
        },
        p: function update(ctx, dirty) {
          if (dirty &
          /*encuesta*/
          1 && t0_value !== (t0_value =
          /*calcularPorcentaje*/
          ctx[7](
          /*o*/
          ctx[15].nombre) + "")) set_data_dev(t0, t0_value);
          if (dirty &
          /*encuesta*/
          1 && t2_value !== (t2_value =
          /*o*/
          ctx[15].nombre + "")) set_data_dev(t2, t2_value);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(li);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_each_block$b.name,
        type: "each",
        source: "(106:20) {#each encuesta.opciones as o}",
        ctx
      });
      return block;
    } // (111:20) <Button color="primary" on:click={() => (estado = 2)}                          >


    function create_default_slot_1$d(ctx) {
      let t;
      const block = {
        c: function create() {
          t = text("Ok");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_1$d.name,
        type: "slot",
        source: "(111:20) <Button color=\\\"primary\\\" on:click={() => (estado = 2)}                          >",
        ctx
      });
      return block;
    } // (110:16) <div slot="actions" class="actions center">


    function create_actions_slot$4(ctx) {
      let div;
      let button;
      let current;
      button = new ye({
        props: {
          color: "primary",
          $$slots: {
            default: [create_default_slot_1$d]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      button.$on("click",
      /*click_handler_2*/
      ctx[11]);
      const block = {
        c: function create() {
          div = element("div");
          create_component(button.$$.fragment);
          attr_dev(div, "slot", "actions");
          attr_dev(div, "class", "actions center");
          add_location(div, file$o, 109, 16, 3600);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          mount_component(button, div, null);
          current = true;
        },
        p: function update(ctx, dirty) {
          const button_changes = {};

          if (dirty &
          /*$$scope*/
          4194304) {
            button_changes.$$scope = {
              dirty,
              ctx
            };
          }

          button.$set(button_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(button.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(button.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
          destroy_component(button);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_actions_slot$4.name,
        type: "slot",
        source: "(110:16) <div slot=\\\"actions\\\" class=\\\"actions center\\\">",
        ctx
      });
      return block;
    } // (100:12) <Dialog visible={true} modal={true}>


    function create_default_slot$e(ctx) {
      let t0;
      let ul;
      let t1;
      let each_value =
      /*encuesta*/
      ctx[0].opciones;
      validate_each_argument(each_value);
      let each_blocks = [];

      for (let i = 0; i < each_value.length; i += 1) {
        each_blocks[i] = create_each_block$b(get_each_context$b(ctx, each_value, i));
      }

      const block = {
        c: function create() {
          t0 = space();
          ul = element("ul");

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].c();
          }

          t1 = space();
          add_location(ul, file$o, 104, 16, 3397);
        },
        m: function mount(target, anchor) {
          insert_dev(target, t0, anchor);
          insert_dev(target, ul, anchor);

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].m(ul, null);
          }

          insert_dev(target, t1, anchor);
        },
        p: function update(ctx, dirty) {
          if (dirty &
          /*encuesta, calcularPorcentaje*/
          129) {
            each_value =
            /*encuesta*/
            ctx[0].opciones;
            validate_each_argument(each_value);
            let i;

            for (i = 0; i < each_value.length; i += 1) {
              const child_ctx = get_each_context$b(ctx, each_value, i);

              if (each_blocks[i]) {
                each_blocks[i].p(child_ctx, dirty);
              } else {
                each_blocks[i] = create_each_block$b(child_ctx);
                each_blocks[i].c();
                each_blocks[i].m(ul, null);
              }
            }

            for (; i < each_blocks.length; i += 1) {
              each_blocks[i].d(1);
            }

            each_blocks.length = each_value.length;
          }
        },
        i: noop,
        o: noop,
        d: function destroy(detaching) {
          if (detaching) detach_dev(t0);
          if (detaching) detach_dev(ul);
          destroy_each(each_blocks, detaching);
          if (detaching) detach_dev(t1);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot$e.name,
        type: "slot",
        source: "(100:12) <Dialog visible={true} modal={true}>",
        ctx
      });
      return block;
    }

    function create_fragment$o(ctx) {
      let div;
      let current;
      let if_block =
      /*encuesta*/
      ctx[0] && create_if_block$l(ctx);
      const block = {
        c: function create() {
          div = element("div");
          if (if_block) if_block.c();
          attr_dev(div, "class", "encuesta svelte-84kkio");
          add_location(div, file$o, 61, 0, 1774);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          if (if_block) if_block.m(div, null);
          current = true;
        },
        p: function update(ctx, [dirty]) {
          if (
          /*encuesta*/
          ctx[0]) {
            if (if_block) {
              if_block.p(ctx, dirty);

              if (dirty &
              /*encuesta*/
              1) {
                transition_in(if_block, 1);
              }
            } else {
              if_block = create_if_block$l(ctx);
              if_block.c();
              transition_in(if_block, 1);
              if_block.m(div, null);
            }
          } else if (if_block) {
            group_outros();
            transition_out(if_block, 1, 1, () => {
              if_block = null;
            });
            check_outros();
          }
        },
        i: function intro(local) {
          if (current) return;
          transition_in(if_block);
          current = true;
        },
        o: function outro(local) {
          transition_out(if_block);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
          if (if_block) if_block.d();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$o.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }

    function instance$o($$self, $$props, $$invalidate) {
      let $globalStore;
      let $comentarioStore;
      validate_store(globalStore, "globalStore");
      component_subscribe($$self, globalStore, $$value => $$invalidate(12, $globalStore = $$value));
      validate_store(comentarioStore, "comentarioStore");
      component_subscribe($$self, comentarioStore, $$value => $$invalidate(13, $comentarioStore = $$value));
      let {
        $$slots: slots = {},
        $$scope
      } = $$props;
      validate_slots("Encuesta", slots, []);
      let {
        encuesta
      } = $$props;
      let {
        hiloId
      } = $$props;
      let {
        votando = false
      } = $$props;
      let dialogo = false;
      let estado = 0; // 0 no voto // 1 votando // 2 voto //3 detalles

      if (encuesta.haVotado || !$globalStore.usuario.estaAutenticado) estado = 2;

      function abrirEncuesta() {
        if (estado == 0) {
          $$invalidate(2, estado = 1);
        } else if (estado == 2) {
          $$invalidate(2, estado = 3);
        }
      }

      async function votar(opcion) {
        try {
          $$invalidate(1, votando = true);
          let res = await RChanClient.votarEncuesta(hiloId, opcion);
          set_store_value(comentarioStore, $comentarioStore = `[${opcion}]\n\n` + $comentarioStore, $comentarioStore);
        } catch (error) {}

        encuesta.opciones.filter(o => o.nombre == opcion)[0].votos++;
        $$invalidate(0, encuesta);
        $$invalidate(1, votando = false);
        $$invalidate(2, estado = 2);
      }

      function cerrar() {
        $$invalidate(1, votando = false);
        $$invalidate(2, estado = 0);
      }

      function calcularPorcentaje(opcion) {
        let votosTotales = 0;
        encuesta.opciones.forEach(o => votosTotales += o.votos);
        if (votosTotales == 0) votosTotales = 1;
        const votosOpcion = encuesta.opciones.filter(o => o.nombre == opcion)[0].votos;
        return (votosOpcion / votosTotales * 100).toFixed(2);
      }

      if (!$globalStore.usuario.estaAutenticado) estado = 2;
      const writable_props = ["encuesta", "hiloId", "votando"];
      Object.keys($$props).forEach(key => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Encuesta> was created with unknown prop '${key}'`);
      });

      const click_handler = o => votar(o.nombre);

      const click_handler_1 = () => cerrar();

      const click_handler_2 = () => $$invalidate(2, estado = 2);

      $$self.$$set = $$props => {
        if ("encuesta" in $$props) $$invalidate(0, encuesta = $$props.encuesta);
        if ("hiloId" in $$props) $$invalidate(8, hiloId = $$props.hiloId);
        if ("votando" in $$props) $$invalidate(1, votando = $$props.votando);
      };

      $$self.$capture_state = () => ({
        Dialog: pn,
        Ripple: he,
        Button: ye,
        globalStore,
        RChanClient,
        comentarioStore,
        Spinner,
        encuesta,
        hiloId,
        votando,
        dialogo,
        estado,
        abrirEncuesta,
        votar,
        cerrar,
        calcularPorcentaje,
        $globalStore,
        totalDeVotos,
        $comentarioStore
      });

      $$self.$inject_state = $$props => {
        if ("encuesta" in $$props) $$invalidate(0, encuesta = $$props.encuesta);
        if ("hiloId" in $$props) $$invalidate(8, hiloId = $$props.hiloId);
        if ("votando" in $$props) $$invalidate(1, votando = $$props.votando);
        if ("dialogo" in $$props) dialogo = $$props.dialogo;
        if ("estado" in $$props) $$invalidate(2, estado = $$props.estado);
        if ("totalDeVotos" in $$props) $$invalidate(3, totalDeVotos = $$props.totalDeVotos);
      };

      let totalDeVotos;

      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }

      $$self.$$.update = () => {
        if ($$self.$$.dirty &
        /*encuesta*/
        1) {
           $$invalidate(3, totalDeVotos = encuesta.opciones.map(e => e.votos).reduce((a, b) => a + b));
        }
      };

      return [encuesta, votando, estado, totalDeVotos, abrirEncuesta, votar, cerrar, calcularPorcentaje, hiloId, click_handler, click_handler_1, click_handler_2];
    }

    class Encuesta extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$o, create_fragment$o, safe_not_equal, {
          encuesta: 0,
          hiloId: 8,
          votando: 1
        });
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "Encuesta",
          options,
          id: create_fragment$o.name
        });
        const {
          ctx
        } = this.$$;
        const props = options.props || {};

        if (
        /*encuesta*/
        ctx[0] === undefined && !("encuesta" in props)) {
          console.warn("<Encuesta> was created without expected prop 'encuesta'");
        }

        if (
        /*hiloId*/
        ctx[8] === undefined && !("hiloId" in props)) {
          console.warn("<Encuesta> was created without expected prop 'hiloId'");
        }
      }

      get encuesta() {
        throw new Error("<Encuesta>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set encuesta(value) {
        throw new Error("<Encuesta>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get hiloId() {
        throw new Error("<Encuesta>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set hiloId(value) {
        throw new Error("<Encuesta>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get votando() {
        throw new Error("<Encuesta>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set votando(value) {
        throw new Error("<Encuesta>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

    }

    /* src\App.svelte generated by Svelte v3.29.0 */
    const file$p = "src\\App.svelte"; // (48:2) {#if hilo.encuestaData}

    function create_if_block_6$2(ctx) {
      let encuesta;
      let updating_encuesta;
      let current;

      function encuesta_encuesta_binding(value) {
        /*encuesta_encuesta_binding*/
        ctx[9].call(null, value);
      }

      let encuesta_props = {
        hiloId:
        /*hilo*/
        ctx[0].id
      };

      if (
      /*hilo*/
      ctx[0].encuestaData !== void 0) {
        encuesta_props.encuesta =
        /*hilo*/
        ctx[0].encuestaData;
      }

      encuesta = new Encuesta({
        props: encuesta_props,
        $$inline: true
      });
      binding_callbacks.push(() => bind(encuesta, "encuesta", encuesta_encuesta_binding));
      const block = {
        c: function create() {
          create_component(encuesta.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(encuesta, target, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          const encuesta_changes = {};
          if (dirty &
          /*hilo*/
          1) encuesta_changes.hiloId =
          /*hilo*/
          ctx[0].id;

          if (!updating_encuesta && dirty &
          /*hilo*/
          1) {
            updating_encuesta = true;
            encuesta_changes.encuesta =
            /*hilo*/
            ctx[0].encuestaData;
            add_flush_callback(() => updating_encuesta = false);
          }

          encuesta.$set(encuesta_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(encuesta.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(encuesta.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(encuesta, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_6$2.name,
        type: "if",
        source: "(48:2) {#if hilo.encuestaData}",
        ctx
      });
      return block;
    } // (52:2) {#if $globalStore.usuario.esMod || $globalStore.usuario.esAuxiliar}


    function create_if_block$m(ctx) {
      let t0;
      let div;
      let t1;
      let button0;
      let t2;
      let t3;
      let t4;
      let button1;
      let t5;
      let current;
      let if_block0 =
      /*hilo*/
      ctx[0].estado == 2 && create_if_block_5$3(ctx);
      let if_block1 =
      /*$globalStore*/
      ctx[4].usuario.esMod && create_if_block_4$4(ctx);
      button0 = new ye({
        props: {
          $$slots: {
            default: [create_default_slot_4$a]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      button0.$on("click",
      /*click_handler*/
      ctx[12]);
      let if_block2 =
      /*hilo*/
      ctx[0].estado != HiloEstado.eliminado && create_if_block_3$8(ctx);
      let if_block3 =
      /*hilo*/
      ctx[0].estado == HiloEstado.eliminado && create_if_block_2$e(ctx);
      button1 = new ye({
        props: {
          $$slots: {
            default: [create_default_slot_1$e]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      button1.$on("click",
      /*click_handler_3*/
      ctx[15]);
      let if_block4 =
      /*$globalStore*/
      ctx[4].usuario.esAdmin && create_if_block_1$f(ctx);
      const block = {
        c: function create() {
          if (if_block0) if_block0.c();
          t0 = space();
          div = element("div");
          if (if_block1) if_block1.c();
          t1 = space();
          create_component(button0.$$.fragment);
          t2 = space();
          if (if_block2) if_block2.c();
          t3 = space();
          if (if_block3) if_block3.c();
          t4 = space();
          create_component(button1.$$.fragment);
          t5 = space();
          if (if_block4) if_block4.c();
          attr_dev(div, "class", "acciones-mod panel");
          add_location(div, file$p, 57, 3, 1855);
        },
        m: function mount(target, anchor) {
          if (if_block0) if_block0.m(target, anchor);
          insert_dev(target, t0, anchor);
          insert_dev(target, div, anchor);
          if (if_block1) if_block1.m(div, null);
          append_dev(div, t1);
          mount_component(button0, div, null);
          append_dev(div, t2);
          if (if_block2) if_block2.m(div, null);
          append_dev(div, t3);
          if (if_block3) if_block3.m(div, null);
          append_dev(div, t4);
          mount_component(button1, div, null);
          append_dev(div, t5);
          if (if_block4) if_block4.m(div, null);
          current = true;
        },
        p: function update(ctx, dirty) {
          if (
          /*hilo*/
          ctx[0].estado == 2) {
            if (if_block0) ; else {
              if_block0 = create_if_block_5$3(ctx);
              if_block0.c();
              if_block0.m(t0.parentNode, t0);
            }
          } else if (if_block0) {
            if_block0.d(1);
            if_block0 = null;
          }

          if (
          /*$globalStore*/
          ctx[4].usuario.esMod) {
            if (if_block1) {
              if_block1.p(ctx, dirty);

              if (dirty &
              /*$globalStore*/
              16) {
                transition_in(if_block1, 1);
              }
            } else {
              if_block1 = create_if_block_4$4(ctx);
              if_block1.c();
              transition_in(if_block1, 1);
              if_block1.m(div, t1);
            }
          } else if (if_block1) {
            group_outros();
            transition_out(if_block1, 1, 1, () => {
              if_block1 = null;
            });
            check_outros();
          }

          const button0_changes = {};

          if (dirty &
          /*$$scope*/
          262144) {
            button0_changes.$$scope = {
              dirty,
              ctx
            };
          }

          button0.$set(button0_changes);

          if (
          /*hilo*/
          ctx[0].estado != HiloEstado.eliminado) {
            if (if_block2) {
              if_block2.p(ctx, dirty);

              if (dirty &
              /*hilo*/
              1) {
                transition_in(if_block2, 1);
              }
            } else {
              if_block2 = create_if_block_3$8(ctx);
              if_block2.c();
              transition_in(if_block2, 1);
              if_block2.m(div, t3);
            }
          } else if (if_block2) {
            group_outros();
            transition_out(if_block2, 1, 1, () => {
              if_block2 = null;
            });
            check_outros();
          }

          if (
          /*hilo*/
          ctx[0].estado == HiloEstado.eliminado) {
            if (if_block3) {
              if_block3.p(ctx, dirty);

              if (dirty &
              /*hilo*/
              1) {
                transition_in(if_block3, 1);
              }
            } else {
              if_block3 = create_if_block_2$e(ctx);
              if_block3.c();
              transition_in(if_block3, 1);
              if_block3.m(div, t4);
            }
          } else if (if_block3) {
            group_outros();
            transition_out(if_block3, 1, 1, () => {
              if_block3 = null;
            });
            check_outros();
          }

          const button1_changes = {};

          if (dirty &
          /*$$scope*/
          262144) {
            button1_changes.$$scope = {
              dirty,
              ctx
            };
          }

          button1.$set(button1_changes);

          if (
          /*$globalStore*/
          ctx[4].usuario.esAdmin) {
            if (if_block4) {
              if_block4.p(ctx, dirty);

              if (dirty &
              /*$globalStore*/
              16) {
                transition_in(if_block4, 1);
              }
            } else {
              if_block4 = create_if_block_1$f(ctx);
              if_block4.c();
              transition_in(if_block4, 1);
              if_block4.m(div, null);
            }
          } else if (if_block4) {
            group_outros();
            transition_out(if_block4, 1, 1, () => {
              if_block4 = null;
            });
            check_outros();
          }
        },
        i: function intro(local) {
          if (current) return;
          transition_in(if_block1);
          transition_in(button0.$$.fragment, local);
          transition_in(if_block2);
          transition_in(if_block3);
          transition_in(button1.$$.fragment, local);
          transition_in(if_block4);
          current = true;
        },
        o: function outro(local) {
          transition_out(if_block1);
          transition_out(button0.$$.fragment, local);
          transition_out(if_block2);
          transition_out(if_block3);
          transition_out(button1.$$.fragment, local);
          transition_out(if_block4);
          current = false;
        },
        d: function destroy(detaching) {
          if (if_block0) if_block0.d(detaching);
          if (detaching) detach_dev(t0);
          if (detaching) detach_dev(div);
          if (if_block1) if_block1.d();
          destroy_component(button0);
          if (if_block2) if_block2.d();
          if (if_block3) if_block3.d();
          destroy_component(button1);
          if (if_block4) if_block4.d();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block$m.name,
        type: "if",
        source: "(52:2) {#if $globalStore.usuario.esMod || $globalStore.usuario.esAuxiliar}",
        ctx
      });
      return block;
    } // (53:3) {#if hilo.estado == 2}


    function create_if_block_5$3(ctx) {
      let span;
      const block = {
        c: function create() {
          span = element("span");
          span.textContent = "Este roz esta eliminado y pronto sera borrado";
          set_style(span, "color", "red");
          add_location(span, file$p, 53, 4, 1751);
        },
        m: function mount(target, anchor) {
          insert_dev(target, span, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(span);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_5$3.name,
        type: "if",
        source: "(53:3) {#if hilo.estado == 2}",
        ctx
      });
      return block;
    } // (59:4) {#if $globalStore.usuario.esMod}


    function create_if_block_4$4(ctx) {
      let dialogo;
      let current;
      dialogo = new Dialogo({
        props: {
          textoActivador: "Sticky",
          titulo: "Configurar Sticky",
          accion:
          /*dialogs*/
          ctx[3].sticky.accion,
          $$slots: {
            body: [create_body_slot$3]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          create_component(dialogo.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(dialogo, target, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          const dialogo_changes = {};
          if (dirty &
          /*dialogs*/
          8) dialogo_changes.accion =
          /*dialogs*/
          ctx[3].sticky.accion;

          if (dirty &
          /*$$scope, dialogs*/
          262152) {
            dialogo_changes.$$scope = {
              dirty,
              ctx
            };
          }

          dialogo.$set(dialogo_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(dialogo.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(dialogo.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(dialogo, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_4$4.name,
        type: "if",
        source: "(59:4) {#if $globalStore.usuario.esMod}",
        ctx
      });
      return block;
    } // (70:7) <Checkbox bind:checked={dialogs.sticky.global}>


    function create_default_slot_6$5(ctx) {
      let span;
      const block = {
        c: function create() {
          span = element("span");
          span.textContent = "Global";
          add_location(span, file$p, 70, 8, 2242);
        },
        m: function mount(target, anchor) {
          insert_dev(target, span, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(span);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_6$5.name,
        type: "slot",
        source: "(70:7) <Checkbox bind:checked={dialogs.sticky.global}>",
        ctx
      });
      return block;
    } // (65:6) <div slot="body">


    function create_body_slot$3(ctx) {
      let div;
      let p0;
      let t1;
      let checkbox;
      let updating_checked;
      let t2;
      let p1;
      let t4;
      let textfield;
      let updating_value;
      let current;

      function checkbox_checked_binding(value) {
        /*checkbox_checked_binding*/
        ctx[10].call(null, value);
      }

      let checkbox_props = {
        $$slots: {
          default: [create_default_slot_6$5]
        },
        $$scope: {
          ctx
        }
      };

      if (
      /*dialogs*/
      ctx[3].sticky.global !== void 0) {
        checkbox_props.checked =
        /*dialogs*/
        ctx[3].sticky.global;
      }

      checkbox = new Ne({
        props: checkbox_props,
        $$inline: true
      });
      binding_callbacks.push(() => bind(checkbox, "checked", checkbox_checked_binding));

      function textfield_value_binding(value) {
        /*textfield_value_binding*/
        ctx[11].call(null, value);
      }

      let textfield_props = {
        autocomplete: "off",
        label: "Importancia",
        type: "number",
        required: true,
        message: ""
      };

      if (
      /*dialogs*/
      ctx[3].sticky.importancia !== void 0) {
        textfield_props.value =
        /*dialogs*/
        ctx[3].sticky.importancia;
      }

      textfield = new Ve({
        props: textfield_props,
        $$inline: true
      });
      binding_callbacks.push(() => bind(textfield, "value", textfield_value_binding));
      const block = {
        c: function create() {
          div = element("div");
          p0 = element("p");
          p0.textContent = "(Los stickies no globales solo aparecen en su\r\n\t\t\t\t\t\t\t\tcategoria)";
          t1 = space();
          create_component(checkbox.$$.fragment);
          t2 = space();
          p1 = element("p");
          p1.textContent = "(Un sticky de importancia 2 sale primero que un\r\n\t\t\t\t\t\t\t\tsticky de importancia 1 )";
          t4 = space();
          create_component(textfield.$$.fragment);
          add_location(p0, file$p, 65, 7, 2085);
          add_location(p1, file$p, 72, 7, 2290);
          attr_dev(div, "slot", "body");
          add_location(div, file$p, 64, 6, 2059);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          append_dev(div, p0);
          append_dev(div, t1);
          mount_component(checkbox, div, null);
          append_dev(div, t2);
          append_dev(div, p1);
          append_dev(div, t4);
          mount_component(textfield, div, null);
          current = true;
        },
        p: function update(ctx, dirty) {
          const checkbox_changes = {};

          if (dirty &
          /*$$scope*/
          262144) {
            checkbox_changes.$$scope = {
              dirty,
              ctx
            };
          }

          if (!updating_checked && dirty &
          /*dialogs*/
          8) {
            updating_checked = true;
            checkbox_changes.checked =
            /*dialogs*/
            ctx[3].sticky.global;
            add_flush_callback(() => updating_checked = false);
          }

          checkbox.$set(checkbox_changes);
          const textfield_changes = {};

          if (!updating_value && dirty &
          /*dialogs*/
          8) {
            updating_value = true;
            textfield_changes.value =
            /*dialogs*/
            ctx[3].sticky.importancia;
            add_flush_callback(() => updating_value = false);
          }

          textfield.$set(textfield_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(checkbox.$$.fragment, local);
          transition_in(textfield.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(checkbox.$$.fragment, local);
          transition_out(textfield.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
          destroy_component(checkbox);
          destroy_component(textfield);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_body_slot$3.name,
        type: "slot",
        source: "(65:6) <div slot=\\\"body\\\">",
        ctx
      });
      return block;
    } // (88:4) <Button on:click={() => abrir.cambiarCategoria(hilo.id)}       >


    function create_default_slot_4$a(ctx) {
      let t;
      const block = {
        c: function create() {
          t = text("Categoria");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_4$a.name,
        type: "slot",
        source: "(88:4) <Button on:click={() => abrir.cambiarCategoria(hilo.id)}       >",
        ctx
      });
      return block;
    } // (91:4) {#if hilo.estado != HiloEstado.eliminado}


    function create_if_block_3$8(ctx) {
      let button;
      let current;
      button = new ye({
        props: {
          $$slots: {
            default: [create_default_slot_3$d]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      button.$on("click",
      /*click_handler_1*/
      ctx[13]);
      const block = {
        c: function create() {
          create_component(button.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(button, target, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          const button_changes = {};

          if (dirty &
          /*$$scope*/
          262144) {
            button_changes.$$scope = {
              dirty,
              ctx
            };
          }

          button.$set(button_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(button.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(button.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(button, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_3$8.name,
        type: "if",
        source: "(91:4) {#if hilo.estado != HiloEstado.eliminado}",
        ctx
      });
      return block;
    } // (92:5) <Button on:click={() => abrir.eliminarHilo(hilo.id)}        >


    function create_default_slot_3$d(ctx) {
      let t;
      const block = {
        c: function create() {
          t = text("Eliminar");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_3$d.name,
        type: "slot",
        source: "(92:5) <Button on:click={() => abrir.eliminarHilo(hilo.id)}        >",
        ctx
      });
      return block;
    } // (96:4) {#if hilo.estado == HiloEstado.eliminado}


    function create_if_block_2$e(ctx) {
      let button;
      let current;
      button = new ye({
        props: {
          $$slots: {
            default: [create_default_slot_2$d]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      button.$on("click",
      /*click_handler_2*/
      ctx[14]);
      const block = {
        c: function create() {
          create_component(button.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(button, target, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          const button_changes = {};

          if (dirty &
          /*$$scope*/
          262144) {
            button_changes.$$scope = {
              dirty,
              ctx
            };
          }

          button.$set(button_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(button.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(button.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(button, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_2$e.name,
        type: "if",
        source: "(96:4) {#if hilo.estado == HiloEstado.eliminado}",
        ctx
      });
      return block;
    } // (97:5) <Button on:click={() => abrir.restaurarHilo(hilo.id)}        >


    function create_default_slot_2$d(ctx) {
      let t;
      const block = {
        c: function create() {
          t = text("Restaurar");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_2$d.name,
        type: "slot",
        source: "(97:5) <Button on:click={() => abrir.restaurarHilo(hilo.id)}        >",
        ctx
      });
      return block;
    } // (101:4) <Button on:click={() => abrir.ban(hilo.id)}>


    function create_default_slot_1$e(ctx) {
      let t;
      const block = {
        c: function create() {
          t = text("Banear");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_1$e.name,
        type: "slot",
        source: "(101:4) <Button on:click={() => abrir.ban(hilo.id)}>",
        ctx
      });
      return block;
    } // (102:4) {#if $globalStore.usuario.esAdmin}


    function create_if_block_1$f(ctx) {
      let a;
      let button;
      let a_href_value;
      let current;
      button = new ye({
        props: {
          $$slots: {
            default: [create_default_slot$f]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          a = element("a");
          create_component(button.$$.fragment);
          attr_dev(a, "href", a_href_value = "/Moderacion/HistorialDeUsuario/" +
          /*usuario*/
          ctx[5].id);
          attr_dev(a, "class", "svelte-ebhz15");
          add_location(a, file$p, 102, 5, 3145);
        },
        m: function mount(target, anchor) {
          insert_dev(target, a, anchor);
          mount_component(button, a, null);
          current = true;
        },
        p: function update(ctx, dirty) {
          const button_changes = {};

          if (dirty &
          /*$$scope*/
          262144) {
            button_changes.$$scope = {
              dirty,
              ctx
            };
          }

          button.$set(button_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(button.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(button.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(a);
          destroy_component(button);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_1$f.name,
        type: "if",
        source: "(102:4) {#if $globalStore.usuario.esAdmin}",
        ctx
      });
      return block;
    } // (104:6) <Button>


    function create_default_slot$f(ctx) {
      let t;
      const block = {
        c: function create() {
          t = text("Op");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot$f.name,
        type: "slot",
        source: "(104:6) <Button>",
        ctx
      });
      return block;
    }

    function create_fragment$p(ctx) {
      let div2;
      let div1;
      let div0;
      let a0;
      let t1;
      let a1;
      let t2;
      let t3_value = config.categoriaPorId(
      /*hilo*/
      ctx[0].categoriaId).nombre + "";
      let t3;
      let a1_href_value;
      let t4;
      let acciones_1;
      let updating_hilo;
      let updating_acciones;
      let t5;
      let t6;
      let t7;
      let hilocuerpo;
      let t8;
      let comentarios_1;
      let updating_comentarios;
      let div2_r_id_value;
      let current;

      function acciones_1_hilo_binding(value) {
        /*acciones_1_hilo_binding*/
        ctx[7].call(null, value);
      }

      function acciones_1_acciones_binding(value) {
        /*acciones_1_acciones_binding*/
        ctx[8].call(null, value);
      }

      let acciones_1_props = {};

      if (
      /*hilo*/
      ctx[0] !== void 0) {
        acciones_1_props.hilo =
        /*hilo*/
        ctx[0];
      }

      if (
      /*acciones*/
      ctx[2] !== void 0) {
        acciones_1_props.acciones =
        /*acciones*/
        ctx[2];
      }

      acciones_1 = new Acciones({
        props: acciones_1_props,
        $$inline: true
      });
      binding_callbacks.push(() => bind(acciones_1, "hilo", acciones_1_hilo_binding));
      binding_callbacks.push(() => bind(acciones_1, "acciones", acciones_1_acciones_binding));
      let if_block0 =
      /*hilo*/
      ctx[0].encuestaData && create_if_block_6$2(ctx);
      let if_block1 = (
      /*$globalStore*/
      ctx[4].usuario.esMod ||
      /*$globalStore*/
      ctx[4].usuario.esAuxiliar) && create_if_block$m(ctx);
      hilocuerpo = new HiloCuerpo({
        props: {
          hilo:
          /*hilo*/
          ctx[0]
        },
        $$inline: true
      });

      function comentarios_1_comentarios_binding(value) {
        /*comentarios_1_comentarios_binding*/
        ctx[16].call(null, value);
      }

      let comentarios_1_props = {
        hilo:
        /*hilo*/
        ctx[0],
        spams:
        /*spams*/
        ctx[6]
      };

      if (
      /*comentarios*/
      ctx[1] !== void 0) {
        comentarios_1_props.comentarios =
        /*comentarios*/
        ctx[1];
      }

      comentarios_1 = new Comentarios({
        props: comentarios_1_props,
        $$inline: true
      });
      binding_callbacks.push(() => bind(comentarios_1, "comentarios", comentarios_1_comentarios_binding));
      const block = {
        c: function create() {
          div2 = element("div");
          div1 = element("div");
          div0 = element("div");
          a0 = element("a");
          a0.textContent = `${config.nombre}`;
          t1 = space();
          a1 = element("a");
          t2 = text("/");
          t3 = text(t3_value);
          t4 = space();
          create_component(acciones_1.$$.fragment);
          t5 = space();
          if (if_block0) if_block0.c();
          t6 = space();
          if (if_block1) if_block1.c();
          t7 = space();
          create_component(hilocuerpo.$$.fragment);
          t8 = space();
          create_component(comentarios_1.$$.fragment);
          attr_dev(a0, "href", "/");
          attr_dev(a0, "class", "svelte-ebhz15");
          add_location(a0, file$p, 40, 3, 1324);
          attr_dev(a1, "href", a1_href_value = "/" + config.categoriaPorId(
          /*hilo*/
          ctx[0].categoriaId).nombreCorto);
          attr_dev(a1, "class", "svelte-ebhz15");
          add_location(a1, file$p, 41, 3, 1360);
          attr_dev(div0, "class", "panel");
          add_location(div0, file$p, 39, 2, 1300);
          attr_dev(div1, "class", "contenido");
          add_location(div1, file$p, 38, 1, 1273);
          attr_dev(div2, "class", "hilo-completo svelte-ebhz15");
          attr_dev(div2, "r-id", div2_r_id_value =
          /*hilo*/
          ctx[0].id);
          add_location(div2, file$p, 37, 0, 1228);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, div2, anchor);
          append_dev(div2, div1);
          append_dev(div1, div0);
          append_dev(div0, a0);
          append_dev(div0, t1);
          append_dev(div0, a1);
          append_dev(a1, t2);
          append_dev(a1, t3);
          append_dev(div1, t4);
          mount_component(acciones_1, div1, null);
          append_dev(div1, t5);
          if (if_block0) if_block0.m(div1, null);
          append_dev(div1, t6);
          if (if_block1) if_block1.m(div1, null);
          append_dev(div1, t7);
          mount_component(hilocuerpo, div1, null);
          append_dev(div2, t8);
          mount_component(comentarios_1, div2, null);
          current = true;
        },
        p: function update(ctx, [dirty]) {
          if ((!current || dirty &
          /*hilo*/
          1) && t3_value !== (t3_value = config.categoriaPorId(
          /*hilo*/
          ctx[0].categoriaId).nombre + "")) set_data_dev(t3, t3_value);

          if (!current || dirty &
          /*hilo*/
          1 && a1_href_value !== (a1_href_value = "/" + config.categoriaPorId(
          /*hilo*/
          ctx[0].categoriaId).nombreCorto)) {
            attr_dev(a1, "href", a1_href_value);
          }

          const acciones_1_changes = {};

          if (!updating_hilo && dirty &
          /*hilo*/
          1) {
            updating_hilo = true;
            acciones_1_changes.hilo =
            /*hilo*/
            ctx[0];
            add_flush_callback(() => updating_hilo = false);
          }

          if (!updating_acciones && dirty &
          /*acciones*/
          4) {
            updating_acciones = true;
            acciones_1_changes.acciones =
            /*acciones*/
            ctx[2];
            add_flush_callback(() => updating_acciones = false);
          }

          acciones_1.$set(acciones_1_changes);

          if (
          /*hilo*/
          ctx[0].encuestaData) {
            if (if_block0) {
              if_block0.p(ctx, dirty);

              if (dirty &
              /*hilo*/
              1) {
                transition_in(if_block0, 1);
              }
            } else {
              if_block0 = create_if_block_6$2(ctx);
              if_block0.c();
              transition_in(if_block0, 1);
              if_block0.m(div1, t6);
            }
          } else if (if_block0) {
            group_outros();
            transition_out(if_block0, 1, 1, () => {
              if_block0 = null;
            });
            check_outros();
          }

          if (
          /*$globalStore*/
          ctx[4].usuario.esMod ||
          /*$globalStore*/
          ctx[4].usuario.esAuxiliar) {
            if (if_block1) {
              if_block1.p(ctx, dirty);

              if (dirty &
              /*$globalStore*/
              16) {
                transition_in(if_block1, 1);
              }
            } else {
              if_block1 = create_if_block$m(ctx);
              if_block1.c();
              transition_in(if_block1, 1);
              if_block1.m(div1, t7);
            }
          } else if (if_block1) {
            group_outros();
            transition_out(if_block1, 1, 1, () => {
              if_block1 = null;
            });
            check_outros();
          }

          const hilocuerpo_changes = {};
          if (dirty &
          /*hilo*/
          1) hilocuerpo_changes.hilo =
          /*hilo*/
          ctx[0];
          hilocuerpo.$set(hilocuerpo_changes);
          const comentarios_1_changes = {};
          if (dirty &
          /*hilo*/
          1) comentarios_1_changes.hilo =
          /*hilo*/
          ctx[0];

          if (!updating_comentarios && dirty &
          /*comentarios*/
          2) {
            updating_comentarios = true;
            comentarios_1_changes.comentarios =
            /*comentarios*/
            ctx[1];
            add_flush_callback(() => updating_comentarios = false);
          }

          comentarios_1.$set(comentarios_1_changes);

          if (!current || dirty &
          /*hilo*/
          1 && div2_r_id_value !== (div2_r_id_value =
          /*hilo*/
          ctx[0].id)) {
            attr_dev(div2, "r-id", div2_r_id_value);
          }
        },
        i: function intro(local) {
          if (current) return;
          transition_in(acciones_1.$$.fragment, local);
          transition_in(if_block0);
          transition_in(if_block1);
          transition_in(hilocuerpo.$$.fragment, local);
          transition_in(comentarios_1.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(acciones_1.$$.fragment, local);
          transition_out(if_block0);
          transition_out(if_block1);
          transition_out(hilocuerpo.$$.fragment, local);
          transition_out(comentarios_1.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div2);
          destroy_component(acciones_1);
          if (if_block0) if_block0.d();
          if (if_block1) if_block1.d();
          destroy_component(hilocuerpo);
          destroy_component(comentarios_1);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$p.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }

    function instance$p($$self, $$props, $$invalidate) {
      let $globalStore;
      validate_store(globalStore, "globalStore");
      component_subscribe($$self, globalStore, $$value => $$invalidate(4, $globalStore = $$value));
      let {
        $$slots: slots = {},
        $$scope
      } = $$props;
      validate_slots("App", slots, []);
      let data = window.data || dataEjemplo;
      let {
        hilo,
        comentarios,
        acciones,
        usuario,
        spams
      } = data;
      let dialogs = {
        sticky: {
          global: true,
          importancia: 1,

          async accion() {
            return await RChanClient.añadirSticky(hilo.id, dialogs.sticky.global, dialogs.sticky.importancia);
          }

        },
        categoria: {
          categoriaId: hilo.categoriaId
        }
      };
      const writable_props = [];
      Object.keys($$props).forEach(key => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<App> was created with unknown prop '${key}'`);
      });

      function acciones_1_hilo_binding(value) {
        hilo = value;
        $$invalidate(0, hilo);
      }

      function acciones_1_acciones_binding(value) {
        acciones = value;
        $$invalidate(2, acciones);
      }

      function encuesta_encuesta_binding(value) {
        hilo.encuestaData = value;
        $$invalidate(0, hilo);
      }

      function checkbox_checked_binding(value) {
        dialogs.sticky.global = value;
        $$invalidate(3, dialogs);
      }

      function textfield_value_binding(value) {
        dialogs.sticky.importancia = value;
        $$invalidate(3, dialogs);
      }

      const click_handler = () => abrir.cambiarCategoria(hilo.id);

      const click_handler_1 = () => abrir.eliminarHilo(hilo.id);

      const click_handler_2 = () => abrir.restaurarHilo(hilo.id);

      const click_handler_3 = () => abrir.ban(hilo.id);

      function comentarios_1_comentarios_binding(value) {
        comentarios = value;
        $$invalidate(1, comentarios);
      }

      $$self.$capture_state = () => ({
        Comentarios,
        Acciones,
        Tiempo,
        Button: ye,
        Dialog: pn,
        Checkbox: Ne,
        Textfield: Ve,
        config,
        RChanClient,
        ErrorValidacion,
        globalStore,
        Dialogo,
        Media,
        HiloCuerpo,
        abrir,
        Encuesta,
        HiloEstado,
        onMount,
        tick,
        data,
        hilo,
        comentarios,
        acciones,
        usuario,
        spams,
        dialogs,
        $globalStore
      });

      $$self.$inject_state = $$props => {
        if ("data" in $$props) data = $$props.data;
        if ("hilo" in $$props) $$invalidate(0, hilo = $$props.hilo);
        if ("comentarios" in $$props) $$invalidate(1, comentarios = $$props.comentarios);
        if ("acciones" in $$props) $$invalidate(2, acciones = $$props.acciones);
        if ("usuario" in $$props) $$invalidate(5, usuario = $$props.usuario);
        if ("spams" in $$props) $$invalidate(6, spams = $$props.spams);
        if ("dialogs" in $$props) $$invalidate(3, dialogs = $$props.dialogs);
      };

      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }

      return [hilo, comentarios, acciones, dialogs, $globalStore, usuario, spams, acciones_1_hilo_binding, acciones_1_acciones_binding, encuesta_encuesta_binding, checkbox_checked_binding, textfield_value_binding, click_handler, click_handler_1, click_handler_2, click_handler_3, comentarios_1_comentarios_binding];
    }

    class App extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$p, create_fragment$p, safe_not_equal, {});
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "App",
          options,
          id: create_fragment$p.name
        });
      }

    }

    /* src\components\Captcha.svelte generated by Svelte v3.29.0 */
    const file$q = "src\\components\\Captcha.svelte"; // (27:0) {#if visible}

    function create_if_block$n(ctx) {
      let div;
      let div_data_sitekey_value;
      const block = {
        c: function create() {
          div = element("div");
          attr_dev(div, "class", "h-captcha svelte-f95t63");
          attr_dev(div, "id", "super-captcha");
          set_style(div, "display", "flex");
          attr_dev(div, "data-callback", "onCaptcha");
          attr_dev(div, "data-theme", "dark");
          attr_dev(div, "data-sitekey", div_data_sitekey_value = window.config.hCaptchaSiteKey);
          add_location(div, file$q, 27, 4, 623);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
        },
        p: noop,
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block$n.name,
        type: "if",
        source: "(27:0) {#if visible}",
        ctx
      });
      return block;
    }

    function create_fragment$q(ctx) {
      let if_block_anchor;
      let if_block =
      /*visible*/
      ctx[0] && create_if_block$n(ctx);
      const block = {
        c: function create() {
          if (if_block) if_block.c();
          if_block_anchor = empty();
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          if (if_block) if_block.m(target, anchor);
          insert_dev(target, if_block_anchor, anchor);
        },
        p: function update(ctx, [dirty]) {
          if (
          /*visible*/
          ctx[0]) {
            if (if_block) {
              if_block.p(ctx, dirty);
            } else {
              if_block = create_if_block$n(ctx);
              if_block.c();
              if_block.m(if_block_anchor.parentNode, if_block_anchor);
            }
          } else if (if_block) {
            if_block.d(1);
            if_block = null;
          }
        },
        i: noop,
        o: noop,
        d: function destroy(detaching) {
          if (if_block) if_block.d(detaching);
          if (detaching) detach_dev(if_block_anchor);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$q.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }

    function cargarCaptcha() {
      window.hcaptcha.render("super-captcha", {
        "theme": "dark",
        "sitekey": window.config.hCaptchaSiteKey
      });
    }

    function instance$q($$self, $$props, $$invalidate) {
      let $globalStore;
      validate_store(globalStore, "globalStore");
      component_subscribe($$self, globalStore, $$value => $$invalidate(2, $globalStore = $$value));
      let {
        $$slots: slots = {},
        $$scope
      } = $$props;
      validate_slots("Captcha", slots, []);
      let {
        token
      } = $$props;
      let {
        visible = true
      } = $$props;
      if ($globalStore.usuario.estaAutenticado && $globalStore.usuario.esMod) visible = false;
      onMount(() => {
        if (window.hcaptcha) cargarCaptcha();else setTimeout(cargarCaptcha, 500);
      });

      window.onCaptcha = e => {
        $$invalidate(1, token = e);
      };

      const writable_props = ["token", "visible"];
      Object.keys($$props).forEach(key => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Captcha> was created with unknown prop '${key}'`);
      });

      $$self.$$set = $$props => {
        if ("token" in $$props) $$invalidate(1, token = $$props.token);
        if ("visible" in $$props) $$invalidate(0, visible = $$props.visible);
      };

      $$self.$capture_state = () => ({
        onMount,
        globalStore,
        token,
        visible,
        cargarCaptcha,
        $globalStore
      });

      $$self.$inject_state = $$props => {
        if ("token" in $$props) $$invalidate(1, token = $$props.token);
        if ("visible" in $$props) $$invalidate(0, visible = $$props.visible);
      };

      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }

      return [visible, token];
    }

    class Captcha extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$q, create_fragment$q, safe_not_equal, {
          token: 1,
          visible: 0
        });
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "Captcha",
          options,
          id: create_fragment$q.name
        });
        const {
          ctx
        } = this.$$;
        const props = options.props || {};

        if (
        /*token*/
        ctx[1] === undefined && !("token" in props)) {
          console.warn("<Captcha> was created without expected prop 'token'");
        }
      }

      get token() {
        throw new Error("<Captcha>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set token(value) {
        throw new Error("<Captcha>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get visible() {
        throw new Error("<Captcha>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set visible(value) {
        throw new Error("<Captcha>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

    }

    /* src\components\Hilos\FormularioEncuesta.svelte generated by Svelte v3.29.0 */
    const {
      console: console_1$4
    } = globals;
    const file$r = "src\\components\\Hilos\\FormularioEncuesta.svelte";

    function get_each_context$c(ctx, list, i) {
      const child_ctx = ctx.slice();
      child_ctx[12] = list[i];
      return child_ctx;
    } // (43:4) {#if estado == 0  || estado == 1}


    function create_if_block_5$4(ctx) {
      let button;
      let current;
      button = new ye({
        props: {
          $$slots: {
            default: [create_default_slot_5$7]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      button.$on("click",
      /*click_handler*/
      ctx[8]);
      const block = {
        c: function create() {
          create_component(button.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(button, target, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          const button_changes = {};

          if (dirty &
          /*$$scope*/
          32768) {
            button_changes.$$scope = {
              dirty,
              ctx
            };
          }

          button.$set(button_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(button.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(button.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(button, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_5$4.name,
        type: "if",
        source: "(43:4) {#if estado == 0  || estado == 1}",
        ctx
      });
      return block;
    } // (44:8) <Button on:click={() => estado = 1}>


    function create_default_slot_5$7(ctx) {
      let icon;
      const block = {
        c: function create() {
          icon = element("icon");
          attr_dev(icon, "class", "fe fe-bar-chart-2");
          set_style(icon, "font-size", "1.2rem");
          add_location(icon, file$r, 43, 44, 1138);
        },
        m: function mount(target, anchor) {
          insert_dev(target, icon, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(icon);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_5$7.name,
        type: "slot",
        source: "(44:8) <Button on:click={() => estado = 1}>",
        ctx
      });
      return block;
    } // (46:4) {#if estado == 2}


    function create_if_block_4$5(ctx) {
      let button;
      let current;
      button = new ye({
        props: {
          color: "var(--color5)",
          $$slots: {
            default: [create_default_slot_4$b]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      button.$on("click",
      /*cancelar*/
      ctx[6]);
      const block = {
        c: function create() {
          create_component(button.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(button, target, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          const button_changes = {};

          if (dirty &
          /*$$scope*/
          32768) {
            button_changes.$$scope = {
              dirty,
              ctx
            };
          }

          button.$set(button_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(button.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(button.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(button, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_4$5.name,
        type: "if",
        source: "(46:4) {#if estado == 2}",
        ctx
      });
      return block;
    } // (47:8) <Button color="var(--color5)" on:click={cancelar}>


    function create_default_slot_4$b(ctx) {
      let icon;
      const block = {
        c: function create() {
          icon = element("icon");
          attr_dev(icon, "class", "fe fe-bar-chart-2");
          set_style(icon, "font-size", "1.2rem");
          add_location(icon, file$r, 46, 58, 1304);
        },
        m: function mount(target, anchor) {
          insert_dev(target, icon, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(icon);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_4$b.name,
        type: "slot",
        source: "(47:8) <Button color=\\\"var(--color5)\\\" on:click={cancelar}>",
        ctx
      });
      return block;
    } // (51:0) {#if estado == 1}


    function create_if_block$o(ctx) {
      let dialog;
      let current;
      dialog = new pn({
        props: {
          visible: true,
          $$slots: {
            default: [create_default_slot$g],
            title: [create_title_slot$5]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          create_component(dialog.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(dialog, target, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          const dialog_changes = {};

          if (dirty &
          /*$$scope, opciones, opcionNueva, opcionesArray*/
          32781) {
            dialog_changes.$$scope = {
              dirty,
              ctx
            };
          }

          dialog.$set(dialog_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(dialog.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(dialog.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(dialog, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block$o.name,
        type: "if",
        source: "(51:0) {#if estado == 1}",
        ctx
      });
      return block;
    } // (53:8) <div slot="title">


    function create_title_slot$5(ctx) {
      let div;
      let t0;
      let t1_value =
      /*opciones*/
      ctx[0].size + "";
      let t1;
      let t2;
      let t3;
      let t4;
      const block = {
        c: function create() {
          div = element("div");
          t0 = text("Opciones (");
          t1 = text(t1_value);
          t2 = text("/");
          t3 = text(limiteOpciones);
          t4 = text(")");
          attr_dev(div, "slot", "title");
          add_location(div, file$r, 52, 8, 1453);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          append_dev(div, t0);
          append_dev(div, t1);
          append_dev(div, t2);
          append_dev(div, t3);
          append_dev(div, t4);
        },
        p: function update(ctx, dirty) {
          if (dirty &
          /*opciones*/
          1 && t1_value !== (t1_value =
          /*opciones*/
          ctx[0].size + "")) set_data_dev(t1, t1_value);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_title_slot$5.name,
        type: "slot",
        source: "(53:8) <div slot=\\\"title\\\">",
        ctx
      });
      return block;
    } // (55:12) {#each opcionesArray as o}


    function create_each_block$c(ctx) {
      let li;
      let t0_value =
      /*o*/
      ctx[12] + "";
      let t0;
      let t1;
      let ripple;
      let current;
      let mounted;
      let dispose;
      ripple = new he({
        $$inline: true
      });

      function click_handler_1(...args) {
        return (
          /*click_handler_1*/
          ctx[9](
          /*o*/
          ctx[12], ...args)
        );
      }

      const block = {
        c: function create() {
          li = element("li");
          t0 = text(t0_value);
          t1 = space();
          create_component(ripple.$$.fragment);
          attr_dev(li, "class", "svelte-1ftt6i3");
          add_location(li, file$r, 55, 16, 1589);
        },
        m: function mount(target, anchor) {
          insert_dev(target, li, anchor);
          append_dev(li, t0);
          append_dev(li, t1);
          mount_component(ripple, li, null);
          current = true;

          if (!mounted) {
            dispose = listen_dev(li, "click", click_handler_1, false, false, false);
            mounted = true;
          }
        },
        p: function update(new_ctx, dirty) {
          ctx = new_ctx;
          if ((!current || dirty &
          /*opcionesArray*/
          4) && t0_value !== (t0_value =
          /*o*/
          ctx[12] + "")) set_data_dev(t0, t0_value);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(ripple.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(ripple.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(li);
          destroy_component(ripple);
          mounted = false;
          dispose();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_each_block$c.name,
        type: "each",
        source: "(55:12) {#each opcionesArray as o}",
        ctx
      });
      return block;
    } // (59:8) {#if opciones.size < 6}


    function create_if_block_3$9(ctx) {
      let input;
      let mounted;
      let dispose;
      const block = {
        c: function create() {
          input = element("input");
          attr_dev(input, "type", "text");
          attr_dev(input, "placeholder", "Añadir opcion");
          add_location(input, file$r, 59, 12, 1718);
        },
        m: function mount(target, anchor) {
          insert_dev(target, input, anchor);
          set_input_value(input,
          /*opcionNueva*/
          ctx[3]);

          if (!mounted) {
            dispose = listen_dev(input, "input",
            /*input_input_handler*/
            ctx[10]);
            mounted = true;
          }
        },
        p: function update(ctx, dirty) {
          if (dirty &
          /*opcionNueva*/
          8 && input.value !==
          /*opcionNueva*/
          ctx[3]) {
            set_input_value(input,
            /*opcionNueva*/
            ctx[3]);
          }
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(input);
          mounted = false;
          dispose();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_3$9.name,
        type: "if",
        source: "(59:8) {#if opciones.size < 6}",
        ctx
      });
      return block;
    } // (65:12) {:else}


    function create_else_block$5(ctx) {
      let button;
      let current;
      button = new ye({
        props: {
          color: "primary",
          $$slots: {
            default: [create_default_slot_3$e]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      button.$on("click",
      /*cancelar*/
      ctx[6]);
      const block = {
        c: function create() {
          create_component(button.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(button, target, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          const button_changes = {};

          if (dirty &
          /*$$scope*/
          32768) {
            button_changes.$$scope = {
              dirty,
              ctx
            };
          }

          button.$set(button_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(button.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(button.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(button, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_else_block$5.name,
        type: "else",
        source: "(65:12) {:else}",
        ctx
      });
      return block;
    } // (63:12) {#if opciones.size > 1}


    function create_if_block_2$f(ctx) {
      let button;
      let current;
      button = new ye({
        props: {
          color: "primary",
          $$slots: {
            default: [create_default_slot_2$e]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      button.$on("click",
      /*aceptar*/
      ctx[7]);
      const block = {
        c: function create() {
          create_component(button.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(button, target, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          const button_changes = {};

          if (dirty &
          /*$$scope*/
          32768) {
            button_changes.$$scope = {
              dirty,
              ctx
            };
          }

          button.$set(button_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(button.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(button.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(button, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_2$f.name,
        type: "if",
        source: "(63:12) {#if opciones.size > 1}",
        ctx
      });
      return block;
    } // (66:16) <Button color="primary" on:click={cancelar}>


    function create_default_slot_3$e(ctx) {
      let t;
      const block = {
        c: function create() {
          t = text("Cancelar");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_3$e.name,
        type: "slot",
        source: "(66:16) <Button color=\\\"primary\\\" on:click={cancelar}>",
        ctx
      });
      return block;
    } // (64:16) <Button on:click={aceptar} color="primary">


    function create_default_slot_2$e(ctx) {
      let t;
      const block = {
        c: function create() {
          t = text("Aceptar");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_2$e.name,
        type: "slot",
        source: "(64:16) <Button on:click={aceptar} color=\\\"primary\\\">",
        ctx
      });
      return block;
    } // (68:12) {#if opciones.size < 6}


    function create_if_block_1$g(ctx) {
      let button;
      let current;
      button = new ye({
        props: {
          color: "primary",
          $$slots: {
            default: [create_default_slot_1$f]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      button.$on("click",
      /*agregarOpcion*/
      ctx[4]);
      const block = {
        c: function create() {
          create_component(button.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(button, target, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          const button_changes = {};

          if (dirty &
          /*$$scope*/
          32768) {
            button_changes.$$scope = {
              dirty,
              ctx
            };
          }

          button.$set(button_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(button.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(button.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(button, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_1$g.name,
        type: "if",
        source: "(68:12) {#if opciones.size < 6}",
        ctx
      });
      return block;
    } // (69:16) <Button color="primary" on:click={agregarOpcion}>


    function create_default_slot_1$f(ctx) {
      let t;
      const block = {
        c: function create() {
          t = text("Añadir");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_1$f.name,
        type: "slot",
        source: "(69:16) <Button color=\\\"primary\\\" on:click={agregarOpcion}>",
        ctx
      });
      return block;
    } // (52:4) <Dialog visible={true}>


    function create_default_slot$g(ctx) {
      let t0;
      let ul;
      let t1;
      let t2;
      let div;
      let current_block_type_index;
      let if_block1;
      let t3;
      let current;
      let each_value =
      /*opcionesArray*/
      ctx[2];
      validate_each_argument(each_value);
      let each_blocks = [];

      for (let i = 0; i < each_value.length; i += 1) {
        each_blocks[i] = create_each_block$c(get_each_context$c(ctx, each_value, i));
      }

      const out = i => transition_out(each_blocks[i], 1, 1, () => {
        each_blocks[i] = null;
      });

      let if_block0 =
      /*opciones*/
      ctx[0].size < 6 && create_if_block_3$9(ctx);
      const if_block_creators = [create_if_block_2$f, create_else_block$5];
      const if_blocks = [];

      function select_block_type(ctx, dirty) {
        if (
        /*opciones*/
        ctx[0].size > 1) return 0;
        return 1;
      }

      current_block_type_index = select_block_type(ctx);
      if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
      let if_block2 =
      /*opciones*/
      ctx[0].size < 6 && create_if_block_1$g(ctx);
      const block = {
        c: function create() {
          t0 = space();
          ul = element("ul");

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].c();
          }

          t1 = space();
          if (if_block0) if_block0.c();
          t2 = space();
          div = element("div");
          if_block1.c();
          t3 = space();
          if (if_block2) if_block2.c();
          add_location(ul, file$r, 53, 8, 1529);
          set_style(div, "margin-top", "8px");
          add_location(div, file$r, 61, 8, 1813);
        },
        m: function mount(target, anchor) {
          insert_dev(target, t0, anchor);
          insert_dev(target, ul, anchor);

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].m(ul, null);
          }

          insert_dev(target, t1, anchor);
          if (if_block0) if_block0.m(target, anchor);
          insert_dev(target, t2, anchor);
          insert_dev(target, div, anchor);
          if_blocks[current_block_type_index].m(div, null);
          append_dev(div, t3);
          if (if_block2) if_block2.m(div, null);
          current = true;
        },
        p: function update(ctx, dirty) {
          if (dirty &
          /*remover, opcionesArray*/
          36) {
            each_value =
            /*opcionesArray*/
            ctx[2];
            validate_each_argument(each_value);
            let i;

            for (i = 0; i < each_value.length; i += 1) {
              const child_ctx = get_each_context$c(ctx, each_value, i);

              if (each_blocks[i]) {
                each_blocks[i].p(child_ctx, dirty);
                transition_in(each_blocks[i], 1);
              } else {
                each_blocks[i] = create_each_block$c(child_ctx);
                each_blocks[i].c();
                transition_in(each_blocks[i], 1);
                each_blocks[i].m(ul, null);
              }
            }

            group_outros();

            for (i = each_value.length; i < each_blocks.length; i += 1) {
              out(i);
            }

            check_outros();
          }

          if (
          /*opciones*/
          ctx[0].size < 6) {
            if (if_block0) {
              if_block0.p(ctx, dirty);
            } else {
              if_block0 = create_if_block_3$9(ctx);
              if_block0.c();
              if_block0.m(t2.parentNode, t2);
            }
          } else if (if_block0) {
            if_block0.d(1);
            if_block0 = null;
          }

          let previous_block_index = current_block_type_index;
          current_block_type_index = select_block_type(ctx);

          if (current_block_type_index === previous_block_index) {
            if_blocks[current_block_type_index].p(ctx, dirty);
          } else {
            group_outros();
            transition_out(if_blocks[previous_block_index], 1, 1, () => {
              if_blocks[previous_block_index] = null;
            });
            check_outros();
            if_block1 = if_blocks[current_block_type_index];

            if (!if_block1) {
              if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
              if_block1.c();
            }

            transition_in(if_block1, 1);
            if_block1.m(div, t3);
          }

          if (
          /*opciones*/
          ctx[0].size < 6) {
            if (if_block2) {
              if_block2.p(ctx, dirty);

              if (dirty &
              /*opciones*/
              1) {
                transition_in(if_block2, 1);
              }
            } else {
              if_block2 = create_if_block_1$g(ctx);
              if_block2.c();
              transition_in(if_block2, 1);
              if_block2.m(div, null);
            }
          } else if (if_block2) {
            group_outros();
            transition_out(if_block2, 1, 1, () => {
              if_block2 = null;
            });
            check_outros();
          }
        },
        i: function intro(local) {
          if (current) return;

          for (let i = 0; i < each_value.length; i += 1) {
            transition_in(each_blocks[i]);
          }

          transition_in(if_block1);
          transition_in(if_block2);
          current = true;
        },
        o: function outro(local) {
          each_blocks = each_blocks.filter(Boolean);

          for (let i = 0; i < each_blocks.length; i += 1) {
            transition_out(each_blocks[i]);
          }

          transition_out(if_block1);
          transition_out(if_block2);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(t0);
          if (detaching) detach_dev(ul);
          destroy_each(each_blocks, detaching);
          if (detaching) detach_dev(t1);
          if (if_block0) if_block0.d(detaching);
          if (detaching) detach_dev(t2);
          if (detaching) detach_dev(div);
          if_blocks[current_block_type_index].d();
          if (if_block2) if_block2.d();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot$g.name,
        type: "slot",
        source: "(52:4) <Dialog visible={true}>",
        ctx
      });
      return block;
    }

    function create_fragment$r(ctx) {
      let span;
      let t0;
      let t1;
      let if_block2_anchor;
      let current;
      let if_block0 = (
      /*estado*/
      ctx[1] == 0 ||
      /*estado*/
      ctx[1] == 1) && create_if_block_5$4(ctx);
      let if_block1 =
      /*estado*/
      ctx[1] == 2 && create_if_block_4$5(ctx);
      let if_block2 =
      /*estado*/
      ctx[1] == 1 && create_if_block$o(ctx);
      const block = {
        c: function create() {
          span = element("span");
          if (if_block0) if_block0.c();
          t0 = space();
          if (if_block1) if_block1.c();
          t1 = space();
          if (if_block2) if_block2.c();
          if_block2_anchor = empty();
          set_style(span, "margin", "4px 0");
          set_style(span, "display", "flex");
          set_style(span, "justify-content", "center");
          add_location(span, file$r, 40, 0, 988);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, span, anchor);
          if (if_block0) if_block0.m(span, null);
          append_dev(span, t0);
          if (if_block1) if_block1.m(span, null);
          insert_dev(target, t1, anchor);
          if (if_block2) if_block2.m(target, anchor);
          insert_dev(target, if_block2_anchor, anchor);
          current = true;
        },
        p: function update(ctx, [dirty]) {
          if (
          /*estado*/
          ctx[1] == 0 ||
          /*estado*/
          ctx[1] == 1) {
            if (if_block0) {
              if_block0.p(ctx, dirty);

              if (dirty &
              /*estado*/
              2) {
                transition_in(if_block0, 1);
              }
            } else {
              if_block0 = create_if_block_5$4(ctx);
              if_block0.c();
              transition_in(if_block0, 1);
              if_block0.m(span, t0);
            }
          } else if (if_block0) {
            group_outros();
            transition_out(if_block0, 1, 1, () => {
              if_block0 = null;
            });
            check_outros();
          }

          if (
          /*estado*/
          ctx[1] == 2) {
            if (if_block1) {
              if_block1.p(ctx, dirty);

              if (dirty &
              /*estado*/
              2) {
                transition_in(if_block1, 1);
              }
            } else {
              if_block1 = create_if_block_4$5(ctx);
              if_block1.c();
              transition_in(if_block1, 1);
              if_block1.m(span, null);
            }
          } else if (if_block1) {
            group_outros();
            transition_out(if_block1, 1, 1, () => {
              if_block1 = null;
            });
            check_outros();
          }

          if (
          /*estado*/
          ctx[1] == 1) {
            if (if_block2) {
              if_block2.p(ctx, dirty);

              if (dirty &
              /*estado*/
              2) {
                transition_in(if_block2, 1);
              }
            } else {
              if_block2 = create_if_block$o(ctx);
              if_block2.c();
              transition_in(if_block2, 1);
              if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
            }
          } else if (if_block2) {
            group_outros();
            transition_out(if_block2, 1, 1, () => {
              if_block2 = null;
            });
            check_outros();
          }
        },
        i: function intro(local) {
          if (current) return;
          transition_in(if_block0);
          transition_in(if_block1);
          transition_in(if_block2);
          current = true;
        },
        o: function outro(local) {
          transition_out(if_block0);
          transition_out(if_block1);
          transition_out(if_block2);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(span);
          if (if_block0) if_block0.d();
          if (if_block1) if_block1.d();
          if (detaching) detach_dev(t1);
          if (if_block2) if_block2.d(detaching);
          if (detaching) detach_dev(if_block2_anchor);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$r.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }

    const limiteOpciones = 6;

    function instance$r($$self, $$props, $$invalidate) {
      let {
        $$slots: slots = {},
        $$scope
      } = $$props;
      validate_slots("FormularioEncuesta", slots, []);
      let visible = true;
      let estado = 0; // 0 sin encuesta, 1 agregando encuesnta 2 encuesta agregada

      let {
        opciones = new Set([])
      } = $$props;
      let opcionesArray = [];
      let opcionNueva = "";

      function agregarOpcion() {
        if (opciones.size >= 6) return;
        opciones.add(opcionNueva);
        $$invalidate(0, opciones);
        $$invalidate(3, opcionNueva = "");
        $$invalidate(2, opcionesArray = [...opciones]);
      }

      function remover(opcion) {
        opciones.delete(opcion);
        $$invalidate(0, opciones);
        $$invalidate(2, opcionesArray = [...opciones]);
      }

      function cancelar() {
        $$invalidate(0, opciones = new Set());
        $$invalidate(1, estado = 0);
        $$invalidate(2, opcionesArray = [...opciones]);
      }

      function aceptar() {
        $$invalidate(1, estado = 2);
        $$invalidate(0, opciones);
        $$invalidate(2, opcionesArray = [...opciones]);
        console.log(opcionesArray);
      }

      const writable_props = ["opciones"];
      Object.keys($$props).forEach(key => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$4.warn(`<FormularioEncuesta> was created with unknown prop '${key}'`);
      });

      const click_handler = () => $$invalidate(1, estado = 1);

      const click_handler_1 = o => remover(o);

      function input_input_handler() {
        opcionNueva = this.value;
        $$invalidate(3, opcionNueva);
      }

      $$self.$$set = $$props => {
        if ("opciones" in $$props) $$invalidate(0, opciones = $$props.opciones);
      };

      $$self.$capture_state = () => ({
        Checkbox: Ne,
        Dialog: pn,
        Button: ye,
        Ripple: he,
        visible,
        estado,
        limiteOpciones,
        opciones,
        opcionesArray,
        opcionNueva,
        agregarOpcion,
        remover,
        cancelar,
        aceptar
      });

      $$self.$inject_state = $$props => {
        if ("visible" in $$props) visible = $$props.visible;
        if ("estado" in $$props) $$invalidate(1, estado = $$props.estado);
        if ("opciones" in $$props) $$invalidate(0, opciones = $$props.opciones);
        if ("opcionesArray" in $$props) $$invalidate(2, opcionesArray = $$props.opcionesArray);
        if ("opcionNueva" in $$props) $$invalidate(3, opcionNueva = $$props.opcionNueva);
      };

      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }

      return [opciones, estado, opcionesArray, opcionNueva, agregarOpcion, remover, cancelar, aceptar, click_handler, click_handler_1, input_input_handler];
    }

    class FormularioEncuesta extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$r, create_fragment$r, safe_not_equal, {
          opciones: 0
        });
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "FormularioEncuesta",
          options,
          id: create_fragment$r.name
        });
      }

      get opciones() {
        throw new Error("<FormularioEncuesta>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set opciones(value) {
        throw new Error("<FormularioEncuesta>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

    }

    /* src\components\Hilos\FormularioHilo.svelte generated by Svelte v3.29.0 */
    const {
      console: console_1$5
    } = globals;
    const file$s = "src\\components\\Hilos\\FormularioHilo.svelte";

    function get_each_context_1$4(ctx, list, i) {
      const child_ctx = ctx.slice();
      child_ctx[46] = list[i];
      return child_ctx;
    }

    function get_each_context$d(ctx, list, i) {
      const child_ctx = ctx.slice();
      child_ctx[43] = list[i];
      return child_ctx;
    } // (106:0) {#if mostrar}


    function create_if_block$p(ctx) {
      let div2;
      let form;
      let mediainput;
      let updating_media;
      let t0;
      let input0;
      let t1;
      let select;
      let option;
      let t3;
      let formularioencuesta;
      let updating_opciones;
      let t4;
      let textarea;
      let t5;
      let t6;
      let errorvalidacion;
      let t7;
      let div0;
      let span0;
      let checkbox0;
      let updating_checked;
      let t8;
      let span1;
      let checkbox1;
      let updating_checked_1;
      let t9;
      let span2;
      let checkbox2;
      let updating_checked_2;
      let t10;
      let span3;
      let checkbox3;
      let updating_checked_3;
      let t11;
      let t12;
      let captcha_1;
      let updating_token;
      let t13;
      let div1;
      let button0;
      let t14;
      let button1;
      let t15;
      let input1;
      let div2_transition;
      let current;
      let mounted;
      let dispose;

      function mediainput_media_binding(value) {
        /*mediainput_media_binding*/
        ctx[23].call(null, value);
      }

      let mediainput_props = {};

      if (
      /*media*/
      ctx[4] !== void 0) {
        mediainput_props.media =
        /*media*/
        ctx[4];
      }

      mediainput = new MediaInput({
        props: mediainput_props,
        $$inline: true
      });
      binding_callbacks.push(() => bind(mediainput, "media", mediainput_media_binding));
      let each_value = config.grupos;
      validate_each_argument(each_value);
      let each_blocks = [];

      for (let i = 0; i < each_value.length; i += 1) {
        each_blocks[i] = create_each_block$d(get_each_context$d(ctx, each_value, i));
      }

      function formularioencuesta_opciones_binding(value) {
        /*formularioencuesta_opciones_binding*/
        ctx[26].call(null, value);
      }

      let formularioencuesta_props = {};

      if (
      /*encuesta*/
      ctx[12] !== void 0) {
        formularioencuesta_props.opciones =
        /*encuesta*/
        ctx[12];
      }

      formularioencuesta = new FormularioEncuesta({
        props: formularioencuesta_props,
        $$inline: true
      });
      binding_callbacks.push(() => bind(formularioencuesta, "opciones", formularioencuesta_opciones_binding));
      let if_block0 =
      /*escribiendoRedactazo*/
      ctx[17] && create_if_block_3$a(ctx);
      errorvalidacion = new ErrorValidacion({
        props: {
          error:
          /*error*/
          ctx[16]
        },
        $$inline: true
      });

      function checkbox0_checked_binding(value) {
        /*checkbox0_checked_binding*/
        ctx[31].call(null, value);
      }

      let checkbox0_props = {
        right: true,
        $$slots: {
          default: [create_default_slot_10$2]
        },
        $$scope: {
          ctx
        }
      };

      if (
      /*banderitas_flag*/
      ctx[6] !== void 0) {
        checkbox0_props.checked =
        /*banderitas_flag*/
        ctx[6];
      }

      checkbox0 = new Ne({
        props: checkbox0_props,
        $$inline: true
      });
      binding_callbacks.push(() => bind(checkbox0, "checked", checkbox0_checked_binding));

      function checkbox1_checked_binding(value) {
        /*checkbox1_checked_binding*/
        ctx[32].call(null, value);
      }

      let checkbox1_props = {
        right: true,
        $$slots: {
          default: [create_default_slot_9$3]
        },
        $$scope: {
          ctx
        }
      };

      if (
      /*dados_flag*/
      ctx[7] !== void 0) {
        checkbox1_props.checked =
        /*dados_flag*/
        ctx[7];
      }

      checkbox1 = new Ne({
        props: checkbox1_props,
        $$inline: true
      });
      binding_callbacks.push(() => bind(checkbox1, "checked", checkbox1_checked_binding));

      function checkbox2_checked_binding(value) {
        /*checkbox2_checked_binding*/
        ctx[33].call(null, value);
      }

      let checkbox2_props = {
        right: true,
        $$slots: {
          default: [create_default_slot_8$3]
        },
        $$scope: {
          ctx
        }
      };

      if (
      /*idunico_flag*/
      ctx[8] !== void 0) {
        checkbox2_props.checked =
        /*idunico_flag*/
        ctx[8];
      }

      checkbox2 = new Ne({
        props: checkbox2_props,
        $$inline: true
      });
      binding_callbacks.push(() => bind(checkbox2, "checked", checkbox2_checked_binding));

      function checkbox3_checked_binding(value) {
        /*checkbox3_checked_binding*/
        ctx[34].call(null, value);
      }

      let checkbox3_props = {
        right: true,
        $$slots: {
          default: [create_default_slot_7$3]
        },
        $$scope: {
          ctx
        }
      };

      if (
      /*serio_flag*/
      ctx[9] !== void 0) {
        checkbox3_props.checked =
        /*serio_flag*/
        ctx[9];
      }

      checkbox3 = new Ne({
        props: checkbox3_props,
        $$inline: true
      });
      binding_callbacks.push(() => bind(checkbox3, "checked", checkbox3_checked_binding));
      let if_block1 =
      /*$globalStore*/
      ctx[19].usuario.esMod && create_if_block_1$h(ctx);

      function captcha_1_token_binding(value) {
        /*captcha_1_token_binding*/
        ctx[39].call(null, value);
      }

      let captcha_1_props = {
        visible: config.general.captchaHilo
      };

      if (
      /*captcha*/
      ctx[5] !== void 0) {
        captcha_1_props.token =
        /*captcha*/
        ctx[5];
      }

      captcha_1 = new Captcha({
        props: captcha_1_props,
        $$inline: true
      });
      binding_callbacks.push(() => bind(captcha_1, "token", captcha_1_token_binding));
      button0 = new ye({
        props: {
          color: "primary",
          $$slots: {
            default: [create_default_slot_2$f]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      button0.$on("click",
      /*click_handler*/
      ctx[40]);
      button1 = new ye({
        props: {
          color: "primary",
          disabled:
          /*cargando*/
          ctx[15],
          $$slots: {
            default: [create_default_slot$h]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      button1.$on("click",
      /*crear*/
      ctx[20]);
      const block = {
        c: function create() {
          div2 = element("div");
          form = element("form");
          create_component(mediainput.$$.fragment);
          t0 = space();
          input0 = element("input");
          t1 = space();
          select = element("select");
          option = element("option");
          option.textContent = "Categoría";

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].c();
          }

          t3 = space();
          create_component(formularioencuesta.$$.fragment);
          t4 = space();
          textarea = element("textarea");
          t5 = space();
          if (if_block0) if_block0.c();
          t6 = space();
          create_component(errorvalidacion.$$.fragment);
          t7 = space();
          div0 = element("div");
          span0 = element("span");
          create_component(checkbox0.$$.fragment);
          t8 = space();
          span1 = element("span");
          create_component(checkbox1.$$.fragment);
          t9 = space();
          span2 = element("span");
          create_component(checkbox2.$$.fragment);
          t10 = space();
          span3 = element("span");
          create_component(checkbox3.$$.fragment);
          t11 = space();
          if (if_block1) if_block1.c();
          t12 = space();
          create_component(captcha_1.$$.fragment);
          t13 = space();
          div1 = element("div");
          create_component(button0.$$.fragment);
          t14 = space();
          create_component(button1.$$.fragment);
          t15 = space();
          input1 = element("input");
          input0.autofocus = true;
          attr_dev(input0, "name", "titulo");
          attr_dev(input0, "placeholder", "Titulo");
          add_location(input0, file$s, 120, 12, 3849);
          option.__value = "-1";
          option.value = option.__value;
          option.selected = "selected";
          option.disabled = "disabled";
          add_location(option, file$s, 128, 16, 4086);
          attr_dev(select, "name", "categoria");
          if (
          /*categoria*/
          ctx[2] === void 0) add_render_callback(() =>
          /*select_change_handler*/
          ctx[25].call(select));
          add_location(select, file$s, 127, 12, 4020);
          attr_dev(textarea, "rows", "15");
          set_style(textarea, "background", "var(--color4)");
          attr_dev(textarea, "name", "contenido");
          attr_dev(textarea, "placeholder", "Escribi un redactazo...");
          add_location(textarea, file$s, 148, 12, 4840);
          set_style(span0, "width", "fit-content");
          set_style(span0, "margin-right", "auto");
          add_location(span0, file$s, 181, 16, 6206);
          set_style(span1, "width", "fit-content");
          set_style(span1, "margin-right", "auto");
          add_location(span1, file$s, 187, 16, 6442);
          set_style(span2, "width", "fit-content");
          set_style(span2, "margin-right", "auto");
          add_location(span2, file$s, 192, 16, 6642);
          set_style(span3, "width", "fit-content");
          set_style(span3, "margin-right", "auto");
          add_location(span3, file$s, 198, 16, 6873);
          set_style(div0, "flex-direction", "row");
          set_style(div0, "display", "flex");
          set_style(div0, "flex-wrap", "wrap");
          add_location(div0, file$s, 180, 12, 6125);
          attr_dev(input1, "type", "submit");
          set_style(input1, "display", "none");
          add_location(input1, file$s, 246, 16, 9073);
          set_style(div1, "display", "flex");
          set_style(div1, "justify-content", "flex-end");
          add_location(div1, file$s, 239, 12, 8700);
          attr_dev(form, "id", "crear-hilo-form");
          attr_dev(form, "class", "formulario crear-hilo panel svelte-1oczee4");
          add_location(form, file$s, 111, 8, 3548);
          attr_dev(div2, "class", "sombra");
          set_style(div2, "position", "fixed");
          set_style(div2, "left", "0");
          set_style(div2, "top", "0");
          add_location(div2, file$s, 106, 4, 3414);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div2, anchor);
          append_dev(div2, form);
          mount_component(mediainput, form, null);
          append_dev(form, t0);
          append_dev(form, input0);
          set_input_value(input0,
          /*titulo*/
          ctx[1]);
          append_dev(form, t1);
          append_dev(form, select);
          append_dev(select, option);

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].m(select, null);
          }

          select_option(select,
          /*categoria*/
          ctx[2]);
          append_dev(form, t3);
          mount_component(formularioencuesta, form, null);
          append_dev(form, t4);
          append_dev(form, textarea);
          set_input_value(textarea,
          /*contenido*/
          ctx[3]);
          append_dev(form, t5);
          if (if_block0) if_block0.m(form, null);
          append_dev(form, t6);
          mount_component(errorvalidacion, form, null);
          append_dev(form, t7);
          append_dev(form, div0);
          append_dev(div0, span0);
          mount_component(checkbox0, span0, null);
          append_dev(div0, t8);
          append_dev(div0, span1);
          mount_component(checkbox1, span1, null);
          append_dev(div0, t9);
          append_dev(div0, span2);
          mount_component(checkbox2, span2, null);
          append_dev(div0, t10);
          append_dev(div0, span3);
          mount_component(checkbox3, span3, null);
          append_dev(form, t11);
          if (if_block1) if_block1.m(form, null);
          append_dev(form, t12);
          mount_component(captcha_1, form, null);
          append_dev(form, t13);
          append_dev(form, div1);
          mount_component(button0, div1, null);
          append_dev(div1, t14);
          mount_component(button1, div1, null);
          append_dev(div1, t15);
          append_dev(div1, input1);
          current = true;
          input0.focus();

          if (!mounted) {
            dispose = [listen_dev(input0, "input",
            /*input0_input_handler*/
            ctx[24]), listen_dev(select, "change",
            /*select_change_handler*/
            ctx[25]), listen_dev(textarea, "input",
            /*textarea_input_handler*/
            ctx[27]), listen_dev(textarea, "focus",
            /*onTeaxtAreaFocus*/
            ctx[21], false, false, false), listen_dev(form, "submit", prevent_default(
            /*submit_handler*/
            ctx[22]), false, true, false)];
            mounted = true;
          }
        },
        p: function update(ctx, dirty) {
          const mediainput_changes = {};

          if (!updating_media && dirty[0] &
          /*media*/
          16) {
            updating_media = true;
            mediainput_changes.media =
            /*media*/
            ctx[4];
            add_flush_callback(() => updating_media = false);
          }

          mediainput.$set(mediainput_changes);

          if (dirty[0] &
          /*titulo*/
          2 && input0.value !==
          /*titulo*/
          ctx[1]) {
            set_input_value(input0,
            /*titulo*/
            ctx[1]);
          }

          if (dirty &
          /*config*/
          0) {
            each_value = config.grupos;
            validate_each_argument(each_value);
            let i;

            for (i = 0; i < each_value.length; i += 1) {
              const child_ctx = get_each_context$d(ctx, each_value, i);

              if (each_blocks[i]) {
                each_blocks[i].p(child_ctx, dirty);
              } else {
                each_blocks[i] = create_each_block$d(child_ctx);
                each_blocks[i].c();
                each_blocks[i].m(select, null);
              }
            }

            for (; i < each_blocks.length; i += 1) {
              each_blocks[i].d(1);
            }

            each_blocks.length = each_value.length;
          }

          if (dirty[0] &
          /*categoria*/
          4) {
            select_option(select,
            /*categoria*/
            ctx[2]);
          }

          const formularioencuesta_changes = {};

          if (!updating_opciones && dirty[0] &
          /*encuesta*/
          4096) {
            updating_opciones = true;
            formularioencuesta_changes.opciones =
            /*encuesta*/
            ctx[12];
            add_flush_callback(() => updating_opciones = false);
          }

          formularioencuesta.$set(formularioencuesta_changes);

          if (dirty[0] &
          /*contenido*/
          8) {
            set_input_value(textarea,
            /*contenido*/
            ctx[3]);
          }

          if (
          /*escribiendoRedactazo*/
          ctx[17]) {
            if (if_block0) {
              if_block0.p(ctx, dirty);

              if (dirty[0] &
              /*escribiendoRedactazo*/
              131072) {
                transition_in(if_block0, 1);
              }
            } else {
              if_block0 = create_if_block_3$a(ctx);
              if_block0.c();
              transition_in(if_block0, 1);
              if_block0.m(form, t6);
            }
          } else if (if_block0) {
            group_outros();
            transition_out(if_block0, 1, 1, () => {
              if_block0 = null;
            });
            check_outros();
          }

          const errorvalidacion_changes = {};
          if (dirty[0] &
          /*error*/
          65536) errorvalidacion_changes.error =
          /*error*/
          ctx[16];
          errorvalidacion.$set(errorvalidacion_changes);
          const checkbox0_changes = {};

          if (dirty[1] &
          /*$$scope*/
          262144) {
            checkbox0_changes.$$scope = {
              dirty,
              ctx
            };
          }

          if (!updating_checked && dirty[0] &
          /*banderitas_flag*/
          64) {
            updating_checked = true;
            checkbox0_changes.checked =
            /*banderitas_flag*/
            ctx[6];
            add_flush_callback(() => updating_checked = false);
          }

          checkbox0.$set(checkbox0_changes);
          const checkbox1_changes = {};

          if (dirty[1] &
          /*$$scope*/
          262144) {
            checkbox1_changes.$$scope = {
              dirty,
              ctx
            };
          }

          if (!updating_checked_1 && dirty[0] &
          /*dados_flag*/
          128) {
            updating_checked_1 = true;
            checkbox1_changes.checked =
            /*dados_flag*/
            ctx[7];
            add_flush_callback(() => updating_checked_1 = false);
          }

          checkbox1.$set(checkbox1_changes);
          const checkbox2_changes = {};

          if (dirty[1] &
          /*$$scope*/
          262144) {
            checkbox2_changes.$$scope = {
              dirty,
              ctx
            };
          }

          if (!updating_checked_2 && dirty[0] &
          /*idunico_flag*/
          256) {
            updating_checked_2 = true;
            checkbox2_changes.checked =
            /*idunico_flag*/
            ctx[8];
            add_flush_callback(() => updating_checked_2 = false);
          }

          checkbox2.$set(checkbox2_changes);
          const checkbox3_changes = {};

          if (dirty[1] &
          /*$$scope*/
          262144) {
            checkbox3_changes.$$scope = {
              dirty,
              ctx
            };
          }

          if (!updating_checked_3 && dirty[0] &
          /*serio_flag*/
          512) {
            updating_checked_3 = true;
            checkbox3_changes.checked =
            /*serio_flag*/
            ctx[9];
            add_flush_callback(() => updating_checked_3 = false);
          }

          checkbox3.$set(checkbox3_changes);

          if (
          /*$globalStore*/
          ctx[19].usuario.esMod) {
            if (if_block1) {
              if_block1.p(ctx, dirty);

              if (dirty[0] &
              /*$globalStore*/
              524288) {
                transition_in(if_block1, 1);
              }
            } else {
              if_block1 = create_if_block_1$h(ctx);
              if_block1.c();
              transition_in(if_block1, 1);
              if_block1.m(form, t12);
            }
          } else if (if_block1) {
            group_outros();
            transition_out(if_block1, 1, 1, () => {
              if_block1 = null;
            });
            check_outros();
          }

          const captcha_1_changes = {};

          if (!updating_token && dirty[0] &
          /*captcha*/
          32) {
            updating_token = true;
            captcha_1_changes.token =
            /*captcha*/
            ctx[5];
            add_flush_callback(() => updating_token = false);
          }

          captcha_1.$set(captcha_1_changes);
          const button0_changes = {};

          if (dirty[1] &
          /*$$scope*/
          262144) {
            button0_changes.$$scope = {
              dirty,
              ctx
            };
          }

          button0.$set(button0_changes);
          const button1_changes = {};
          if (dirty[0] &
          /*cargando*/
          32768) button1_changes.disabled =
          /*cargando*/
          ctx[15];

          if (dirty[0] &
          /*cargando*/
          32768 | dirty[1] &
          /*$$scope*/
          262144) {
            button1_changes.$$scope = {
              dirty,
              ctx
            };
          }

          button1.$set(button1_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(mediainput.$$.fragment, local);
          transition_in(formularioencuesta.$$.fragment, local);
          transition_in(if_block0);
          transition_in(errorvalidacion.$$.fragment, local);
          transition_in(checkbox0.$$.fragment, local);
          transition_in(checkbox1.$$.fragment, local);
          transition_in(checkbox2.$$.fragment, local);
          transition_in(checkbox3.$$.fragment, local);
          transition_in(if_block1);
          transition_in(captcha_1.$$.fragment, local);
          transition_in(button0.$$.fragment, local);
          transition_in(button1.$$.fragment, local);
          add_render_callback(() => {
            if (!div2_transition) div2_transition = create_bidirectional_transition(div2, fly, {
              duration: 200
            }, true);
            div2_transition.run(1);
          });
          current = true;
        },
        o: function outro(local) {
          transition_out(mediainput.$$.fragment, local);
          transition_out(formularioencuesta.$$.fragment, local);
          transition_out(if_block0);
          transition_out(errorvalidacion.$$.fragment, local);
          transition_out(checkbox0.$$.fragment, local);
          transition_out(checkbox1.$$.fragment, local);
          transition_out(checkbox2.$$.fragment, local);
          transition_out(checkbox3.$$.fragment, local);
          transition_out(if_block1);
          transition_out(captcha_1.$$.fragment, local);
          transition_out(button0.$$.fragment, local);
          transition_out(button1.$$.fragment, local);
          if (!div2_transition) div2_transition = create_bidirectional_transition(div2, fly, {
            duration: 200
          }, false);
          div2_transition.run(0);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div2);
          destroy_component(mediainput);
          destroy_each(each_blocks, detaching);
          destroy_component(formularioencuesta);
          if (if_block0) if_block0.d();
          destroy_component(errorvalidacion);
          destroy_component(checkbox0);
          destroy_component(checkbox1);
          destroy_component(checkbox2);
          destroy_component(checkbox3);
          if (if_block1) if_block1.d();
          destroy_component(captcha_1);
          destroy_component(button0);
          destroy_component(button1);
          if (detaching && div2_transition) div2_transition.end();
          mounted = false;
          run_all(dispose);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block$p.name,
        type: "if",
        source: "(106:0) {#if mostrar}",
        ctx
      });
      return block;
    } // (138:24) {#each g.categorias as cid}


    function create_each_block_1$4(ctx) {
      let option;
      let t_value = config.categoriaPorId(
      /*cid*/
      ctx[46]).nombre + "";
      let t;
      let option_value_value;
      const block = {
        c: function create() {
          option = element("option");
          t = text(t_value);
          option.__value = option_value_value =
          /*cid*/
          ctx[46];
          option.value = option.__value;
          add_location(option, file$s, 138, 28, 4519);
        },
        m: function mount(target, anchor) {
          insert_dev(target, option, anchor);
          append_dev(option, t);
        },
        p: noop,
        d: function destroy(detaching) {
          if (detaching) detach_dev(option);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_each_block_1$4.name,
        type: "each",
        source: "(138:24) {#each g.categorias as cid}",
        ctx
      });
      return block;
    } // (132:16) {#each config.grupos as g}


    function create_each_block$d(ctx) {
      let optgroup;
      let optgroup_id_value;
      let optgroup_label_value;
      let each_value_1 =
      /*g*/
      ctx[43].categorias;
      validate_each_argument(each_value_1);
      let each_blocks = [];

      for (let i = 0; i < each_value_1.length; i += 1) {
        each_blocks[i] = create_each_block_1$4(get_each_context_1$4(ctx, each_value_1, i));
      }

      const block = {
        c: function create() {
          optgroup = element("optgroup");

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].c();
          }

          attr_dev(optgroup, "id", optgroup_id_value = "grupo_" +
          /*g*/
          ctx[43].id);
          attr_dev(optgroup, "label", optgroup_label_value =
          /*g*/
          ctx[43].nombre);
          attr_dev(optgroup, "class", "grupo-categorias");
          add_location(optgroup, file$s, 132, 20, 4269);
        },
        m: function mount(target, anchor) {
          insert_dev(target, optgroup, anchor);

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].m(optgroup, null);
          }
        },
        p: function update(ctx, dirty) {
          if (dirty &
          /*config*/
          0) {
            each_value_1 =
            /*g*/
            ctx[43].categorias;
            validate_each_argument(each_value_1);
            let i;

            for (i = 0; i < each_value_1.length; i += 1) {
              const child_ctx = get_each_context_1$4(ctx, each_value_1, i);

              if (each_blocks[i]) {
                each_blocks[i].p(child_ctx, dirty);
              } else {
                each_blocks[i] = create_each_block_1$4(child_ctx);
                each_blocks[i].c();
                each_blocks[i].m(optgroup, null);
              }
            }

            for (; i < each_blocks.length; i += 1) {
              each_blocks[i].d(1);
            }

            each_blocks.length = each_value_1.length;
          }
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(optgroup);
          destroy_each(each_blocks, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_each_block$d.name,
        type: "each",
        source: "(132:16) {#each config.grupos as g}",
        ctx
      });
      return block;
    } // (157:12) {#if escribiendoRedactazo}


    function create_if_block_3$a(ctx) {
      let div1;
      let textarea;
      let t;
      let div0;
      let button;
      let current;
      let mounted;
      let dispose;
      button = new ye({
        props: {
          color: "var(--color5)",
          icon: true,
          $$slots: {
            default: [create_default_slot_11$1]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          div1 = element("div");
          textarea = element("textarea");
          t = space();
          div0 = element("div");
          create_component(button.$$.fragment);
          attr_dev(textarea, "rows", "10");
          set_style(textarea, "background", "var(--color4)");
          attr_dev(textarea, "name", "contenido");
          attr_dev(textarea, "class", "expandida svelte-1oczee4");
          attr_dev(textarea, "placeholder", "Escribi un redactazo...");
          add_location(textarea, file$s, 158, 20, 5212);
          set_style(div0, "position", "absolute");
          set_style(div0, "z-index", "2");
          set_style(div0, "bottom", "60px");
          set_style(div0, "right", "10px");
          add_location(div0, file$s, 169, 20, 5730);
          attr_dev(div1, "class", "");
          add_location(div1, file$s, 157, 16, 5176);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div1, anchor);
          append_dev(div1, textarea);
          /*textarea_binding*/

          ctx[28](textarea);
          set_input_value(textarea,
          /*contenido*/
          ctx[3]);
          append_dev(div1, t);
          append_dev(div1, div0);
          mount_component(button, div0, null);
          current = true;

          if (!mounted) {
            dispose = [listen_dev(textarea, "input",
            /*textarea_input_handler_1*/
            ctx[29]), listen_dev(textarea, "focus",
            /*onTeaxtAreaFocus*/
            ctx[21], false, false, false), listen_dev(textarea, "blur",
            /*blur_handler*/
            ctx[30], false, false, false)];
            mounted = true;
          }
        },
        p: function update(ctx, dirty) {
          if (dirty[0] &
          /*contenido*/
          8) {
            set_input_value(textarea,
            /*contenido*/
            ctx[3]);
          }

          const button_changes = {};

          if (dirty[1] &
          /*$$scope*/
          262144) {
            button_changes.$$scope = {
              dirty,
              ctx
            };
          }

          button.$set(button_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(button.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(button.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div1);
          /*textarea_binding*/

          ctx[28](null);
          destroy_component(button);
          mounted = false;
          run_all(dispose);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_3$a.name,
        type: "if",
        source: "(157:12) {#if escribiendoRedactazo}",
        ctx
      });
      return block;
    } // (173:24) <Button color="var(--color5)" icon                              >


    function create_default_slot_11$1(ctx) {
      let icon;
      const block = {
        c: function create() {
          icon = element("icon");
          attr_dev(icon, "class", "fe fe-check");
          add_location(icon, file$s, 173, 29, 5934);
        },
        m: function mount(target, anchor) {
          insert_dev(target, icon, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(icon);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_11$1.name,
        type: "slot",
        source: "(173:24) <Button color=\\\"var(--color5)\\\" icon                              >",
        ctx
      });
      return block;
    } // (183:21) <Checkbox bind:checked={banderitas_flag} right                          >


    function create_default_slot_10$2(ctx) {
      let t;
      const block = {
        c: function create() {
          t = text("Banderitas");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_10$2.name,
        type: "slot",
        source: "(183:21) <Checkbox bind:checked={banderitas_flag} right                          >",
        ctx
      });
      return block;
    } // (189:21) <Checkbox bind:checked={dados_flag} right>


    function create_default_slot_9$3(ctx) {
      let t;
      const block = {
        c: function create() {
          t = text("Dados");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_9$3.name,
        type: "slot",
        source: "(189:21) <Checkbox bind:checked={dados_flag} right>",
        ctx
      });
      return block;
    } // (194:21) <Checkbox bind:checked={idunico_flag} right                          >


    function create_default_slot_8$3(ctx) {
      let t;
      const block = {
        c: function create() {
          t = text("Id único");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_8$3.name,
        type: "slot",
        source: "(194:21) <Checkbox bind:checked={idunico_flag} right                          >",
        ctx
      });
      return block;
    } // (200:21) <Checkbox bind:checked={serio_flag} right>


    function create_default_slot_7$3(ctx) {
      let t;
      const block = {
        c: function create() {
          t = text("Serio");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_7$3.name,
        type: "slot",
        source: "(200:21) <Checkbox bind:checked={serio_flag} right>",
        ctx
      });
      return block;
    } // (210:12) {#if $globalStore.usuario.esMod}


    function create_if_block_1$h(ctx) {
      let div;
      let span0;
      let checkbox0;
      let updating_checked;
      let t0;
      let span1;
      let checkbox1;
      let updating_checked_1;
      let t1;
      let span2;
      let checkbox2;
      let updating_checked_2;
      let t2;
      let current;

      function checkbox0_checked_binding_1(value) {
        /*checkbox0_checked_binding_1*/
        ctx[35].call(null, value);
      }

      let checkbox0_props = {
        right: true,
        $$slots: {
          default: [create_default_slot_6$6]
        },
        $$scope: {
          ctx
        }
      };

      if (
      /*concentracion_flag*/
      ctx[10] !== void 0) {
        checkbox0_props.checked =
        /*concentracion_flag*/
        ctx[10];
      }

      checkbox0 = new Ne({
        props: checkbox0_props,
        $$inline: true
      });
      binding_callbacks.push(() => bind(checkbox0, "checked", checkbox0_checked_binding_1));

      function checkbox1_checked_binding_1(value) {
        /*checkbox1_checked_binding_1*/
        ctx[36].call(null, value);
      }

      let checkbox1_props = {
        right: true,
        $$slots: {
          default: [create_default_slot_5$8]
        },
        $$scope: {
          ctx
        }
      };

      if (
      /*md_flag*/
      ctx[11] !== void 0) {
        checkbox1_props.checked =
        /*md_flag*/
        ctx[11];
      }

      checkbox1 = new Ne({
        props: checkbox1_props,
        $$inline: true
      });
      binding_callbacks.push(() => bind(checkbox1, "checked", checkbox1_checked_binding_1));

      function checkbox2_checked_binding_1(value) {
        /*checkbox2_checked_binding_1*/
        ctx[37].call(null, value);
      }

      let checkbox2_props = {
        right: true,
        $$slots: {
          default: [create_default_slot_4$c]
        },
        $$scope: {
          ctx
        }
      };

      if (
      /*mostrarRango*/
      ctx[13] !== void 0) {
        checkbox2_props.checked =
        /*mostrarRango*/
        ctx[13];
      }

      checkbox2 = new Ne({
        props: checkbox2_props,
        $$inline: true
      });
      binding_callbacks.push(() => bind(checkbox2, "checked", checkbox2_checked_binding_1));
      let if_block =
      /*$globalStore*/
      ctx[19].usuario.esAdmin && create_if_block_2$g(ctx);
      const block = {
        c: function create() {
          div = element("div");
          span0 = element("span");
          create_component(checkbox0.$$.fragment);
          t0 = space();
          span1 = element("span");
          create_component(checkbox1.$$.fragment);
          t1 = space();
          span2 = element("span");
          create_component(checkbox2.$$.fragment);
          t2 = space();
          if (if_block) if_block.c();
          set_style(span0, "width", "fit-content");
          set_style(span0, "margin-right", "auto");
          add_location(span0, file$s, 211, 20, 7432);
          set_style(span1, "width", "fit-content");
          set_style(span1, "margin-right", "auto");
          add_location(span1, file$s, 216, 20, 7692);
          set_style(span2, "width", "fit-content");
          set_style(span2, "margin-right", "auto");
          add_location(span2, file$s, 221, 20, 7936);
          set_style(div, "flex-direction", "row");
          set_style(div, "display", "flex");
          set_style(div, "flex-wrap", "wrap");
          add_location(div, file$s, 210, 16, 7347);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          append_dev(div, span0);
          mount_component(checkbox0, span0, null);
          append_dev(div, t0);
          append_dev(div, span1);
          mount_component(checkbox1, span1, null);
          append_dev(div, t1);
          append_dev(div, span2);
          mount_component(checkbox2, span2, null);
          append_dev(div, t2);
          if (if_block) if_block.m(div, null);
          current = true;
        },
        p: function update(ctx, dirty) {
          const checkbox0_changes = {};

          if (dirty[1] &
          /*$$scope*/
          262144) {
            checkbox0_changes.$$scope = {
              dirty,
              ctx
            };
          }

          if (!updating_checked && dirty[0] &
          /*concentracion_flag*/
          1024) {
            updating_checked = true;
            checkbox0_changes.checked =
            /*concentracion_flag*/
            ctx[10];
            add_flush_callback(() => updating_checked = false);
          }

          checkbox0.$set(checkbox0_changes);
          const checkbox1_changes = {};

          if (dirty[1] &
          /*$$scope*/
          262144) {
            checkbox1_changes.$$scope = {
              dirty,
              ctx
            };
          }

          if (!updating_checked_1 && dirty[0] &
          /*md_flag*/
          2048) {
            updating_checked_1 = true;
            checkbox1_changes.checked =
            /*md_flag*/
            ctx[11];
            add_flush_callback(() => updating_checked_1 = false);
          }

          checkbox1.$set(checkbox1_changes);
          const checkbox2_changes = {};

          if (dirty[1] &
          /*$$scope*/
          262144) {
            checkbox2_changes.$$scope = {
              dirty,
              ctx
            };
          }

          if (!updating_checked_2 && dirty[0] &
          /*mostrarRango*/
          8192) {
            updating_checked_2 = true;
            checkbox2_changes.checked =
            /*mostrarRango*/
            ctx[13];
            add_flush_callback(() => updating_checked_2 = false);
          }

          checkbox2.$set(checkbox2_changes);

          if (
          /*$globalStore*/
          ctx[19].usuario.esAdmin) {
            if (if_block) {
              if_block.p(ctx, dirty);

              if (dirty[0] &
              /*$globalStore*/
              524288) {
                transition_in(if_block, 1);
              }
            } else {
              if_block = create_if_block_2$g(ctx);
              if_block.c();
              transition_in(if_block, 1);
              if_block.m(div, null);
            }
          } else if (if_block) {
            group_outros();
            transition_out(if_block, 1, 1, () => {
              if_block = null;
            });
            check_outros();
          }
        },
        i: function intro(local) {
          if (current) return;
          transition_in(checkbox0.$$.fragment, local);
          transition_in(checkbox1.$$.fragment, local);
          transition_in(checkbox2.$$.fragment, local);
          transition_in(if_block);
          current = true;
        },
        o: function outro(local) {
          transition_out(checkbox0.$$.fragment, local);
          transition_out(checkbox1.$$.fragment, local);
          transition_out(checkbox2.$$.fragment, local);
          transition_out(if_block);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
          destroy_component(checkbox0);
          destroy_component(checkbox1);
          destroy_component(checkbox2);
          if (if_block) if_block.d();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_1$h.name,
        type: "if",
        source: "(210:12) {#if $globalStore.usuario.esMod}",
        ctx
      });
      return block;
    } // (213:25) <Checkbox bind:checked={concentracion_flag} right                              >


    function create_default_slot_6$6(ctx) {
      let t;
      const block = {
        c: function create() {
          t = text("Concentración");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_6$6.name,
        type: "slot",
        source: "(213:25) <Checkbox bind:checked={concentracion_flag} right                              >",
        ctx
      });
      return block;
    } // (218:25) <Checkbox bind:checked={md_flag} right                              >


    function create_default_slot_5$8(ctx) {
      let t;
      const block = {
        c: function create() {
          t = text("Markdown");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_5$8.name,
        type: "slot",
        source: "(218:25) <Checkbox bind:checked={md_flag} right                              >",
        ctx
      });
      return block;
    } // (223:25) <Checkbox bind:checked={mostrarRango} right                              >


    function create_default_slot_4$c(ctx) {
      let t;
      const block = {
        c: function create() {
          t = text("Tag_Mod");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_4$c.name,
        type: "slot",
        source: "(223:25) <Checkbox bind:checked={mostrarRango} right                              >",
        ctx
      });
      return block;
    } // (227:20) {#if $globalStore.usuario.esAdmin}


    function create_if_block_2$g(ctx) {
      let span;
      let checkbox;
      let updating_checked;
      let current;

      function checkbox_checked_binding(value) {
        /*checkbox_checked_binding*/
        ctx[38].call(null, value);
      }

      let checkbox_props = {
        right: true,
        $$slots: {
          default: [create_default_slot_3$f]
        },
        $$scope: {
          ctx
        }
      };

      if (
      /*mostrarNombre*/
      ctx[14] !== void 0) {
        checkbox_props.checked =
        /*mostrarNombre*/
        ctx[14];
      }

      checkbox = new Ne({
        props: checkbox_props,
        $$inline: true
      });
      binding_callbacks.push(() => bind(checkbox, "checked", checkbox_checked_binding));
      const block = {
        c: function create() {
          span = element("span");
          create_component(checkbox.$$.fragment);
          set_style(span, "width", "fit-content");
          set_style(span, "margin-right", "auto");
          add_location(span, file$s, 227, 24, 8244);
        },
        m: function mount(target, anchor) {
          insert_dev(target, span, anchor);
          mount_component(checkbox, span, null);
          current = true;
        },
        p: function update(ctx, dirty) {
          const checkbox_changes = {};

          if (dirty[1] &
          /*$$scope*/
          262144) {
            checkbox_changes.$$scope = {
              dirty,
              ctx
            };
          }

          if (!updating_checked && dirty[0] &
          /*mostrarNombre*/
          16384) {
            updating_checked = true;
            checkbox_changes.checked =
            /*mostrarNombre*/
            ctx[14];
            add_flush_callback(() => updating_checked = false);
          }

          checkbox.$set(checkbox_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(checkbox.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(checkbox.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(span);
          destroy_component(checkbox);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_2$g.name,
        type: "if",
        source: "(227:20) {#if $globalStore.usuario.esAdmin}",
        ctx
      });
      return block;
    } // (229:29) <Checkbox bind:checked={mostrarNombre} right                                  >


    function create_default_slot_3$f(ctx) {
      let t;
      const block = {
        c: function create() {
          t = text("Nombre");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_3$f.name,
        type: "slot",
        source: "(229:29) <Checkbox bind:checked={mostrarNombre} right                                  >",
        ctx
      });
      return block;
    } // (241:16) <Button color="primary" on:click={() => (mostrar = false)}                      >


    function create_default_slot_2$f(ctx) {
      let t;
      const block = {
        c: function create() {
          t = text("Cancelar");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_2$f.name,
        type: "slot",
        source: "(241:16) <Button color=\\\"primary\\\" on:click={() => (mostrar = false)}                      >",
        ctx
      });
      return block;
    } // (245:20) <Spinner {cargando}>


    function create_default_slot_1$g(ctx) {
      let t;
      const block = {
        c: function create() {
          t = text("Crear");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_1$g.name,
        type: "slot",
        source: "(245:20) <Spinner {cargando}>",
        ctx
      });
      return block;
    } // (244:16) <Button color="primary" disabled={cargando} on:click={crear}>


    function create_default_slot$h(ctx) {
      let spinner;
      let current;
      spinner = new Spinner({
        props: {
          cargando:
          /*cargando*/
          ctx[15],
          $$slots: {
            default: [create_default_slot_1$g]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          create_component(spinner.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(spinner, target, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          const spinner_changes = {};
          if (dirty[0] &
          /*cargando*/
          32768) spinner_changes.cargando =
          /*cargando*/
          ctx[15];

          if (dirty[1] &
          /*$$scope*/
          262144) {
            spinner_changes.$$scope = {
              dirty,
              ctx
            };
          }

          spinner.$set(spinner_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(spinner.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(spinner.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(spinner, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot$h.name,
        type: "slot",
        source: "(244:16) <Button color=\\\"primary\\\" disabled={cargando} on:click={crear}>",
        ctx
      });
      return block;
    }

    function create_fragment$s(ctx) {
      let if_block_anchor;
      let current;
      let if_block =
      /*mostrar*/
      ctx[0] && create_if_block$p(ctx);
      const block = {
        c: function create() {
          if (if_block) if_block.c();
          if_block_anchor = empty();
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          if (if_block) if_block.m(target, anchor);
          insert_dev(target, if_block_anchor, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          if (
          /*mostrar*/
          ctx[0]) {
            if (if_block) {
              if_block.p(ctx, dirty);

              if (dirty[0] &
              /*mostrar*/
              1) {
                transition_in(if_block, 1);
              }
            } else {
              if_block = create_if_block$p(ctx);
              if_block.c();
              transition_in(if_block, 1);
              if_block.m(if_block_anchor.parentNode, if_block_anchor);
            }
          } else if (if_block) {
            group_outros();
            transition_out(if_block, 1, 1, () => {
              if_block = null;
            });
            check_outros();
          }
        },
        i: function intro(local) {
          if (current) return;
          transition_in(if_block);
          current = true;
        },
        o: function outro(local) {
          transition_out(if_block);
          current = false;
        },
        d: function destroy(detaching) {
          if (if_block) if_block.d(detaching);
          if (detaching) detach_dev(if_block_anchor);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$s.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }

    function instance$s($$self, $$props, $$invalidate) {
      let $globalStore;
      validate_store(globalStore, "globalStore");
      component_subscribe($$self, globalStore, $$value => $$invalidate(19, $globalStore = $$value));
      let {
        $$slots: slots = {},
        $$scope
      } = $$props;
      validate_slots("FormularioHilo", slots, []);
      let {
        mostrar = false
      } = $$props;
      let titulo = "";
      let categoria = "-1";
      let contenido = "";
      let media;
      let audio;
      let captcha = "";
      let banderitas_flag = false;
      let dados_flag = false;
      let idunico_flag = false;
      let serio_flag = false;
      let concentracion_flag = false;
      let md_flag = false; //let audio_flag = false;

      let encuesta = new Set([]);
      let mostrarRango = false;
      let mostrarNombre = false;
      let cargando = false;
      let error = null;

      async function crear() {
        $$invalidate(15, cargando = true);
        $$invalidate(12, encuesta);
        console.log(encuesta);
        var contenidoConFlags = contenido;

        if (contenidoConFlags != "") {
          contenidoConFlags += "\n";
        }

        contenidoConFlags += banderitas_flag ? ">>banderitas\n" : "";
        contenidoConFlags += dados_flag ? ">>dados\n" : "";
        contenidoConFlags += idunico_flag ? ">>idunico\n" : "";
        contenidoConFlags += serio_flag ? ">>serio\n" : "";
        contenidoConFlags += concentracion_flag ? ">>concentracion\n" : "";
        contenidoConFlags += md_flag ? ">>md\n" : ""; //contenidoConFlags += audio_flag? ">>audios\n": audio ? ">>audios\n" : "";

        try {
          let r = null;

          if (!$globalStore.usuario.esMod) {
            r = await await RChanClient.crearHilo(titulo, categoria, contenidoConFlags, media.archivo, media.link, audio, captcha, [...encuesta]);
          } else {
            r = await await RChanClient.crearHilo(titulo, categoria, contenidoConFlags, media.archivo, media.link, audio, captcha, [...encuesta], mostrarNombre && $globalStore.usuario.esAdmin, mostrarRango);
          }

          if (r.status == 201) {
            window.location.replace(r.headers.location);
          }
        } catch (e) {
          $$invalidate(16, error = e.response.data);
        }

        $$invalidate(15, cargando = false);
      }

      let escribiendoRedactazo = false;
      let textarea2;

      async function onTeaxtAreaFocus(params) {
        console.log(textarea2);
        $$invalidate(17, escribiendoRedactazo = true);
        await tick();
        textarea2.focus();
      }

      const writable_props = ["mostrar"];
      Object.keys($$props).forEach(key => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$5.warn(`<FormularioHilo> was created with unknown prop '${key}'`);
      });

      function submit_handler(event) {
        bubble($$self, event);
      }

      function mediainput_media_binding(value) {
        media = value;
        $$invalidate(4, media);
      }

      function input0_input_handler() {
        titulo = this.value;
        $$invalidate(1, titulo);
      }

      function select_change_handler() {
        categoria = select_value(this);
        $$invalidate(2, categoria);
      }

      function formularioencuesta_opciones_binding(value) {
        encuesta = value;
        $$invalidate(12, encuesta);
      }

      function textarea_input_handler() {
        contenido = this.value;
        $$invalidate(3, contenido);
      }

      function textarea_binding($$value) {
        binding_callbacks[$$value ? "unshift" : "push"](() => {
          textarea2 = $$value;
          $$invalidate(18, textarea2);
        });
      }

      function textarea_input_handler_1() {
        contenido = this.value;
        $$invalidate(3, contenido);
      }

      const blur_handler = () => $$invalidate(17, escribiendoRedactazo = false);

      function checkbox0_checked_binding(value) {
        banderitas_flag = value;
        $$invalidate(6, banderitas_flag);
      }

      function checkbox1_checked_binding(value) {
        dados_flag = value;
        $$invalidate(7, dados_flag);
      }

      function checkbox2_checked_binding(value) {
        idunico_flag = value;
        $$invalidate(8, idunico_flag);
      }

      function checkbox3_checked_binding(value) {
        serio_flag = value;
        $$invalidate(9, serio_flag);
      }

      function checkbox0_checked_binding_1(value) {
        concentracion_flag = value;
        $$invalidate(10, concentracion_flag);
      }

      function checkbox1_checked_binding_1(value) {
        md_flag = value;
        $$invalidate(11, md_flag);
      }

      function checkbox2_checked_binding_1(value) {
        mostrarRango = value;
        $$invalidate(13, mostrarRango);
      }

      function checkbox_checked_binding(value) {
        mostrarNombre = value;
        $$invalidate(14, mostrarNombre);
      }

      function captcha_1_token_binding(value) {
        captcha = value;
        $$invalidate(5, captcha);
      }

      const click_handler = () => $$invalidate(0, mostrar = false);

      $$self.$$set = $$props => {
        if ("mostrar" in $$props) $$invalidate(0, mostrar = $$props.mostrar);
      };

      $$self.$capture_state = () => ({
        fade,
        blur,
        fly,
        Button: ye,
        Ripple: he,
        Checkbox: Ne,
        config,
        RChanClient,
        ErrorValidacion,
        MediaType,
        MediaInput,
        Captcha,
        Spinner,
        globalStore,
        FormularioEncuesta,
        tick,
        mostrar,
        titulo,
        categoria,
        contenido,
        media,
        audio,
        captcha,
        banderitas_flag,
        dados_flag,
        idunico_flag,
        serio_flag,
        concentracion_flag,
        md_flag,
        encuesta,
        mostrarRango,
        mostrarNombre,
        cargando,
        error,
        crear,
        escribiendoRedactazo,
        textarea2,
        onTeaxtAreaFocus,
        encuestaArray,
        $globalStore
      });

      $$self.$inject_state = $$props => {
        if ("mostrar" in $$props) $$invalidate(0, mostrar = $$props.mostrar);
        if ("titulo" in $$props) $$invalidate(1, titulo = $$props.titulo);
        if ("categoria" in $$props) $$invalidate(2, categoria = $$props.categoria);
        if ("contenido" in $$props) $$invalidate(3, contenido = $$props.contenido);
        if ("media" in $$props) $$invalidate(4, media = $$props.media);
        if ("audio" in $$props) audio = $$props.audio;
        if ("captcha" in $$props) $$invalidate(5, captcha = $$props.captcha);
        if ("banderitas_flag" in $$props) $$invalidate(6, banderitas_flag = $$props.banderitas_flag);
        if ("dados_flag" in $$props) $$invalidate(7, dados_flag = $$props.dados_flag);
        if ("idunico_flag" in $$props) $$invalidate(8, idunico_flag = $$props.idunico_flag);
        if ("serio_flag" in $$props) $$invalidate(9, serio_flag = $$props.serio_flag);
        if ("concentracion_flag" in $$props) $$invalidate(10, concentracion_flag = $$props.concentracion_flag);
        if ("md_flag" in $$props) $$invalidate(11, md_flag = $$props.md_flag);
        if ("encuesta" in $$props) $$invalidate(12, encuesta = $$props.encuesta);
        if ("mostrarRango" in $$props) $$invalidate(13, mostrarRango = $$props.mostrarRango);
        if ("mostrarNombre" in $$props) $$invalidate(14, mostrarNombre = $$props.mostrarNombre);
        if ("cargando" in $$props) $$invalidate(15, cargando = $$props.cargando);
        if ("error" in $$props) $$invalidate(16, error = $$props.error);
        if ("escribiendoRedactazo" in $$props) $$invalidate(17, escribiendoRedactazo = $$props.escribiendoRedactazo);
        if ("textarea2" in $$props) $$invalidate(18, textarea2 = $$props.textarea2);
        if ("encuestaArray" in $$props) encuestaArray = $$props.encuestaArray;
      };

      let encuestaArray;

      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }

      $$self.$$.update = () => {
        if ($$self.$$.dirty[0] &
        /*encuesta*/
        4096) {
           encuestaArray = [...encuesta];
        }

        if ($$self.$$.dirty[0] &
        /*encuesta*/
        4096) {
           console.log(encuesta);
        }
      };

      return [mostrar, titulo, categoria, contenido, media, captcha, banderitas_flag, dados_flag, idunico_flag, serio_flag, concentracion_flag, md_flag, encuesta, mostrarRango, mostrarNombre, cargando, error, escribiendoRedactazo, textarea2, $globalStore, crear, onTeaxtAreaFocus, submit_handler, mediainput_media_binding, input0_input_handler, select_change_handler, formularioencuesta_opciones_binding, textarea_input_handler, textarea_binding, textarea_input_handler_1, blur_handler, checkbox0_checked_binding, checkbox1_checked_binding, checkbox2_checked_binding, checkbox3_checked_binding, checkbox0_checked_binding_1, checkbox1_checked_binding_1, checkbox2_checked_binding_1, checkbox_checked_binding, captcha_1_token_binding, click_handler];
    }

    class FormularioHilo extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$s, create_fragment$s, safe_not_equal, {
          mostrar: 0
        }, [-1, -1]);
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "FormularioHilo",
          options,
          id: create_fragment$s.name
        });
      }

      get mostrar() {
        throw new Error("<FormularioHilo>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set mostrar(value) {
        throw new Error("<FormularioHilo>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

    }

    /* src\components\Notificaciones.svelte generated by Svelte v3.29.0 */
    const {
      console: console_1$6,
      document: document_1
    } = globals;
    const file$t = "src\\components\\Notificaciones.svelte";

    function get_each_context$e(ctx, list, i) {
      const child_ctx = ctx.slice();
      child_ctx[8] = list[i];
      return child_ctx;
    }

    function get_each_context_1$5(ctx, list, i) {
      const child_ctx = ctx.slice();
      child_ctx[8] = list[i];
      return child_ctx;
    } // (85:8) {#if notificaciones.length != 0}


    function create_if_block_3$b(ctx) {
      let div;
      let span;
      let t;
      const block = {
        c: function create() {
          div = element("div");
          span = element("span");
          t = text(
          /*totalNotificaciones*/
          ctx[3]);
          add_location(span, file$t, 86, 16, 2759);
          attr_dev(div, "class", "noti-cont");
          set_style(div, "position", "absolute");
          add_location(div, file$t, 85, 12, 2690);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          append_dev(div, span);
          append_dev(span, t);
        },
        p: function update(ctx, dirty) {
          if (dirty &
          /*totalNotificaciones*/
          8) set_data_dev(t,
          /*totalNotificaciones*/
          ctx[3]);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_3$b.name,
        type: "if",
        source: "(85:8) {#if notificaciones.length != 0}",
        ctx
      });
      return block;
    } // (79:4) <Button          icon          dense          on:click={() => (mostrar = !mostrar && totalNotificaciones != 0)}      >


    function create_default_slot$i(ctx) {
      let span;
      let t0;
      let t1;
      let ripple;
      let current;
      let if_block =
      /*notificaciones*/
      ctx[0].length != 0 && create_if_block_3$b(ctx);
      ripple = new he({
        $$inline: true
      });
      const block = {
        c: function create() {
          span = element("span");
          t0 = space();
          if (if_block) if_block.c();
          t1 = space();
          create_component(ripple.$$.fragment);
          attr_dev(span, "class", "fe fe-bell");
          add_location(span, file$t, 83, 8, 2607);
        },
        m: function mount(target, anchor) {
          insert_dev(target, span, anchor);
          insert_dev(target, t0, anchor);
          if (if_block) if_block.m(target, anchor);
          insert_dev(target, t1, anchor);
          mount_component(ripple, target, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          if (
          /*notificaciones*/
          ctx[0].length != 0) {
            if (if_block) {
              if_block.p(ctx, dirty);
            } else {
              if_block = create_if_block_3$b(ctx);
              if_block.c();
              if_block.m(t1.parentNode, t1);
            }
          } else if (if_block) {
            if_block.d(1);
            if_block = null;
          }
        },
        i: function intro(local) {
          if (current) return;
          transition_in(ripple.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(ripple.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(span);
          if (detaching) detach_dev(t0);
          if (if_block) if_block.d(detaching);
          if (detaching) detach_dev(t1);
          destroy_component(ripple, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot$i.name,
        type: "slot",
        source: "(79:4) <Button          icon          dense          on:click={() => (mostrar = !mostrar && totalNotificaciones != 0)}      >",
        ctx
      });
      return block;
    } // (92:4) {#if mostrar}


    function create_if_block_1$i(ctx) {
      let ul;
      let t0;
      let li;
      let ul_transition;
      let current;
      let mounted;
      let dispose;
      let each_value_1 =
      /*notificaciones*/
      ctx[0];
      validate_each_argument(each_value_1);
      let each_blocks = [];

      for (let i = 0; i < each_value_1.length; i += 1) {
        each_blocks[i] = create_each_block_1$5(get_each_context_1$5(ctx, each_value_1, i));
      }

      const block = {
        c: function create() {
          ul = element("ul");

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].c();
          }

          t0 = space();
          li = element("li");
          li.textContent = "Limpiar todas";
          attr_dev(li, "class", "noti");
          set_style(li, "justify-content", "center");
          add_location(li, file$t, 115, 12, 3865);
          attr_dev(ul, "class", "notis panel drop-menu abs lista-nav menu1");
          add_location(ul, file$t, 92, 8, 2892);
        },
        m: function mount(target, anchor) {
          insert_dev(target, ul, anchor);

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].m(ul, null);
          }

          append_dev(ul, t0);
          append_dev(ul, li);
          current = true;

          if (!mounted) {
            dispose = [listen_dev(li, "click",
            /*limpiar*/
            ctx[5], false, false, false), listen_dev(ul, "mouseleave",
            /*mouseleave_handler*/
            ctx[7], false, false, false)];
            mounted = true;
          }
        },
        p: function update(ctx, dirty) {
          if (dirty &
          /*notificaciones*/
          1) {
            each_value_1 =
            /*notificaciones*/
            ctx[0];
            validate_each_argument(each_value_1);
            let i;

            for (i = 0; i < each_value_1.length; i += 1) {
              const child_ctx = get_each_context_1$5(ctx, each_value_1, i);

              if (each_blocks[i]) {
                each_blocks[i].p(child_ctx, dirty);
              } else {
                each_blocks[i] = create_each_block_1$5(child_ctx);
                each_blocks[i].c();
                each_blocks[i].m(ul, t0);
              }
            }

            for (; i < each_blocks.length; i += 1) {
              each_blocks[i].d(1);
            }

            each_blocks.length = each_value_1.length;
          }
        },
        i: function intro(local) {
          if (current) return;
          add_render_callback(() => {
            if (!ul_transition) ul_transition = create_bidirectional_transition(ul, fly, {
              x: -50,
              duration: 150
            }, true);
            ul_transition.run(1);
          });
          current = true;
        },
        o: function outro(local) {
          if (!ul_transition) ul_transition = create_bidirectional_transition(ul, fly, {
            x: -50,
            duration: 150
          }, false);
          ul_transition.run(0);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(ul);
          destroy_each(each_blocks, detaching);
          if (detaching && ul_transition) ul_transition.end();
          mounted = false;
          run_all(dispose);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_1$i.name,
        type: "if",
        source: "(92:4) {#if mostrar}",
        ctx
      });
      return block;
    } // (108:24) {:else}


    function create_else_block_1$3(ctx) {
      let span;
      let t0_value =
      /*n*/
      ctx[8].conteo + "";
      let t0;
      let t1;
      let t2_value =
      /*n*/
      ctx[8].comentarioId + "";
      let t2;
      const block = {
        c: function create() {
          span = element("span");
          t0 = text(t0_value);
          t1 = text(" Respondieron a tu comentario : ");
          t2 = text(t2_value);
          add_location(span, file$t, 108, 28, 3615);
        },
        m: function mount(target, anchor) {
          insert_dev(target, span, anchor);
          append_dev(span, t0);
          append_dev(span, t1);
          append_dev(span, t2);
        },
        p: function update(ctx, dirty) {
          if (dirty &
          /*notificaciones*/
          1 && t0_value !== (t0_value =
          /*n*/
          ctx[8].conteo + "")) set_data_dev(t0, t0_value);
          if (dirty &
          /*notificaciones*/
          1 && t2_value !== (t2_value =
          /*n*/
          ctx[8].comentarioId + "")) set_data_dev(t2, t2_value);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(span);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_else_block_1$3.name,
        type: "else",
        source: "(108:24) {:else}",
        ctx
      });
      return block;
    } // (104:24) {#if n.tipo == 0}


    function create_if_block_2$h(ctx) {
      let span;
      let t0_value =
      /*n*/
      ctx[8].conteo + "";
      let t0;
      let t1;
      let t2_value =
      /*n*/
      ctx[8].hiloTitulo + "";
      let t2;
      const block = {
        c: function create() {
          span = element("span");
          t0 = text(t0_value);
          t1 = text(" Nuevos Comentarios en : ");
          t2 = text(t2_value);
          add_location(span, file$t, 104, 28, 3426);
        },
        m: function mount(target, anchor) {
          insert_dev(target, span, anchor);
          append_dev(span, t0);
          append_dev(span, t1);
          append_dev(span, t2);
        },
        p: function update(ctx, dirty) {
          if (dirty &
          /*notificaciones*/
          1 && t0_value !== (t0_value =
          /*n*/
          ctx[8].conteo + "")) set_data_dev(t0, t0_value);
          if (dirty &
          /*notificaciones*/
          1 && t2_value !== (t2_value =
          /*n*/
          ctx[8].hiloTitulo + "")) set_data_dev(t2, t2_value);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(span);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_2$h.name,
        type: "if",
        source: "(104:24) {#if n.tipo == 0}",
        ctx
      });
      return block;
    } // (98:12) {#each notificaciones as n}


    function create_each_block_1$5(ctx) {
      let a;
      let li;
      let img;
      let img_src_value;
      let t;
      let a_href_value;

      function select_block_type(ctx, dirty) {
        if (
        /*n*/
        ctx[8].tipo == 0) return create_if_block_2$h;
        return create_else_block_1$3;
      }

      let current_block_type = select_block_type(ctx);
      let if_block = current_block_type(ctx);
      const block = {
        c: function create() {
          a = element("a");
          li = element("li");
          img = element("img");
          t = space();
          if_block.c();
          if (img.src !== (img_src_value =
          /*n*/
          ctx[8].hiloImagen)) attr_dev(img, "src", img_src_value);
          attr_dev(img, "alt", "");
          add_location(img, file$t, 102, 24, 3320);
          attr_dev(li, "class", "noti");
          add_location(li, file$t, 101, 20, 3277);
          attr_dev(a, "href", a_href_value = "/Notificacion/" +
          /*n*/
          ctx[8].id + "?hiloId=" +
          /*n*/
          ctx[8].hiloId + "&comentarioId=" +
          /*n*/
          ctx[8].comentarioId);
          add_location(a, file$t, 98, 16, 3137);
        },
        m: function mount(target, anchor) {
          insert_dev(target, a, anchor);
          append_dev(a, li);
          append_dev(li, img);
          append_dev(li, t);
          if_block.m(li, null);
        },
        p: function update(ctx, dirty) {
          if (dirty &
          /*notificaciones*/
          1 && img.src !== (img_src_value =
          /*n*/
          ctx[8].hiloImagen)) {
            attr_dev(img, "src", img_src_value);
          }

          if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
            if_block.p(ctx, dirty);
          } else {
            if_block.d(1);
            if_block = current_block_type(ctx);

            if (if_block) {
              if_block.c();
              if_block.m(li, null);
            }
          }

          if (dirty &
          /*notificaciones*/
          1 && a_href_value !== (a_href_value = "/Notificacion/" +
          /*n*/
          ctx[8].id + "?hiloId=" +
          /*n*/
          ctx[8].hiloId + "&comentarioId=" +
          /*n*/
          ctx[8].comentarioId)) {
            attr_dev(a, "href", a_href_value);
          }
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(a);
          if_block.d();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_each_block_1$5.name,
        type: "each",
        source: "(98:12) {#each notificaciones as n}",
        ctx
      });
      return block;
    } // (142:24) {:else}


    function create_else_block$6(ctx) {
      let span;
      const block = {
        c: function create() {
          span = element("span");
          span.textContent = "Han respondido tu comentario";
          set_style(span, "color", "var(--color5)");
          add_location(span, file$t, 142, 28, 4817);
        },
        m: function mount(target, anchor) {
          insert_dev(target, span, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(span);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_else_block$6.name,
        type: "else",
        source: "(142:24) {:else}",
        ctx
      });
      return block;
    } // (138:24) {#if n.tipo == 0}


    function create_if_block$q(ctx) {
      let span;
      const block = {
        c: function create() {
          span = element("span");
          span.textContent = "Han comentado";
          set_style(span, "color", "var(--color5)");
          add_location(span, file$t, 138, 28, 4635);
        },
        m: function mount(target, anchor) {
          insert_dev(target, span, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(span);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block$q.name,
        type: "if",
        source: "(138:24) {#if n.tipo == 0}",
        ctx
      });
      return block;
    } // (128:4) {#each nuevasNotificaciones as n}


    function create_each_block$e(ctx) {
      let div1;
      let a;
      let li;
      let img;
      let img_src_value;
      let t0;
      let div0;
      let h3;
      let t1_value =
      /*n*/
      ctx[8].hiloTitulo + "";
      let t1;
      let t2;
      let t3;
      let span;
      let raw_value =
      /*n*/
      ctx[8].contenido + "";
      let a_href_value;
      let t4;
      let div1_outro;
      let current;

      function select_block_type_1(ctx, dirty) {
        if (
        /*n*/
        ctx[8].tipo == 0) return create_if_block$q;
        return create_else_block$6;
      }

      let current_block_type = select_block_type_1(ctx);
      let if_block = current_block_type(ctx);
      const block = {
        c: function create() {
          div1 = element("div");
          a = element("a");
          li = element("li");
          img = element("img");
          t0 = space();
          div0 = element("div");
          h3 = element("h3");
          t1 = text(t1_value);
          t2 = space();
          if_block.c();
          t3 = space();
          span = element("span");
          t4 = space();
          if (img.src !== (img_src_value =
          /*n*/
          ctx[8].hiloImagen)) attr_dev(img, "src", img_src_value);
          attr_dev(img, "alt", "");
          add_location(img, file$t, 133, 20, 4442);
          attr_dev(h3, "class", "svelte-juq78y");
          add_location(h3, file$t, 135, 24, 4537);
          add_location(span, file$t, 146, 24, 5008);
          attr_dev(div0, "class", "");
          add_location(div0, file$t, 134, 20, 4497);
          attr_dev(li, "class", "noti svelte-juq78y");
          add_location(li, file$t, 132, 16, 4403);
          attr_dev(a, "href", a_href_value = "/Notificacion/" +
          /*n*/
          ctx[8].id + "?hiloId=" +
          /*n*/
          ctx[8].hiloId + "&comentarioId=" +
          /*n*/
          ctx[8].comentarioId);
          add_location(a, file$t, 129, 12, 4275);
          add_location(div1, file$t, 128, 8, 4213);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div1, anchor);
          append_dev(div1, a);
          append_dev(a, li);
          append_dev(li, img);
          append_dev(li, t0);
          append_dev(li, div0);
          append_dev(div0, h3);
          append_dev(h3, t1);
          append_dev(div0, t2);
          if_block.m(div0, null);
          append_dev(div0, t3);
          append_dev(div0, span);
          span.innerHTML = raw_value;
          append_dev(div1, t4);
          current = true;
        },
        p: function update(ctx, dirty) {
          if (!current || dirty &
          /*nuevasNotificaciones*/
          4 && img.src !== (img_src_value =
          /*n*/
          ctx[8].hiloImagen)) {
            attr_dev(img, "src", img_src_value);
          }

          if ((!current || dirty &
          /*nuevasNotificaciones*/
          4) && t1_value !== (t1_value =
          /*n*/
          ctx[8].hiloTitulo + "")) set_data_dev(t1, t1_value);

          if (current_block_type !== (current_block_type = select_block_type_1(ctx))) {
            if_block.d(1);
            if_block = current_block_type(ctx);

            if (if_block) {
              if_block.c();
              if_block.m(div0, t3);
            }
          }

          if ((!current || dirty &
          /*nuevasNotificaciones*/
          4) && raw_value !== (raw_value =
          /*n*/
          ctx[8].contenido + "")) span.innerHTML = raw_value;

          if (!current || dirty &
          /*nuevasNotificaciones*/
          4 && a_href_value !== (a_href_value = "/Notificacion/" +
          /*n*/
          ctx[8].id + "?hiloId=" +
          /*n*/
          ctx[8].hiloId + "&comentarioId=" +
          /*n*/
          ctx[8].comentarioId)) {
            attr_dev(a, "href", a_href_value);
          }
        },
        i: function intro(local) {
          if (current) return;
          if (div1_outro) div1_outro.end(1);
          current = true;
        },
        o: function outro(local) {
          if (local) {
            div1_outro = create_out_transition(div1, fly, {
              x: -150,
              duration: 250
            });
          }

          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div1);
          if_block.d();
          if (detaching && div1_outro) div1_outro.end();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_each_block$e.name,
        type: "each",
        source: "(128:4) {#each nuevasNotificaciones as n}",
        ctx
      });
      return block;
    }

    function create_fragment$t(ctx) {
      let title_value;
      let t0;
      let span;
      let button;
      let t1;
      let t2;
      let ul;
      let current;
      document_1.title = title_value = "" + ((
      /*totalNotificaciones*/
      ctx[3] != 0 ? `(${
  /*totalNotificaciones*/
  ctx[3]})` : "") + "\r\n        " +
      /*titulo*/
      ctx[4]);
      button = new ye({
        props: {
          icon: true,
          dense: true,
          $$slots: {
            default: [create_default_slot$i]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      button.$on("click",
      /*click_handler*/
      ctx[6]);
      let if_block =
      /*mostrar*/
      ctx[1] && create_if_block_1$i(ctx);
      let each_value =
      /*nuevasNotificaciones*/
      ctx[2];
      validate_each_argument(each_value);
      let each_blocks = [];

      for (let i = 0; i < each_value.length; i += 1) {
        each_blocks[i] = create_each_block$e(get_each_context$e(ctx, each_value, i));
      }

      const out = i => transition_out(each_blocks[i], 1, 1, () => {
        each_blocks[i] = null;
      });

      const block = {
        c: function create() {
          t0 = space();
          span = element("span");
          create_component(button.$$.fragment);
          t1 = space();
          if (if_block) if_block.c();
          t2 = space();
          ul = element("ul");

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].c();
          }

          set_style(span, "position", "relative");
          add_location(span, file$t, 77, 0, 2439);
          attr_dev(ul, "class", "nuevas-notificaciones notis panel drop-menu abs lista-nav menu1 svelte-juq78y");
          add_location(ul, file$t, 126, 0, 4088);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t0, anchor);
          insert_dev(target, span, anchor);
          mount_component(button, span, null);
          append_dev(span, t1);
          if (if_block) if_block.m(span, null);
          insert_dev(target, t2, anchor);
          insert_dev(target, ul, anchor);

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].m(ul, null);
          }

          current = true;
        },
        p: function update(ctx, [dirty]) {
          if ((!current || dirty &
          /*totalNotificaciones, titulo*/
          24) && title_value !== (title_value = "" + ((
          /*totalNotificaciones*/
          ctx[3] != 0 ? `(${
      /*totalNotificaciones*/
      ctx[3]})` : "") + "\r\n        " +
          /*titulo*/
          ctx[4]))) {
            document_1.title = title_value;
          }

          const button_changes = {};

          if (dirty &
          /*$$scope, totalNotificaciones, notificaciones*/
          8201) {
            button_changes.$$scope = {
              dirty,
              ctx
            };
          }

          button.$set(button_changes);

          if (
          /*mostrar*/
          ctx[1]) {
            if (if_block) {
              if_block.p(ctx, dirty);

              if (dirty &
              /*mostrar*/
              2) {
                transition_in(if_block, 1);
              }
            } else {
              if_block = create_if_block_1$i(ctx);
              if_block.c();
              transition_in(if_block, 1);
              if_block.m(span, null);
            }
          } else if (if_block) {
            group_outros();
            transition_out(if_block, 1, 1, () => {
              if_block = null;
            });
            check_outros();
          }

          if (dirty &
          /*nuevasNotificaciones*/
          4) {
            each_value =
            /*nuevasNotificaciones*/
            ctx[2];
            validate_each_argument(each_value);
            let i;

            for (i = 0; i < each_value.length; i += 1) {
              const child_ctx = get_each_context$e(ctx, each_value, i);

              if (each_blocks[i]) {
                each_blocks[i].p(child_ctx, dirty);
                transition_in(each_blocks[i], 1);
              } else {
                each_blocks[i] = create_each_block$e(child_ctx);
                each_blocks[i].c();
                transition_in(each_blocks[i], 1);
                each_blocks[i].m(ul, null);
              }
            }

            group_outros();

            for (i = each_value.length; i < each_blocks.length; i += 1) {
              out(i);
            }

            check_outros();
          }
        },
        i: function intro(local) {
          if (current) return;
          transition_in(button.$$.fragment, local);
          transition_in(if_block);

          for (let i = 0; i < each_value.length; i += 1) {
            transition_in(each_blocks[i]);
          }

          current = true;
        },
        o: function outro(local) {
          transition_out(button.$$.fragment, local);
          transition_out(if_block);
          each_blocks = each_blocks.filter(Boolean);

          for (let i = 0; i < each_blocks.length; i += 1) {
            transition_out(each_blocks[i]);
          }

          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(t0);
          if (detaching) detach_dev(span);
          destroy_component(button);
          if (if_block) if_block.d();
          if (detaching) detach_dev(t2);
          if (detaching) detach_dev(ul);
          destroy_each(each_blocks, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$t.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }

    function instance$t($$self, $$props, $$invalidate) {
      let {
        $$slots: slots = {},
        $$scope
      } = $$props;
      validate_slots("Notificaciones", slots, []);
      let {
        notificaciones
      } = $$props;
      const titulo = document.title;
      let mostrar = false;
      let nuevasNotificaciones = [];

      async function limpiar() {
        try {
          await RChanClient.limpiarNotificaciones();
        } catch (error) {
          console.log(error);
          return;
        }

        $$invalidate(0, notificaciones = []);
        $$invalidate(1, mostrar = false);
      }

      Signal.coneccion.on("NuevaNotificacion", noti => {
        $$invalidate(2, nuevasNotificaciones = [noti, ...nuevasNotificaciones]);
        setTimeout(() => {
          nuevasNotificaciones.pop();
          $$invalidate(2, nuevasNotificaciones);
        }, 3000 + nuevasNotificaciones.length * 1000);
        let yaExisteUnaNotiDeEseTipo = false;
        let notiVieja = null;

        for (const n of notificaciones) {
          if (n.hiloId == noti.hiloId && n.tipo == noti.tipo && n.tipo == 0) {
            n.conteo++;
            yaExisteUnaNotiDeEseTipo = true;
            notiVieja = n;
          } else if (n.hiloId == noti.hiloId && n.comentarioId == noti.comentarioId && n.tipo == noti.tipo && n.tipo == 1) {
            n.conteo++;
            yaExisteUnaNotiDeEseTipo = true;
            notiVieja = n;
          }
        }

        if (!yaExisteUnaNotiDeEseTipo) {
          noti.conteo = 1;
          $$invalidate(0, notificaciones = [noti, ...notificaciones]);
        } else {
          $$invalidate(0, notificaciones = notificaciones.filter(n => n != notiVieja));
          $$invalidate(0, notificaciones = [notiVieja, ...notificaciones]);
        }
      });
      Signal.coneccion.on("notificacionesLimpeadas", () => {
        $$invalidate(0, notificaciones = []);
      });
      const writable_props = ["notificaciones"];
      Object.keys($$props).forEach(key => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$6.warn(`<Notificaciones> was created with unknown prop '${key}'`);
      });

      const click_handler = () => $$invalidate(1, mostrar = !mostrar && totalNotificaciones != 0);

      const mouseleave_handler = () => $$invalidate(1, mostrar = false);

      $$self.$$set = $$props => {
        if ("notificaciones" in $$props) $$invalidate(0, notificaciones = $$props.notificaciones);
      };

      $$self.$capture_state = () => ({
        RChanClient,
        fade,
        blur,
        fly,
        Ripple: he,
        Button: ye,
        Signal,
        notificaciones,
        titulo,
        mostrar,
        nuevasNotificaciones,
        limpiar,
        totalNotificaciones
      });

      $$self.$inject_state = $$props => {
        if ("notificaciones" in $$props) $$invalidate(0, notificaciones = $$props.notificaciones);
        if ("mostrar" in $$props) $$invalidate(1, mostrar = $$props.mostrar);
        if ("nuevasNotificaciones" in $$props) $$invalidate(2, nuevasNotificaciones = $$props.nuevasNotificaciones);
        if ("totalNotificaciones" in $$props) $$invalidate(3, totalNotificaciones = $$props.totalNotificaciones);
      };

      let totalNotificaciones;

      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }

      $$self.$$.update = () => {
        if ($$self.$$.dirty &
        /*notificaciones*/
        1) {
           $$invalidate(3, totalNotificaciones = notificaciones.map(n => n.conteo).reduce((c, n) => c += n, 0));
        }
      };

      return [notificaciones, mostrar, nuevasNotificaciones, totalNotificaciones, titulo, limpiar, click_handler, mouseleave_handler];
    }

    class Notificaciones extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$t, create_fragment$t, safe_not_equal, {
          notificaciones: 0
        });
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "Notificaciones",
          options,
          id: create_fragment$t.name
        });
        const {
          ctx
        } = this.$$;
        const props = options.props || {};

        if (
        /*notificaciones*/
        ctx[0] === undefined && !("notificaciones" in props)) {
          console_1$6.warn("<Notificaciones> was created without expected prop 'notificaciones'");
        }
      }

      get notificaciones() {
        throw new Error("<Notificaciones>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set notificaciones(value) {
        throw new Error("<Notificaciones>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

    }

    /* src\icons\more-vertical.svg generated by Svelte v3.29.0 */

    const file$u = "src\\icons\\more-vertical.svg";

    function create_fragment$u(ctx) {
    	let svg;
    	let circle0;
    	let circle1;
    	let circle2;

    	const block = {
    		c: function create() {
    			svg = svg_element("svg");
    			circle0 = svg_element("circle");
    			circle1 = svg_element("circle");
    			circle2 = svg_element("circle");
    			attr_dev(circle0, "cx", "12");
    			attr_dev(circle0, "cy", "12");
    			attr_dev(circle0, "r", "1");
    			add_location(circle0, file$u, 0, 219, 219);
    			attr_dev(circle1, "cx", "12");
    			attr_dev(circle1, "cy", "5");
    			attr_dev(circle1, "r", "1");
    			add_location(circle1, file$u, 0, 258, 258);
    			attr_dev(circle2, "cx", "12");
    			attr_dev(circle2, "cy", "19");
    			attr_dev(circle2, "r", "1");
    			add_location(circle2, file$u, 0, 296, 296);
    			attr_dev(svg, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg, "width", "24");
    			attr_dev(svg, "height", "24");
    			attr_dev(svg, "viewBox", "0 0 24 24");
    			attr_dev(svg, "fill", "none");
    			attr_dev(svg, "stroke", "currentColor");
    			attr_dev(svg, "stroke-width", "2");
    			attr_dev(svg, "stroke-linecap", "round");
    			attr_dev(svg, "stroke-linejoin", "round");
    			attr_dev(svg, "class", "feather feather-more-vertical");
    			add_location(svg, file$u, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg, anchor);
    			append_dev(svg, circle0);
    			append_dev(svg, circle1);
    			append_dev(svg, circle2);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$u.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$u($$self, $$props) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("More_vertical", slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<More_vertical> was created with unknown prop '${key}'`);
    	});

    	return [];
    }

    class More_vertical extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$u, create_fragment$u, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "More_vertical",
    			options,
    			id: create_fragment$u.name
    		});
    	}
    }

    /* src\icons\serio.svg generated by Svelte v3.29.0 */

    const file$v = "src\\icons\\serio.svg";

    function create_fragment$v(ctx) {
    	let svg1;
    	let g;
    	let svg0;
    	let path;

    	const block = {
    		c: function create() {
    			svg1 = svg_element("svg");
    			g = svg_element("g");
    			svg0 = svg_element("svg");
    			path = svg_element("path");
    			attr_dev(path, "d", "M67.6,52.5h2.6c0.3-0.5,0.9-0.9,1.6-0.9c1.1,0,1.9,0.9,1.9,1.9c0,1.1-0.9,1.9-1.9,1.9c-0.7,0-1.3-0.3-1.6-0.9h-1.8l-1.1,1.1  v36.1c6-2.1,11.4-5.4,16.1-9.5c-2.5-2.9-4.4-5.1-4.4-5.1c-1.9-2.9-1.9-4-1.9-4c-2.9-12.1-2-17.4,3.4-28.7c1.9-3.9,2.8-8.6,2.8-13  C83.4,18.3,71.8,9.1,61.2,6c-8-2.3-16.4-1.4-24.3,0.8c-7,1.9-12.7,6-15.7,12.9c-1.3,2.8-2.3,5.9-3.2,9c-0.3,1.5,0.4,3.3,0.4,4.8  c0,1.4,0.2,3.2-0.4,4.3c-2,3.6-4.3,7.1-6.2,10.6c-1.2,2.1-0.8,3.3,1.2,4.4c0.8,0.4,1.4,0.7,2.2,0.9c2.4,0.9,2.8,1.7,2.4,4.1  c-0.2,1,0,1.5,0.1,2.6c0,0,0.2,1.1,1.1,0.8c-1,1.3-1.5,2.4,0,3.9c0.8,0.9,1.1,2.6,1,3.8c-0.1,4.4,0.9,6.2,5.2,6.7  c2.8,0.3,5.9-0.1,8.7-0.3c1.9-0.2,3.6-0.2,4.3,1.7c1.3,3.5,2.6,7,3.7,10.5c0.3,1,0.4,2.2,0.7,3.4c-0.2,1.1-0.6,2.1-1,3  c2.9,0.6,5.9,0.9,9,0.9V47.9l-8-8h-8.6L32.8,39c-0.1,0-0.3,0-0.4,0c-1.1,0-1.9-0.9-1.9-1.9c0-1.1,0.9-1.9,1.9-1.9  c1.1,0,1.9,0.9,1.9,1.9c0,0.1,0,0.3,0,0.4l0.3,0.3h8.6l7.1,7.1v-2.5l-7.8-7.8H26.6l-2-2c-0.1,0-0.3,0-0.4,0c-1.1,0-1.9-0.9-1.9-1.9  c0-1.1,0.9-1.9,1.9-1.9c1.1,0,1.9,0.9,1.9,1.9c0,0.1,0,0.3,0,0.4l1.4,1.4h15.9l9,9v53.1c1,0,1.9-0.1,2.9-0.2V42.3L68,29.5v-6.3  c-0.5-0.3-0.9-0.9-0.9-1.6c0-1.1,0.9-1.9,1.9-1.9c1.1,0,1.9,0.9,1.9,1.9c0,0.7-0.3,1.3-0.9,1.6v7.2L57.4,43.1v2l6.5-6.5  c0-0.1,0-0.3,0-0.4c0-1.1,0.9-1.9,1.9-1.9c1.1,0,1.9,0.9,1.9,1.9c0,1.1-0.9,1.9-1.9,1.9c-0.1,0-0.3,0-0.4,0l-8,8v2.2L74.7,33v-3  c-0.5-0.3-0.9-0.9-0.9-1.6c0-1.1,0.9-1.9,1.9-1.9c1.1,0,1.9,0.9,1.9,1.9c0,0.7-0.3,1.3-0.9,1.6v3.9L57.4,53.3v40.9  c1-0.1,1.9-0.3,2.9-0.5V53.6l9.9-9.9h4.4l1-1c0-0.1,0-0.3,0-0.4c0-1.1,0.9-1.9,1.9-1.9c1.1,0,1.9,0.9,1.9,1.9s-0.9,1.9-1.9,1.9  c-0.1,0-0.3,0-0.4,0l-1.6,1.6H71l-8.6,8.6v38.8c1-0.2,1.9-0.5,2.9-0.8V54.8L67.6,52.5z M39.8,8.8c0.7,0,1.3,0.3,1.6,0.9H44l8.7,8.7  c0.1,0,0.3,0,0.4,0c1.1,0,1.9,0.9,1.9,1.9c0,1.1-0.9,1.9-1.9,1.9c-1.1,0-1.9-0.9-1.9-1.9c0-0.1,0-0.3,0-0.4l-8.1-8.1h-1.7  c-0.3,0.5-0.9,0.9-1.6,0.9c-1.1,0-1.9-0.9-1.9-1.9S38.7,8.8,39.8,8.8z M29.2,14.5c0.1,0,0.3,0,0.4,0l3-3h3.9l16.7,16.7l3.5-3.5V13.8  l-2-2h-1.7c-0.3,0.5-0.9,0.9-1.6,0.9c-1.1,0-1.9-0.9-1.9-1.9s0.9-1.9,1.9-1.9c0.7,0,1.3,0.3,1.6,0.9h2.5l3.2,3.2v12.6l-5.6,5.6  L35.7,13.6h-2.2L31.1,16c0,0.1,0,0.3,0,0.4c0,1.1-0.9,1.9-1.9,1.9c-1.1,0-1.9-0.9-1.9-1.9C27.3,15.3,28.2,14.5,29.2,14.5z   M27.6,18.7c1.1,0,1.9,0.9,1.9,1.9c0,0.1,0,0.3,0,0.4l2.8,2.8h6.5l-3.3-3.3c-0.1,0-0.3,0-0.4,0c-1.1,0-1.9-0.9-1.9-1.9  c0-1.1,0.9-1.9,1.9-1.9c1.1,0,1.9,0.9,1.9,1.9c0,0.1,0,0.3,0,0.4l6.8,6.8H31.4L28,22.5c-0.1,0-0.3,0-0.4,0c-1.1,0-1.9-0.9-1.9-1.9  S26.5,18.7,27.6,18.7z M56.7,36.8c-0.1,0-0.1,0-0.2,0l-2.9,2.9l-9.3-9.3H27.8l-3.6-3.6c-0.1,0-0.3,0-0.4,0c-1.1,0-1.9-0.9-1.9-1.9  c0-1.1,0.9-1.9,1.9-1.9c1.1,0,1.9,0.9,1.9,1.9c0,0.1,0,0.3,0,0.4l3,3h16.6l8.4,8.4l1.2-1.2c-0.1-0.2-0.1-0.4-0.1-0.6  c0-1.1,0.9-1.9,1.9-1.9s1.9,0.9,1.9,1.9C58.7,35.9,57.8,36.8,56.7,36.8z M64.2,17.7v10.2l-2.3,2.3c0,0.1,0,0.3,0,0.4  c0,1.1-0.9,1.9-1.9,1.9c-1.1,0-1.9-0.9-1.9-1.9c0-1.1,0.9-1.9,1.9-1.9c0.1,0,0.3,0,0.4,0l1.7-1.7v-9.3c-0.5-0.3-0.9-0.9-0.9-1.6  c0-1.1,0.9-1.9,1.9-1.9c1.1,0,1.9,0.9,1.9,1.9C65.1,16.8,64.7,17.4,64.2,17.7z");
    			add_location(path, file$v, 7, 12, 501);
    			attr_dev(svg0, "fill", "#FFFFFF");
    			attr_dev(svg0, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg0, "xmlns:xlink", "http://www.w3.org/1999/xlink");
    			attr_dev(svg0, "version", "1.1");
    			attr_dev(svg0, "x", "0px");
    			attr_dev(svg0, "y", "0px");
    			attr_dev(svg0, "viewBox", "0 0 100 100");
    			attr_dev(svg0, "enable-background", "new 0 0 100 100");
    			attr_dev(svg0, "xml:space", "preserve");
    			add_location(svg0, file$v, 3, 8, 256);
    			attr_dev(g, "transform", "translate(600 600) scale(-0.69 0.69) rotate(0) translate(-600 -600)");
    			set_style(g, "fill", "#FFFFFF");
    			add_location(g, file$v, 2, 4, 143);
    			attr_dev(svg1, "xmlns", "http://www.w3.org/2000/svg");
    			attr_dev(svg1, "xmlns:xlink", "http://www.w3.org/1999/xlink");
    			attr_dev(svg1, "width", "1200");
    			attr_dev(svg1, "height", "1200");
    			attr_dev(svg1, "viewBox", "0 0 1200 1200");
    			add_location(svg1, file$v, 0, 0, 0);
    		},
    		l: function claim(nodes) {
    			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    		},
    		m: function mount(target, anchor) {
    			insert_dev(target, svg1, anchor);
    			append_dev(svg1, g);
    			append_dev(g, svg0);
    			append_dev(svg0, path);
    		},
    		p: noop,
    		i: noop,
    		o: noop,
    		d: function destroy(detaching) {
    			if (detaching) detach_dev(svg1);
    		}
    	};

    	dispatch_dev("SvelteRegisterBlock", {
    		block,
    		id: create_fragment$v.name,
    		type: "component",
    		source: "",
    		ctx
    	});

    	return block;
    }

    function instance$v($$self, $$props) {
    	let { $$slots: slots = {}, $$scope } = $$props;
    	validate_slots("Serio", slots, []);
    	const writable_props = [];

    	Object.keys($$props).forEach(key => {
    		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Serio> was created with unknown prop '${key}'`);
    	});

    	return [];
    }

    class Serio extends SvelteComponentDev {
    	constructor(options) {
    		super(options);
    		init(this, options, instance$v, create_fragment$v, safe_not_equal, {});

    		dispatch_dev("SvelteRegisterComponent", {
    			component: this,
    			tagName: "Serio",
    			options,
    			id: create_fragment$v.name
    		});
    	}
    }

    /* src\components\MenuPrincipal.svelte generated by Svelte v3.29.0 */
    const file$w = "src\\components\\MenuPrincipal.svelte";

    function get_each_context_1$6(ctx, list, i) {
      const child_ctx = ctx.slice();
      child_ctx[27] = list[i];
      child_ctx[28] = list;
      child_ctx[29] = i;
      return child_ctx;
    }

    function get_each_context$f(ctx, list, i) {
      const child_ctx = ctx.slice();
      child_ctx[24] = list[i];
      child_ctx[25] = list;
      child_ctx[26] = i;
      return child_ctx;
    } // (97:12) {#if usuario.estaAutenticado}


    function create_if_block_8$2(ctx) {
      let span;
      let t0;
      let t1_value =
      /*usuario*/
      ctx[6].userName + "";
      let t1;
      let t2;
      const block = {
        c: function create() {
          span = element("span");
          t0 = text("Hola ");
          t1 = text(t1_value);
          t2 = text("!");
          set_style(span, "display", "block");
          set_style(span, "text-align", "center");
          add_location(span, file$w, 97, 16, 3042);
        },
        m: function mount(target, anchor) {
          insert_dev(target, span, anchor);
          append_dev(span, t0);
          append_dev(span, t1);
          append_dev(span, t2);
        },
        p: function update(ctx, dirty) {
          if (dirty &
          /*usuario*/
          64 && t1_value !== (t1_value =
          /*usuario*/
          ctx[6].userName + "")) set_data_dev(t1, t1_value);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(span);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_8$2.name,
        type: "if",
        source: "(97:12) {#if usuario.estaAutenticado}",
        ctx
      });
      return block;
    } // (104:12) {#if !usuario.estaAutenticado}


    function create_if_block_7$2(ctx) {
      let a0;
      let li0;
      let icon0;
      let t0;
      let ripple0;
      let t1;
      let a1;
      let li1;
      let icon1;
      let t2;
      let ripple1;
      let current;
      ripple0 = new he({
        $$inline: true
      });
      ripple1 = new he({
        $$inline: true
      });
      const block = {
        c: function create() {
          a0 = element("a");
          li0 = element("li");
          icon0 = element("icon");
          t0 = text(" Iniciar Sesion ");
          create_component(ripple0.$$.fragment);
          t1 = space();
          a1 = element("a");
          li1 = element("li");
          icon1 = element("icon");
          t2 = text(" Crear Sesion ");
          create_component(ripple1.$$.fragment);
          attr_dev(icon0, "class", "fe fe-log-in");
          add_location(icon0, file$w, 106, 24, 3342);
          add_location(li0, file$w, 105, 20, 3312);
          attr_dev(a0, "href", "/Login");
          add_location(a0, file$w, 104, 16, 3273);
          attr_dev(icon1, "class", "fe fe-user");
          add_location(icon1, file$w, 110, 24, 3508);
          add_location(li1, file$w, 110, 20, 3504);
          attr_dev(a1, "href", "/Inicio");
          add_location(a1, file$w, 109, 16, 3464);
        },
        m: function mount(target, anchor) {
          insert_dev(target, a0, anchor);
          append_dev(a0, li0);
          append_dev(li0, icon0);
          append_dev(li0, t0);
          mount_component(ripple0, li0, null);
          insert_dev(target, t1, anchor);
          insert_dev(target, a1, anchor);
          append_dev(a1, li1);
          append_dev(li1, icon1);
          append_dev(li1, t2);
          mount_component(ripple1, li1, null);
          current = true;
        },
        i: function intro(local) {
          if (current) return;
          transition_in(ripple0.$$.fragment, local);
          transition_in(ripple1.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(ripple0.$$.fragment, local);
          transition_out(ripple1.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(a0);
          destroy_component(ripple0);
          if (detaching) detach_dev(t1);
          if (detaching) detach_dev(a1);
          destroy_component(ripple1);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_7$2.name,
        type: "if",
        source: "(104:12) {#if !usuario.estaAutenticado}",
        ctx
      });
      return block;
    } // (131:12) {#if mostrarCategorias}


    function create_if_block_5$5(ctx) {
      let div;
      let each_blocks = [];
      let each_1_lookup = new Map();
      let div_transition;
      let current;
      let each_value =
      /*grupos*/
      ctx[4];
      validate_each_argument(each_value);

      const get_key = ctx =>
      /*g*/
      ctx[24].id;

      validate_each_keys(ctx, each_value, get_each_context$f, get_key);

      for (let i = 0; i < each_value.length; i += 1) {
        let child_ctx = get_each_context$f(ctx, each_value, i);
        let key = get_key(child_ctx);
        each_1_lookup.set(key, each_blocks[i] = create_each_block$f(key, child_ctx));
      }

      const block = {
        c: function create() {
          div = element("div");

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].c();
          }

          add_location(div, file$w, 131, 16, 4228);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].m(div, null);
          }

          current = true;
        },
        p: function update(ctx, dirty) {
          if (dirty &
          /*categorias, grupos, updateGrupo, mostrarLista, updateCategorias*/
          1592) {
            const each_value =
            /*grupos*/
            ctx[4];
            validate_each_argument(each_value);
            group_outros();
            validate_each_keys(ctx, each_value, get_each_context$f, get_key);
            each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, div, outro_and_destroy_block, create_each_block$f, null, get_each_context$f);
            check_outros();
          }
        },
        i: function intro(local) {
          if (current) return;

          for (let i = 0; i < each_value.length; i += 1) {
            transition_in(each_blocks[i]);
          }

          add_render_callback(() => {
            if (!div_transition) div_transition = create_bidirectional_transition(div, fly, {
              y: -50,
              duration: 150
            }, true);
            div_transition.run(1);
          });
          current = true;
        },
        o: function outro(local) {
          for (let i = 0; i < each_blocks.length; i += 1) {
            transition_out(each_blocks[i]);
          }

          if (!div_transition) div_transition = create_bidirectional_transition(div, fly, {
            y: -50,
            duration: 150
          }, false);
          div_transition.run(0);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].d();
          }

          if (detaching && div_transition) div_transition.end();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_5$5.name,
        type: "if",
        source: "(131:12) {#if mostrarCategorias}",
        ctx
      });
      return block;
    } // (179:24) {#if mostrarLista.find((g1) => g1.id == g.id).activo}


    function create_if_block_6$3(ctx) {
      let div;
      let each_blocks = [];
      let each_1_lookup = new Map();
      let t;
      let div_transition;
      let current;

      function func_3(...args) {
        return (
          /*func_3*/
          ctx[18](
          /*g*/
          ctx[24], ...args)
        );
      }

      let each_value_1 =
      /*categorias*/
      ctx[3].filter(func_3);
      validate_each_argument(each_value_1);

      const get_key = ctx =>
      /*c*/
      ctx[27].id;

      validate_each_keys(ctx, each_value_1, get_each_context_1$6, get_key);

      for (let i = 0; i < each_value_1.length; i += 1) {
        let child_ctx = get_each_context_1$6(ctx, each_value_1, i);
        let key = get_key(child_ctx);
        each_1_lookup.set(key, each_blocks[i] = create_each_block_1$6(key, child_ctx));
      }

      const block = {
        c: function create() {
          div = element("div");

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].c();
          }

          t = space();
          add_location(div, file$w, 179, 28, 6780);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].m(div, null);
          }

          append_dev(div, t);
          current = true;
        },
        p: function update(new_ctx, dirty) {
          ctx = new_ctx;

          if (dirty &
          /*categorias, grupos, updateGrupo*/
          1048) {
            const each_value_1 =
            /*categorias*/
            ctx[3].filter(func_3);
            validate_each_argument(each_value_1);
            group_outros();
            validate_each_keys(ctx, each_value_1, get_each_context_1$6, get_key);
            each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value_1, each_1_lookup, div, outro_and_destroy_block, create_each_block_1$6, t, get_each_context_1$6);
            check_outros();
          }
        },
        i: function intro(local) {
          if (current) return;

          for (let i = 0; i < each_value_1.length; i += 1) {
            transition_in(each_blocks[i]);
          }

          add_render_callback(() => {
            if (!div_transition) div_transition = create_bidirectional_transition(div, fly, {
              y: -50,
              duration: 150
            }, true);
            div_transition.run(1);
          });
          current = true;
        },
        o: function outro(local) {
          for (let i = 0; i < each_blocks.length; i += 1) {
            transition_out(each_blocks[i]);
          }

          if (!div_transition) div_transition = create_bidirectional_transition(div, fly, {
            y: -50,
            duration: 150
          }, false);
          div_transition.run(0);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].d();
          }

          if (detaching && div_transition) div_transition.end();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_6$3.name,
        type: "if",
        source: "(179:24) {#if mostrarLista.find((g1) => g1.id == g.id).activo}",
        ctx
      });
      return block;
    } // (181:32) {#each categorias.filter( (c) => g.categorias.includes(c.id) ) as c (c.id)}


    function create_each_block_1$6(key_1, ctx) {
      let li;
      let a;
      let icon;
      let t0;
      let t1_value =
      /*c*/
      ctx[27].nombre + "";
      let t1;
      let a_href_value;
      let t2;
      let span;
      let checkbox;
      let updating_checked;
      let t3;
      let ripple;
      let current;

      function checkbox_checked_binding_1(value) {
        /*checkbox_checked_binding_1*/
        ctx[19].call(null, value,
        /*c*/
        ctx[27]);
      }

      function change_handler_1(...args) {
        return (
          /*change_handler_1*/
          ctx[20](
          /*c*/
          ctx[27], ...args)
        );
      }

      let checkbox_props = {
        right: true
      };

      if (
      /*c*/
      ctx[27].activa !== void 0) {
        checkbox_props.checked =
        /*c*/
        ctx[27].activa;
      }

      checkbox = new Ne({
        props: checkbox_props,
        $$inline: true
      });
      binding_callbacks.push(() => bind(checkbox, "checked", checkbox_checked_binding_1));
      checkbox.$on("change", change_handler_1);
      ripple = new he({
        $$inline: true
      });
      const block = {
        key: key_1,
        first: null,
        c: function create() {
          li = element("li");
          a = element("a");
          icon = element("icon");
          t0 = space();
          t1 = text(t1_value);
          t2 = space();
          span = element("span");
          create_component(checkbox.$$.fragment);
          t3 = space();
          create_component(ripple.$$.fragment);
          attr_dev(icon, "class", "fe fe-circle");
          add_location(icon, file$w, 183, 44, 7117);
          attr_dev(a, "href", a_href_value = "/" +
          /*c*/
          ctx[27].nombreCorto);
          attr_dev(a, "class", "svelte-swp9qc");
          add_location(a, file$w, 182, 40, 7044);
          set_style(span, "width", "fit-content");
          set_style(span, "margin-left", "auto");
          add_location(span, file$w, 186, 40, 7290);
          attr_dev(li, "class", "categoria-link svelte-swp9qc");
          add_location(li, file$w, 181, 36, 6975);
          this.first = li;
        },
        m: function mount(target, anchor) {
          insert_dev(target, li, anchor);
          append_dev(li, a);
          append_dev(a, icon);
          append_dev(a, t0);
          append_dev(a, t1);
          append_dev(li, t2);
          append_dev(li, span);
          mount_component(checkbox, span, null);
          append_dev(li, t3);
          mount_component(ripple, li, null);
          current = true;
        },
        p: function update(new_ctx, dirty) {
          ctx = new_ctx;
          if ((!current || dirty &
          /*categorias, grupos*/
          24) && t1_value !== (t1_value =
          /*c*/
          ctx[27].nombre + "")) set_data_dev(t1, t1_value);

          if (!current || dirty &
          /*categorias, grupos*/
          24 && a_href_value !== (a_href_value = "/" +
          /*c*/
          ctx[27].nombreCorto)) {
            attr_dev(a, "href", a_href_value);
          }

          const checkbox_changes = {};

          if (!updating_checked && dirty &
          /*categorias, grupos*/
          24) {
            updating_checked = true;
            checkbox_changes.checked =
            /*c*/
            ctx[27].activa;
            add_flush_callback(() => updating_checked = false);
          }

          checkbox.$set(checkbox_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(checkbox.$$.fragment, local);
          transition_in(ripple.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(checkbox.$$.fragment, local);
          transition_out(ripple.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(li);
          destroy_component(checkbox);
          destroy_component(ripple);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_each_block_1$6.name,
        type: "each",
        source: "(181:32) {#each categorias.filter( (c) => g.categorias.includes(c.id) ) as c (c.id)}",
        ctx
      });
      return block;
    } // (133:20) {#each grupos as g, i (g.id)}


    function create_each_block$f(key_1, ctx) {
      let li;
      let icon;
      let t0;
      let span0;
      let t1;
      let t2_value =
      /*g*/
      ctx[24].nombre + "";
      let t2;
      let t3;
      let ripple;
      let t4;
      let span1;
      let checkbox;
      let updating_checked;
      let li_class_value;
      let t5;
      let show_if =
      /*mostrarLista*/
      ctx[5].find(func).activo;
      let if_block_anchor;
      let current;
      let mounted;
      let dispose;

      function func(...args) {
        return (
          /*func*/
          ctx[11](
          /*g*/
          ctx[24], ...args)
        );
      }

      function func_1(...args) {
        return (
          /*func_1*/
          ctx[13](
          /*g*/
          ctx[24], ...args)
        );
      }

      ripple = new he({
        $$inline: true
      });

      function checkbox_checked_binding(value) {
        /*checkbox_checked_binding*/
        ctx[14].call(null, value,
        /*g*/
        ctx[24]);
      }

      function change_handler(...args) {
        return (
          /*change_handler*/
          ctx[15](
          /*g*/
          ctx[24], ...args)
        );
      }

      let checkbox_props = {
        true: true,
        right: true
      };

      if (
      /*g*/
      ctx[24].activo !== void 0) {
        checkbox_props.checked =
        /*g*/
        ctx[24].activo;
      }

      checkbox = new Ne({
        props: checkbox_props,
        $$inline: true
      });
      binding_callbacks.push(() => bind(checkbox, "checked", checkbox_checked_binding));
      checkbox.$on("change", change_handler);

      function func_2(...args) {
        return (
          /*func_2*/
          ctx[16](
          /*g*/
          ctx[24], ...args)
        );
      }

      function click_handler_1(...args) {
        return (
          /*click_handler_1*/
          ctx[17](
          /*g*/
          ctx[24], ...args)
        );
      }

      let if_block = show_if && create_if_block_6$3(ctx);
      const block = {
        key: key_1,
        first: null,
        c: function create() {
          li = element("li");
          icon = element("icon");
          t0 = space();
          span0 = element("span");
          t1 = space();
          t2 = text(t2_value);
          t3 = space();
          create_component(ripple.$$.fragment);
          t4 = space();
          span1 = element("span");
          create_component(checkbox.$$.fragment);
          t5 = space();
          if (if_block) if_block.c();
          if_block_anchor = empty();
          attr_dev(icon, "class", "fe fe-chevron-down");
          set_style(icon, "padding", "0");
          set_style(icon, "transform", "rotate(" + (
          /*mostrarLista*/
          ctx[5].find(func_1).activo ? 180 : 0) + "deg)");
          set_style(icon, "transition", "all 0.2s ease 0s");
          add_location(icon, file$w, 148, 28, 5098);
          set_style(span0, "margin-left", "auto");
          add_location(span0, file$w, 156, 28, 5534);
          set_style(span1, "width", "fit-content");
          set_style(span1, "margin-left", "auto");
          add_location(span1, file$w, 159, 28, 5677);
          attr_dev(li, "class", li_class_value = "grupo-categorias " + (
          /*mostrarLista*/
          ctx[5].find(func_2).activo ? "grupo-categorias-activo" : ""));
          add_location(li, file$w, 133, 24, 4353);
          this.first = li;
        },
        m: function mount(target, anchor) {
          insert_dev(target, li, anchor);
          append_dev(li, icon);
          append_dev(li, t0);
          append_dev(li, span0);
          append_dev(li, t1);
          append_dev(li, t2);
          append_dev(li, t3);
          mount_component(ripple, li, null);
          append_dev(li, t4);
          append_dev(li, span1);
          mount_component(checkbox, span1, null);
          insert_dev(target, t5, anchor);
          if (if_block) if_block.m(target, anchor);
          insert_dev(target, if_block_anchor, anchor);
          current = true;

          if (!mounted) {
            dispose = listen_dev(li, "click", click_handler_1, false, false, false);
            mounted = true;
          }
        },
        p: function update(new_ctx, dirty) {
          ctx = new_ctx;

          if (!current || dirty &
          /*mostrarLista, grupos*/
          48) {
            set_style(icon, "transform", "rotate(" + (
            /*mostrarLista*/
            ctx[5].find(func_1).activo ? 180 : 0) + "deg)");
          }

          if ((!current || dirty &
          /*grupos*/
          16) && t2_value !== (t2_value =
          /*g*/
          ctx[24].nombre + "")) set_data_dev(t2, t2_value);
          const checkbox_changes = {};

          if (!updating_checked && dirty &
          /*grupos*/
          16) {
            updating_checked = true;
            checkbox_changes.checked =
            /*g*/
            ctx[24].activo;
            add_flush_callback(() => updating_checked = false);
          }

          checkbox.$set(checkbox_changes);

          if (!current || dirty &
          /*mostrarLista, grupos*/
          48 && li_class_value !== (li_class_value = "grupo-categorias " + (
          /*mostrarLista*/
          ctx[5].find(func_2).activo ? "grupo-categorias-activo" : ""))) {
            attr_dev(li, "class", li_class_value);
          }

          if (dirty &
          /*mostrarLista, grupos*/
          48) show_if =
          /*mostrarLista*/
          ctx[5].find(func).activo;

          if (show_if) {
            if (if_block) {
              if_block.p(ctx, dirty);

              if (dirty &
              /*mostrarLista, grupos*/
              48) {
                transition_in(if_block, 1);
              }
            } else {
              if_block = create_if_block_6$3(ctx);
              if_block.c();
              transition_in(if_block, 1);
              if_block.m(if_block_anchor.parentNode, if_block_anchor);
            }
          } else if (if_block) {
            group_outros();
            transition_out(if_block, 1, 1, () => {
              if_block = null;
            });
            check_outros();
          }
        },
        i: function intro(local) {
          if (current) return;
          transition_in(ripple.$$.fragment, local);
          transition_in(checkbox.$$.fragment, local);
          transition_in(if_block);
          current = true;
        },
        o: function outro(local) {
          transition_out(ripple.$$.fragment, local);
          transition_out(checkbox.$$.fragment, local);
          transition_out(if_block);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(li);
          destroy_component(ripple);
          destroy_component(checkbox);
          if (detaching) detach_dev(t5);
          if (if_block) if_block.d(detaching);
          if (detaching) detach_dev(if_block_anchor);
          mounted = false;
          dispose();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_each_block$f.name,
        type: "each",
        source: "(133:20) {#each grupos as g, i (g.id)}",
        ctx
      });
      return block;
    } // (211:20) <Icon                          color="var(--color-texto2)"                          style="padding-right: 23px;"                          >


    function create_default_slot_1$h(ctx) {
      let switch_instance;
      let switch_instance_anchor;
      let current;
      var switch_value = Serio;

      function switch_props(ctx) {
        return {
          $$inline: true
        };
      }

      if (switch_value) {
        switch_instance = new switch_value(switch_props());
      }

      const block = {
        c: function create() {
          if (switch_instance) create_component(switch_instance.$$.fragment);
          switch_instance_anchor = empty();
        },
        m: function mount(target, anchor) {
          if (switch_instance) {
            mount_component(switch_instance, target, anchor);
          }

          insert_dev(target, switch_instance_anchor, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          if (switch_value !== (switch_value = Serio)) {
            if (switch_instance) {
              group_outros();
              const old_component = switch_instance;
              transition_out(old_component.$$.fragment, 1, 0, () => {
                destroy_component(old_component, 1);
              });
              check_outros();
            }

            if (switch_value) {
              switch_instance = new switch_value(switch_props());
              create_component(switch_instance.$$.fragment);
              transition_in(switch_instance.$$.fragment, 1);
              mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
            } else {
              switch_instance = null;
            }
          }
        },
        i: function intro(local) {
          if (current) return;
          if (switch_instance) transition_in(switch_instance.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          if (switch_instance) transition_out(switch_instance.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(switch_instance_anchor);
          if (switch_instance) destroy_component(switch_instance, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_1$h.name,
        type: "slot",
        source: "(211:20) <Icon                          color=\\\"var(--color-texto2)\\\"                          style=\\\"padding-right: 23px;\\\"                          >",
        ctx
      });
      return block;
    } // (219:12) {#if $globalStore.usuario.estaAutenticado}


    function create_if_block_4$6(ctx) {
      let a0;
      let li0;
      let icon0;
      let t0;
      let ripple0;
      let t1;
      let a1;
      let li1;
      let icon1;
      let t2;
      let ripple1;
      let t3;
      let a2;
      let li2;
      let icon2;
      let t4;
      let ripple2;
      let t5;
      let a3;
      let li3;
      let icon3;
      let t6;
      let ripple3;
      let current;
      ripple0 = new he({
        $$inline: true
      });
      ripple1 = new he({
        $$inline: true
      });
      ripple2 = new he({
        $$inline: true
      });
      ripple3 = new he({
        $$inline: true
      });
      const block = {
        c: function create() {
          a0 = element("a");
          li0 = element("li");
          icon0 = element("icon");
          t0 = text(" Creados ");
          create_component(ripple0.$$.fragment);
          t1 = space();
          a1 = element("a");
          li1 = element("li");
          icon1 = element("icon");
          t2 = text(" Favoritos ");
          create_component(ripple1.$$.fragment);
          t3 = space();
          a2 = element("a");
          li2 = element("li");
          icon2 = element("icon");
          t4 = text(" Seguidos ");
          create_component(ripple2.$$.fragment);
          t5 = space();
          a3 = element("a");
          li3 = element("li");
          icon3 = element("icon");
          t6 = text(" Ocultos ");
          create_component(ripple3.$$.fragment);
          attr_dev(icon0, "class", "fe fe-target");
          add_location(icon0, file$w, 220, 24, 8746);
          add_location(li0, file$w, 220, 20, 8742);
          attr_dev(a0, "href", "/Mis/Creados");
          add_location(a0, file$w, 219, 16, 8697);
          attr_dev(icon1, "class", "fe fe-star");
          add_location(icon1, file$w, 223, 24, 8890);
          add_location(li1, file$w, 223, 20, 8886);
          attr_dev(a1, "href", "/Mis/Favoritos");
          add_location(a1, file$w, 222, 16, 8839);
          attr_dev(icon2, "class", "fe fe-eye");
          add_location(icon2, file$w, 226, 24, 9033);
          add_location(li2, file$w, 226, 20, 9029);
          attr_dev(a2, "href", "/Mis/Seguidos");
          add_location(a2, file$w, 225, 16, 8983);
          attr_dev(icon3, "class", "fe fe-eye-off");
          add_location(icon3, file$w, 229, 24, 9173);
          add_location(li3, file$w, 229, 20, 9169);
          attr_dev(a3, "href", "/Mis/Ocultos");
          add_location(a3, file$w, 228, 16, 9124);
        },
        m: function mount(target, anchor) {
          insert_dev(target, a0, anchor);
          append_dev(a0, li0);
          append_dev(li0, icon0);
          append_dev(li0, t0);
          mount_component(ripple0, li0, null);
          insert_dev(target, t1, anchor);
          insert_dev(target, a1, anchor);
          append_dev(a1, li1);
          append_dev(li1, icon1);
          append_dev(li1, t2);
          mount_component(ripple1, li1, null);
          insert_dev(target, t3, anchor);
          insert_dev(target, a2, anchor);
          append_dev(a2, li2);
          append_dev(li2, icon2);
          append_dev(li2, t4);
          mount_component(ripple2, li2, null);
          insert_dev(target, t5, anchor);
          insert_dev(target, a3, anchor);
          append_dev(a3, li3);
          append_dev(li3, icon3);
          append_dev(li3, t6);
          mount_component(ripple3, li3, null);
          current = true;
        },
        i: function intro(local) {
          if (current) return;
          transition_in(ripple0.$$.fragment, local);
          transition_in(ripple1.$$.fragment, local);
          transition_in(ripple2.$$.fragment, local);
          transition_in(ripple3.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(ripple0.$$.fragment, local);
          transition_out(ripple1.$$.fragment, local);
          transition_out(ripple2.$$.fragment, local);
          transition_out(ripple3.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(a0);
          destroy_component(ripple0);
          if (detaching) detach_dev(t1);
          if (detaching) detach_dev(a1);
          destroy_component(ripple1);
          if (detaching) detach_dev(t3);
          if (detaching) detach_dev(a2);
          destroy_component(ripple2);
          if (detaching) detach_dev(t5);
          if (detaching) detach_dev(a3);
          destroy_component(ripple3);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_4$6.name,
        type: "if",
        source: "(219:12) {#if $globalStore.usuario.estaAutenticado}",
        ctx
      });
      return block;
    } // (241:12) {#if $globalStore.usuario.tieneToken}


    function create_if_block_3$c(ctx) {
      let a;
      let li;
      let icon;
      let t;
      let ripple;
      let current;
      ripple = new he({
        $$inline: true
      });
      const block = {
        c: function create() {
          a = element("a");
          li = element("li");
          icon = element("icon");
          t = text(" Ver token ");
          create_component(ripple.$$.fragment);
          attr_dev(icon, "class", "fe fe-user-check");
          add_location(icon, file$w, 243, 24, 9728);
          add_location(li, file$w, 242, 20, 9698);
          attr_dev(a, "href", "/Token");
          add_location(a, file$w, 241, 16, 9659);
        },
        m: function mount(target, anchor) {
          insert_dev(target, a, anchor);
          append_dev(a, li);
          append_dev(li, icon);
          append_dev(li, t);
          mount_component(ripple, li, null);
          current = true;
        },
        i: function intro(local) {
          if (current) return;
          transition_in(ripple.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(ripple.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(a);
          destroy_component(ripple);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_3$c.name,
        type: "if",
        source: "(241:12) {#if $globalStore.usuario.tieneToken}",
        ctx
      });
      return block;
    } // (248:12) {#if $globalStore.usuario.estaAutenticado}


    function create_if_block_2$i(ctx) {
      let li;
      let icon;
      let t;
      let ripple;
      let current;
      let mounted;
      let dispose;
      ripple = new he({
        $$inline: true
      });
      const block = {
        c: function create() {
          li = element("li");
          icon = element("icon");
          t = text(" Salir ");
          create_component(ripple.$$.fragment);
          attr_dev(icon, "class", "fe fe-log-out");
          add_location(icon, file$w, 249, 20, 9974);
          add_location(li, file$w, 248, 16, 9924);
        },
        m: function mount(target, anchor) {
          insert_dev(target, li, anchor);
          append_dev(li, icon);
          append_dev(li, t);
          mount_component(ripple, li, null);
          current = true;

          if (!mounted) {
            dispose = listen_dev(li, "click",
            /*desloguearse*/
            ctx[8], false, false, false);
            mounted = true;
          }
        },
        p: noop,
        i: function intro(local) {
          if (current) return;
          transition_in(ripple.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(ripple.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(li);
          destroy_component(ripple);
          mounted = false;
          dispose();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_2$i.name,
        type: "if",
        source: "(248:12) {#if $globalStore.usuario.estaAutenticado}",
        ctx
      });
      return block;
    } // (255:12) {#if $globalStore.usuario.esMod}


    function create_if_block_1$j(ctx) {
      let a;
      let li;
      let icon;
      let t;
      let ripple;
      let current;
      ripple = new he({
        $$inline: true
      });
      const block = {
        c: function create() {
          a = element("a");
          li = element("li");
          icon = element("icon");
          t = text(" Moderacion ");
          create_component(ripple.$$.fragment);
          attr_dev(icon, "class", "fe fe-triangle");
          add_location(icon, file$w, 257, 24, 10223);
          add_location(li, file$w, 256, 20, 10193);
          attr_dev(a, "href", "/Moderacion");
          add_location(a, file$w, 255, 16, 10149);
        },
        m: function mount(target, anchor) {
          insert_dev(target, a, anchor);
          append_dev(a, li);
          append_dev(li, icon);
          append_dev(li, t);
          mount_component(ripple, li, null);
          current = true;
        },
        i: function intro(local) {
          if (current) return;
          transition_in(ripple.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(ripple.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(a);
          destroy_component(ripple);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_1$j.name,
        type: "if",
        source: "(255:12) {#if $globalStore.usuario.esMod}",
        ctx
      });
      return block;
    } // (262:12) {#if $globalStore.usuario.esAdmin}


    function create_if_block$r(ctx) {
      let a;
      let li;
      let icon;
      let t;
      let ripple;
      let current;
      ripple = new he({
        $$inline: true
      });
      const block = {
        c: function create() {
          a = element("a");
          li = element("li");
          icon = element("icon");
          t = text(" Administracion ");
          create_component(ripple.$$.fragment);
          attr_dev(icon, "class", "fe fe-triangle");
          add_location(icon, file$w, 264, 24, 10488);
          add_location(li, file$w, 263, 20, 10458);
          attr_dev(a, "href", "/Administracion");
          add_location(a, file$w, 262, 16, 10410);
        },
        m: function mount(target, anchor) {
          insert_dev(target, a, anchor);
          append_dev(a, li);
          append_dev(li, icon);
          append_dev(li, t);
          mount_component(ripple, li, null);
          current = true;
        },
        i: function intro(local) {
          if (current) return;
          transition_in(ripple.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(ripple.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(a);
          destroy_component(ripple);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block$r.name,
        type: "if",
        source: "(262:12) {#if $globalStore.usuario.esAdmin}",
        ctx
      });
      return block;
    } // (89:0) <Sidepanel left bind:visible={mostrar} style="background: red">


    function create_default_slot$j(ctx) {
      let section;
      let div;
      let a0;
      let h1;
      let t1;
      let t2;
      let ul;
      let t3;
      let li0;
      let icon0;
      let t4;
      let span;
      let t5;
      let icon1;
      let t6;
      let ripple0;
      let t7;
      let t8;
      let hr0;
      let t9;
      let a1;
      let li1;
      let icon2;
      let t10;
      let ripple1;
      let t11;
      let a2;
      let li2;
      let icon3;
      let t12;
      let ripple2;
      let t13;
      let hr1;
      let t14;
      let t15;
      let hr2;
      let t16;
      let li3;
      let icon4;
      let t17;
      let ripple3;
      let t18;
      let a3;
      let li4;
      let icon5;
      let t19;
      let ripple4;
      let t20;
      let hr3;
      let t21;
      let t22;
      let t23;
      let hr4;
      let t24;
      let t25;
      let t26;
      let hr5;
      let current;
      let mounted;
      let dispose;
      let if_block0 =
      /*usuario*/
      ctx[6].estaAutenticado && create_if_block_8$2(ctx);
      let if_block1 = !
      /*usuario*/
      ctx[6].estaAutenticado && create_if_block_7$2(ctx);
      ripple0 = new he({
        $$inline: true
      });
      let if_block2 =
      /*mostrarCategorias*/
      ctx[1] && create_if_block_5$5(ctx);
      ripple1 = new he({
        $$inline: true
      });
      icon3 = new Me({
        props: {
          color: "var(--color-texto2)",
          style: "padding-right: 23px;",
          $$slots: {
            default: [create_default_slot_1$h]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      ripple2 = new he({
        $$inline: true
      });
      let if_block3 =
      /*$globalStore*/
      ctx[7].usuario.estaAutenticado && create_if_block_4$6(ctx);
      ripple3 = new he({
        $$inline: true
      });
      ripple4 = new he({
        $$inline: true
      });
      let if_block4 =
      /*$globalStore*/
      ctx[7].usuario.tieneToken && create_if_block_3$c(ctx);
      let if_block5 =
      /*$globalStore*/
      ctx[7].usuario.estaAutenticado && create_if_block_2$i(ctx);
      let if_block6 =
      /*$globalStore*/
      ctx[7].usuario.esMod && create_if_block_1$j(ctx);
      let if_block7 =
      /*$globalStore*/
      ctx[7].usuario.esAdmin && create_if_block$r(ctx);
      const block = {
        c: function create() {
          section = element("section");
          div = element("div");
          a0 = element("a");
          h1 = element("h1");
          h1.textContent = `${window.config.general.nombre.toUpperCase()}`;
          t1 = space();
          if (if_block0) if_block0.c();
          t2 = space();
          ul = element("ul");
          if (if_block1) if_block1.c();
          t3 = space();
          li0 = element("li");
          icon0 = element("icon");
          t4 = text(" Categorias\r\n                ");
          span = element("span");
          t5 = space();
          icon1 = element("icon");
          t6 = space();
          create_component(ripple0.$$.fragment);
          t7 = space();
          if (if_block2) if_block2.c();
          t8 = space();
          hr0 = element("hr");
          t9 = space();
          a1 = element("a");
          li1 = element("li");
          icon2 = element("icon");
          t10 = text(" Archivo ");
          create_component(ripple1.$$.fragment);
          t11 = space();
          a2 = element("a");
          li2 = element("li");
          create_component(icon3.$$.fragment);
          t12 = text(" Serios ");
          create_component(ripple2.$$.fragment);
          t13 = space();
          hr1 = element("hr");
          t14 = space();
          if (if_block3) if_block3.c();
          t15 = space();
          hr2 = element("hr");
          t16 = space();
          li3 = element("li");
          icon4 = element("icon");
          t17 = text(" Ajustes ");
          create_component(ripple3.$$.fragment);
          t18 = space();
          a3 = element("a");
          li4 = element("li");
          icon5 = element("icon");
          t19 = text(" Reglas ");
          create_component(ripple4.$$.fragment);
          t20 = space();
          hr3 = element("hr");
          t21 = space();
          if (if_block4) if_block4.c();
          t22 = space();
          if (if_block5) if_block5.c();
          t23 = space();
          hr4 = element("hr");
          t24 = space();
          if (if_block6) if_block6.c();
          t25 = space();
          if (if_block7) if_block7.c();
          t26 = space();
          hr5 = element("hr");
          set_style(h1, "font-family", "'euroFighter'");
          add_location(h1, file$w, 92, 16, 2834);
          attr_dev(a0, "href", "/");
          add_location(a0, file$w, 91, 12, 2804);
          attr_dev(div, "class", "menu-principal-header");
          add_location(div, file$w, 90, 8, 2755);
          attr_dev(icon0, "class", "fe fe-menu");
          add_location(icon0, file$w, 118, 16, 3771);
          set_style(span, "margin-left", "auto");
          add_location(span, file$w, 119, 16, 3827);
          attr_dev(icon1, "class", "fe fe-chevron-down");
          set_style(icon1, "padding", "0");
          set_style(icon1, "transform", "rotate(" + (
          /*mostrarCategorias*/
          ctx[1] ? 180 : 0) + "deg)");
          set_style(icon1, "transition", "all 0.2s ease 0s");
          add_location(icon1, file$w, 121, 16, 3880);
          add_location(li0, file$w, 113, 12, 3619);
          add_location(hr0, file$w, 204, 12, 8137);
          attr_dev(icon2, "class", "fe fe-book");
          add_location(icon2, file$w, 206, 20, 8198);
          add_location(li1, file$w, 206, 16, 8194);
          attr_dev(a1, "href", "/Archivo");
          add_location(a1, file$w, 205, 12, 8157);
          add_location(li2, file$w, 209, 16, 8317);
          attr_dev(a2, "href", "/Serios");
          add_location(a2, file$w, 208, 12, 8281);
          add_location(hr1, file$w, 217, 12, 8617);
          add_location(hr2, file$w, 232, 12, 9282);
          attr_dev(icon4, "class", "fe fe-settings");
          add_location(icon4, file$w, 234, 16, 9365);
          add_location(li3, file$w, 233, 12, 9302);
          attr_dev(icon5, "class", "fe fe-align-justify");
          add_location(icon5, file$w, 237, 20, 9493);
          add_location(li4, file$w, 237, 16, 9489);
          attr_dev(a3, "href", "/reglas.html");
          add_location(a3, file$w, 236, 12, 9448);
          add_location(hr3, file$w, 239, 12, 9584);
          add_location(hr4, file$w, 252, 12, 10077);
          add_location(hr5, file$w, 269, 12, 10652);
          add_location(ul, file$w, 102, 8, 3207);
          attr_dev(section, "class", "menu-principal svelte-swp9qc");
          add_location(section, file$w, 89, 4, 2713);
        },
        m: function mount(target, anchor) {
          insert_dev(target, section, anchor);
          append_dev(section, div);
          append_dev(div, a0);
          append_dev(a0, h1);
          append_dev(div, t1);
          if (if_block0) if_block0.m(div, null);
          append_dev(section, t2);
          append_dev(section, ul);
          if (if_block1) if_block1.m(ul, null);
          append_dev(ul, t3);
          append_dev(ul, li0);
          append_dev(li0, icon0);
          append_dev(li0, t4);
          append_dev(li0, span);
          append_dev(li0, t5);
          append_dev(li0, icon1);
          append_dev(li0, t6);
          mount_component(ripple0, li0, null);
          append_dev(ul, t7);
          if (if_block2) if_block2.m(ul, null);
          append_dev(ul, t8);
          append_dev(ul, hr0);
          append_dev(ul, t9);
          append_dev(ul, a1);
          append_dev(a1, li1);
          append_dev(li1, icon2);
          append_dev(li1, t10);
          mount_component(ripple1, li1, null);
          append_dev(ul, t11);
          append_dev(ul, a2);
          append_dev(a2, li2);
          mount_component(icon3, li2, null);
          append_dev(li2, t12);
          mount_component(ripple2, li2, null);
          append_dev(ul, t13);
          append_dev(ul, hr1);
          append_dev(ul, t14);
          if (if_block3) if_block3.m(ul, null);
          append_dev(ul, t15);
          append_dev(ul, hr2);
          append_dev(ul, t16);
          append_dev(ul, li3);
          append_dev(li3, icon4);
          append_dev(li3, t17);
          mount_component(ripple3, li3, null);
          append_dev(ul, t18);
          append_dev(ul, a3);
          append_dev(a3, li4);
          append_dev(li4, icon5);
          append_dev(li4, t19);
          mount_component(ripple4, li4, null);
          append_dev(ul, t20);
          append_dev(ul, hr3);
          append_dev(ul, t21);
          if (if_block4) if_block4.m(ul, null);
          append_dev(ul, t22);
          if (if_block5) if_block5.m(ul, null);
          append_dev(ul, t23);
          append_dev(ul, hr4);
          append_dev(ul, t24);
          if (if_block6) if_block6.m(ul, null);
          append_dev(ul, t25);
          if (if_block7) if_block7.m(ul, null);
          append_dev(ul, t26);
          append_dev(ul, hr5);
          current = true;

          if (!mounted) {
            dispose = [listen_dev(li0, "click",
            /*click_handler*/
            ctx[12], false, false, false), listen_dev(li3, "click",
            /*click_handler_2*/
            ctx[21], false, false, false)];
            mounted = true;
          }
        },
        p: function update(ctx, dirty) {
          if (
          /*usuario*/
          ctx[6].estaAutenticado) {
            if (if_block0) {
              if_block0.p(ctx, dirty);
            } else {
              if_block0 = create_if_block_8$2(ctx);
              if_block0.c();
              if_block0.m(div, null);
            }
          } else if (if_block0) {
            if_block0.d(1);
            if_block0 = null;
          }

          if (!
          /*usuario*/
          ctx[6].estaAutenticado) {
            if (if_block1) {
              if (dirty &
              /*usuario*/
              64) {
                transition_in(if_block1, 1);
              }
            } else {
              if_block1 = create_if_block_7$2(ctx);
              if_block1.c();
              transition_in(if_block1, 1);
              if_block1.m(ul, t3);
            }
          } else if (if_block1) {
            group_outros();
            transition_out(if_block1, 1, 1, () => {
              if_block1 = null;
            });
            check_outros();
          }

          if (!current || dirty &
          /*mostrarCategorias*/
          2) {
            set_style(icon1, "transform", "rotate(" + (
            /*mostrarCategorias*/
            ctx[1] ? 180 : 0) + "deg)");
          }

          if (
          /*mostrarCategorias*/
          ctx[1]) {
            if (if_block2) {
              if_block2.p(ctx, dirty);

              if (dirty &
              /*mostrarCategorias*/
              2) {
                transition_in(if_block2, 1);
              }
            } else {
              if_block2 = create_if_block_5$5(ctx);
              if_block2.c();
              transition_in(if_block2, 1);
              if_block2.m(ul, t8);
            }
          } else if (if_block2) {
            group_outros();
            transition_out(if_block2, 1, 1, () => {
              if_block2 = null;
            });
            check_outros();
          }

          const icon3_changes = {};

          if (dirty &
          /*$$scope*/
          1073741824) {
            icon3_changes.$$scope = {
              dirty,
              ctx
            };
          }

          icon3.$set(icon3_changes);

          if (
          /*$globalStore*/
          ctx[7].usuario.estaAutenticado) {
            if (if_block3) {
              if (dirty &
              /*$globalStore*/
              128) {
                transition_in(if_block3, 1);
              }
            } else {
              if_block3 = create_if_block_4$6(ctx);
              if_block3.c();
              transition_in(if_block3, 1);
              if_block3.m(ul, t15);
            }
          } else if (if_block3) {
            group_outros();
            transition_out(if_block3, 1, 1, () => {
              if_block3 = null;
            });
            check_outros();
          }

          if (
          /*$globalStore*/
          ctx[7].usuario.tieneToken) {
            if (if_block4) {
              if (dirty &
              /*$globalStore*/
              128) {
                transition_in(if_block4, 1);
              }
            } else {
              if_block4 = create_if_block_3$c(ctx);
              if_block4.c();
              transition_in(if_block4, 1);
              if_block4.m(ul, t22);
            }
          } else if (if_block4) {
            group_outros();
            transition_out(if_block4, 1, 1, () => {
              if_block4 = null;
            });
            check_outros();
          }

          if (
          /*$globalStore*/
          ctx[7].usuario.estaAutenticado) {
            if (if_block5) {
              if_block5.p(ctx, dirty);

              if (dirty &
              /*$globalStore*/
              128) {
                transition_in(if_block5, 1);
              }
            } else {
              if_block5 = create_if_block_2$i(ctx);
              if_block5.c();
              transition_in(if_block5, 1);
              if_block5.m(ul, t23);
            }
          } else if (if_block5) {
            group_outros();
            transition_out(if_block5, 1, 1, () => {
              if_block5 = null;
            });
            check_outros();
          }

          if (
          /*$globalStore*/
          ctx[7].usuario.esMod) {
            if (if_block6) {
              if (dirty &
              /*$globalStore*/
              128) {
                transition_in(if_block6, 1);
              }
            } else {
              if_block6 = create_if_block_1$j(ctx);
              if_block6.c();
              transition_in(if_block6, 1);
              if_block6.m(ul, t25);
            }
          } else if (if_block6) {
            group_outros();
            transition_out(if_block6, 1, 1, () => {
              if_block6 = null;
            });
            check_outros();
          }

          if (
          /*$globalStore*/
          ctx[7].usuario.esAdmin) {
            if (if_block7) {
              if (dirty &
              /*$globalStore*/
              128) {
                transition_in(if_block7, 1);
              }
            } else {
              if_block7 = create_if_block$r(ctx);
              if_block7.c();
              transition_in(if_block7, 1);
              if_block7.m(ul, t26);
            }
          } else if (if_block7) {
            group_outros();
            transition_out(if_block7, 1, 1, () => {
              if_block7 = null;
            });
            check_outros();
          }
        },
        i: function intro(local) {
          if (current) return;
          transition_in(if_block1);
          transition_in(ripple0.$$.fragment, local);
          transition_in(if_block2);
          transition_in(ripple1.$$.fragment, local);
          transition_in(icon3.$$.fragment, local);
          transition_in(ripple2.$$.fragment, local);
          transition_in(if_block3);
          transition_in(ripple3.$$.fragment, local);
          transition_in(ripple4.$$.fragment, local);
          transition_in(if_block4);
          transition_in(if_block5);
          transition_in(if_block6);
          transition_in(if_block7);
          current = true;
        },
        o: function outro(local) {
          transition_out(if_block1);
          transition_out(ripple0.$$.fragment, local);
          transition_out(if_block2);
          transition_out(ripple1.$$.fragment, local);
          transition_out(icon3.$$.fragment, local);
          transition_out(ripple2.$$.fragment, local);
          transition_out(if_block3);
          transition_out(ripple3.$$.fragment, local);
          transition_out(ripple4.$$.fragment, local);
          transition_out(if_block4);
          transition_out(if_block5);
          transition_out(if_block6);
          transition_out(if_block7);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(section);
          if (if_block0) if_block0.d();
          if (if_block1) if_block1.d();
          destroy_component(ripple0);
          if (if_block2) if_block2.d();
          destroy_component(ripple1);
          destroy_component(icon3);
          destroy_component(ripple2);
          if (if_block3) if_block3.d();
          destroy_component(ripple3);
          destroy_component(ripple4);
          if (if_block4) if_block4.d();
          if (if_block5) if_block5.d();
          if (if_block6) if_block6.d();
          if (if_block7) if_block7.d();
          mounted = false;
          run_all(dispose);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot$j.name,
        type: "slot",
        source: "(89:0) <Sidepanel left bind:visible={mostrar} style=\\\"background: red\\\">",
        ctx
      });
      return block;
    }

    function create_fragment$w(ctx) {
      let sidepanel;
      let updating_visible;
      let t;
      let ajustes;
      let updating_visible_1;
      let current;

      function sidepanel_visible_binding(value) {
        /*sidepanel_visible_binding*/
        ctx[22].call(null, value);
      }

      let sidepanel_props = {
        left: true,
        style: "background: red",
        $$slots: {
          default: [create_default_slot$j]
        },
        $$scope: {
          ctx
        }
      };

      if (
      /*mostrar*/
      ctx[0] !== void 0) {
        sidepanel_props.visible =
        /*mostrar*/
        ctx[0];
      }

      sidepanel = new Pn({
        props: sidepanel_props,
        $$inline: true
      });
      binding_callbacks.push(() => bind(sidepanel, "visible", sidepanel_visible_binding));

      function ajustes_visible_binding(value) {
        /*ajustes_visible_binding*/
        ctx[23].call(null, value);
      }

      let ajustes_props = {};

      if (
      /*mostrarAjustes*/
      ctx[2] !== void 0) {
        ajustes_props.visible =
        /*mostrarAjustes*/
        ctx[2];
      }

      ajustes = new Ajustes({
        props: ajustes_props,
        $$inline: true
      });
      binding_callbacks.push(() => bind(ajustes, "visible", ajustes_visible_binding));
      const block = {
        c: function create() {
          create_component(sidepanel.$$.fragment);
          t = space();
          create_component(ajustes.$$.fragment);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          mount_component(sidepanel, target, anchor);
          insert_dev(target, t, anchor);
          mount_component(ajustes, target, anchor);
          current = true;
        },
        p: function update(ctx, [dirty]) {
          const sidepanel_changes = {};

          if (dirty &
          /*$$scope, $globalStore, mostrarAjustes, grupos, categorias, mostrarLista, mostrarCategorias, usuario*/
          1073742078) {
            sidepanel_changes.$$scope = {
              dirty,
              ctx
            };
          }

          if (!updating_visible && dirty &
          /*mostrar*/
          1) {
            updating_visible = true;
            sidepanel_changes.visible =
            /*mostrar*/
            ctx[0];
            add_flush_callback(() => updating_visible = false);
          }

          sidepanel.$set(sidepanel_changes);
          const ajustes_changes = {};

          if (!updating_visible_1 && dirty &
          /*mostrarAjustes*/
          4) {
            updating_visible_1 = true;
            ajustes_changes.visible =
            /*mostrarAjustes*/
            ctx[2];
            add_flush_callback(() => updating_visible_1 = false);
          }

          ajustes.$set(ajustes_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(sidepanel.$$.fragment, local);
          transition_in(ajustes.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(sidepanel.$$.fragment, local);
          transition_out(ajustes.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(sidepanel, detaching);
          if (detaching) detach_dev(t);
          destroy_component(ajustes, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$w.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }

    function instance$w($$self, $$props, $$invalidate) {
      let $globalStore;
      validate_store(globalStore, "globalStore");
      component_subscribe($$self, globalStore, $$value => $$invalidate(7, $globalStore = $$value));
      let {
        $$slots: slots = {},
        $$scope
      } = $$props;
      validate_slots("MenuPrincipal", slots, []);
      let {
        mostrar = true
      } = $$props;
      let mostrarCategorias = false;
      let mostrarAjustes = false;
      let categorias = config.categorias.map(c => {
        c.activa = $globalStore.categoriasActivas.includes(c.id);
        c = c;
        return c;
      });
      let grupos = config.grupos.map(g => {
        let activo = g.categorias.reduce((acc, cid) => acc || categorias.find(c => c.id == cid).activa, false);
        return {
          id: g.id,
          nombre: g.nombre,
          categorias: g.categorias,
          activo
        };
      });
      let mostrarLista = config.grupos.map(g => {
        let activo = $globalStore.gruposActivos.includes(g.id);
        return {
          id: g.id,
          activo
        };
      });

      async function desloguearse() {
        await RChanClient.deslogearse();
        location.reload();
      }

      function updateCategorias(cids, value) {
        categorias.filter(c => cids.includes(c.id)).map(c => {
          c.activa = value;
          c = c;
        });
        $$invalidate(3, categorias);
      }

      function updateGrupo(cid) {
        grupos.filter(g => g.categorias.includes(cid)).map(g => {
          g.activo = g.categorias.reduce((acc, cid) => acc || categorias.find(c => c.id == cid).activa, false);
          g = g;
        });
        $$invalidate(4, grupos);
        mostrarLista.filter(g0 => grupos.find(g1 => g1.id == g0.id).categorias.includes(cid)).map(g => g.activo = grupos.find(g1 => g1.id == g.id).activo);
        $$invalidate(5, mostrarLista);
      }

      const writable_props = ["mostrar"];
      Object.keys($$props).forEach(key => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<MenuPrincipal> was created with unknown prop '${key}'`);
      });

      const func = (g, g1) => g1.id == g.id;

      const click_handler = () => {
        $$invalidate(1, mostrarCategorias = !mostrarCategorias);
      };

      const func_1 = (g, g1) => g1.id == g.id;

      function checkbox_checked_binding(value, g) {
        g.activo = value;
        $$invalidate(4, grupos);
      }

      const change_handler = (g, e) => {
        e.preventDefault();
        updateCategorias(g.categorias, e.target.checked);
        mostrarLista.find(g1 => g1.id == g.id).activo = e.target.checked;
        $$invalidate(5, mostrarLista);
      };

      const func_2 = (g, g1) => g1.id == g.id;

      const click_handler_1 = g => {
        mostrarLista.find(g1 => g1.id == g.id).activo = !mostrarLista.find(g1 => g1.id == g.id).activo;
        $$invalidate(5, mostrarLista);
      };

      const func_3 = (g, c) => g.categorias.includes(c.id);

      function checkbox_checked_binding_1(value, c) {
        c.activa = value;
        $$invalidate(3, categorias);
      }

      const change_handler_1 = (c, e) => updateGrupo(c.id);

      const click_handler_2 = () => $$invalidate(2, mostrarAjustes = true);

      function sidepanel_visible_binding(value) {
        mostrar = value;
        $$invalidate(0, mostrar), $$invalidate(2, mostrarAjustes);
      }

      function ajustes_visible_binding(value) {
        mostrarAjustes = value;
        $$invalidate(2, mostrarAjustes);
      }

      $$self.$$set = $$props => {
        if ("mostrar" in $$props) $$invalidate(0, mostrar = $$props.mostrar);
      };

      $$self.$capture_state = () => ({
        Ripple: he,
        Sidepanel: Pn,
        Checkbox: Ne,
        Icon: Me,
        fly,
        config,
        globalStore,
        RChanClient,
        Dialogo,
        Ajustes,
        more: More_vertical,
        serio: Serio,
        mostrar,
        mostrarCategorias,
        mostrarAjustes,
        categorias,
        grupos,
        mostrarLista,
        desloguearse,
        updateCategorias,
        updateGrupo,
        usuario,
        $globalStore
      });

      $$self.$inject_state = $$props => {
        if ("mostrar" in $$props) $$invalidate(0, mostrar = $$props.mostrar);
        if ("mostrarCategorias" in $$props) $$invalidate(1, mostrarCategorias = $$props.mostrarCategorias);
        if ("mostrarAjustes" in $$props) $$invalidate(2, mostrarAjustes = $$props.mostrarAjustes);
        if ("categorias" in $$props) $$invalidate(3, categorias = $$props.categorias);
        if ("grupos" in $$props) $$invalidate(4, grupos = $$props.grupos);
        if ("mostrarLista" in $$props) $$invalidate(5, mostrarLista = $$props.mostrarLista);
        if ("usuario" in $$props) $$invalidate(6, usuario = $$props.usuario);
      };

      let usuario;

      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }

      $$self.$$.update = () => {
        if ($$self.$$.dirty &
        /*mostrarLista*/
        32) {
           set_store_value(globalStore, $globalStore.gruposActivos = mostrarLista.filter(g => g.activo).map(g => g.id), $globalStore);
        }

        if ($$self.$$.dirty &
        /*categorias*/
        8) {
           set_store_value(globalStore, $globalStore.categoriasActivas = categorias.filter(c => c.activa).map(c => c.id), $globalStore);
        }

        if ($$self.$$.dirty &
        /*$globalStore*/
        128) {
           $$invalidate(6, usuario = $globalStore.usuario);
        }

        if ($$self.$$.dirty &
        /*mostrarAjustes*/
        4) {
           if (mostrarAjustes) $$invalidate(0, mostrar = false);
        }
      };

      return [mostrar, mostrarCategorias, mostrarAjustes, categorias, grupos, mostrarLista, usuario, $globalStore, desloguearse, updateCategorias, updateGrupo, func, click_handler, func_1, checkbox_checked_binding, change_handler, func_2, click_handler_1, func_3, checkbox_checked_binding_1, change_handler_1, click_handler_2, sidepanel_visible_binding, ajustes_visible_binding];
    }

    class MenuPrincipal extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$w, create_fragment$w, safe_not_equal, {
          mostrar: 0
        });
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "MenuPrincipal",
          options,
          id: create_fragment$w.name
        });
      }

      get mostrar() {
        throw new Error("<MenuPrincipal>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set mostrar(value) {
        throw new Error("<MenuPrincipal>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

    }

    /* src\components\FormularioLogin.svelte generated by Svelte v3.29.0 */
    const {
      console: console_1$7
    } = globals;
    const file$x = "src\\components\\FormularioLogin.svelte"; // (37:8) <div slot="title">

    function create_title_slot_1$1(ctx) {
      let div;
      const block = {
        c: function create() {
          div = element("div");
          div.textContent = "Ingresar";
          attr_dev(div, "slot", "title");
          add_location(div, file$x, 36, 8, 980);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_title_slot_1$1.name,
        type: "slot",
        source: "(37:8) <div slot=\\\"title\\\">",
        ctx
      });
      return block;
    } // (59:12) <Button color="primary" on:click={login} >


    function create_default_slot_3$g(ctx) {
      let t;
      const block = {
        c: function create() {
          t = text("Jeje ta bien");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_3$g.name,
        type: "slot",
        source: "(59:12) <Button color=\\\"primary\\\" on:click={login} >",
        ctx
      });
      return block;
    } // (58:8) <div slot="actions" class="actions center">


    function create_actions_slot_1$1(ctx) {
      let div;
      let button;
      let current;
      button = new ye({
        props: {
          color: "primary",
          $$slots: {
            default: [create_default_slot_3$g]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      button.$on("click",
      /*login*/
      ctx[5]);
      const block = {
        c: function create() {
          div = element("div");
          create_component(button.$$.fragment);
          attr_dev(div, "slot", "actions");
          attr_dev(div, "class", "actions center");
          add_location(div, file$x, 57, 8, 1464);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          mount_component(button, div, null);
          current = true;
        },
        p: function update(ctx, dirty) {
          const button_changes = {};

          if (dirty &
          /*$$scope*/
          4096) {
            button_changes.$$scope = {
              dirty,
              ctx
            };
          }

          button.$set(button_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(button.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(button.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
          destroy_component(button);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_actions_slot_1$1.name,
        type: "slot",
        source: "(58:8) <div slot=\\\"actions\\\" class=\\\"actions center\\\">",
        ctx
      });
      return block;
    } // (36:0) <Dialog width="290" bind:visible= {$globalStore.mostrarLogin}>


    function create_default_slot_2$g(ctx) {
      let t0;
      let textfield0;
      let updating_value;
      let t1;
      let textfield1;
      let updating_value_1;
      let t2;
      let errorvalidacion;
      let t3;
      let current;

      function textfield0_value_binding(value) {
        /*textfield0_value_binding*/
        ctx[6].call(null, value);
      }

      let textfield0_props = {
        name: "Nick",
        autocomplete: "off",
        required: true,
        label: "nick",
        message: "Como te llamas tu?"
      };

      if (
      /*nick*/
      ctx[0] !== void 0) {
        textfield0_props.value =
        /*nick*/
        ctx[0];
      }

      textfield0 = new Ve({
        props: textfield0_props,
        $$inline: true
      });
      binding_callbacks.push(() => bind(textfield0, "value", textfield0_value_binding));

      function textfield1_value_binding(value) {
        /*textfield1_value_binding*/
        ctx[7].call(null, value);
      }

      let textfield1_props = {
        type: "password",
        name: "Contraseña",
        autocomplete: "off",
        required: true,
        label: "Contraseña",
        message: "Gordo1234"
      };

      if (
      /*contraseña*/
      ctx[1] !== void 0) {
        textfield1_props.value =
        /*contraseña*/
        ctx[1];
      }

      textfield1 = new Ve({
        props: textfield1_props,
        $$inline: true
      });
      binding_callbacks.push(() => bind(textfield1, "value", textfield1_value_binding));
      errorvalidacion = new ErrorValidacion({
        props: {
          error:
          /*error*/
          ctx[2]
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          t0 = space();
          create_component(textfield0.$$.fragment);
          t1 = space();
          create_component(textfield1.$$.fragment);
          t2 = space();
          create_component(errorvalidacion.$$.fragment);
          t3 = space();
        },
        m: function mount(target, anchor) {
          insert_dev(target, t0, anchor);
          mount_component(textfield0, target, anchor);
          insert_dev(target, t1, anchor);
          mount_component(textfield1, target, anchor);
          insert_dev(target, t2, anchor);
          mount_component(errorvalidacion, target, anchor);
          insert_dev(target, t3, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          const textfield0_changes = {};

          if (!updating_value && dirty &
          /*nick*/
          1) {
            updating_value = true;
            textfield0_changes.value =
            /*nick*/
            ctx[0];
            add_flush_callback(() => updating_value = false);
          }

          textfield0.$set(textfield0_changes);
          const textfield1_changes = {};

          if (!updating_value_1 && dirty &
          /*contraseña*/
          2) {
            updating_value_1 = true;
            textfield1_changes.value =
            /*contraseña*/
            ctx[1];
            add_flush_callback(() => updating_value_1 = false);
          }

          textfield1.$set(textfield1_changes);
          const errorvalidacion_changes = {};
          if (dirty &
          /*error*/
          4) errorvalidacion_changes.error =
          /*error*/
          ctx[2];
          errorvalidacion.$set(errorvalidacion_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(textfield0.$$.fragment, local);
          transition_in(textfield1.$$.fragment, local);
          transition_in(errorvalidacion.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(textfield0.$$.fragment, local);
          transition_out(textfield1.$$.fragment, local);
          transition_out(errorvalidacion.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(t0);
          destroy_component(textfield0, detaching);
          if (detaching) detach_dev(t1);
          destroy_component(textfield1, detaching);
          if (detaching) detach_dev(t2);
          destroy_component(errorvalidacion, detaching);
          if (detaching) detach_dev(t3);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_2$g.name,
        type: "slot",
        source: "(36:0) <Dialog width=\\\"290\\\" bind:visible= {$globalStore.mostrarLogin}>",
        ctx
      });
      return block;
    } // (65:4) <div slot="title">


    function create_title_slot$6(ctx) {
      let div;
      const block = {
        c: function create() {
          div = element("div");
          div.textContent = "Registrate";
          attr_dev(div, "slot", "title");
          add_location(div, file$x, 64, 4, 1693);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_title_slot$6.name,
        type: "slot",
        source: "(65:4) <div slot=\\\"title\\\">",
        ctx
      });
      return block;
    } // (87:8) <Button  on:click={registrar} color="primary" >


    function create_default_slot_1$i(ctx) {
      let t;
      const block = {
        c: function create() {
          t = text("Jeje ta bien");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_1$i.name,
        type: "slot",
        source: "(87:8) <Button  on:click={registrar} color=\\\"primary\\\" >",
        ctx
      });
      return block;
    } // (86:4) <div slot="actions" class="actions center">


    function create_actions_slot$5(ctx) {
      let div;
      let button;
      let current;
      button = new ye({
        props: {
          color: "primary",
          $$slots: {
            default: [create_default_slot_1$i]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      button.$on("click",
      /*registrar*/
      ctx[4]);
      const block = {
        c: function create() {
          div = element("div");
          create_component(button.$$.fragment);
          attr_dev(div, "slot", "actions");
          attr_dev(div, "class", "actions center");
          add_location(div, file$x, 85, 4, 2139);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          mount_component(button, div, null);
          current = true;
        },
        p: function update(ctx, dirty) {
          const button_changes = {};

          if (dirty &
          /*$$scope*/
          4096) {
            button_changes.$$scope = {
              dirty,
              ctx
            };
          }

          button.$set(button_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(button.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(button.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
          destroy_component(button);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_actions_slot$5.name,
        type: "slot",
        source: "(86:4) <div slot=\\\"actions\\\" class=\\\"actions center\\\">",
        ctx
      });
      return block;
    } // (64:0) <Dialog width="290" bind:visible= {$globalStore.mostrarRegistro}>


    function create_default_slot$k(ctx) {
      let t0;
      let textfield0;
      let updating_value;
      let t1;
      let textfield1;
      let updating_value_1;
      let t2;
      let errorvalidacion;
      let t3;
      let current;

      function textfield0_value_binding_1(value) {
        /*textfield0_value_binding_1*/
        ctx[9].call(null, value);
      }

      let textfield0_props = {
        name: "Nick",
        autocomplete: "off",
        required: true,
        label: "nick",
        message: "Como te llamas tu?"
      };

      if (
      /*nick*/
      ctx[0] !== void 0) {
        textfield0_props.value =
        /*nick*/
        ctx[0];
      }

      textfield0 = new Ve({
        props: textfield0_props,
        $$inline: true
      });
      binding_callbacks.push(() => bind(textfield0, "value", textfield0_value_binding_1));

      function textfield1_value_binding_1(value) {
        /*textfield1_value_binding_1*/
        ctx[10].call(null, value);
      }

      let textfield1_props = {
        type: "password",
        name: "Contraseña",
        autocomplete: "off",
        required: true,
        label: "Contraseña",
        message: "Gordo1234"
      };

      if (
      /*contraseña*/
      ctx[1] !== void 0) {
        textfield1_props.value =
        /*contraseña*/
        ctx[1];
      }

      textfield1 = new Ve({
        props: textfield1_props,
        $$inline: true
      });
      binding_callbacks.push(() => bind(textfield1, "value", textfield1_value_binding_1));
      errorvalidacion = new ErrorValidacion({
        props: {
          error:
          /*error*/
          ctx[2]
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          t0 = space();
          create_component(textfield0.$$.fragment);
          t1 = space();
          create_component(textfield1.$$.fragment);
          t2 = space();
          create_component(errorvalidacion.$$.fragment);
          t3 = space();
        },
        m: function mount(target, anchor) {
          insert_dev(target, t0, anchor);
          mount_component(textfield0, target, anchor);
          insert_dev(target, t1, anchor);
          mount_component(textfield1, target, anchor);
          insert_dev(target, t2, anchor);
          mount_component(errorvalidacion, target, anchor);
          insert_dev(target, t3, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          const textfield0_changes = {};

          if (!updating_value && dirty &
          /*nick*/
          1) {
            updating_value = true;
            textfield0_changes.value =
            /*nick*/
            ctx[0];
            add_flush_callback(() => updating_value = false);
          }

          textfield0.$set(textfield0_changes);
          const textfield1_changes = {};

          if (!updating_value_1 && dirty &
          /*contraseña*/
          2) {
            updating_value_1 = true;
            textfield1_changes.value =
            /*contraseña*/
            ctx[1];
            add_flush_callback(() => updating_value_1 = false);
          }

          textfield1.$set(textfield1_changes);
          const errorvalidacion_changes = {};
          if (dirty &
          /*error*/
          4) errorvalidacion_changes.error =
          /*error*/
          ctx[2];
          errorvalidacion.$set(errorvalidacion_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(textfield0.$$.fragment, local);
          transition_in(textfield1.$$.fragment, local);
          transition_in(errorvalidacion.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(textfield0.$$.fragment, local);
          transition_out(textfield1.$$.fragment, local);
          transition_out(errorvalidacion.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(t0);
          destroy_component(textfield0, detaching);
          if (detaching) detach_dev(t1);
          destroy_component(textfield1, detaching);
          if (detaching) detach_dev(t2);
          destroy_component(errorvalidacion, detaching);
          if (detaching) detach_dev(t3);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot$k.name,
        type: "slot",
        source: "(64:0) <Dialog width=\\\"290\\\" bind:visible= {$globalStore.mostrarRegistro}>",
        ctx
      });
      return block;
    }

    function create_fragment$x(ctx) {
      let dialog0;
      let updating_visible;
      let t;
      let dialog1;
      let updating_visible_1;
      let current;

      function dialog0_visible_binding(value) {
        /*dialog0_visible_binding*/
        ctx[8].call(null, value);
      }

      let dialog0_props = {
        width: "290",
        $$slots: {
          default: [create_default_slot_2$g],
          actions: [create_actions_slot_1$1],
          title: [create_title_slot_1$1]
        },
        $$scope: {
          ctx
        }
      };

      if (
      /*$globalStore*/
      ctx[3].mostrarLogin !== void 0) {
        dialog0_props.visible =
        /*$globalStore*/
        ctx[3].mostrarLogin;
      }

      dialog0 = new pn({
        props: dialog0_props,
        $$inline: true
      });
      binding_callbacks.push(() => bind(dialog0, "visible", dialog0_visible_binding));

      function dialog1_visible_binding(value) {
        /*dialog1_visible_binding*/
        ctx[11].call(null, value);
      }

      let dialog1_props = {
        width: "290",
        $$slots: {
          default: [create_default_slot$k],
          actions: [create_actions_slot$5],
          title: [create_title_slot$6]
        },
        $$scope: {
          ctx
        }
      };

      if (
      /*$globalStore*/
      ctx[3].mostrarRegistro !== void 0) {
        dialog1_props.visible =
        /*$globalStore*/
        ctx[3].mostrarRegistro;
      }

      dialog1 = new pn({
        props: dialog1_props,
        $$inline: true
      });
      binding_callbacks.push(() => bind(dialog1, "visible", dialog1_visible_binding));
      const block = {
        c: function create() {
          create_component(dialog0.$$.fragment);
          t = space();
          create_component(dialog1.$$.fragment);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          mount_component(dialog0, target, anchor);
          insert_dev(target, t, anchor);
          mount_component(dialog1, target, anchor);
          current = true;
        },
        p: function update(ctx, [dirty]) {
          const dialog0_changes = {};

          if (dirty &
          /*$$scope, error, contraseña, nick*/
          4103) {
            dialog0_changes.$$scope = {
              dirty,
              ctx
            };
          }

          if (!updating_visible && dirty &
          /*$globalStore*/
          8) {
            updating_visible = true;
            dialog0_changes.visible =
            /*$globalStore*/
            ctx[3].mostrarLogin;
            add_flush_callback(() => updating_visible = false);
          }

          dialog0.$set(dialog0_changes);
          const dialog1_changes = {};

          if (dirty &
          /*$$scope, error, contraseña, nick*/
          4103) {
            dialog1_changes.$$scope = {
              dirty,
              ctx
            };
          }

          if (!updating_visible_1 && dirty &
          /*$globalStore*/
          8) {
            updating_visible_1 = true;
            dialog1_changes.visible =
            /*$globalStore*/
            ctx[3].mostrarRegistro;
            add_flush_callback(() => updating_visible_1 = false);
          }

          dialog1.$set(dialog1_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(dialog0.$$.fragment, local);
          transition_in(dialog1.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(dialog0.$$.fragment, local);
          transition_out(dialog1.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(dialog0, detaching);
          if (detaching) detach_dev(t);
          destroy_component(dialog1, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$x.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }

    function instance$x($$self, $$props, $$invalidate) {
      let $globalStore;
      validate_store(globalStore, "globalStore");
      component_subscribe($$self, globalStore, $$value => $$invalidate(3, $globalStore = $$value));
      let {
        $$slots: slots = {},
        $$scope
      } = $$props;
      validate_slots("FormularioLogin", slots, []);
      let {
        nick = ""
      } = $$props;
      let {
        contraseña = ""
      } = $$props;
      let error = null;

      async function registrar() {
        try {
          await RChanClient.registrase(nick, contraseña);
        } catch (e) {
          console.log(e);
          $$invalidate(2, error = e.response.data);
          return;
        }

        window.location = "/";
        location.reload();
      }

      async function login() {
        try {
          await RChanClient.logearse(nick, contraseña);
        } catch (e) {
          console.log(e);
          console.log(e.response);
          $$invalidate(2, error = e.response.data);
          return;
        }

        window.location = "/";
        location.reload();
      }

      const writable_props = ["nick", "contraseña"];
      Object.keys($$props).forEach(key => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$7.warn(`<FormularioLogin> was created with unknown prop '${key}'`);
      });

      function textfield0_value_binding(value) {
        nick = value;
        $$invalidate(0, nick);
      }

      function textfield1_value_binding(value) {
        contraseña = value;
        $$invalidate(1, contraseña);
      }

      function dialog0_visible_binding(value) {
        $globalStore.mostrarLogin = value;
        globalStore.set($globalStore);
      }

      function textfield0_value_binding_1(value) {
        nick = value;
        $$invalidate(0, nick);
      }

      function textfield1_value_binding_1(value) {
        contraseña = value;
        $$invalidate(1, contraseña);
      }

      function dialog1_visible_binding(value) {
        $globalStore.mostrarRegistro = value;
        globalStore.set($globalStore);
      }

      $$self.$$set = $$props => {
        if ("nick" in $$props) $$invalidate(0, nick = $$props.nick);
        if ("contraseña" in $$props) $$invalidate(1, contraseña = $$props.contraseña);
      };

      $$self.$capture_state = () => ({
        Dialog: pn,
        Textfield: Ve,
        Button: ye,
        globalStore,
        RChanClient,
        ErrorValidacion,
        nick,
        contraseña,
        error,
        registrar,
        login,
        $globalStore
      });

      $$self.$inject_state = $$props => {
        if ("nick" in $$props) $$invalidate(0, nick = $$props.nick);
        if ("contraseña" in $$props) $$invalidate(1, contraseña = $$props.contraseña);
        if ("error" in $$props) $$invalidate(2, error = $$props.error);
      };

      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }

      return [nick, contraseña, error, $globalStore, registrar, login, textfield0_value_binding, textfield1_value_binding, dialog0_visible_binding, textfield0_value_binding_1, textfield1_value_binding_1, dialog1_visible_binding];
    }

    class FormularioLogin extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$x, create_fragment$x, safe_not_equal, {
          nick: 0,
          contraseña: 1
        });
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "FormularioLogin",
          options,
          id: create_fragment$x.name
        });
      }

      get nick() {
        throw new Error("<FormularioLogin>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set nick(value) {
        throw new Error("<FormularioLogin>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get contraseña() {
        throw new Error("<FormularioLogin>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set contraseña(value) {
        throw new Error("<FormularioLogin>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

    }

    /* src\components\MensajeRotativo.svelte generated by Svelte v3.29.0 */
    const file$y = "src\\components\\MensajeRotativo.svelte";

    function create_fragment$y(ctx) {
      let div1;
      let div0;
      let span0;
      let t0;
      let span0_resize_listener;
      let t1;
      let span1;
      let t2;
      let div1_resize_listener;
      const block = {
        c: function create() {
          div1 = element("div");
          div0 = element("div");
          span0 = element("span");
          t0 = text(
          /*texto*/
          ctx[0]);
          t1 = space();
          span1 = element("span");
          t2 = text(
          /*texto*/
          ctx[0]);
          attr_dev(span0, "class", "rt1 svelte-c1fezs");
          add_render_callback(() =>
          /*span0_elementresize_handler*/
          ctx[7].call(span0));
          add_location(span0, file$y, 28, 8, 2502);
          attr_dev(span1, "class", "rt2 svelte-c1fezs");
          add_location(span1, file$y, 29, 8, 2588);
          attr_dev(div0, "class", "mensaje-rotativo svelte-c1fezs");
          set_style(div0, "--width",
          /*textWidth*/
          ctx[1] + "px");
          set_style(div0, "--duracion",
          /*duracion*/
          ctx[5] + "s");
          add_location(div0, file$y, 27, 4, 2407);
          attr_dev(div1, "class", "container svelte-c1fezs");
          add_render_callback(() =>
          /*div1_elementresize_handler*/
          ctx[9].call(div1));
          add_location(div1, file$y, 26, 0, 2354);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, div1, anchor);
          append_dev(div1, div0);
          append_dev(div0, span0);
          append_dev(span0, t0);
          /*span0_binding*/

          ctx[6](span0);
          span0_resize_listener = add_resize_listener(span0,
          /*span0_elementresize_handler*/
          ctx[7].bind(span0));
          append_dev(div0, t1);
          append_dev(div0, span1);
          append_dev(span1, t2);
          /*span1_binding*/

          ctx[8](span1);
          div1_resize_listener = add_resize_listener(div1,
          /*div1_elementresize_handler*/
          ctx[9].bind(div1));
        },
        p: function update(ctx, [dirty]) {
          if (dirty &
          /*texto*/
          1) set_data_dev(t0,
          /*texto*/
          ctx[0]);
          if (dirty &
          /*texto*/
          1) set_data_dev(t2,
          /*texto*/
          ctx[0]);

          if (dirty &
          /*textWidth*/
          2) {
            set_style(div0, "--width",
            /*textWidth*/
            ctx[1] + "px");
          }

          if (dirty &
          /*duracion*/
          32) {
            set_style(div0, "--duracion",
            /*duracion*/
            ctx[5] + "s");
          }
        },
        i: noop,
        o: noop,
        d: function destroy(detaching) {
          if (detaching) detach_dev(div1);
          /*span0_binding*/

          ctx[6](null);
          span0_resize_listener();
          /*span1_binding*/

          ctx[8](null);
          div1_resize_listener();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$y.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }

    function instance$y($$self, $$props, $$invalidate) {
      let {
        $$slots: slots = {},
        $$scope
      } = $$props;
      validate_slots("MensajeRotativo", slots, []);
      let {
        texto = `Me agarré a las piñas con la familia de mi novia

Fui a cenar a lo de mi novia y me agarre con el padre.
Les pasó a contar, la cosa es que estoy saliendo hace dos meses con una chica y el sábado pasado fui a cenar a la casa por primera vez.
La cita era en la casa del padre a eso de las 21,00hs. Apenas llego nos atiende una chica de más de 20 años a lo que le pregunto si era la hermana, la chica puso cara rara y me dijo "no, soy la novia del papá" a esto el padre estaba ya sentado en la cabeza de la mesa y escuchó todo, me clavó una mirada de odio terrible. Ahí nomás me presenta con el padre y el hermano que también estaba ahí.
Todo transcurria con normalidad hasta que me ofrece pan para la comida (hicieron ravioles caseros) lo cual le digo que no, gracias,que estoy dejando los carbohidratos y que ya tenía sufriente con los ravioles, a lo que el padre se me caga de risa y me dice"pero si pareces una lombriz, mi nena es mucha carne para tan poco perro". En ese instante me sale del alma " que maleducado que es usted"a lo cual instantaneamente se levanta y dice "que dijiste pendejo de mierda" y me quiere dar un cachetazo, al cual por reflejo se lo freno apartandole la mano violentamente. Al toque salta el hermano y nose que me dice, lo miro y el padre me emboca una piña en la cara, ahí me caigo un poco para atrás se caen unos vasos los platos, me repongo y le devuelvo la piña, se la pego pero de refilón,y ahí salta el hermano a pegarme a traición, lo veo venir con mi vista periférica y trato de esquivarlo, a lo cual la hermana me quiere dar un botellazo.
Esquivo el botellazo y me quiere pegar de nuevo, ahí me doy cuenta que los tres están contra mi, entonces no me quedo otra que, lo tenía que hacer, hago una maniobra para pararme bien y hago la patada 360° sobre mi propio eje, golpeando a los tres a la vez,agarró a mi novia salimos corriendo y pasamos toda la noche haciendo el amor`
      } = $$props;
      let textWidth = 0;
      let rt1;
      let rt2;
      let width = 100;
      let duracion = 100;
      const writable_props = ["texto"];
      Object.keys($$props).forEach(key => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<MensajeRotativo> was created with unknown prop '${key}'`);
      });

      function span0_binding($$value) {
        binding_callbacks[$$value ? "unshift" : "push"](() => {
          rt1 = $$value;
          $$invalidate(2, rt1);
        });
      }

      function span0_elementresize_handler() {
        textWidth = this.offsetWidth;
        $$invalidate(1, textWidth);
      }

      function span1_binding($$value) {
        binding_callbacks[$$value ? "unshift" : "push"](() => {
          rt2 = $$value;
          $$invalidate(3, rt2);
        });
      }

      function div1_elementresize_handler() {
        width = this.offsetWidth;
        $$invalidate(4, width);
      }

      $$self.$$set = $$props => {
        if ("texto" in $$props) $$invalidate(0, texto = $$props.texto);
      };

      $$self.$capture_state = () => ({
        onMount,
        texto,
        textWidth,
        rt1,
        rt2,
        width,
        duracion
      });

      $$self.$inject_state = $$props => {
        if ("texto" in $$props) $$invalidate(0, texto = $$props.texto);
        if ("textWidth" in $$props) $$invalidate(1, textWidth = $$props.textWidth);
        if ("rt1" in $$props) $$invalidate(2, rt1 = $$props.rt1);
        if ("rt2" in $$props) $$invalidate(3, rt2 = $$props.rt2);
        if ("width" in $$props) $$invalidate(4, width = $$props.width);
        if ("duracion" in $$props) $$invalidate(5, duracion = $$props.duracion);
      };

      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }

      $$self.$$.update = () => {
        if ($$self.$$.dirty &
        /*width, rt1, rt2*/
        28) {
           if (width && rt1 && rt2) {
            $$invalidate(5, duracion = width * width / 2000);
            rt1.classList.remove("rt1");
            rt2.classList.remove("rt2");
            setTimeout(() => {
              rt1.classList.add("rt1");
              rt2.classList.add("rt2");
            }, 50);
          }
        }
      };

      return [texto, textWidth, rt1, rt2, width, duracion, span0_binding, span0_elementresize_handler, span1_binding, div1_elementresize_handler];
    }

    class MensajeRotativo extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$y, create_fragment$y, safe_not_equal, {
          texto: 0
        });
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "MensajeRotativo",
          options,
          id: create_fragment$y.name
        });
      }

      get texto() {
        throw new Error("<MensajeRotativo>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set texto(value) {
        throw new Error("<MensajeRotativo>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

    }

    /* src\components\Dado.svelte generated by Svelte v3.29.0 */
    const file$z = "src\\components\\Dado.svelte";

    function create_fragment$z(ctx) {
      let div3;
      let div0;
      let span0;
      let t0;
      let span1;
      let t1;
      let div1;
      let span2;
      let t2;
      let div2;
      let span3;
      let t3;
      let span4;
      const block = {
        c: function create() {
          div3 = element("div");
          div0 = element("div");
          span0 = element("span");
          t0 = space();
          span1 = element("span");
          t1 = space();
          div1 = element("div");
          span2 = element("span");
          t2 = space();
          div2 = element("div");
          span3 = element("span");
          t3 = space();
          span4 = element("span");
          attr_dev(span0, "class", "dot svelte-8u8x8o");
          add_location(span0, file$z, 4, 6, 65);
          attr_dev(span1, "class", "dot svelte-8u8x8o");
          add_location(span1, file$z, 5, 6, 97);
          attr_dev(div0, "class", "column svelte-8u8x8o");
          add_location(div0, file$z, 3, 4, 38);
          attr_dev(span2, "class", "dot svelte-8u8x8o");
          add_location(span2, file$z, 9, 6, 170);
          attr_dev(div1, "class", "column svelte-8u8x8o");
          add_location(div1, file$z, 8, 4, 143);
          attr_dev(span3, "class", "dot svelte-8u8x8o");
          add_location(span3, file$z, 13, 6, 243);
          attr_dev(span4, "class", "dot svelte-8u8x8o");
          add_location(span4, file$z, 14, 6, 275);
          attr_dev(div2, "class", "column svelte-8u8x8o");
          add_location(div2, file$z, 12, 4, 216);
          attr_dev(div3, "class", "fifth-face dice svelte-8u8x8o");
          add_location(div3, file$z, 1, 0, 1);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, div3, anchor);
          append_dev(div3, div0);
          append_dev(div0, span0);
          append_dev(div0, t0);
          append_dev(div0, span1);
          append_dev(div3, t1);
          append_dev(div3, div1);
          append_dev(div1, span2);
          append_dev(div3, t2);
          append_dev(div3, div2);
          append_dev(div2, span3);
          append_dev(div2, t3);
          append_dev(div2, span4);
        },
        p: noop,
        i: noop,
        o: noop,
        d: function destroy(detaching) {
          if (detaching) detach_dev(div3);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$z.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }

    function instance$z($$self, $$props) {
      let {
        $$slots: slots = {},
        $$scope
      } = $$props;
      validate_slots("Dado", slots, []);
      const writable_props = [];
      Object.keys($$props).forEach(key => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Dado> was created with unknown prop '${key}'`);
      });
      return [];
    }

    class Dado extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$z, create_fragment$z, safe_not_equal, {});
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "Dado",
          options,
          id: create_fragment$z.name
        });
      }

    }

    /* src\components\Hilos\HiloPreview.svelte generated by Svelte v3.29.0 */
    const {
      console: console_1$8
    } = globals;
    const file$A = "src\\components\\Hilos\\HiloPreview.svelte"; // (272:4) {:else}

    function create_else_block$7(ctx) {
      let div;
      let button0;
      let t;
      let button1;
      let current;
      button0 = new ye({
        props: {
          icon: true,
          color: "white",
          $$slots: {
            default: [create_default_slot_4$d]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      button0.$on("click",
      /*toggle*/
      ctx[6]);
      button1 = new ye({
        props: {
          icon: true,
          color: "red",
          $$slots: {
            default: [create_default_slot_3$h]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      button1.$on("click",
      /*click_handler_5*/
      ctx[14]);
      const block = {
        c: function create() {
          div = element("div");
          create_component(button0.$$.fragment);
          t = space();
          create_component(button1.$$.fragment);
          attr_dev(div, "class", "");
          set_style(div, "top", "0");
          set_style(div, "right", "0");
          set_style(div, "z-index", "232");
          set_style(div, "display", "flex");
          set_style(div, "flex-direction", "column");
          set_style(div, "position", "absolute");
          add_location(div, file$A, 272, 8, 9085);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          mount_component(button0, div, null);
          append_dev(div, t);
          mount_component(button1, div, null);
          current = true;
        },
        p: function update(ctx, dirty) {
          const button0_changes = {};

          if (dirty &
          /*$$scope*/
          2097152) {
            button0_changes.$$scope = {
              dirty,
              ctx
            };
          }

          button0.$set(button0_changes);
          const button1_changes = {};

          if (dirty &
          /*$$scope*/
          2097152) {
            button1_changes.$$scope = {
              dirty,
              ctx
            };
          }

          button1.$set(button1_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(button0.$$.fragment, local);
          transition_in(button1.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(button0.$$.fragment, local);
          transition_out(button1.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
          destroy_component(button0);
          destroy_component(button1);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_else_block$7.name,
        type: "else",
        source: "(272:4) {:else}",
        ctx
      });
      return block;
    } // (234:4) {#if $globalStore.usuario.esMod || $globalStore.usuario.esAuxiliar}


    function create_if_block_13$2(ctx) {
      let div;
      let menu;
      let current;
      menu = new Menu_1({
        props: {
          style: "top: 100%;",
          $$slots: {
            default: [create_default_slot$l],
            activador: [create_activador_slot$4]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          div = element("div");
          create_component(menu.$$.fragment);
          attr_dev(div, "class", "");
          set_style(div, "top", "0");
          set_style(div, "right", "0");
          set_style(div, "z-index", "232");
          set_style(div, "display", "flex");
          set_style(div, "flex-direction", "column");
          set_style(div, "position", "absolute");
          add_location(div, file$A, 234, 8, 7676);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          mount_component(menu, div, null);
          current = true;
        },
        p: function update(ctx, dirty) {
          const menu_changes = {};

          if (dirty &
          /*$$scope, hilo, visible, mostrarMenu*/
          2097165) {
            menu_changes.$$scope = {
              dirty,
              ctx
            };
          }

          menu.$set(menu_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(menu.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(menu.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
          destroy_component(menu);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_13$2.name,
        type: "if",
        source: "(234:4) {#if $globalStore.usuario.esMod || $globalStore.usuario.esAuxiliar}",
        ctx
      });
      return block;
    } // (282:12) <Button icon color="white" on:click={toggle}>


    function create_default_slot_4$d(ctx) {
      let icon;
      const block = {
        c: function create() {
          icon = element("icon");
          attr_dev(icon, "class", "fe fe-eye-off");
          add_location(icon, file$A, 282, 16, 9356);
        },
        m: function mount(target, anchor) {
          insert_dev(target, icon, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(icon);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_4$d.name,
        type: "slot",
        source: "(282:12) <Button icon color=\\\"white\\\" on:click={toggle}>",
        ctx
      });
      return block;
    } // (285:12) <Button                  icon                  color="red"                  on:click={() => abrir.reporte(hilo.id, "")}              >


    function create_default_slot_3$h(ctx) {
      let icon;
      const block = {
        c: function create() {
          icon = element("icon");
          attr_dev(icon, "class", "fe fe-flag");
          add_location(icon, file$A, 289, 16, 9575);
        },
        m: function mount(target, anchor) {
          insert_dev(target, icon, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(icon);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_3$h.name,
        type: "slot",
        source: "(285:12) <Button                  icon                  color=\\\"red\\\"                  on:click={() => abrir.reporte(hilo.id, \\\"\\\")}              >",
        ctx
      });
      return block;
    } // (252:24) <Icon>


    function create_default_slot_2$h(ctx) {
      let switch_instance;
      let switch_instance_anchor;
      let current;
      var switch_value = More_vertical;

      function switch_props(ctx) {
        return {
          $$inline: true
        };
      }

      if (switch_value) {
        switch_instance = new switch_value(switch_props());
      }

      const block = {
        c: function create() {
          if (switch_instance) create_component(switch_instance.$$.fragment);
          switch_instance_anchor = empty();
        },
        m: function mount(target, anchor) {
          if (switch_instance) {
            mount_component(switch_instance, target, anchor);
          }

          insert_dev(target, switch_instance_anchor, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          if (switch_value !== (switch_value = More_vertical)) {
            if (switch_instance) {
              group_outros();
              const old_component = switch_instance;
              transition_out(old_component.$$.fragment, 1, 0, () => {
                destroy_component(old_component, 1);
              });
              check_outros();
            }

            if (switch_value) {
              switch_instance = new switch_value(switch_props());
              create_component(switch_instance.$$.fragment);
              transition_in(switch_instance.$$.fragment, 1);
              mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
            } else {
              switch_instance = null;
            }
          }
        },
        i: function intro(local) {
          if (current) return;
          if (switch_instance) transition_in(switch_instance.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          if (switch_instance) transition_out(switch_instance.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(switch_instance_anchor);
          if (switch_instance) destroy_component(switch_instance, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_2$h.name,
        type: "slot",
        source: "(252:24) <Icon>",
        ctx
      });
      return block;
    } // (246:20) <Button                          icon                          color="white"                          style="margin-left: auto; border-radius: 50% 0% 0% 50%;"                          on:click={() => (mostrarMenu = !mostrarMenu)}                      >


    function create_default_slot_1$j(ctx) {
      let icon;
      let current;
      icon = new Me({
        props: {
          $$slots: {
            default: [create_default_slot_2$h]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          create_component(icon.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(icon, target, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          const icon_changes = {};

          if (dirty &
          /*$$scope*/
          2097152) {
            icon_changes.$$scope = {
              dirty,
              ctx
            };
          }

          icon.$set(icon_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(icon.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(icon.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(icon, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_1$j.name,
        type: "slot",
        source: "(246:20) <Button                          icon                          color=\\\"white\\\"                          style=\\\"margin-left: auto; border-radius: 50% 0% 0% 50%;\\\"                          on:click={() => (mostrarMenu = !mostrarMenu)}                      >",
        ctx
      });
      return block;
    } // (245:16) <span slot="activador">


    function create_activador_slot$4(ctx) {
      let span;
      let button;
      let current;
      button = new ye({
        props: {
          icon: true,
          color: "white",
          style: "margin-left: auto; border-radius: 50% 0% 0% 50%;",
          $$slots: {
            default: [create_default_slot_1$j]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      button.$on("click",
      /*click_handler*/
      ctx[9]);
      const block = {
        c: function create() {
          span = element("span");
          create_component(button.$$.fragment);
          attr_dev(span, "slot", "activador");
          add_location(span, file$A, 244, 16, 7907);
        },
        m: function mount(target, anchor) {
          insert_dev(target, span, anchor);
          mount_component(button, span, null);
          current = true;
        },
        p: function update(ctx, dirty) {
          const button_changes = {};

          if (dirty &
          /*$$scope*/
          2097152) {
            button_changes.$$scope = {
              dirty,
              ctx
            };
          }

          button.$set(button_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(button.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(button.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(span);
          destroy_component(button);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_activador_slot$4.name,
        type: "slot",
        source: "(245:16) <span slot=\\\"activador\\\">",
        ctx
      });
      return block;
    } // (244:12) <Menu style="top: 100%;">


    function create_default_slot$l(ctx) {
      let t0;
      let li0;
      let t1_value = (
      /*visible*/
      ctx[2] ? "Ocultar" : "Mostrar") + "";
      let t1;
      let t2;
      let ripple0;
      let t3;
      let li1;
      let t4;
      let ripple1;
      let t5;
      let li2;
      let t6;
      let ripple2;
      let t7;
      let li3;
      let t8;
      let ripple3;
      let t9;
      let li4;
      let t10;
      let ripple4;
      let current;
      let mounted;
      let dispose;
      ripple0 = new he({
        $$inline: true
      });
      ripple1 = new he({
        $$inline: true
      });
      ripple2 = new he({
        $$inline: true
      });
      ripple3 = new he({
        $$inline: true
      });
      ripple4 = new he({
        $$inline: true
      });
      const block = {
        c: function create() {
          t0 = space();
          li0 = element("li");
          t1 = text(t1_value);
          t2 = space();
          create_component(ripple0.$$.fragment);
          t3 = space();
          li1 = element("li");
          t4 = text("Reportar ");
          create_component(ripple1.$$.fragment);
          t5 = space();
          li2 = element("li");
          t6 = text("Categoria ");
          create_component(ripple2.$$.fragment);
          t7 = space();
          li3 = element("li");
          t8 = text("Eliminar ");
          create_component(ripple3.$$.fragment);
          t9 = space();
          li4 = element("li");
          t10 = text("Banear ");
          create_component(ripple4.$$.fragment);
          add_location(li0, file$A, 255, 16, 8412);
          add_location(li1, file$A, 259, 16, 8562);
          add_location(li2, file$A, 262, 16, 8692);
          add_location(li3, file$A, 265, 16, 8828);
          add_location(li4, file$A, 268, 16, 8963);
        },
        m: function mount(target, anchor) {
          insert_dev(target, t0, anchor);
          insert_dev(target, li0, anchor);
          append_dev(li0, t1);
          append_dev(li0, t2);
          mount_component(ripple0, li0, null);
          insert_dev(target, t3, anchor);
          insert_dev(target, li1, anchor);
          append_dev(li1, t4);
          mount_component(ripple1, li1, null);
          insert_dev(target, t5, anchor);
          insert_dev(target, li2, anchor);
          append_dev(li2, t6);
          mount_component(ripple2, li2, null);
          insert_dev(target, t7, anchor);
          insert_dev(target, li3, anchor);
          append_dev(li3, t8);
          mount_component(ripple3, li3, null);
          insert_dev(target, t9, anchor);
          insert_dev(target, li4, anchor);
          append_dev(li4, t10);
          mount_component(ripple4, li4, null);
          current = true;

          if (!mounted) {
            dispose = [listen_dev(li0, "click",
            /*toggle*/
            ctx[6], false, false, false), listen_dev(li1, "click",
            /*click_handler_1*/
            ctx[10], false, false, false), listen_dev(li2, "click",
            /*click_handler_2*/
            ctx[11], false, false, false), listen_dev(li3, "click",
            /*click_handler_3*/
            ctx[12], false, false, false), listen_dev(li4, "click",
            /*click_handler_4*/
            ctx[13], false, false, false)];
            mounted = true;
          }
        },
        p: function update(ctx, dirty) {
          if ((!current || dirty &
          /*visible*/
          4) && t1_value !== (t1_value = (
          /*visible*/
          ctx[2] ? "Ocultar" : "Mostrar") + "")) set_data_dev(t1, t1_value);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(ripple0.$$.fragment, local);
          transition_in(ripple1.$$.fragment, local);
          transition_in(ripple2.$$.fragment, local);
          transition_in(ripple3.$$.fragment, local);
          transition_in(ripple4.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(ripple0.$$.fragment, local);
          transition_out(ripple1.$$.fragment, local);
          transition_out(ripple2.$$.fragment, local);
          transition_out(ripple3.$$.fragment, local);
          transition_out(ripple4.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(t0);
          if (detaching) detach_dev(li0);
          destroy_component(ripple0);
          if (detaching) detach_dev(t3);
          if (detaching) detach_dev(li1);
          destroy_component(ripple1);
          if (detaching) detach_dev(t5);
          if (detaching) detach_dev(li2);
          destroy_component(ripple2);
          if (detaching) detach_dev(t7);
          if (detaching) detach_dev(li3);
          destroy_component(ripple3);
          if (detaching) detach_dev(t9);
          if (detaching) detach_dev(li4);
          destroy_component(ripple4);
          mounted = false;
          run_all(dispose);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot$l.name,
        type: "slot",
        source: "(244:12) <Menu style=\\\"top: 100%;\\\">",
        ctx
      });
      return block;
    } // (303:8) {#if destellando}


    function create_if_block_12$2(ctx) {
      let div;
      const block = {
        c: function create() {
          div = element("div");
          attr_dev(div, "class", "destello");
          add_location(div, file$A, 303, 12, 9977);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_12$2.name,
        type: "if",
        source: "(303:8) {#if destellando}",
        ctx
      });
      return block;
    } // (308:12) {#if hilo.sticky > 0}


    function create_if_block_11$2(ctx) {
      let div;
      let icon;
      let current;
      icon = new Me({
        props: {
          size: "17",
          path: "M16,12V4H17V2H7V4H8V12L6,14V16H11.2V22H12.8V16H18V14L16,12M8.8,14L10,12.8V4H14V12.8L15.2,14H8.8Z"
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          div = element("div");
          create_component(icon.$$.fragment);
          attr_dev(div, "class", "info sticky-info svelte-dxyjhe");
          add_location(div, file$A, 308, 16, 10190);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          mount_component(icon, div, null);
          current = true;
        },
        i: function intro(local) {
          if (current) return;
          transition_in(icon.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(icon.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
          destroy_component(icon);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_11$2.name,
        type: "if",
        source: "(308:12) {#if hilo.sticky > 0}",
        ctx
      });
      return block;
    } // (315:12) {#if hilo.nuevo}


    function create_if_block_10$2(ctx) {
      let div;
      const block = {
        c: function create() {
          div = element("div");
          div.textContent = "NUEVO";
          attr_dev(div, "class", "info svelte-dxyjhe");
          set_style(div, "background", "#18222D");
          add_location(div, file$A, 315, 16, 10512);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_10$2.name,
        type: "if",
        source: "(315:12) {#if hilo.nuevo}",
        ctx
      });
      return block;
    } // (325:12) {#if media.tipo == MediaType.Video}


    function create_if_block_9$2(ctx) {
      let div;
      let span;
      const block = {
        c: function create() {
          div = element("div");
          span = element("span");
          attr_dev(span, "class", "fe fe-play");
          add_location(span, file$A, 326, 20, 10985);
          attr_dev(div, "class", "info svelte-dxyjhe");
          set_style(div, "background", "#18222D");
          add_location(div, file$A, 325, 16, 10918);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          append_dev(div, span);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_9$2.name,
        type: "if",
        source: "(325:12) {#if media.tipo == MediaType.Video}",
        ctx
      });
      return block;
    } // (329:12) {#if media.tipo == MediaType.Youtube}


    function create_if_block_8$3(ctx) {
      let div;
      let span;
      const block = {
        c: function create() {
          div = element("div");
          span = element("span");
          attr_dev(span, "class", "fe fe-play");
          add_location(span, file$A, 330, 20, 11177);
          attr_dev(div, "class", "info svelte-dxyjhe");
          set_style(div, "background", "#F10002");
          add_location(div, file$A, 329, 16, 11110);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          append_dev(div, span);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_8$3.name,
        type: "if",
        source: "(329:12) {#if media.tipo == MediaType.Youtube}",
        ctx
      });
      return block;
    } // (333:12) {#if media.tipo == MediaType.Bitchute}


    function create_if_block_7$3(ctx) {
      let div;
      let span;
      const block = {
        c: function create() {
          div = element("div");
          span = element("span");
          attr_dev(span, "class", "fe fe-play");
          add_location(span, file$A, 334, 20, 11370);
          attr_dev(div, "class", "info svelte-dxyjhe");
          set_style(div, "background", "#E33E34");
          add_location(div, file$A, 333, 16, 11303);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          append_dev(div, span);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_7$3.name,
        type: "if",
        source: "(333:12) {#if media.tipo == MediaType.Bitchute}",
        ctx
      });
      return block;
    } // (337:12) {#if media.tipo == MediaType.DailyMotion}


    function create_if_block_6$4(ctx) {
      let div;
      let span;
      const block = {
        c: function create() {
          div = element("div");
          span = element("span");
          attr_dev(span, "class", "fe fe-play");
          add_location(span, file$A, 338, 20, 11566);
          attr_dev(div, "class", "info svelte-dxyjhe");
          set_style(div, "background", "#0062D2");
          add_location(div, file$A, 337, 16, 11499);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          append_dev(div, span);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_6$4.name,
        type: "if",
        source: "(337:12) {#if media.tipo == MediaType.DailyMotion}",
        ctx
      });
      return block;
    } // (341:12) {#if media.tipo == MediaType.PornHub}


    function create_if_block_5$6(ctx) {
      let div;
      let span;
      const block = {
        c: function create() {
          div = element("div");
          span = element("span");
          attr_dev(span, "class", "fe fe-play");
          add_location(span, file$A, 342, 20, 11758);
          attr_dev(div, "class", "info svelte-dxyjhe");
          set_style(div, "background", "#EA8F1C");
          add_location(div, file$A, 341, 16, 11691);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          append_dev(div, span);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_5$6.name,
        type: "if",
        source: "(341:12) {#if media.tipo == MediaType.PornHub}",
        ctx
      });
      return block;
    } // (345:12) {#if hilo.encuesta}


    function create_if_block_4$7(ctx) {
      let div;
      let span;
      const block = {
        c: function create() {
          div = element("div");
          span = element("span");
          attr_dev(span, "class", "fe fe-bar-chart-2");
          add_location(span, file$A, 346, 20, 11914);
          attr_dev(div, "class", "info encuesta svelte-dxyjhe");
          add_location(div, file$A, 345, 16, 11865);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          append_dev(div, span);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_4$7.name,
        type: "if",
        source: "(345:12) {#if hilo.encuesta}",
        ctx
      });
      return block;
    } // (349:12) {#if hilo.dados}


    function create_if_block_3$d(ctx) {
      let dado;
      let current;
      dado = new Dado({
        $$inline: true
      });
      const block = {
        c: function create() {
          create_component(dado.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(dado, target, anchor);
          current = true;
        },
        i: function intro(local) {
          if (current) return;
          transition_in(dado.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(dado.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(dado, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_3$d.name,
        type: "if",
        source: "(349:12) {#if hilo.dados}",
        ctx
      });
      return block;
    } // (350:12) {#if hilo.concentracion}


    function create_if_block_2$j(ctx) {
      let div;
      let span;
      const block = {
        c: function create() {
          div = element("div");
          span = element("span");
          attr_dev(span, "class", "fe fe-puas svelte-dxyjhe");
          add_location(span, file$A, 357, 20, 12335);
          attr_dev(div, "class", "info svelte-dxyjhe");
          set_style(div, "padding", "0px 0", 1);
          set_style(div, "border-radius", "4px", 1);
          set_style(div, "margin", "0 2px");
          set_style(div, "background", "var(--color3)");
          add_location(div, file$A, 350, 16, 12076);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          append_dev(div, span);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_2$j.name,
        type: "if",
        source: "(350:12) {#if hilo.concentracion}",
        ctx
      });
      return block;
    } // (360:12) {#if hilo.serio}


    function create_if_block_1$k(ctx) {
      let div;
      let span;
      const block = {
        c: function create() {
          div = element("div");
          span = element("span");
          attr_dev(span, "class", "fe fe-serio svelte-dxyjhe");
          add_location(span, file$A, 367, 20, 12698);
          attr_dev(div, "class", "info svelte-dxyjhe");
          set_style(div, "padding", "0px 0", 1);
          set_style(div, "border-radius", "4px", 1);
          set_style(div, "margin", "0 2px");
          set_style(div, "background", "var(--color3)");
          add_location(div, file$A, 360, 16, 12439);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          append_dev(div, span);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_1$k.name,
        type: "if",
        source: "(360:12) {#if hilo.serio}",
        ctx
      });
      return block;
    } // (370:12) {#if hilo.historico}


    function create_if_block$s(ctx) {
      let div;
      const block = {
        c: function create() {
          div = element("div");
          attr_dev(div, "class", "info svelte-12j5r62 fe fe-anchor svelte-dxyjhe");
          set_style(div, "background", "var(--color6)");
          add_location(div, file$A, 370, 16, 12807);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block$s.name,
        type: "if",
        source: "(370:12) {#if hilo.historico}",
        ctx
      });
      return block;
    }

    function create_fragment$A(ctx) {
      let li;
      let current_block_type_index;
      let if_block0;
      let t0;
      let a;
      let t1;
      let div2;
      let t2;
      let t3;
      let div0;
      let t4_value = (config.categoriaPorId(
      /*hilo*/
      ctx[0].categoriaId) || {
        nombreCorto: "??"
      }).nombreCorto + "";
      let t4;
      let t5;
      let t6;
      let t7;
      let t8;
      let t9;
      let t10;
      let t11;
      let t12;
      let t13;
      let t14;
      let t15;
      let div1;
      let t16_value =
      /*hilo*/
      ctx[0].cantidadComentarios + "";
      let t16;
      let t17;
      let h3;
      let t18_value =
      /*hilo*/
      ctx[0].titulo + "";
      let t18;
      let a_href_value;
      let a_transition;
      let li_class_value;
      let current;
      let mounted;
      let dispose;
      const if_block_creators = [create_if_block_13$2, create_else_block$7];
      const if_blocks = [];

      function select_block_type(ctx, dirty) {
        if (
        /*$globalStore*/
        ctx[4].usuario.esMod ||
        /*$globalStore*/
        ctx[4].usuario.esAuxiliar) return 0;
        return 1;
      }

      current_block_type_index = select_block_type(ctx);
      if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
      let if_block1 =
      /*destellando*/
      ctx[1] && create_if_block_12$2(ctx);
      let if_block2 =
      /*hilo*/
      ctx[0].sticky > 0 && create_if_block_11$2(ctx);
      let if_block3 =
      /*hilo*/
      ctx[0].nuevo && create_if_block_10$2(ctx);
      let if_block4 =
      /*media*/
      ctx[5].tipo == MediaType.Video && create_if_block_9$2(ctx);
      let if_block5 =
      /*media*/
      ctx[5].tipo == MediaType.Youtube && create_if_block_8$3(ctx);
      let if_block6 =
      /*media*/
      ctx[5].tipo == MediaType.Bitchute && create_if_block_7$3(ctx);
      let if_block7 =
      /*media*/
      ctx[5].tipo == MediaType.DailyMotion && create_if_block_6$4(ctx);
      let if_block8 =
      /*media*/
      ctx[5].tipo == MediaType.PornHub && create_if_block_5$6(ctx);
      let if_block9 =
      /*hilo*/
      ctx[0].encuesta && create_if_block_4$7(ctx);
      let if_block10 =
      /*hilo*/
      ctx[0].dados && create_if_block_3$d(ctx);
      let if_block11 =
      /*hilo*/
      ctx[0].concentracion && create_if_block_2$j(ctx);
      let if_block12 =
      /*hilo*/
      ctx[0].serio && create_if_block_1$k(ctx);
      let if_block13 =
      /*hilo*/
      ctx[0].historico && create_if_block$s(ctx);
      const block = {
        c: function create() {
          li = element("li");
          if_block0.c();
          t0 = space();
          a = element("a");
          if (if_block1) if_block1.c();
          t1 = space();
          div2 = element("div");
          if (if_block2) if_block2.c();
          t2 = space();
          if (if_block3) if_block3.c();
          t3 = space();
          div0 = element("div");
          t4 = text(t4_value);
          t5 = space();
          if (if_block4) if_block4.c();
          t6 = space();
          if (if_block5) if_block5.c();
          t7 = space();
          if (if_block6) if_block6.c();
          t8 = space();
          if (if_block7) if_block7.c();
          t9 = space();
          if (if_block8) if_block8.c();
          t10 = space();
          if (if_block9) if_block9.c();
          t11 = space();
          if (if_block10) if_block10.c();
          t12 = space();
          if (if_block11) if_block11.c();
          t13 = space();
          if (if_block12) if_block12.c();
          t14 = space();
          if (if_block13) if_block13.c();
          t15 = space();
          div1 = element("div");
          t16 = text(t16_value);
          t17 = space();
          h3 = element("h3");
          t18 = text(t18_value);
          attr_dev(div0, "class", "info svelte-dxyjhe");
          add_location(div0, file$A, 316, 12, 10587);
          attr_dev(div1, "class", "info svelte-dxyjhe");
          add_location(div1, file$A, 376, 12, 12984);
          attr_dev(div2, "class", "infos");
          add_location(div2, file$A, 306, 8, 10118);
          add_location(h3, file$A, 379, 8, 13062);
          set_style(a, "background", "url(" +
          /*media*/
          ctx[5].vistaPreviaCuadrado + ")");
          attr_dev(a, "href", a_href_value = "/Hilo/" +
          /*hilo*/
          ctx[0].id);
          attr_dev(a, "class", "hilo-in");
          add_location(a, file$A, 294, 4, 9660);
          attr_dev(li, "class", li_class_value = "hilo " + (
          /*visible*/
          ctx[2] ? "" : "hilo-oculto") + " svelte-dxyjhe");
          add_location(li, file$A, 226, 0, 7436);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, li, anchor);
          if_blocks[current_block_type_index].m(li, null);
          append_dev(li, t0);
          append_dev(li, a);
          if (if_block1) if_block1.m(a, null);
          append_dev(a, t1);
          append_dev(a, div2);
          if (if_block2) if_block2.m(div2, null);
          append_dev(div2, t2);
          if (if_block3) if_block3.m(div2, null);
          append_dev(div2, t3);
          append_dev(div2, div0);
          append_dev(div0, t4);
          append_dev(div2, t5);
          if (if_block4) if_block4.m(div2, null);
          append_dev(div2, t6);
          if (if_block5) if_block5.m(div2, null);
          append_dev(div2, t7);
          if (if_block6) if_block6.m(div2, null);
          append_dev(div2, t8);
          if (if_block7) if_block7.m(div2, null);
          append_dev(div2, t9);
          if (if_block8) if_block8.m(div2, null);
          append_dev(div2, t10);
          if (if_block9) if_block9.m(div2, null);
          append_dev(div2, t11);
          if (if_block10) if_block10.m(div2, null);
          append_dev(div2, t12);
          if (if_block11) if_block11.m(div2, null);
          append_dev(div2, t13);
          if (if_block12) if_block12.m(div2, null);
          append_dev(div2, t14);
          if (if_block13) if_block13.m(div2, null);
          append_dev(div2, t15);
          append_dev(div2, div1);
          append_dev(div1, t16);
          append_dev(a, t17);
          append_dev(a, h3);
          append_dev(h3, t18);
          current = true;

          if (!mounted) {
            dispose = [listen_dev(a, "click",
            /*onClick*/
            ctx[7], false, false, false), listen_dev(li, "mouseleave",
            /*mouseleave_handler*/
            ctx[15], false, false, false), listen_dev(li, "contextmenu",
            /*onContextMenu*/
            ctx[8], false, false, false)];
            mounted = true;
          }
        },
        p: function update(ctx, [dirty]) {
          let previous_block_index = current_block_type_index;
          current_block_type_index = select_block_type(ctx);

          if (current_block_type_index === previous_block_index) {
            if_blocks[current_block_type_index].p(ctx, dirty);
          } else {
            group_outros();
            transition_out(if_blocks[previous_block_index], 1, 1, () => {
              if_blocks[previous_block_index] = null;
            });
            check_outros();
            if_block0 = if_blocks[current_block_type_index];

            if (!if_block0) {
              if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
              if_block0.c();
            }

            transition_in(if_block0, 1);
            if_block0.m(li, t0);
          }

          if (
          /*destellando*/
          ctx[1]) {
            if (if_block1) ; else {
              if_block1 = create_if_block_12$2(ctx);
              if_block1.c();
              if_block1.m(a, t1);
            }
          } else if (if_block1) {
            if_block1.d(1);
            if_block1 = null;
          }

          if (
          /*hilo*/
          ctx[0].sticky > 0) {
            if (if_block2) {
              if (dirty &
              /*hilo*/
              1) {
                transition_in(if_block2, 1);
              }
            } else {
              if_block2 = create_if_block_11$2(ctx);
              if_block2.c();
              transition_in(if_block2, 1);
              if_block2.m(div2, t2);
            }
          } else if (if_block2) {
            group_outros();
            transition_out(if_block2, 1, 1, () => {
              if_block2 = null;
            });
            check_outros();
          }

          if (
          /*hilo*/
          ctx[0].nuevo) {
            if (if_block3) ; else {
              if_block3 = create_if_block_10$2(ctx);
              if_block3.c();
              if_block3.m(div2, t3);
            }
          } else if (if_block3) {
            if_block3.d(1);
            if_block3 = null;
          }

          if ((!current || dirty &
          /*hilo*/
          1) && t4_value !== (t4_value = (config.categoriaPorId(
          /*hilo*/
          ctx[0].categoriaId) || {
            nombreCorto: "??"
          }).nombreCorto + "")) set_data_dev(t4, t4_value);

          if (
          /*hilo*/
          ctx[0].encuesta) {
            if (if_block9) ; else {
              if_block9 = create_if_block_4$7(ctx);
              if_block9.c();
              if_block9.m(div2, t11);
            }
          } else if (if_block9) {
            if_block9.d(1);
            if_block9 = null;
          }

          if (
          /*hilo*/
          ctx[0].dados) {
            if (if_block10) {
              if (dirty &
              /*hilo*/
              1) {
                transition_in(if_block10, 1);
              }
            } else {
              if_block10 = create_if_block_3$d(ctx);
              if_block10.c();
              transition_in(if_block10, 1);
              if_block10.m(div2, t12);
            }
          } else if (if_block10) {
            group_outros();
            transition_out(if_block10, 1, 1, () => {
              if_block10 = null;
            });
            check_outros();
          }

          if (
          /*hilo*/
          ctx[0].concentracion) {
            if (if_block11) ; else {
              if_block11 = create_if_block_2$j(ctx);
              if_block11.c();
              if_block11.m(div2, t13);
            }
          } else if (if_block11) {
            if_block11.d(1);
            if_block11 = null;
          }

          if (
          /*hilo*/
          ctx[0].serio) {
            if (if_block12) ; else {
              if_block12 = create_if_block_1$k(ctx);
              if_block12.c();
              if_block12.m(div2, t14);
            }
          } else if (if_block12) {
            if_block12.d(1);
            if_block12 = null;
          }

          if (
          /*hilo*/
          ctx[0].historico) {
            if (if_block13) ; else {
              if_block13 = create_if_block$s(ctx);
              if_block13.c();
              if_block13.m(div2, t15);
            }
          } else if (if_block13) {
            if_block13.d(1);
            if_block13 = null;
          }

          if ((!current || dirty &
          /*hilo*/
          1) && t16_value !== (t16_value =
          /*hilo*/
          ctx[0].cantidadComentarios + "")) set_data_dev(t16, t16_value);
          if ((!current || dirty &
          /*hilo*/
          1) && t18_value !== (t18_value =
          /*hilo*/
          ctx[0].titulo + "")) set_data_dev(t18, t18_value);

          if (!current || dirty &
          /*hilo*/
          1 && a_href_value !== (a_href_value = "/Hilo/" +
          /*hilo*/
          ctx[0].id)) {
            attr_dev(a, "href", a_href_value);
          }

          if (!current || dirty &
          /*visible*/
          4 && li_class_value !== (li_class_value = "hilo " + (
          /*visible*/
          ctx[2] ? "" : "hilo-oculto") + " svelte-dxyjhe")) {
            attr_dev(li, "class", li_class_value);
          }
        },
        i: function intro(local) {
          if (current) return;
          transition_in(if_block0);
          transition_in(if_block2);
          transition_in(if_block10);

          if (local) {
            add_render_callback(() => {
              if (!a_transition) a_transition = create_bidirectional_transition(a, fly, {
                duration: 250
              }, true);
              a_transition.run(1);
            });
          }

          current = true;
        },
        o: function outro(local) {
          transition_out(if_block0);
          transition_out(if_block2);
          transition_out(if_block10);

          if (local) {
            if (!a_transition) a_transition = create_bidirectional_transition(a, fly, {
              duration: 250
            }, false);
            a_transition.run(0);
          }

          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(li);
          if_blocks[current_block_type_index].d();
          if (if_block1) if_block1.d();
          if (if_block2) if_block2.d();
          if (if_block3) if_block3.d();
          if (if_block4) if_block4.d();
          if (if_block5) if_block5.d();
          if (if_block6) if_block6.d();
          if (if_block7) if_block7.d();
          if (if_block8) if_block8.d();
          if (if_block9) if_block9.d();
          if (if_block10) if_block10.d();
          if (if_block11) if_block11.d();
          if (if_block12) if_block12.d();
          if (if_block13) if_block13.d();
          if (detaching && a_transition) a_transition.end();
          mounted = false;
          run_all(dispose);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$A.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }

    function instance$A($$self, $$props, $$invalidate) {
      let $globalStore;
      validate_store(globalStore, "globalStore");
      component_subscribe($$self, globalStore, $$value => $$invalidate(4, $globalStore = $$value));
      let {
        $$slots: slots = {},
        $$scope
      } = $$props;
      validate_slots("HiloPreview", slots, []);
      let {
        hilo
      } = $$props;
      let dispatch = createEventDispatcher();
      if (!hilo.cantidadComentarios) hilo.cantidadComentarios = 0;
      let categorias = config.categorias;
      let media = hilo.media;
      let destellando = false;
      let visible = true;
      let mostrarMenu = false;
      let recienCargado = true;

      function destellar(cantidadComentarios) {
        if (recienCargado) {
          recienCargado = false;
          return;
        }

        $$invalidate(1, destellando = true);
        setTimeout(() => $$invalidate(1, destellando = false), 2000);
      }

      async function toggle() {
        $$invalidate(2, visible = !visible);

        if ($globalStore.usuario.estaAutenticado) {
          await RChanClient.agregar("ocultos", hilo.id);
        }
      } // setInterval(() => {
      //     hilo.cantidadComentarios+=1
      // }, Math.random() * 5000 + 4000);


      function onClick(e) {
        dispatch("click");
        console.log(e.target.nodeName);

        if (e.target.nodeName == "A" || e.target.nodeName == "H3") {
          window.location = `/Hilo/${hilo.id}`;
        }
      }

      async function onContextMenu(e) {
        // AYNS
        if (teclas.estaPresionada("a") && $globalStore.usuario.esMod) {
          e.preventDefault();
          console.log((await RChanClient.cambiarCategoria(hilo.id, 2, false)).data.mensaje);
          return;
        } // DEP


        if (teclas.estaPresionada("d") && $globalStore.usuario.esMod) {
          e.preventDefault();
          console.log((await RChanClient.cambiarCategoria(hilo.id, 16, false)).data.mensaje);
          return;
        } // ECO


        if (teclas.estaPresionada("e") && $globalStore.usuario.esMod) {
          e.preventDefault();
          console.log((await RChanClient.cambiarCategoria(hilo.id, 29, false)).data.mensaje);
          return;
        } // GNR


        if (teclas.estaPresionada("g") && $globalStore.usuario.esMod) {
          e.preventDefault();
          console.log((await RChanClient.cambiarCategoria(hilo.id, 1, false)).data.mensaje);
          return;
        } // HMR


        if (teclas.estaPresionada("h") && $globalStore.usuario.esMod) {
          e.preventDefault();
          console.log((await RChanClient.cambiarCategoria(hilo.id, 11, false)).data.mensaje);
          return;
        } // JUE


        if (teclas.estaPresionada("j") && $globalStore.usuario.esMod) {
          e.preventDefault();
          console.log((await RChanClient.cambiarCategoria(hilo.id, 10, false)).data.mensaje);
          return;
        } // LIT


        if (teclas.estaPresionada("l") && $globalStore.usuario.esMod) {
          e.preventDefault();
          console.log((await RChanClient.cambiarCategoria(hilo.id, 12, false)).data.mensaje);
          return;
        } // MUS


        if (teclas.estaPresionada("m") && $globalStore.usuario.esMod) {
          e.preventDefault();
          console.log((await RChanClient.cambiarCategoria(hilo.id, 13, false)).data.mensaje);
          return;
        } // NPC


        if (teclas.estaPresionada("n") && $globalStore.usuario.esMod) {
          e.preventDefault();
          console.log((await RChanClient.cambiarCategoria(hilo.id, 21, false)).data.mensaje);
          return;
        } // O3P


        if (teclas.estaPresionada("o") && $globalStore.usuario.esMod) {
          e.preventDefault();
          console.log((await RChanClient.cambiarCategoria(hilo.id, 14, false)).data.mensaje);
          return;
        } // PRG


        if (teclas.estaPresionada("p") && $globalStore.usuario.esMod) {
          e.preventDefault();
          console.log((await RChanClient.cambiarCategoria(hilo.id, 18, false)).data.mensaje);
          return;
        } // RS


        if (teclas.estaPresionada("r") && $globalStore.usuario.esMod) {
          e.preventDefault();
          console.log((await RChanClient.cambiarCategoria(hilo.id, 20, false)).data.mensaje);
          return;
        } // SLD


        if (teclas.estaPresionada("s") && $globalStore.usuario.esMod) {
          e.preventDefault();
          console.log((await RChanClient.cambiarCategoria(hilo.id, 37, false)).data.mensaje);
          return;
        } // TEC


        if (teclas.estaPresionada("t") && $globalStore.usuario.esMod) {
          e.preventDefault();
          console.log((await RChanClient.cambiarCategoria(hilo.id, 23, false)).data.mensaje);
          return;
        } // UMA


        if (teclas.estaPresionada("u") && $globalStore.usuario.esMod) {
          e.preventDefault();
          console.log((await RChanClient.cambiarCategoria(hilo.id, 26, false)).data.mensaje);
          return;
        } // JTB


        if (teclas.estaPresionada("y") && $globalStore.usuario.esMod) {
          e.preventDefault();
          console.log((await RChanClient.cambiarCategoria(hilo.id, 44, false)).data.mensaje);
          return;
        }

        if (teclas.estaPresionada("c") && $globalStore.usuario.esMod) {
          e.preventDefault();
          abrir.cambiarCategoria(hilo.id);
          return;
        }

        if (teclas.estaPresionada("v") && $globalStore.usuario.esMod) {
          e.preventDefault();
          abrir.ban(hilo.id);
          return;
        }

        if (teclas.estaPresionada("x") && $globalStore.usuario.esMod) {
          e.preventDefault();
          await RChanClient.borrarHilo(hilo.id);
          return;
        }

        if (!e.ctrlKey) return;
        e.preventDefault();
        toggle();
      }

      const writable_props = ["hilo"];
      Object.keys($$props).forEach(key => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$8.warn(`<HiloPreview> was created with unknown prop '${key}'`);
      });

      const click_handler = () => $$invalidate(3, mostrarMenu = !mostrarMenu);

      const click_handler_1 = () => abrir.reporte(hilo.id, "");

      const click_handler_2 = () => abrir.cambiarCategoria(hilo.id);

      const click_handler_3 = () => abrir.eliminarHilo(hilo.id, "");

      const click_handler_4 = () => abrir.ban(hilo.id);

      const click_handler_5 = () => abrir.reporte(hilo.id, "");

      const mouseleave_handler = () => {
        $$invalidate(3, mostrarMenu = false);
      };

      $$self.$$set = $$props => {
        if ("hilo" in $$props) $$invalidate(0, hilo = $$props.hilo);
      };

      $$self.$capture_state = () => ({
        Ripple: he,
        Button: ye,
        Icon: Me,
        abrir,
        Menu: Menu_1,
        config,
        globalStore,
        MediaType,
        fly,
        createEventDispatcher,
        more: More_vertical,
        RChanClient,
        Dado,
        shortcuts: teclas,
        hilo,
        dispatch,
        categorias,
        media,
        destellando,
        visible,
        mostrarMenu,
        recienCargado,
        destellar,
        toggle,
        onClick,
        onContextMenu,
        cantidadComentarios,
        $globalStore
      });

      $$self.$inject_state = $$props => {
        if ("hilo" in $$props) $$invalidate(0, hilo = $$props.hilo);
        if ("dispatch" in $$props) dispatch = $$props.dispatch;
        if ("categorias" in $$props) categorias = $$props.categorias;
        if ("media" in $$props) $$invalidate(5, media = $$props.media);
        if ("destellando" in $$props) $$invalidate(1, destellando = $$props.destellando);
        if ("visible" in $$props) $$invalidate(2, visible = $$props.visible);
        if ("mostrarMenu" in $$props) $$invalidate(3, mostrarMenu = $$props.mostrarMenu);
        if ("recienCargado" in $$props) recienCargado = $$props.recienCargado;
        if ("cantidadComentarios" in $$props) $$invalidate(17, cantidadComentarios = $$props.cantidadComentarios);
      };

      let cantidadComentarios;

      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }

      $$self.$$.update = () => {
        if ($$self.$$.dirty &
        /*hilo*/
        1) {
           $$invalidate(17, cantidadComentarios = hilo.cantidadComentarios);
        }

        if ($$self.$$.dirty &
        /*cantidadComentarios*/
        131072) {
           destellar();
        }
      };

      return [hilo, destellando, visible, mostrarMenu, $globalStore, media, toggle, onClick, onContextMenu, click_handler, click_handler_1, click_handler_2, click_handler_3, click_handler_4, click_handler_5, mouseleave_handler];
    }

    class HiloPreview extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$A, create_fragment$A, safe_not_equal, {
          hilo: 0
        });
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "HiloPreview",
          options,
          id: create_fragment$A.name
        });
        const {
          ctx
        } = this.$$;
        const props = options.props || {};

        if (
        /*hilo*/
        ctx[0] === undefined && !("hilo" in props)) {
          console_1$8.warn("<HiloPreview> was created without expected prop 'hilo'");
        }
      }

      get hilo() {
        throw new Error("<HiloPreview>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set hilo(value) {
        throw new Error("<HiloPreview>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

    }

    /* src\components\Moderacion\HiloPreviewMod.svelte generated by Svelte v3.29.0 */
    const file$B = "src\\components\\Moderacion\\HiloPreviewMod.svelte";

    function create_fragment$B(ctx) {
      let div;
      let hilopreview;
      let current;
      hilopreview = new HiloPreview({
        props: {
          hilo:
          /*hilo*/
          ctx[0]
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          div = element("div");
          create_component(hilopreview.$$.fragment);
          attr_dev(div, "class", "hilo-preview-mod svelte-u3ue3s");
          toggle_class(div, "eliminado",
          /*hilo*/
          ctx[0].estado == HiloEstado.eliminado);
          add_location(div, file$B, 6, 4, 146);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          mount_component(hilopreview, div, null);
          current = true;
        },
        p: function update(ctx, [dirty]) {
          const hilopreview_changes = {};
          if (dirty &
          /*hilo*/
          1) hilopreview_changes.hilo =
          /*hilo*/
          ctx[0];
          hilopreview.$set(hilopreview_changes);

          if (dirty &
          /*hilo, HiloEstado*/
          1) {
            toggle_class(div, "eliminado",
            /*hilo*/
            ctx[0].estado == HiloEstado.eliminado);
          }
        },
        i: function intro(local) {
          if (current) return;
          transition_in(hilopreview.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(hilopreview.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
          destroy_component(hilopreview);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$B.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }

    function instance$B($$self, $$props, $$invalidate) {
      let {
        $$slots: slots = {},
        $$scope
      } = $$props;
      validate_slots("HiloPreviewMod", slots, []);
      let {
        hilo
      } = $$props;
      const writable_props = ["hilo"];
      Object.keys($$props).forEach(key => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<HiloPreviewMod> was created with unknown prop '${key}'`);
      });

      $$self.$$set = $$props => {
        if ("hilo" in $$props) $$invalidate(0, hilo = $$props.hilo);
      };

      $$self.$capture_state = () => ({
        HiloPreview,
        HiloEstado,
        hilo
      });

      $$self.$inject_state = $$props => {
        if ("hilo" in $$props) $$invalidate(0, hilo = $$props.hilo);
      };

      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }

      return [hilo];
    }

    class HiloPreviewMod extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$B, create_fragment$B, safe_not_equal, {
          hilo: 0
        });
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "HiloPreviewMod",
          options,
          id: create_fragment$B.name
        });
        const {
          ctx
        } = this.$$;
        const props = options.props || {};

        if (
        /*hilo*/
        ctx[0] === undefined && !("hilo" in props)) {
          console.warn("<HiloPreviewMod> was created without expected prop 'hilo'");
        }
      }

      get hilo() {
        throw new Error("<HiloPreviewMod>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set hilo(value) {
        throw new Error("<HiloPreviewMod>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

    }

    /* src\components\Denuncia.svelte generated by Svelte v3.29.0 */
    const {
      Object: Object_1$5
    } = globals;
    const file$C = "src\\components\\Denuncia.svelte"; // (54:8) {:else}

    function create_else_block_2$3(ctx) {
      let span0;
      let t1;
      let span1;
      const block = {
        c: function create() {
          span0 = element("span");
          span0.textContent = "Gordo";
          t1 = text("\n            denuncio a \n            ");
          span1 = element("span");
          span1.textContent = "Gordo";
          attr_dev(span0, "class", "userlink svelte-u2edks");
          attr_dev(span0, "href", "/#");
          add_location(span0, file$C, 54, 12, 1933);
          attr_dev(span1, "class", "userlink svelte-u2edks");
          attr_dev(span1, "href", "/#");
          add_location(span1, file$C, 56, 12, 2015);
        },
        m: function mount(target, anchor) {
          insert_dev(target, span0, anchor);
          insert_dev(target, t1, anchor);
          insert_dev(target, span1, anchor);
        },
        p: noop,
        d: function destroy(detaching) {
          if (detaching) detach_dev(span0);
          if (detaching) detach_dev(t1);
          if (detaching) detach_dev(span1);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_else_block_2$3.name,
        type: "else",
        source: "(54:8) {:else}",
        ctx
      });
      return block;
    } // (46:8) {#if $globalStore.usuario.esMod}


    function create_if_block_2$k(ctx) {
      let a;
      let t0_value =
      /*usuario*/
      ctx[2].userName + "";
      let t0;
      let a_href_value;
      let t1;
      let if_block_anchor;

      function select_block_type_1(ctx, dirty) {
        if (
        /*denuncia*/
        ctx[0].tipo == 0) return create_if_block_3$e;
        return create_else_block_1$4;
      }

      let current_block_type = select_block_type_1(ctx);
      let if_block = current_block_type(ctx);
      const block = {
        c: function create() {
          a = element("a");
          t0 = text(t0_value);
          t1 = text("\n            denuncio a \n            ");
          if_block.c();
          if_block_anchor = empty();
          attr_dev(a, "class", "userlink svelte-u2edks");
          attr_dev(a, "href", a_href_value = "/Moderacion/HistorialDeUsuario/" +
          /*usuario*/
          ctx[2].id);
          add_location(a, file$C, 46, 12, 1460);
        },
        m: function mount(target, anchor) {
          insert_dev(target, a, anchor);
          append_dev(a, t0);
          insert_dev(target, t1, anchor);
          if_block.m(target, anchor);
          insert_dev(target, if_block_anchor, anchor);
        },
        p: function update(ctx, dirty) {
          if (dirty &
          /*usuario*/
          4 && t0_value !== (t0_value =
          /*usuario*/
          ctx[2].userName + "")) set_data_dev(t0, t0_value);

          if (dirty &
          /*usuario*/
          4 && a_href_value !== (a_href_value = "/Moderacion/HistorialDeUsuario/" +
          /*usuario*/
          ctx[2].id)) {
            attr_dev(a, "href", a_href_value);
          }

          if (current_block_type === (current_block_type = select_block_type_1(ctx)) && if_block) {
            if_block.p(ctx, dirty);
          } else {
            if_block.d(1);
            if_block = current_block_type(ctx);

            if (if_block) {
              if_block.c();
              if_block.m(if_block_anchor.parentNode, if_block_anchor);
            }
          }
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(a);
          if (detaching) detach_dev(t1);
          if_block.d(detaching);
          if (detaching) detach_dev(if_block_anchor);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_2$k.name,
        type: "if",
        source: "(46:8) {#if $globalStore.usuario.esMod}",
        ctx
      });
      return block;
    } // (51:12) {:else}


    function create_else_block_1$4(ctx) {
      let a;
      let t_value =
      /*comentario*/
      ctx[7].usuario.userName + "";
      let t;
      let a_href_value;
      const block = {
        c: function create() {
          a = element("a");
          t = text(t_value);
          attr_dev(a, "class", "userlink svelte-u2edks");
          attr_dev(a, "href", a_href_value = "/Moderacion/HistorialDeUsuario/" +
          /*comentario*/
          ctx[7].usuario.id);
          add_location(a, file$C, 51, 16, 1771);
        },
        m: function mount(target, anchor) {
          insert_dev(target, a, anchor);
          append_dev(a, t);
        },
        p: noop,
        d: function destroy(detaching) {
          if (detaching) detach_dev(a);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_else_block_1$4.name,
        type: "else",
        source: "(51:12) {:else}",
        ctx
      });
      return block;
    } // (49:12) {#if denuncia.tipo == 0}


    function create_if_block_3$e(ctx) {
      let a;
      let t_value =
      /*hilo*/
      ctx[1].usuario.userName + "";
      let t;
      let a_href_value;
      const block = {
        c: function create() {
          a = element("a");
          t = text(t_value);
          attr_dev(a, "class", "userlink svelte-u2edks");
          attr_dev(a, "href", a_href_value = "/Moderacion/HistorialDeUsuario/" +
          /*hilo*/
          ctx[1].usuario.id);
          add_location(a, file$C, 49, 16, 1631);
        },
        m: function mount(target, anchor) {
          insert_dev(target, a, anchor);
          append_dev(a, t);
        },
        p: function update(ctx, dirty) {
          if (dirty &
          /*hilo*/
          2 && t_value !== (t_value =
          /*hilo*/
          ctx[1].usuario.userName + "")) set_data_dev(t, t_value);

          if (dirty &
          /*hilo*/
          2 && a_href_value !== (a_href_value = "/Moderacion/HistorialDeUsuario/" +
          /*hilo*/
          ctx[1].usuario.id)) {
            attr_dev(a, "href", a_href_value);
          }
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(a);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_3$e.name,
        type: "if",
        source: "(49:12) {#if denuncia.tipo == 0}",
        ctx
      });
      return block;
    } // (63:8) <Button  dense on:click={() => mostrarVistaPrevia = !mostrarVistaPrevia}>


    function create_default_slot_2$i(ctx) {
      let t;
      const block = {
        c: function create() {
          t = text("Previsualizar");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_2$i.name,
        type: "slot",
        source: "(63:8) <Button  dense on:click={() => mostrarVistaPrevia = !mostrarVistaPrevia}>",
        ctx
      });
      return block;
    } // (66:12) <Button dense  >


    function create_default_slot_1$k(ctx) {
      let t;
      const block = {
        c: function create() {
          t = text("Ir");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_1$k.name,
        type: "slot",
        source: "(66:12) <Button dense  >",
        ctx
      });
      return block;
    } // (68:8) <Button dense  on:click={rechazar}>


    function create_default_slot$m(ctx) {
      let t;
      const block = {
        c: function create() {
          t = text("Rechazar");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot$m.name,
        type: "slot",
        source: "(68:8) <Button dense  on:click={rechazar}>",
        ctx
      });
      return block;
    } // (71:8) {:else}


    function create_else_block$8(ctx) {
      let comentario_1;
      let current;
      comentario_1 = new Comentario({
        props: {
          comentario:
          /*comentario*/
          ctx[7]
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          create_component(comentario_1.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(comentario_1, target, anchor);
          current = true;
        },
        p: noop,
        i: function intro(local) {
          if (current) return;
          transition_in(comentario_1.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(comentario_1.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(comentario_1, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_else_block$8.name,
        type: "else",
        source: "(71:8) {:else}",
        ctx
      });
      return block;
    } // (69:8) {#if denuncia.tipo == 0}


    function create_if_block_1$l(ctx) {
      let hilopreviewmod;
      let current;
      hilopreviewmod = new HiloPreviewMod({
        props: {
          hilo:
          /*hilo*/
          ctx[1]
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          create_component(hilopreviewmod.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(hilopreviewmod, target, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          const hilopreviewmod_changes = {};
          if (dirty &
          /*hilo*/
          2) hilopreviewmod_changes.hilo =
          /*hilo*/
          ctx[1];
          hilopreviewmod.$set(hilopreviewmod_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(hilopreviewmod.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(hilopreviewmod.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(hilopreviewmod, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_1$l.name,
        type: "if",
        source: "(69:8) {#if denuncia.tipo == 0}",
        ctx
      });
      return block;
    } // (74:8) {#if mostrarVistaPrevia}


    function create_if_block$t(ctx) {
      let div;
      let hilocuerpo;
      let current;
      let mounted;
      let dispose;
      hilocuerpo = new HiloCuerpo({
        props: {
          hilo:
          /*hilo*/
          ctx[1]
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          div = element("div");
          create_component(hilocuerpo.$$.fragment);
          attr_dev(div, "class", "vista-previa svelte-u2edks");
          add_location(div, file$C, 74, 12, 2765);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          mount_component(hilocuerpo, div, null);
          current = true;

          if (!mounted) {
            dispose = listen_dev(div, "mouseleave",
            /*mouseleave_handler*/
            ctx[11], false, false, false);
            mounted = true;
          }
        },
        p: function update(ctx, dirty) {
          const hilocuerpo_changes = {};
          if (dirty &
          /*hilo*/
          2) hilocuerpo_changes.hilo =
          /*hilo*/
          ctx[1];
          hilocuerpo.$set(hilocuerpo_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(hilocuerpo.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(hilocuerpo.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
          destroy_component(hilocuerpo);
          mounted = false;
          dispose();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block$t.name,
        type: "if",
        source: "(74:8) {#if mostrarVistaPrevia}",
        ctx
      });
      return block;
    }

    function create_fragment$C(ctx) {
      let div2;
      let div0;
      let span;
      let tiempo;
      let t0;
      let t1;
      let t2_value =
      /*motivos*/
      ctx[8][
      /*denuncia*/
      ctx[0].motivo] + "";
      let t2;
      let t3;
      let t4_value = (
      /*denuncia*/
      ctx[0].aclaracion ? `(${
  /*denuncia*/
  ctx[0].aclaracion})` : "") + "";
      let t4;
      let t5;
      let div1;
      let button0;
      let t6;
      let a;
      let button1;
      let a_href_value;
      let t7;
      let button2;
      let t8;
      let current_block_type_index;
      let if_block1;
      let t9;
      let current;
      tiempo = new Tiempo({
        props: {
          date:
          /*denuncia*/
          ctx[0].creacion
        },
        $$inline: true
      });

      function select_block_type(ctx, dirty) {
        if (
        /*$globalStore*/
        ctx[6].usuario.esMod) return create_if_block_2$k;
        return create_else_block_2$3;
      }

      let current_block_type = select_block_type(ctx);
      let if_block0 = current_block_type(ctx);
      button0 = new ye({
        props: {
          dense: true,
          $$slots: {
            default: [create_default_slot_2$i]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      button0.$on("click",
      /*click_handler*/
      ctx[10]);
      button1 = new ye({
        props: {
          dense: true,
          $$slots: {
            default: [create_default_slot_1$k]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      button2 = new ye({
        props: {
          dense: true,
          $$slots: {
            default: [create_default_slot$m]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      button2.$on("click",
      /*rechazar*/
      ctx[9]);
      const if_block_creators = [create_if_block_1$l, create_else_block$8];
      const if_blocks = [];

      function select_block_type_2(ctx, dirty) {
        if (
        /*denuncia*/
        ctx[0].tipo == 0) return 0;
        return 1;
      }

      current_block_type_index = select_block_type_2(ctx);
      if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
      let if_block2 =
      /*mostrarVistaPrevia*/
      ctx[3] && create_if_block$t(ctx);
      const block = {
        c: function create() {
          div2 = element("div");
          div0 = element("div");
          span = element("span");
          create_component(tiempo.$$.fragment);
          t0 = space();
          if_block0.c();
          t1 = text("\n          por ");
          t2 = text(t2_value);
          t3 = space();
          t4 = text(t4_value);
          t5 = space();
          div1 = element("div");
          create_component(button0.$$.fragment);
          t6 = space();
          a = element("a");
          create_component(button1.$$.fragment);
          t7 = space();
          create_component(button2.$$.fragment);
          t8 = space();
          if_block1.c();
          t9 = space();
          if (if_block2) if_block2.c();
          set_style(span, "background", "var(--color2)");
          set_style(span, "padding", "2px");
          set_style(span, "border-radius", "4px");
          add_location(span, file$C, 42, 8, 1271);
          attr_dev(div0, "class", "header svelte-u2edks");
          add_location(div0, file$C, 41, 4, 1242);
          attr_dev(a, "href", a_href_value = "/Hilo/" +
          /*hilo*/
          ctx[1].id + "#" + (
          /*comentario*/
          ctx[7] &&
          /*comentario*/
          ctx[7].id ?
          /*comentario*/
          ctx[7].id : ""));
          add_location(a, file$C, 64, 8, 2381);
          attr_dev(div1, "class", "body");
          add_location(div1, file$C, 61, 4, 2185);
          attr_dev(div2, "class", "denuncia svelte-u2edks");
          toggle_class(div2, "rechazada",
          /*rechazada*/
          ctx[4]);
          toggle_class(div2, "aceptada",
          /*aceptada*/
          ctx[5]);
          add_location(div2, file$C, 40, 0, 1183);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, div2, anchor);
          append_dev(div2, div0);
          append_dev(div0, span);
          mount_component(tiempo, span, null);
          append_dev(div0, t0);
          if_block0.m(div0, null);
          append_dev(div0, t1);
          append_dev(div0, t2);
          append_dev(div0, t3);
          append_dev(div0, t4);
          append_dev(div2, t5);
          append_dev(div2, div1);
          mount_component(button0, div1, null);
          append_dev(div1, t6);
          append_dev(div1, a);
          mount_component(button1, a, null);
          append_dev(div1, t7);
          mount_component(button2, div1, null);
          append_dev(div1, t8);
          if_blocks[current_block_type_index].m(div1, null);
          append_dev(div1, t9);
          if (if_block2) if_block2.m(div1, null);
          current = true;
        },
        p: function update(ctx, [dirty]) {
          const tiempo_changes = {};
          if (dirty &
          /*denuncia*/
          1) tiempo_changes.date =
          /*denuncia*/
          ctx[0].creacion;
          tiempo.$set(tiempo_changes);

          if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block0) {
            if_block0.p(ctx, dirty);
          } else {
            if_block0.d(1);
            if_block0 = current_block_type(ctx);

            if (if_block0) {
              if_block0.c();
              if_block0.m(div0, t1);
            }
          }

          if ((!current || dirty &
          /*denuncia*/
          1) && t2_value !== (t2_value =
          /*motivos*/
          ctx[8][
          /*denuncia*/
          ctx[0].motivo] + "")) set_data_dev(t2, t2_value);
          if ((!current || dirty &
          /*denuncia*/
          1) && t4_value !== (t4_value = (
          /*denuncia*/
          ctx[0].aclaracion ? `(${
      /*denuncia*/
      ctx[0].aclaracion})` : "") + "")) set_data_dev(t4, t4_value);
          const button0_changes = {};

          if (dirty &
          /*$$scope*/
          8192) {
            button0_changes.$$scope = {
              dirty,
              ctx
            };
          }

          button0.$set(button0_changes);
          const button1_changes = {};

          if (dirty &
          /*$$scope*/
          8192) {
            button1_changes.$$scope = {
              dirty,
              ctx
            };
          }

          button1.$set(button1_changes);

          if (!current || dirty &
          /*hilo*/
          2 && a_href_value !== (a_href_value = "/Hilo/" +
          /*hilo*/
          ctx[1].id + "#" + (
          /*comentario*/
          ctx[7] &&
          /*comentario*/
          ctx[7].id ?
          /*comentario*/
          ctx[7].id : ""))) {
            attr_dev(a, "href", a_href_value);
          }

          const button2_changes = {};

          if (dirty &
          /*$$scope*/
          8192) {
            button2_changes.$$scope = {
              dirty,
              ctx
            };
          }

          button2.$set(button2_changes);
          let previous_block_index = current_block_type_index;
          current_block_type_index = select_block_type_2(ctx);

          if (current_block_type_index === previous_block_index) {
            if_blocks[current_block_type_index].p(ctx, dirty);
          } else {
            group_outros();
            transition_out(if_blocks[previous_block_index], 1, 1, () => {
              if_blocks[previous_block_index] = null;
            });
            check_outros();
            if_block1 = if_blocks[current_block_type_index];

            if (!if_block1) {
              if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
              if_block1.c();
            }

            transition_in(if_block1, 1);
            if_block1.m(div1, t9);
          }

          if (
          /*mostrarVistaPrevia*/
          ctx[3]) {
            if (if_block2) {
              if_block2.p(ctx, dirty);

              if (dirty &
              /*mostrarVistaPrevia*/
              8) {
                transition_in(if_block2, 1);
              }
            } else {
              if_block2 = create_if_block$t(ctx);
              if_block2.c();
              transition_in(if_block2, 1);
              if_block2.m(div1, null);
            }
          } else if (if_block2) {
            group_outros();
            transition_out(if_block2, 1, 1, () => {
              if_block2 = null;
            });
            check_outros();
          }

          if (dirty &
          /*rechazada*/
          16) {
            toggle_class(div2, "rechazada",
            /*rechazada*/
            ctx[4]);
          }

          if (dirty &
          /*aceptada*/
          32) {
            toggle_class(div2, "aceptada",
            /*aceptada*/
            ctx[5]);
          }
        },
        i: function intro(local) {
          if (current) return;
          transition_in(tiempo.$$.fragment, local);
          transition_in(button0.$$.fragment, local);
          transition_in(button1.$$.fragment, local);
          transition_in(button2.$$.fragment, local);
          transition_in(if_block1);
          transition_in(if_block2);
          current = true;
        },
        o: function outro(local) {
          transition_out(tiempo.$$.fragment, local);
          transition_out(button0.$$.fragment, local);
          transition_out(button1.$$.fragment, local);
          transition_out(button2.$$.fragment, local);
          transition_out(if_block1);
          transition_out(if_block2);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div2);
          destroy_component(tiempo);
          if_block0.d();
          destroy_component(button0);
          destroy_component(button1);
          destroy_component(button2);
          if_blocks[current_block_type_index].d();
          if (if_block2) if_block2.d();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$C.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }

    function instance$C($$self, $$props, $$invalidate) {
      let $globalStore;
      validate_store(globalStore, "globalStore");
      component_subscribe($$self, globalStore, $$value => $$invalidate(6, $globalStore = $$value));
      let {
        $$slots: slots = {},
        $$scope
      } = $$props;
      validate_slots("Denuncia", slots, []);
      const dispatch = createEventDispatcher();
      let {
        denuncia
      } = $$props;
      let {
        hilo,
        comentario,
        usuario
      } = denuncia;
      usuario = usuario || {
        id: "",
        userName: "Anonimo"
      };
      hilo.cantidadComentarios = "";
      let mostrarVistaPrevia = false;
      const motivos = Object.keys(MotivoDenuncia);

      async function rechazar() {
        try {
          let res = await RChanClient.rechazarDenuncia(denuncia.id);
          dispatch("rechazar", denuncia.id);
          $$invalidate(0, denuncia.estado = 1, denuncia);
        } catch (error) {}
      }

      const writable_props = ["denuncia"];
      Object_1$5.keys($$props).forEach(key => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Denuncia> was created with unknown prop '${key}'`);
      });

      const click_handler = () => $$invalidate(3, mostrarVistaPrevia = !mostrarVistaPrevia);

      const mouseleave_handler = () => $$invalidate(3, mostrarVistaPrevia = false);

      $$self.$$set = $$props => {
        if ("denuncia" in $$props) $$invalidate(0, denuncia = $$props.denuncia);
      };

      $$self.$capture_state = () => ({
        HiloCuerpo,
        Button: ye,
        Tiempo,
        Comentario,
        RChanClient,
        createEventDispatcher,
        HiloPreviewMod,
        EstadoDenuncia,
        MotivoDenuncia,
        globalStore,
        dispatch,
        denuncia,
        hilo,
        comentario,
        usuario,
        mostrarVistaPrevia,
        motivos,
        rechazar,
        rechazada,
        aceptada,
        $globalStore
      });

      $$self.$inject_state = $$props => {
        if ("denuncia" in $$props) $$invalidate(0, denuncia = $$props.denuncia);
        if ("hilo" in $$props) $$invalidate(1, hilo = $$props.hilo);
        if ("comentario" in $$props) $$invalidate(7, comentario = $$props.comentario);
        if ("usuario" in $$props) $$invalidate(2, usuario = $$props.usuario);
        if ("mostrarVistaPrevia" in $$props) $$invalidate(3, mostrarVistaPrevia = $$props.mostrarVistaPrevia);
        if ("rechazada" in $$props) $$invalidate(4, rechazada = $$props.rechazada);
        if ("aceptada" in $$props) $$invalidate(5, aceptada = $$props.aceptada);
      };

      let rechazada;
      let aceptada;

      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }

      $$self.$$.update = () => {
        if ($$self.$$.dirty &
        /*denuncia*/
        1) {
           $$invalidate(4, rechazada = denuncia.estado == EstadoDenuncia.Rechazada);
        }

        if ($$self.$$.dirty &
        /*denuncia*/
        1) {
           $$invalidate(5, aceptada = denuncia.estado == EstadoDenuncia.Aceptada);
        }
      };

      return [denuncia, hilo, usuario, mostrarVistaPrevia, rechazada, aceptada, $globalStore, comentario, motivos, rechazar, click_handler, mouseleave_handler];
    }

    class Denuncia extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$C, create_fragment$C, safe_not_equal, {
          denuncia: 0
        });
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "Denuncia",
          options,
          id: create_fragment$C.name
        });
        const {
          ctx
        } = this.$$;
        const props = options.props || {};

        if (
        /*denuncia*/
        ctx[0] === undefined && !("denuncia" in props)) {
          console.warn("<Denuncia> was created without expected prop 'denuncia'");
        }
      }

      get denuncia() {
        throw new Error("<Denuncia>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set denuncia(value) {
        throw new Error("<Denuncia>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

    }

    /* src\components\Moderacion\DenunciasNav.svelte generated by Svelte v3.29.0 */
    const {
      console: console_1$9,
      document: document_1$1
    } = globals;
    const file$D = "src\\components\\Moderacion\\DenunciasNav.svelte";

    function get_each_context$g(ctx, list, i) {
      const child_ctx = ctx.slice();
      child_ctx[12] = list[i];
      child_ctx[13] = list;
      child_ctx[14] = i;
      return child_ctx;
    } // (64:0) {#if $globalStore.usuario.esMod || $globalStore.usuario.esAuxiliar}


    function create_if_block$u(ctx) {
      let button;
      let t;
      let if_block_anchor;
      let current;
      button = new ye({
        props: {
          icon: true,
          dense: true,
          style: "position:relative",
          $$slots: {
            default: [create_default_slot$n]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      button.$on("click",
      /*click_handler*/
      ctx[6]);
      let if_block =
      /*mostrar*/
      ctx[1] && create_if_block_1$m(ctx);
      const block = {
        c: function create() {
          create_component(button.$$.fragment);
          t = space();
          if (if_block) if_block.c();
          if_block_anchor = empty();
        },
        m: function mount(target, anchor) {
          mount_component(button, target, anchor);
          insert_dev(target, t, anchor);
          if (if_block) if_block.m(target, anchor);
          insert_dev(target, if_block_anchor, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          const button_changes = {};

          if (dirty &
          /*$$scope, denuncias*/
          32769) {
            button_changes.$$scope = {
              dirty,
              ctx
            };
          }

          button.$set(button_changes);

          if (
          /*mostrar*/
          ctx[1]) {
            if (if_block) {
              if_block.p(ctx, dirty);

              if (dirty &
              /*mostrar*/
              2) {
                transition_in(if_block, 1);
              }
            } else {
              if_block = create_if_block_1$m(ctx);
              if_block.c();
              transition_in(if_block, 1);
              if_block.m(if_block_anchor.parentNode, if_block_anchor);
            }
          } else if (if_block) {
            group_outros();
            transition_out(if_block, 1, 1, () => {
              if_block = null;
            });
            check_outros();
          }
        },
        i: function intro(local) {
          if (current) return;
          transition_in(button.$$.fragment, local);
          transition_in(if_block);
          current = true;
        },
        o: function outro(local) {
          transition_out(button.$$.fragment, local);
          transition_out(if_block);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(button, detaching);
          if (detaching) detach_dev(t);
          if (if_block) if_block.d(detaching);
          if (detaching) detach_dev(if_block_anchor);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block$u.name,
        type: "if",
        source: "(64:0) {#if $globalStore.usuario.esMod || $globalStore.usuario.esAuxiliar}",
        ctx
      });
      return block;
    } // (69:8) {#if denuncias.filter(d => d.estado == EstadoDenuncia.NoRevisada).length != 0}


    function create_if_block_2$l(ctx) {
      let div;
      let span;
      let t_value =
      /*denuncias*/
      ctx[0].filter(
      /*func_1*/
      ctx[5]).length + "";
      let t;
      const block = {
        c: function create() {
          div = element("div");
          span = element("span");
          t = text(t_value);
          add_location(span, file$D, 70, 16, 2335);
          attr_dev(div, "class", "noti-cont");
          set_style(div, "position", "absolute");
          add_location(div, file$D, 69, 12, 2267);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          append_dev(div, span);
          append_dev(span, t);
        },
        p: function update(ctx, dirty) {
          if (dirty &
          /*denuncias*/
          1 && t_value !== (t_value =
          /*denuncias*/
          ctx[0].filter(
          /*func_1*/
          ctx[5]).length + "")) set_data_dev(t, t_value);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_2$l.name,
        type: "if",
        source: "(69:8) {#if denuncias.filter(d => d.estado == EstadoDenuncia.NoRevisada).length != 0}",
        ctx
      });
      return block;
    } // (66:4) <Button icon dense on:click={() => mostrar = !mostrar } style="position:relative">


    function create_default_slot$n(ctx) {
      let span;
      let t;
      let show_if =
      /*denuncias*/
      ctx[0].filter(
      /*func*/
      ctx[4]).length != 0;
      let if_block_anchor;
      let if_block = show_if && create_if_block_2$l(ctx);
      const block = {
        c: function create() {
          span = element("span");
          t = space();
          if (if_block) if_block.c();
          if_block_anchor = empty();
          attr_dev(span, "class", "fe fe-alert-circle");
          add_location(span, file$D, 67, 8, 2132);
        },
        m: function mount(target, anchor) {
          insert_dev(target, span, anchor);
          insert_dev(target, t, anchor);
          if (if_block) if_block.m(target, anchor);
          insert_dev(target, if_block_anchor, anchor);
        },
        p: function update(ctx, dirty) {
          if (dirty &
          /*denuncias*/
          1) show_if =
          /*denuncias*/
          ctx[0].filter(
          /*func*/
          ctx[4]).length != 0;

          if (show_if) {
            if (if_block) {
              if_block.p(ctx, dirty);
            } else {
              if_block = create_if_block_2$l(ctx);
              if_block.c();
              if_block.m(if_block_anchor.parentNode, if_block_anchor);
            }
          } else if (if_block) {
            if_block.d(1);
            if_block = null;
          }
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(span);
          if (detaching) detach_dev(t);
          if (if_block) if_block.d(detaching);
          if (detaching) detach_dev(if_block_anchor);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot$n.name,
        type: "slot",
        source: "(66:4) <Button icon dense on:click={() => mostrar = !mostrar } style=\\\"position:relative\\\">",
        ctx
      });
      return block;
    } // (76:4) {#if mostrar}


    function create_if_block_1$m(ctx) {
      let div;
      let ul;
      let each_blocks = [];
      let each_1_lookup = new Map();
      let current;
      let each_value =
      /*denuncias*/
      ctx[0];
      validate_each_argument(each_value);

      const get_key = ctx =>
      /*d*/
      ctx[12].id;

      validate_each_keys(ctx, each_value, get_each_context$g, get_key);

      for (let i = 0; i < each_value.length; i += 1) {
        let child_ctx = get_each_context$g(ctx, each_value, i);
        let key = get_key(child_ctx);
        each_1_lookup.set(key, each_blocks[i] = create_each_block$g(key, child_ctx));
      }

      let each_1_else = null;

      if (!each_value.length) {
        each_1_else = create_else_block$9(ctx);
      }

      const block = {
        c: function create() {
          div = element("div");
          ul = element("ul");

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].c();
          }

          if (each_1_else) {
            each_1_else.c();
          }

          attr_dev(ul, "class", "svelte-2zjzlq");
          add_location(ul, file$D, 77, 12, 2532);
          attr_dev(div, "class", "denuncias-nav svelte-2zjzlq");
          add_location(div, file$D, 76, 8, 2492);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          append_dev(div, ul);

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].m(ul, null);
          }

          if (each_1_else) {
            each_1_else.m(ul, null);
          }

          current = true;
        },
        p: function update(ctx, dirty) {
          if (dirty &
          /*denuncias*/
          1) {
            const each_value =
            /*denuncias*/
            ctx[0];
            validate_each_argument(each_value);
            group_outros();
            validate_each_keys(ctx, each_value, get_each_context$g, get_key);
            each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, ul, outro_and_destroy_block, create_each_block$g, null, get_each_context$g);
            check_outros();

            if (each_value.length) {
              if (each_1_else) {
                each_1_else.d(1);
                each_1_else = null;
              }
            } else if (!each_1_else) {
              each_1_else = create_else_block$9(ctx);
              each_1_else.c();
              each_1_else.m(ul, null);
            }
          }
        },
        i: function intro(local) {
          if (current) return;

          for (let i = 0; i < each_value.length; i += 1) {
            transition_in(each_blocks[i]);
          }

          current = true;
        },
        o: function outro(local) {
          for (let i = 0; i < each_blocks.length; i += 1) {
            transition_out(each_blocks[i]);
          }

          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].d();
          }

          if (each_1_else) each_1_else.d();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_1$m.name,
        type: "if",
        source: "(76:4) {#if mostrar}",
        ctx
      });
      return block;
    } // (81:16) {:else}


    function create_else_block$9(ctx) {
      let h3;
      const block = {
        c: function create() {
          h3 = element("h3");
          h3.textContent = "No hay denuncias";
          set_style(h3, "text-align", "center");
          add_location(h3, file$D, 81, 20, 2678);
        },
        m: function mount(target, anchor) {
          insert_dev(target, h3, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(h3);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_else_block$9.name,
        type: "else",
        source: "(81:16) {:else}",
        ctx
      });
      return block;
    } // (79:16) {#each denuncias as d (d.id)}


    function create_each_block$g(key_1, ctx) {
      let first;
      let denuncia;
      let updating_denuncia;
      let current;

      function denuncia_denuncia_binding(value) {
        /*denuncia_denuncia_binding*/
        ctx[7].call(null, value,
        /*d*/
        ctx[12],
        /*each_value*/
        ctx[13],
        /*d_index*/
        ctx[14]);
      }

      let denuncia_props = {};

      if (
      /*d*/
      ctx[12] !== void 0) {
        denuncia_props.denuncia =
        /*d*/
        ctx[12];
      }

      denuncia = new Denuncia({
        props: denuncia_props,
        $$inline: true
      });
      binding_callbacks.push(() => bind(denuncia, "denuncia", denuncia_denuncia_binding));
      const block = {
        key: key_1,
        first: null,
        c: function create() {
          first = empty();
          create_component(denuncia.$$.fragment);
          this.first = first;
        },
        m: function mount(target, anchor) {
          insert_dev(target, first, anchor);
          mount_component(denuncia, target, anchor);
          current = true;
        },
        p: function update(new_ctx, dirty) {
          ctx = new_ctx;
          const denuncia_changes = {};

          if (!updating_denuncia && dirty &
          /*denuncias*/
          1) {
            updating_denuncia = true;
            denuncia_changes.denuncia =
            /*d*/
            ctx[12];
            add_flush_callback(() => updating_denuncia = false);
          }

          denuncia.$set(denuncia_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(denuncia.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(denuncia.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(first);
          destroy_component(denuncia, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_each_block$g.name,
        type: "each",
        source: "(79:16) {#each denuncias as d (d.id)}",
        ctx
      });
      return block;
    }

    function create_fragment$D(ctx) {
      let title_value;
      let t;
      let if_block_anchor;
      let current;
      document_1$1.title = title_value = "" + ((
      /*denunciasActivas*/
      ctx[2].length != 0 ? `{${
  /*denunciasActivas*/
  ctx[2].length}}!` : "") + " " + document.title.split("!").pop());
      let if_block = (
      /*$globalStore*/
      ctx[3].usuario.esMod ||
      /*$globalStore*/
      ctx[3].usuario.esAuxiliar) && create_if_block$u(ctx);
      const block = {
        c: function create() {
          t = space();
          if (if_block) if_block.c();
          if_block_anchor = empty();
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
          if (if_block) if_block.m(target, anchor);
          insert_dev(target, if_block_anchor, anchor);
          current = true;
        },
        p: function update(ctx, [dirty]) {
          if ((!current || dirty &
          /*denunciasActivas, document*/
          4) && title_value !== (title_value = "" + ((
          /*denunciasActivas*/
          ctx[2].length != 0 ? `{${
      /*denunciasActivas*/
      ctx[2].length}}!` : "") + " " + document.title.split("!").pop()))) {
            document_1$1.title = title_value;
          }

          if (
          /*$globalStore*/
          ctx[3].usuario.esMod ||
          /*$globalStore*/
          ctx[3].usuario.esAuxiliar) {
            if (if_block) {
              if_block.p(ctx, dirty);

              if (dirty &
              /*$globalStore*/
              8) {
                transition_in(if_block, 1);
              }
            } else {
              if_block = create_if_block$u(ctx);
              if_block.c();
              transition_in(if_block, 1);
              if_block.m(if_block_anchor.parentNode, if_block_anchor);
            }
          } else if (if_block) {
            group_outros();
            transition_out(if_block, 1, 1, () => {
              if_block = null;
            });
            check_outros();
          }
        },
        i: function intro(local) {
          if (current) return;
          transition_in(if_block);
          current = true;
        },
        o: function outro(local) {
          transition_out(if_block);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(t);
          if (if_block) if_block.d(detaching);
          if (detaching) detach_dev(if_block_anchor);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$D.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }

    function instance$D($$self, $$props, $$invalidate) {
      let $globalStore;
      let $ajustesConfigModStore;
      validate_store(globalStore, "globalStore");
      component_subscribe($$self, globalStore, $$value => $$invalidate(3, $globalStore = $$value));
      validate_store(ajustesConfigMod, "ajustesConfigModStore");
      component_subscribe($$self, ajustesConfigMod, $$value => $$invalidate(10, $ajustesConfigModStore = $$value));
      let {
        $$slots: slots = {},
        $$scope
      } = $$props;
      validate_slots("DenunciasNav", slots, []);
      let denuncias = window.denuncias || [];
      let mostrar = false;

      if ($globalStore.usuario.esMod || $globalStore.usuario.esAuxiliar) {
        Signal.subscribirAModeracion();
      }

      const underAttack = new Audio("/audio/underAttack.mp3");
      const toing = new Audio("/audio/toing.mp3");
      const denunciasVolumen = $ajustesConfigModStore.mutearDenuncias ? 0 : 0.03;
      underAttack.volume = denunciasVolumen;
      toing.volume = denunciasVolumen;
      Signal.coneccion.on("nuevaDenuncia", denuncia => {
        underAttack.play();
        console.log(denuncia);
        $$invalidate(0, denuncias = [denuncia, ...denuncias]);
        $$invalidate(1, mostrar = $ajustesConfigModStore.autoDesplegarDenuncias);
      });
      Signal.coneccion.on("denunciasRechazadas", ids => {
        if (ids.length == 0) return;
        toing.play();
        $$invalidate(0, denuncias = denuncias.map(d => {
          if (ids.includes(d.id)) d.estado = EstadoDenuncia.Rechazada;
          return d;
        }));
      });
      Signal.coneccion.on("denunciasAceptadas", ids => {
        if (ids.length == 0) return;
        toing.play();
        $$invalidate(0, denuncias = denuncias.map(d => {
          if (ids.includes(d.id)) d.estado = EstadoDenuncia.Aceptada;
          return d;
        }));
      });
      const writable_props = [];
      Object.keys($$props).forEach(key => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$9.warn(`<DenunciasNav> was created with unknown prop '${key}'`);
      });

      const func = d => d.estado == EstadoDenuncia.NoRevisada;

      const func_1 = d => d.estado == EstadoDenuncia.NoRevisada;

      const click_handler = () => $$invalidate(1, mostrar = !mostrar);

      function denuncia_denuncia_binding(value, d, each_value, d_index) {
        each_value[d_index] = value;
        $$invalidate(0, denuncias);
      }

      $$self.$capture_state = () => ({
        Ripple: he,
        Button: ye,
        EstadoDenuncia,
        globalStore,
        Signal,
        Denuncia,
        ajustesConfigModStore: ajustesConfigMod,
        denuncias,
        mostrar,
        underAttack,
        toing,
        denunciasVolumen,
        denunciasActivas,
        $globalStore,
        $ajustesConfigModStore
      });

      $$self.$inject_state = $$props => {
        if ("denuncias" in $$props) $$invalidate(0, denuncias = $$props.denuncias);
        if ("mostrar" in $$props) $$invalidate(1, mostrar = $$props.mostrar);
        if ("denunciasActivas" in $$props) $$invalidate(2, denunciasActivas = $$props.denunciasActivas);
      };

      let denunciasActivas;

      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }

      $$self.$$.update = () => {
        if ($$self.$$.dirty &
        /*denuncias*/
        1) {
           $$invalidate(2, denunciasActivas = denuncias.filter(d => d.estado == EstadoDenuncia.NoRevisada));
        }

        if ($$self.$$.dirty &
        /*denuncias*/
        1) {
           if (denuncias.filter(d => d.estado == EstadoDenuncia.NoRevisada).length == 0) {
            $$invalidate(1, mostrar = false);
          }
        }
      };

      return [denuncias, mostrar, denunciasActivas, $globalStore, func, func_1, click_handler, denuncia_denuncia_binding];
    }

    class DenunciasNav extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$D, create_fragment$D, safe_not_equal, {});
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "DenunciasNav",
          options,
          id: create_fragment$D.name
        });
      }

    }

    /* src\components\Moderacion\SelectorDeComentarios.svelte generated by Svelte v3.29.0 */
    const file$E = "src\\components\\Moderacion\\SelectorDeComentarios.svelte"; // (15:0) {#if $selectorStore.seleccionados.size != 0}

    function create_if_block$v(ctx) {
      let div;
      let button;
      let current;
      button = new ye({
        props: {
          color: "var(--color5)",
          raised: true,
          $$slots: {
            default: [create_default_slot$o]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      button.$on("click",
      /*eliminarComentariosSeleccionados*/
      ctx[1]);
      const block = {
        c: function create() {
          div = element("div");
          create_component(button.$$.fragment);
          attr_dev(div, "class", "selector-comentarios svelte-rrcziw");
          add_location(div, file$E, 15, 4, 401);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          mount_component(button, div, null);
          current = true;
        },
        p: function update(ctx, dirty) {
          const button_changes = {};

          if (dirty &
          /*$$scope, $selectorStore*/
          5) {
            button_changes.$$scope = {
              dirty,
              ctx
            };
          }

          button.$set(button_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(button.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(button.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
          destroy_component(button);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block$v.name,
        type: "if",
        source: "(15:0) {#if $selectorStore.seleccionados.size != 0}",
        ctx
      });
      return block;
    } // (17:8) <Button on:click={eliminarComentariosSeleccionados} color="var(--color5)" raised>


    function create_default_slot$o(ctx) {
      let t0;
      let t1_value =
      /*$selectorStore*/
      ctx[0].seleccionados.size + "";
      let t1;
      let t2;
      const block = {
        c: function create() {
          t0 = text("Eliminar ");
          t1 = text(t1_value);
          t2 = text(" Comentario/s");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t0, anchor);
          insert_dev(target, t1, anchor);
          insert_dev(target, t2, anchor);
        },
        p: function update(ctx, dirty) {
          if (dirty &
          /*$selectorStore*/
          1 && t1_value !== (t1_value =
          /*$selectorStore*/
          ctx[0].seleccionados.size + "")) set_data_dev(t1, t1_value);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(t0);
          if (detaching) detach_dev(t1);
          if (detaching) detach_dev(t2);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot$o.name,
        type: "slot",
        source: "(17:8) <Button on:click={eliminarComentariosSeleccionados} color=\\\"var(--color5)\\\" raised>",
        ctx
      });
      return block;
    }

    function create_fragment$E(ctx) {
      let if_block_anchor;
      let current;
      let if_block =
      /*$selectorStore*/
      ctx[0].seleccionados.size != 0 && create_if_block$v(ctx);
      const block = {
        c: function create() {
          if (if_block) if_block.c();
          if_block_anchor = empty();
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          if (if_block) if_block.m(target, anchor);
          insert_dev(target, if_block_anchor, anchor);
          current = true;
        },
        p: function update(ctx, [dirty]) {
          if (
          /*$selectorStore*/
          ctx[0].seleccionados.size != 0) {
            if (if_block) {
              if_block.p(ctx, dirty);

              if (dirty &
              /*$selectorStore*/
              1) {
                transition_in(if_block, 1);
              }
            } else {
              if_block = create_if_block$v(ctx);
              if_block.c();
              transition_in(if_block, 1);
              if_block.m(if_block_anchor.parentNode, if_block_anchor);
            }
          } else if (if_block) {
            group_outros();
            transition_out(if_block, 1, 1, () => {
              if_block = null;
            });
            check_outros();
          }
        },
        i: function intro(local) {
          if (current) return;
          transition_in(if_block);
          current = true;
        },
        o: function outro(local) {
          transition_out(if_block);
          current = false;
        },
        d: function destroy(detaching) {
          if (if_block) if_block.d(detaching);
          if (detaching) detach_dev(if_block_anchor);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$E.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }

    function instance$E($$self, $$props, $$invalidate) {
      let $selectorStore;
      validate_store(selectorStore, "selectorStore");
      component_subscribe($$self, selectorStore, $$value => $$invalidate(0, $selectorStore = $$value));
      let {
        $$slots: slots = {},
        $$scope
      } = $$props;
      validate_slots("SelectorDeComentarios", slots, []);

      function eliminarComentariosSeleccionados() {
        abrir.eliminarComentarios(Array.from($selectorStore.seleccionados));
        set_store_value(selectorStore, $selectorStore.seleccionados = new Set([]), $selectorStore);
      }

      const writable_props = [];
      Object.keys($$props).forEach(key => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<SelectorDeComentarios> was created with unknown prop '${key}'`);
      });

      $$self.$capture_state = () => ({
        selectorStore,
        Button: ye,
        abrir,
        eliminarComentariosSeleccionados,
        $selectorStore
      });

      return [$selectorStore, eliminarComentariosSeleccionados];
    }

    class SelectorDeComentarios extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$E, create_fragment$E, safe_not_equal, {});
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "SelectorDeComentarios",
          options,
          id: create_fragment$E.name
        });
      }

    }

    /* src\components\Subir.svelte generated by Svelte v3.29.0 */
    const file$F = "src\\components\\Subir.svelte";

    function create_fragment$F(ctx) {
      let scrolling = false;

      let clear_scrolling = () => {
        scrolling = false;
      };

      let scrolling_timeout;
      let div;
      let icon;
      let mounted;
      let dispose;
      add_render_callback(
      /*onwindowscroll*/
      ctx[2]);
      const block = {
        c: function create() {
          div = element("div");
          icon = element("icon");
          attr_dev(icon, "class", "fe fe-arrow-up");
          add_location(icon, file$F, 16, 4, 379);
          attr_dev(div, "class", "subir svelte-1oocozg");
          toggle_class(div, "oculta",
          /*oculta*/
          ctx[0]);
          add_location(div, file$F, 15, 0, 325);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          append_dev(div, icon);

          if (!mounted) {
            dispose = [listen_dev(window, "scroll", () => {
              scrolling = true;
              clearTimeout(scrolling_timeout);
              scrolling_timeout = setTimeout(clear_scrolling, 100);
              /*onwindowscroll*/

              ctx[2]();
            }), listen_dev(div, "click", subir, false, false, false)];
            mounted = true;
          }
        },
        p: function update(ctx, [dirty]) {
          if (dirty &
          /*scrollY*/
          2 && !scrolling) {
            scrolling = true;
            clearTimeout(scrolling_timeout);
            scrollTo(window.pageXOffset,
            /*scrollY*/
            ctx[1]);
            scrolling_timeout = setTimeout(clear_scrolling, 100);
          }

          if (dirty &
          /*oculta*/
          1) {
            toggle_class(div, "oculta",
            /*oculta*/
            ctx[0]);
          }
        },
        i: noop,
        o: noop,
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
          mounted = false;
          run_all(dispose);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$F.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }

    function subir() {
      document.body.scrollTop = 0;
      document.documentElement.scrollTop = 0;
    }

    function instance$F($$self, $$props, $$invalidate) {
      let {
        $$slots: slots = {},
        $$scope
      } = $$props;
      validate_slots("Subir", slots, []);
      let oculta = true;
      let scrollY = 0;
      const writable_props = [];
      Object.keys($$props).forEach(key => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Subir> was created with unknown prop '${key}'`);
      });

      function onwindowscroll() {
        $$invalidate(1, scrollY = window.pageYOffset);
      }

      $$self.$capture_state = () => ({
        oculta,
        scrollY,
        subir
      });

      $$self.$inject_state = $$props => {
        if ("oculta" in $$props) $$invalidate(0, oculta = $$props.oculta);
        if ("scrollY" in $$props) $$invalidate(1, scrollY = $$props.scrollY);
      };

      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }

      $$self.$$.update = () => {
        if ($$self.$$.dirty &
        /*scrollY*/
        2) {
           if (scrollY > 1000) {
            $$invalidate(0, oculta = false);
          } else {
            $$invalidate(0, oculta = true);
          }
        }
      };

      return [oculta, scrollY, onwindowscroll];
    }

    class Subir extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$F, create_fragment$F, safe_not_equal, {});
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "Subir",
          options,
          id: create_fragment$F.name
        });
      }

    }

    /* src\components\NavCategorias.svelte generated by Svelte v3.29.0 */
    const file$G = "src\\components\\NavCategorias.svelte";

    function get_each_context$h(ctx, list, i) {
      const child_ctx = ctx.slice();
      child_ctx[18] = list[i];
      return child_ctx;
    }

    function get_each_context_1$7(ctx, list, i) {
      const child_ctx = ctx.slice();
      child_ctx[18] = list[i];
      return child_ctx;
    }

    const get_body_slot_changes$1 = dirty => ({});

    const get_body_slot_context$1 = ctx => ({});

    function get_each_context_2$3(ctx, list, i) {
      const child_ctx = ctx.slice();
      child_ctx[18] = list[i];
      return child_ctx;
    }

    function get_each_context_3$1(ctx, list, i) {
      const child_ctx = ctx.slice();
      child_ctx[18] = list[i];
      return child_ctx;
    } // (34:4) {#each config.categorias.filter(c => favoritas.includes(c.id)) as c (c.id)}


    function create_each_block_3$1(key_1, ctx) {
      let a;
      let t_value =
      /*c*/
      ctx[18].nombreCorto + "";
      let t;
      let a_href_value;
      let a_title_value;
      const block = {
        key: key_1,
        first: null,
        c: function create() {
          a = element("a");
          t = text(t_value);
          attr_dev(a, "class", "categoria favorita svelte-cj657z");
          attr_dev(a, "href", a_href_value = "/" +
          /*c*/
          ctx[18].nombreCorto);
          attr_dev(a, "title", a_title_value =
          /*c*/
          ctx[18].nombre);
          add_location(a, file$G, 34, 8, 1331);
          this.first = a;
        },
        m: function mount(target, anchor) {
          insert_dev(target, a, anchor);
          append_dev(a, t);
        },
        p: function update(ctx, dirty) {
          if (dirty &
          /*favoritas*/
          16 && t_value !== (t_value =
          /*c*/
          ctx[18].nombreCorto + "")) set_data_dev(t, t_value);

          if (dirty &
          /*favoritas*/
          16 && a_href_value !== (a_href_value = "/" +
          /*c*/
          ctx[18].nombreCorto)) {
            attr_dev(a, "href", a_href_value);
          }

          if (dirty &
          /*favoritas*/
          16 && a_title_value !== (a_title_value =
          /*c*/
          ctx[18].nombre)) {
            attr_dev(a, "title", a_title_value);
          }
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(a);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_each_block_3$1.name,
        type: "each",
        source: "(34:4) {#each config.categorias.filter(c => favoritas.includes(c.id)) as c (c.id)}",
        ctx
      });
      return block;
    } // (42:4) {#each config.categorias.filter(c => !favoritas.includes(c.id)) as c (c.id)}


    function create_each_block_2$3(key_1, ctx) {
      let a;
      let t_value =
      /*c*/
      ctx[18].nombreCorto + "";
      let t;
      let a_href_value;
      let a_title_value;
      const block = {
        key: key_1,
        first: null,
        c: function create() {
          a = element("a");
          t = text(t_value);
          attr_dev(a, "class", "categoria comunacha svelte-cj657z");
          attr_dev(a, "href", a_href_value = "/" +
          /*c*/
          ctx[18].nombreCorto);
          attr_dev(a, "title", a_title_value =
          /*c*/
          ctx[18].nombre);
          add_location(a, file$G, 42, 8, 1956);
          this.first = a;
        },
        m: function mount(target, anchor) {
          insert_dev(target, a, anchor);
          append_dev(a, t);
        },
        p: function update(ctx, dirty) {
          if (dirty &
          /*favoritas*/
          16 && t_value !== (t_value =
          /*c*/
          ctx[18].nombreCorto + "")) set_data_dev(t, t_value);

          if (dirty &
          /*favoritas*/
          16 && a_href_value !== (a_href_value = "/" +
          /*c*/
          ctx[18].nombreCorto)) {
            attr_dev(a, "href", a_href_value);
          }

          if (dirty &
          /*favoritas*/
          16 && a_title_value !== (a_title_value =
          /*c*/
          ctx[18].nombre)) {
            attr_dev(a, "title", a_title_value);
          }
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(a);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_each_block_2$3.name,
        type: "each",
        source: "(42:4) {#each config.categorias.filter(c => !favoritas.includes(c.id)) as c (c.id)}",
        ctx
      });
      return block;
    } // (48:0) {#if configurando}


    function create_if_block$w(ctx) {
      let dialog;
      let updating_visible;
      let current;

      function dialog_visible_binding(value) {
        /*dialog_visible_binding*/
        ctx[16].call(null, value);
      }

      let dialog_props = {
        width: "600",
        $$slots: {
          default: [create_default_slot$p],
          actions: [create_actions_slot$6],
          title: [create_title_slot$7]
        },
        $$scope: {
          ctx
        }
      };

      if (
      /*visible*/
      ctx[0] !== void 0) {
        dialog_props.visible =
        /*visible*/
        ctx[0];
      }

      dialog = new pn({
        props: dialog_props,
        $$inline: true
      });
      binding_callbacks.push(() => bind(dialog, "visible", dialog_visible_binding));
      const block = {
        c: function create() {
          create_component(dialog.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(dialog, target, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          const dialog_changes = {};

          if (dirty &
          /*$$scope, configurando, favoritas, $localConfig*/
          131094) {
            dialog_changes.$$scope = {
              dirty,
              ctx
            };
          }

          if (!updating_visible && dirty &
          /*visible*/
          1) {
            updating_visible = true;
            dialog_changes.visible =
            /*visible*/
            ctx[0];
            add_flush_callback(() => updating_visible = false);
          }

          dialog.$set(dialog_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(dialog.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(dialog.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(dialog, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block$w.name,
        type: "if",
        source: "(48:0) {#if configurando}",
        ctx
      });
      return block;
    } // (50:8) <div slot="title">


    function create_title_slot$7(ctx) {
      let div;
      const block = {
        c: function create() {
          div = element("div");
          div.textContent = "Categorias favoritas";
          attr_dev(div, "slot", "title");
          add_location(div, file$G, 49, 8, 2248);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_title_slot$7.name,
        type: "slot",
        source: "(50:8) <div slot=\\\"title\\\">",
        ctx
      });
      return block;
    } // (54:16) {#each config.categorias.filter(c => favoritas.includes(c.id)) as c (c.id)}


    function create_each_block_1$7(key_1, ctx) {
      let span;
      let t_value =
      /*c*/
      ctx[18].nombreCorto + "";
      let t;
      let span_href_value;
      let span_title_value;
      let mounted;
      let dispose;

      function click_handler_1(...args) {
        return (
          /*click_handler_1*/
          ctx[12](
          /*c*/
          ctx[18], ...args)
        );
      }

      const block = {
        key: key_1,
        first: null,
        c: function create() {
          span = element("span");
          t = text(t_value);
          attr_dev(span, "class", "categoria favorita svelte-cj657z");
          attr_dev(span, "href", span_href_value = "/" +
          /*c*/
          ctx[18].nombreCorto);
          attr_dev(span, "title", span_title_value =
          /*c*/
          ctx[18].nombre);
          add_location(span, file$G, 54, 16, 2579);
          this.first = span;
        },
        m: function mount(target, anchor) {
          insert_dev(target, span, anchor);
          append_dev(span, t);

          if (!mounted) {
            dispose = listen_dev(span, "click", click_handler_1, false, false, false);
            mounted = true;
          }
        },
        p: function update(new_ctx, dirty) {
          ctx = new_ctx;
          if (dirty &
          /*favoritas*/
          16 && t_value !== (t_value =
          /*c*/
          ctx[18].nombreCorto + "")) set_data_dev(t, t_value);

          if (dirty &
          /*favoritas*/
          16 && span_href_value !== (span_href_value = "/" +
          /*c*/
          ctx[18].nombreCorto)) {
            attr_dev(span, "href", span_href_value);
          }

          if (dirty &
          /*favoritas*/
          16 && span_title_value !== (span_title_value =
          /*c*/
          ctx[18].nombre)) {
            attr_dev(span, "title", span_title_value);
          }
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(span);
          mounted = false;
          dispose();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_each_block_1$7.name,
        type: "each",
        source: "(54:16) {#each config.categorias.filter(c => favoritas.includes(c.id)) as c (c.id)}",
        ctx
      });
      return block;
    } // (61:16) {#each config.categorias.filter(c => !favoritas.includes(c.id)) as c (c.id)}


    function create_each_block$h(key_1, ctx) {
      let span;
      let t_value =
      /*c*/
      ctx[18].nombreCorto + "";
      let t;
      let span_title_value;
      let mounted;
      let dispose;

      function click_handler_2(...args) {
        return (
          /*click_handler_2*/
          ctx[14](
          /*c*/
          ctx[18], ...args)
        );
      }

      const block = {
        key: key_1,
        first: null,
        c: function create() {
          span = element("span");
          t = text(t_value);
          attr_dev(span, "class", "categoria svelte-cj657z");
          attr_dev(span, "title", span_title_value =
          /*c*/
          ctx[18].nombre);
          add_location(span, file$G, 61, 20, 3145);
          this.first = span;
        },
        m: function mount(target, anchor) {
          insert_dev(target, span, anchor);
          append_dev(span, t);

          if (!mounted) {
            dispose = listen_dev(span, "click", click_handler_2, false, false, false);
            mounted = true;
          }
        },
        p: function update(new_ctx, dirty) {
          ctx = new_ctx;
          if (dirty &
          /*favoritas*/
          16 && t_value !== (t_value =
          /*c*/
          ctx[18].nombreCorto + "")) set_data_dev(t, t_value);

          if (dirty &
          /*favoritas*/
          16 && span_title_value !== (span_title_value =
          /*c*/
          ctx[18].nombre)) {
            attr_dev(span, "title", span_title_value);
          }
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(span);
          mounted = false;
          dispose();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_each_block$h.name,
        type: "each",
        source: "(61:16) {#each config.categorias.filter(c => !favoritas.includes(c.id)) as c (c.id)}",
        ctx
      });
      return block;
    } // (51:26)               


    function fallback_block$1(ctx) {
      let span0;
      let t0;
      let t1_value =
      /*favoritas*/
      ctx[4].length + "";
      let t1;
      let t2;
      let t3;
      let div0;
      let each_blocks_1 = [];
      let each0_lookup = new Map();
      let t4;
      let span1;
      let t5;
      let t6_value = config.categorias.length -
      /*favoritas*/
      ctx[4].length + "";
      let t6;
      let t7;
      let t8;
      let div1;
      let each_blocks = [];
      let each1_lookup = new Map();
      let each_value_1 = config.categorias.filter(
      /*func_2*/
      ctx[11]);
      validate_each_argument(each_value_1);

      const get_key = ctx =>
      /*c*/
      ctx[18].id;

      validate_each_keys(ctx, each_value_1, get_each_context_1$7, get_key);

      for (let i = 0; i < each_value_1.length; i += 1) {
        let child_ctx = get_each_context_1$7(ctx, each_value_1, i);
        let key = get_key(child_ctx);
        each0_lookup.set(key, each_blocks_1[i] = create_each_block_1$7(key, child_ctx));
      }

      let each_value = config.categorias.filter(
      /*func_3*/
      ctx[13]);
      validate_each_argument(each_value);

      const get_key_1 = ctx =>
      /*c*/
      ctx[18].id;

      validate_each_keys(ctx, each_value, get_each_context$h, get_key_1);

      for (let i = 0; i < each_value.length; i += 1) {
        let child_ctx = get_each_context$h(ctx, each_value, i);
        let key = get_key_1(child_ctx);
        each1_lookup.set(key, each_blocks[i] = create_each_block$h(key, child_ctx));
      }

      const block = {
        c: function create() {
          span0 = element("span");
          t0 = text("Favoritas (");
          t1 = text(t1_value);
          t2 = text("):");
          t3 = space();
          div0 = element("div");

          for (let i = 0; i < each_blocks_1.length; i += 1) {
            each_blocks_1[i].c();
          }

          t4 = space();
          span1 = element("span");
          t5 = text("Comunachas (");
          t6 = text(t6_value);
          t7 = text("):");
          t8 = space();
          div1 = element("div");

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].c();
          }

          set_style(span0, "color", "var(--color5)");
          add_location(span0, file$G, 51, 12, 2334);
          attr_dev(div0, "class", "favoritas container-categorias cpt svelte-cj657z");
          add_location(div0, file$G, 52, 12, 2420);
          set_style(span1, "color", "var(--color5)");
          add_location(span1, file$G, 58, 12, 2839);
          attr_dev(div1, "class", "no-favoritas container-categorias cpt svelte-cj657z");
          set_style(div1, "margin-top", "10px");
          add_location(div1, file$G, 59, 12, 2954);
        },
        m: function mount(target, anchor) {
          insert_dev(target, span0, anchor);
          append_dev(span0, t0);
          append_dev(span0, t1);
          append_dev(span0, t2);
          insert_dev(target, t3, anchor);
          insert_dev(target, div0, anchor);

          for (let i = 0; i < each_blocks_1.length; i += 1) {
            each_blocks_1[i].m(div0, null);
          }

          insert_dev(target, t4, anchor);
          insert_dev(target, span1, anchor);
          append_dev(span1, t5);
          append_dev(span1, t6);
          append_dev(span1, t7);
          insert_dev(target, t8, anchor);
          insert_dev(target, div1, anchor);

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].m(div1, null);
          }
        },
        p: function update(ctx, dirty) {
          if (dirty &
          /*favoritas*/
          16 && t1_value !== (t1_value =
          /*favoritas*/
          ctx[4].length + "")) set_data_dev(t1, t1_value);

          if (dirty &
          /*config, favoritas, $localConfig*/
          20) {
            const each_value_1 = config.categorias.filter(
            /*func_2*/
            ctx[11]);
            validate_each_argument(each_value_1);
            validate_each_keys(ctx, each_value_1, get_each_context_1$7, get_key);
            each_blocks_1 = update_keyed_each(each_blocks_1, dirty, get_key, 1, ctx, each_value_1, each0_lookup, div0, destroy_block, create_each_block_1$7, null, get_each_context_1$7);
          }

          if (dirty &
          /*favoritas*/
          16 && t6_value !== (t6_value = config.categorias.length -
          /*favoritas*/
          ctx[4].length + "")) set_data_dev(t6, t6_value);

          if (dirty &
          /*config, favoritas, $localConfig*/
          20) {
            const each_value = config.categorias.filter(
            /*func_3*/
            ctx[13]);
            validate_each_argument(each_value);
            validate_each_keys(ctx, each_value, get_each_context$h, get_key_1);
            each_blocks = update_keyed_each(each_blocks, dirty, get_key_1, 1, ctx, each_value, each1_lookup, div1, destroy_block, create_each_block$h, null, get_each_context$h);
          }
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(span0);
          if (detaching) detach_dev(t3);
          if (detaching) detach_dev(div0);

          for (let i = 0; i < each_blocks_1.length; i += 1) {
            each_blocks_1[i].d();
          }

          if (detaching) detach_dev(t4);
          if (detaching) detach_dev(span1);
          if (detaching) detach_dev(t8);
          if (detaching) detach_dev(div1);

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].d();
          }
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: fallback_block$1.name,
        type: "fallback",
        source: "(51:26)               ",
        ctx
      });
      return block;
    } // (68:12) <Button color="primary" on:click={() => configurando = false}>


    function create_default_slot_1$l(ctx) {
      let t;
      const block = {
        c: function create() {
          t = text("Ok");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_1$l.name,
        type: "slot",
        source: "(68:12) <Button color=\\\"primary\\\" on:click={() => configurando = false}>",
        ctx
      });
      return block;
    } // (67:8) <div slot="actions" class="actions center">


    function create_actions_slot$6(ctx) {
      let div;
      let button;
      let current;
      button = new ye({
        props: {
          color: "primary",
          $$slots: {
            default: [create_default_slot_1$l]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      button.$on("click",
      /*click_handler_3*/
      ctx[15]);
      const block = {
        c: function create() {
          div = element("div");
          create_component(button.$$.fragment);
          attr_dev(div, "slot", "actions");
          attr_dev(div, "class", "actions center");
          add_location(div, file$G, 66, 8, 3366);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          mount_component(button, div, null);
          current = true;
        },
        p: function update(ctx, dirty) {
          const button_changes = {};

          if (dirty &
          /*$$scope*/
          131072) {
            button_changes.$$scope = {
              dirty,
              ctx
            };
          }

          button.$set(button_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(button.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(button.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
          destroy_component(button);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_actions_slot$6.name,
        type: "slot",
        source: "(67:8) <div slot=\\\"actions\\\" class=\\\"actions center\\\">",
        ctx
      });
      return block;
    } // (49:4) <Dialog width="600" bind:visible={visible}>


    function create_default_slot$p(ctx) {
      let t0;
      let t1;
      let current;
      const body_slot_template =
      /*#slots*/
      ctx[7].body;
      const body_slot = create_slot(body_slot_template, ctx,
      /*$$scope*/
      ctx[17], get_body_slot_context$1);
      const body_slot_or_fallback = body_slot || fallback_block$1(ctx);
      const block = {
        c: function create() {
          t0 = space();
          if (body_slot_or_fallback) body_slot_or_fallback.c();
          t1 = space();
        },
        m: function mount(target, anchor) {
          insert_dev(target, t0, anchor);

          if (body_slot_or_fallback) {
            body_slot_or_fallback.m(target, anchor);
          }

          insert_dev(target, t1, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          if (body_slot) {
            if (body_slot.p && dirty &
            /*$$scope*/
            131072) {
              update_slot(body_slot, body_slot_template, ctx,
              /*$$scope*/
              ctx[17], dirty, get_body_slot_changes$1, get_body_slot_context$1);
            }
          } else {
            if (body_slot_or_fallback && body_slot_or_fallback.p && dirty &
            /*favoritas, $localConfig*/
            20) {
              body_slot_or_fallback.p(ctx, dirty);
            }
          }
        },
        i: function intro(local) {
          if (current) return;
          transition_in(body_slot_or_fallback, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(body_slot_or_fallback, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(t0);
          if (body_slot_or_fallback) body_slot_or_fallback.d(detaching);
          if (detaching) detach_dev(t1);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot$p.name,
        type: "slot",
        source: "(49:4) <Dialog width=\\\"600\\\" bind:visible={visible}>",
        ctx
      });
      return block;
    }

    function create_fragment$G(ctx) {
      let nav;
      let div1;
      let div0;
      let t0;
      let ripple;
      let t1;
      let a;
      let span0;
      let t2;
      let div2;
      let t3;
      let each_blocks_1 = [];
      let each0_lookup = new Map();
      let t4;
      let span1;
      let t6;
      let span2;
      let t8;
      let each_blocks = [];
      let each1_lookup = new Map();
      let t9;
      let span3;
      let t11;
      let if_block_anchor;
      let current;
      let mounted;
      let dispose;
      ripple = new he({
        props: {
          color: "var(--color5)"
        },
        $$inline: true
      });
      let each_value_3 = config.categorias.filter(
      /*func*/
      ctx[9]);
      validate_each_argument(each_value_3);

      const get_key = ctx =>
      /*c*/
      ctx[18].id;

      validate_each_keys(ctx, each_value_3, get_each_context_3$1, get_key);

      for (let i = 0; i < each_value_3.length; i += 1) {
        let child_ctx = get_each_context_3$1(ctx, each_value_3, i);
        let key = get_key(child_ctx);
        each0_lookup.set(key, each_blocks_1[i] = create_each_block_3$1(key, child_ctx));
      }

      let each_value_2 = config.categorias.filter(
      /*func_1*/
      ctx[10]);
      validate_each_argument(each_value_2);

      const get_key_1 = ctx =>
      /*c*/
      ctx[18].id;

      validate_each_keys(ctx, each_value_2, get_each_context_2$3, get_key_1);

      for (let i = 0; i < each_value_2.length; i += 1) {
        let child_ctx = get_each_context_2$3(ctx, each_value_2, i);
        let key = get_key_1(child_ctx);
        each1_lookup.set(key, each_blocks[i] = create_each_block_2$3(key, child_ctx));
      }

      let if_block =
      /*configurando*/
      ctx[1] && create_if_block$w(ctx);
      const block = {
        c: function create() {
          nav = element("nav");
          div1 = element("div");
          div0 = element("div");
          t0 = space();
          create_component(ripple.$$.fragment);
          t1 = space();
          a = element("a");
          span0 = element("span");
          t2 = space();
          div2 = element("div");
          t3 = space();

          for (let i = 0; i < each_blocks_1.length; i += 1) {
            each_blocks_1[i].c();
          }

          t4 = space();
          span1 = element("span");
          span1.textContent = ".";
          t6 = space();
          span2 = element("span");
          span2.textContent = ".";
          t8 = space();

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].c();
          }

          t9 = space();
          span3 = element("span");
          span3.textContent = ".";
          t11 = space();
          if (if_block) if_block.c();
          if_block_anchor = empty();
          attr_dev(div0, "class", "fe fe-circle");
          add_location(div0, file$G, 27, 8, 833);
          attr_dev(div1, "class", "colapsar-categorias categoria favorita svelte-cj657z");
          add_location(div1, file$G, 26, 4, 753);
          attr_dev(span0, "class", "fe fe-star");
          add_location(span0, file$G, 30, 133, 1053);
          attr_dev(a, "href", "/Favoritas");
          attr_dev(a, "title", "favoritas");
          attr_dev(a, "class", "colapsar-categorias favorita categoria svelte-cj657z");
          set_style(a, "display", "flex");
          set_style(a, "align-items", "center");
          add_location(a, file$G, 30, 4, 924);
          attr_dev(div2, "title", "Configurar favoritas");
          attr_dev(div2, "class", "colapsar-categorias fe fe-settings categoria favorita cpt svelte-cj657z");
          add_location(div2, file$G, 31, 4, 1095);
          attr_dev(span1, "class", "categoria sep favorita svelte-cj657z");
          set_style(span1, "border-radius", "0 20px 20px 0");
          set_style(span1, "color", "transparent");
          set_style(span1, "margin-right", "4px");
          add_location(span1, file$G, 36, 4, 1439);
          attr_dev(span2, "class", "categoria sep svelte-cj657z");
          set_style(span2, "border-radius", "20px 0 0 20px");
          set_style(span2, "color", "transparent");
          add_location(span2, file$G, 40, 4, 1773);
          attr_dev(span3, "class", "categoria sep svelte-cj657z");
          set_style(span3, "border-radius", "0 20px 20px 0");
          set_style(span3, "color", "transparent");
          add_location(span3, file$G, 44, 4, 2067);
          attr_dev(nav, "class", "nav-categorias svelte-cj657z");
          toggle_class(nav, "visible",
          /*visible*/
          ctx[0]);
          toggle_class(nav, "oculta",
          /*oculta*/
          ctx[3]);
          add_location(nav, file$G, 23, 0, 682);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, nav, anchor);
          append_dev(nav, div1);
          append_dev(div1, div0);
          append_dev(div1, t0);
          mount_component(ripple, div1, null);
          append_dev(nav, t1);
          append_dev(nav, a);
          append_dev(a, span0);
          append_dev(nav, t2);
          append_dev(nav, div2);
          append_dev(nav, t3);

          for (let i = 0; i < each_blocks_1.length; i += 1) {
            each_blocks_1[i].m(nav, null);
          }

          append_dev(nav, t4);
          append_dev(nav, span1);
          append_dev(nav, t6);
          append_dev(nav, span2);
          append_dev(nav, t8);

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].m(nav, null);
          }

          append_dev(nav, t9);
          append_dev(nav, span3);
          insert_dev(target, t11, anchor);
          if (if_block) if_block.m(target, anchor);
          insert_dev(target, if_block_anchor, anchor);
          current = true;

          if (!mounted) {
            dispose = [listen_dev(div1, "click",
            /*toggle*/
            ctx[6], false, false, false), listen_dev(div2, "click",
            /*click_handler*/
            ctx[8], false, false, false)];
            mounted = true;
          }
        },
        p: function update(ctx, [dirty]) {
          if (dirty &
          /*config, favoritas*/
          16) {
            const each_value_3 = config.categorias.filter(
            /*func*/
            ctx[9]);
            validate_each_argument(each_value_3);
            validate_each_keys(ctx, each_value_3, get_each_context_3$1, get_key);
            each_blocks_1 = update_keyed_each(each_blocks_1, dirty, get_key, 1, ctx, each_value_3, each0_lookup, nav, destroy_block, create_each_block_3$1, t4, get_each_context_3$1);
          }

          if (dirty &
          /*config, favoritas*/
          16) {
            const each_value_2 = config.categorias.filter(
            /*func_1*/
            ctx[10]);
            validate_each_argument(each_value_2);
            validate_each_keys(ctx, each_value_2, get_each_context_2$3, get_key_1);
            each_blocks = update_keyed_each(each_blocks, dirty, get_key_1, 1, ctx, each_value_2, each1_lookup, nav, destroy_block, create_each_block_2$3, t9, get_each_context_2$3);
          }

          if (dirty &
          /*visible*/
          1) {
            toggle_class(nav, "visible",
            /*visible*/
            ctx[0]);
          }

          if (dirty &
          /*oculta*/
          8) {
            toggle_class(nav, "oculta",
            /*oculta*/
            ctx[3]);
          }

          if (
          /*configurando*/
          ctx[1]) {
            if (if_block) {
              if_block.p(ctx, dirty);

              if (dirty &
              /*configurando*/
              2) {
                transition_in(if_block, 1);
              }
            } else {
              if_block = create_if_block$w(ctx);
              if_block.c();
              transition_in(if_block, 1);
              if_block.m(if_block_anchor.parentNode, if_block_anchor);
            }
          } else if (if_block) {
            group_outros();
            transition_out(if_block, 1, 1, () => {
              if_block = null;
            });
            check_outros();
          }
        },
        i: function intro(local) {
          if (current) return;
          transition_in(ripple.$$.fragment, local);
          transition_in(if_block);
          current = true;
        },
        o: function outro(local) {
          transition_out(ripple.$$.fragment, local);
          transition_out(if_block);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(nav);
          destroy_component(ripple);

          for (let i = 0; i < each_blocks_1.length; i += 1) {
            each_blocks_1[i].d();
          }

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].d();
          }

          if (detaching) detach_dev(t11);
          if (if_block) if_block.d(detaching);
          if (detaching) detach_dev(if_block_anchor);
          mounted = false;
          run_all(dispose);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$G.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }

    function instance$G($$self, $$props, $$invalidate) {
      let $localConfig;
      let {
        $$slots: slots = {},
        $$scope
      } = $$props;
      validate_slots("NavCategorias", slots, ['body']);
      let {
        visible = true
      } = $$props;
      let localConfig = localStore("NavCategorias", {
        oculta: true,
        favoritas: [1, 3, 6, 10]
      });
      validate_store(localConfig, "localConfig");
      component_subscribe($$self, localConfig, value => $$invalidate(2, $localConfig = value));
      if (!$localConfig.favoritas) set_store_value(localConfig, $localConfig.favoritas = [], $localConfig);

      function toggle() {
        set_store_value(localConfig, $localConfig.oculta = !$localConfig.oculta, $localConfig);
      }

      let configurando = false;
      const writable_props = ["visible"];
      Object.keys($$props).forEach(key => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<NavCategorias> was created with unknown prop '${key}'`);
      });

      const click_handler = () => $$invalidate(1, configurando = true);

      const func = c => favoritas.includes(c.id);

      const func_1 = c => !favoritas.includes(c.id);

      const func_2 = c => favoritas.includes(c.id);

      const click_handler_1 = c => set_store_value(localConfig, $localConfig.favoritas = $localConfig.favoritas.filter(c1 => c1 != c.id), $localConfig);

      const func_3 = c => !favoritas.includes(c.id);

      const click_handler_2 = c => set_store_value(localConfig, $localConfig.favoritas = [...$localConfig.favoritas, c.id], $localConfig);

      const click_handler_3 = () => $$invalidate(1, configurando = false);

      function dialog_visible_binding(value) {
        visible = value;
        $$invalidate(0, visible);
      }

      $$self.$$set = $$props => {
        if ("visible" in $$props) $$invalidate(0, visible = $$props.visible);
        if ("$$scope" in $$props) $$invalidate(17, $$scope = $$props.$$scope);
      };

      $$self.$capture_state = () => ({
        config,
        Ripple: he,
        Dialog: pn,
        Button: ye,
        localStore,
        Cookie: js_cookie,
        visible,
        localConfig,
        toggle,
        configurando,
        $localConfig,
        oculta,
        favoritas
      });

      $$self.$inject_state = $$props => {
        if ("visible" in $$props) $$invalidate(0, visible = $$props.visible);
        if ("localConfig" in $$props) $$invalidate(5, localConfig = $$props.localConfig);
        if ("configurando" in $$props) $$invalidate(1, configurando = $$props.configurando);
        if ("oculta" in $$props) $$invalidate(3, oculta = $$props.oculta);
        if ("favoritas" in $$props) $$invalidate(4, favoritas = $$props.favoritas);
      };

      let oculta;
      let favoritas;

      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }

      $$self.$$.update = () => {
        if ($$self.$$.dirty &
        /*$localConfig*/
        4) {
           $$invalidate(3, oculta = $localConfig.oculta);
        }

        if ($$self.$$.dirty &
        /*$localConfig*/
        4) {
           $$invalidate(4, favoritas = $localConfig.favoritas);
        }

        if ($$self.$$.dirty &
        /*favoritas*/
        16) {
           favoritas && js_cookie.set("categoriasFavoritas", favoritas, {
            expires: 696969
          });
        }
      };

      return [visible, configurando, $localConfig, oculta, favoritas, localConfig, toggle, slots, click_handler, func, func_1, func_2, click_handler_1, func_3, click_handler_2, click_handler_3, dialog_visible_binding, $$scope];
    }

    class NavCategorias extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$G, create_fragment$G, safe_not_equal, {
          visible: 0
        });
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "NavCategorias",
          options,
          id: create_fragment$G.name
        });
      }

      get visible() {
        throw new Error("<NavCategorias>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set visible(value) {
        throw new Error("<NavCategorias>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

    }

    /* src\components\Especiales\NadieLoSabra.svelte generated by Svelte v3.29.0 */
    const {
      console: console_1$a
    } = globals;

    function create_fragment$H(ctx) {
      const block = {
        c: noop,
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: noop,
        p: noop,
        i: noop,
        o: noop,
        d: noop
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$H.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }

    function wait$1(milisegundos = 1000) {
      return new Promise(resolve => {
        setTimeout(resolve, milisegundos);
      });
    }

    function instance$H($$self, $$props, $$invalidate) {
      let $configStore;
      validate_store(configStore, "configStore");
      component_subscribe($$self, configStore, $$value => $$invalidate(2, $configStore = $$value));
      let {
        $$slots: slots = {},
        $$scope
      } = $$props;
      validate_slots("NadieLoSabra", slots, []);
      let activo = false;
      let audio = new Audio("/audio/re4regenerador.mp3");
      audio.loop = true;
      setInterval(() => {}, 1000);
      onMount(async () => {
        $$invalidate(3, tembleque = Math.random() > 0.5 && activo);

        while (true) {
          if (activo) {
            await wait$1(Math.random() * 10 * 1000);
            $$invalidate(3, tembleque = true);
            await wait$1(Math.random() * 10 * 1000);
            $$invalidate(3, tembleque = false);
          } else {
            await wait$1(Math.random() * 10 * 1000);
            $$invalidate(3, tembleque = false);
          }
        }
      });
      const writable_props = [];
      Object.keys($$props).forEach(key => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$a.warn(`<NadieLoSabra> was created with unknown prop '${key}'`);
      });

      $$self.$capture_state = () => ({
        onMount,
        configStore,
        activo,
        audio,
        wait: wait$1,
        $configStore,
        tembleque
      });

      $$self.$inject_state = $$props => {
        if ("activo" in $$props) $$invalidate(0, activo = $$props.activo);
        if ("audio" in $$props) $$invalidate(1, audio = $$props.audio);
        if ("tembleque" in $$props) $$invalidate(3, tembleque = $$props.tembleque);
      };

      let tembleque;

      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }

      $$self.$$.update = () => {
        if ($$self.$$.dirty &
        /*$configStore*/
        4) {
           $$invalidate(0, activo = $configStore.general.flags.includes("[3:33]"));
        }

        if ($$self.$$.dirty &
        /*activo*/
        1) {
           $$invalidate(3, tembleque = Math.random() > 0.5 && activo);
        }

        if ($$self.$$.dirty &
        /*tembleque*/
        8) {
           tembleque ? $$invalidate(1, audio.volume = 1, audio) : $$invalidate(1, audio.volume = 0, audio);
        }

        if ($$self.$$.dirty &
        /*activo, audio*/
        3) {
           if (activo) {
            try {
              audio.play();
            } catch (error) {
              console.log(error);
            }
          }
        }

        if ($$self.$$.dirty &
        /*tembleque*/
        8) {
           if (tembleque) document.body.classList.add("nls");else document.body.classList.remove("nls");
        }
      };

      return [];
    }

    class NadieLoSabra extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$H, create_fragment$H, safe_not_equal, {});
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "NadieLoSabra",
          options,
          id: create_fragment$H.name
        });
      }

    }

    /* src\components\Especiales\AlertaPortenho.svelte generated by Svelte v3.29.0 */
    const {
      console: console_1$b
    } = globals;

    function create_fragment$I(ctx) {
      const block = {
        c: noop,
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: noop,
        p: noop,
        i: noop,
        o: noop,
        d: noop
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$I.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }

    function instance$I($$self, $$props, $$invalidate) {
      let $configStore;
      validate_store(configStore, "configStore");
      component_subscribe($$self, configStore, $$value => $$invalidate(4, $configStore = $$value));
      let {
        $$slots: slots = {},
        $$scope
      } = $$props;
      validate_slots("AlertaPortenho", slots, []);
      let activado = false;
      let sonido = new Audio("/audio/portenho.mp3");
      sonido.loop = true;
      var hidden, visibilityChange;

      if (typeof document.hidden !== "undefined") {
        hidden = "hidden";
        visibilityChange = "visibilitychange";
      } else if (typeof document.mozHidden !== "undefined") {
        hidden = "mozHidden";
        visibilityChange = "mozvisibilitychange";
      } else if (typeof document.msHidden !== "undefined") {
        hidden = "msHidden";
        visibilityChange = "msvisibilitychange";
      } else if (typeof document.webkitHidden !== "undefined") {
        hidden = "webkitHidden";
        visibilityChange = "webkitvisibilitychange";
      }

      document.addEventListener(visibilityChange, handleVisibilityChange, false);

      function handleVisibilityChange() {
        $$invalidate(1, sonido.volume = activado && !document[hidden] ? $$invalidate(1, sonido.volume = 1, sonido) : $$invalidate(1, sonido.volume = 0, sonido), sonido);
      }

      const writable_props = [];
      Object.keys($$props).forEach(key => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$b.warn(`<AlertaPortenho> was created with unknown prop '${key}'`);
      });

      $$self.$capture_state = () => ({
        configStore,
        onDestroy,
        activado,
        sonido,
        hidden,
        visibilityChange,
        handleVisibilityChange,
        $configStore
      });

      $$self.$inject_state = $$props => {
        if ("activado" in $$props) $$invalidate(0, activado = $$props.activado);
        if ("sonido" in $$props) $$invalidate(1, sonido = $$props.sonido);
        if ("hidden" in $$props) $$invalidate(2, hidden = $$props.hidden);
        if ("visibilityChange" in $$props) visibilityChange = $$props.visibilityChange;
      };

      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }

      $$self.$$.update = () => {
        if ($$self.$$.dirty &
        /*$configStore*/
        16) {
           $$invalidate(0, activado = $configStore.general.flags.includes("portenho"));
        }

        if ($$self.$$.dirty &
        /*activado, hidden*/
        5) {
           activado && !document[hidden] ? $$invalidate(1, sonido.volume = 1, sonido) : $$invalidate(1, sonido.volume = 0, sonido);
        }

        if ($$self.$$.dirty &
        /*activado, sonido*/
        3) {
           if (activado) {
            try {
              sonido.play();
              onDestroy(() => sonido.stop());
            } catch (error) {
              console.log(error);
            }

            document.getElementById("portenho").innerHTML = `body{--color1:#ff91af!important;--color2:#e75480!important;--color3:#e75480!important;--color4:#c20073!important;--color5:pink!important;--color7:#d74894!important;--color8:#893843!important;--color9:#e4717a!important;}#fondo-global,.media-input,.menu-principal-header{filter:sepia(100%) hue-rotate(264deg) saturate(341%)}.hilo>.hilo-in::after,.media::after{content:"";background:url(/imagenes/portenho.gif);background-size:contain;top:0;left:0;width:100%;height:100%;position:absolute}.hilo-in::after{opacity:0}.hilo-in{border:1px solid var(--color5)}.hilo-in,.media,.nav-categorias,.panel,li>.comentario{animation-name:shake;animation-duration:.82s;animation-iteration-count:infinite}.hilo:nth-child(4n+1)>.hilo-in,li:nth-child(2n)>.comentario{animation-delay:.2s}.hilo:nth-child(4n+2)>.hilo-in{animation-delay:.6s}.hilo:nth-child(4n+3)>.hilo-in{animation-delay:.4s}.panel{animation-delay:.4s}.nav-categorias{animation-delay:.5s}.hilo>.hilo-in::after{animation-duration:7.5s;animation-name:porteno1;animation-iteration-count:infinite}.hilo:nth-child(4n+1)>.hilo-in::after{animation-delay:1.875s}.hilo:nth-child(4n+2)>.hilo-in::after{animation-delay:3.75s}.hilo:nth-child(4n+3)>.hilo-in::after{animation-delay:5.625s}.hilo>.hilo-in:hover::after,.media:hover::after{opacity:0!important;z-index:-10}@keyframes porteno1{0%,10%,100%,90%{opacity:0}40%,60%{opacity:1}}@keyframes shake{10%,90%{transform:translate3d(-1px,0,0)}20%,80%{transform:translate3d(2px,0,0)}30%,50%,70%{transform:translate3d(-4px,0,0)}40%,60%{transform:translate3d(4px,0,0)}}`;
          } else {
            document.getElementById("portenho").innerHTML = ``;
          }
        }
      };

      return [];
    }

    class AlertaPortenho extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$I, create_fragment$I, safe_not_equal, {});
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "AlertaPortenho",
          options,
          id: create_fragment$I.name
        });
      }

    }

    /* src\components\Especiales\Halloween.svelte generated by Svelte v3.29.0 */

    function create_fragment$J(ctx) {
      const block = {
        c: noop,
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: noop,
        p: noop,
        i: noop,
        o: noop,
        d: noop
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$J.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }

    function instance$J($$self, $$props, $$invalidate) {
      let $configStore;
      validate_store(configStore, "configStore");
      component_subscribe($$self, configStore, $$value => $$invalidate(1, $configStore = $$value));
      let {
        $$slots: slots = {},
        $$scope
      } = $$props;
      validate_slots("Halloween", slots, []);
      let activated = false;
      const writable_props = [];
      Object.keys($$props).forEach(key => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Halloween> was created with unknown prop '${key}'`);
      });

      $$self.$capture_state = () => ({
        configStore,
        activated,
        $configStore
      });

      $$self.$inject_state = $$props => {
        if ("activated" in $$props) $$invalidate(0, activated = $$props.activated);
      };

      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }

      $$self.$$.update = () => {
        if ($$self.$$.dirty &
        /*$configStore*/
        2) {
           $$invalidate(0, activated = $configStore.general.flags.includes("halloween"));
        }

        if ($$self.$$.dirty &
        /*activated*/
        1) {
           if (activated) {
            document.getElementById("halloween").innerHTML = `body{--color1:#4E2508;--color2:rgb(20 20 20);--color3:rgb(30 30 30);--color4:rgb(40 40 40);--color5:#FF730F;--color6:#fc9208;--color7:#603300}.hilo>.hilo-in::after{content:"";background:url(/imagenes/bats.png);background-size:cover;top:0;left:0;width:100%;height:100%;position:absolute}#fondo-global,.media-input,.menu-principal-header{filter:grayscale(100%)}.color-ario::after,.color-azul::after,.color-blanco::after,.color-marron::after,.color-multi::after,.color-navideño::after,.color-negro::after,.color-rojo::after,.color-rosa::after,.color-serio::after,.color-verde::after,.color::after{content:"";background:url(/imagenes/mask3.png);position:absolute;top:10px;left:10px;height:50px;width:50px;background-size:100%;background-repeat:no-repeat;border-radius:3px}.color-amarillo::after{content:"";background:url(/imagenes/mask2.png);position:absolute;top:10px;left:10px;height:50px;width:50px;background-size:100%;background-repeat:no-repeat;border-radius:3px}.color{color:transparent!important}.hilo h3{z-index:1}.infos{z-index:1}.dado{color:#fff!important}`;
          } else {
            document.getElementById("halloween").innerHTML = ``;
          }
        }
      };

      return [];
    }

    class Halloween extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$J, create_fragment$J, safe_not_equal, {});
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "Halloween",
          options,
          id: create_fragment$J.name
        });
      }

    }

    /* src\components\Estadisticas.svelte generated by Svelte v3.29.0 */
    const file$H = "src\\components\\Estadisticas.svelte"; // (26:0) {#if $estadisticasStore.visible}

    function create_if_block$x(ctx) {
      let div1;
      let div0;
      let span0;
      let t0_value = formatear(
      /*computadorasConectadas*/
      ctx[0]) + "";
      let t0;
      let t1;
      let span1;
      let t2_value = formatear(
      /*rozCreados*/
      ctx[1]) + "";
      let t2;
      let t3;
      let span2;
      let t4_value = formatear(
      /*comentariosCreados*/
      ctx[2]) + "";
      let t4;
      let t5;
      let span3;
      let t6_value =
      /*estabilidad*/
      ctx[3].toFixed(1) + "";
      let t6;
      let t7;
      let div1_transition;
      let current;
      let mounted;
      let dispose;
      const block = {
        c: function create() {
          div1 = element("div");
          div0 = element("div");
          span0 = element("span");
          t0 = text(t0_value);
          t1 = space();
          span1 = element("span");
          t2 = text(t2_value);
          t3 = space();
          span2 = element("span");
          t4 = text(t4_value);
          t5 = space();
          span3 = element("span");
          t6 = text(t6_value);
          t7 = text("%");
          set_style(span0, "right", "68%");
          attr_dev(span0, "title", "Computadoras conectadas");
          attr_dev(span0, "class", "svelte-2gdyz2");
          add_location(span0, file$H, 35, 12, 1452);
          set_style(span1, "right", "50%");
          attr_dev(span1, "title", "Roz creados");
          attr_dev(span1, "class", "svelte-2gdyz2");
          add_location(span1, file$H, 38, 12, 1598);
          set_style(span2, "right", "32%");
          attr_dev(span2, "title", "Comentarios creados");
          attr_dev(span2, "class", "svelte-2gdyz2");
          add_location(span2, file$H, 41, 12, 1720);
          set_style(span3, "right", "16%");
          attr_dev(span3, "title", "Estabilidad");
          attr_dev(span3, "class", "svelte-2gdyz2");
          add_location(span3, file$H, 44, 12, 1858);
          attr_dev(div0, "class", "estadisticas  svelte-2gdyz2");
          add_location(div0, file$H, 31, 8, 1321);
          attr_dev(div1, "class", "container");
          set_style(div1, "position", "absolute");
          set_style(div1, "width", "100vw");
          set_style(div1, "z-index", "1");
          set_style(div1, "height", "100%");
          set_style(div1, "pointer-events", "none", 1);
          add_location(div1, file$H, 26, 4, 1103);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div1, anchor);
          append_dev(div1, div0);
          append_dev(div0, span0);
          append_dev(span0, t0);
          append_dev(div0, t1);
          append_dev(div0, span1);
          append_dev(span1, t2);
          append_dev(div0, t3);
          append_dev(div0, span2);
          append_dev(span2, t4);
          append_dev(div0, t5);
          append_dev(div0, span3);
          append_dev(span3, t6);
          append_dev(span3, t7);
          current = true;

          if (!mounted) {
            dispose = listen_dev(div0, "click",
            /*click_handler*/
            ctx[6], false, false, false);
            mounted = true;
          }
        },
        p: function update(ctx, dirty) {
          if ((!current || dirty &
          /*computadorasConectadas*/
          1) && t0_value !== (t0_value = formatear(
          /*computadorasConectadas*/
          ctx[0]) + "")) set_data_dev(t0, t0_value);
          if ((!current || dirty &
          /*rozCreados*/
          2) && t2_value !== (t2_value = formatear(
          /*rozCreados*/
          ctx[1]) + "")) set_data_dev(t2, t2_value);
          if ((!current || dirty &
          /*comentariosCreados*/
          4) && t4_value !== (t4_value = formatear(
          /*comentariosCreados*/
          ctx[2]) + "")) set_data_dev(t4, t4_value);
          if ((!current || dirty &
          /*estabilidad*/
          8) && t6_value !== (t6_value =
          /*estabilidad*/
          ctx[3].toFixed(1) + "")) set_data_dev(t6, t6_value);
        },
        i: function intro(local) {
          if (current) return;
          add_render_callback(() => {
            if (!div1_transition) div1_transition = create_bidirectional_transition(div1, fly, {
              opacity: 1,
              y: -48,
              duration: 300
            }, true);
            div1_transition.run(1);
          });
          current = true;
        },
        o: function outro(local) {
          if (!div1_transition) div1_transition = create_bidirectional_transition(div1, fly, {
            opacity: 1,
            y: -48,
            duration: 300
          }, false);
          div1_transition.run(0);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div1);
          if (detaching && div1_transition) div1_transition.end();
          mounted = false;
          dispose();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block$x.name,
        type: "if",
        source: "(26:0) {#if $estadisticasStore.visible}",
        ctx
      });
      return block;
    }

    function create_fragment$K(ctx) {
      let t0;
      let div;
      let span;
      let t1;
      let ripple;
      let current;
      let mounted;
      let dispose;
      let if_block =
      /*$estadisticasStore*/
      ctx[4].visible && create_if_block$x(ctx);
      ripple = new he({
        $$inline: true
      });
      const block = {
        c: function create() {
          if (if_block) if_block.c();
          t0 = space();
          div = element("div");
          span = element("span");
          t1 = space();
          create_component(ripple.$$.fragment);
          attr_dev(span, "class", "fe fe-bar-chart-2");
          add_location(span, file$H, 55, 4, 2113);
          attr_dev(div, "class", "desplegar-estadisticas svelte-2gdyz2");
          add_location(div, file$H, 51, 0, 2006);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          if (if_block) if_block.m(target, anchor);
          insert_dev(target, t0, anchor);
          insert_dev(target, div, anchor);
          append_dev(div, span);
          append_dev(div, t1);
          mount_component(ripple, div, null);
          current = true;

          if (!mounted) {
            dispose = listen_dev(div, "click",
            /*click_handler_1*/
            ctx[7], false, false, false);
            mounted = true;
          }
        },
        p: function update(ctx, [dirty]) {
          if (
          /*$estadisticasStore*/
          ctx[4].visible) {
            if (if_block) {
              if_block.p(ctx, dirty);

              if (dirty &
              /*$estadisticasStore*/
              16) {
                transition_in(if_block, 1);
              }
            } else {
              if_block = create_if_block$x(ctx);
              if_block.c();
              transition_in(if_block, 1);
              if_block.m(t0.parentNode, t0);
            }
          } else if (if_block) {
            group_outros();
            transition_out(if_block, 1, 1, () => {
              if_block = null;
            });
            check_outros();
          }
        },
        i: function intro(local) {
          if (current) return;
          transition_in(if_block);
          transition_in(ripple.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(if_block);
          transition_out(ripple.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (if_block) if_block.d(detaching);
          if (detaching) detach_dev(t0);
          if (detaching) detach_dev(div);
          destroy_component(ripple);
          mounted = false;
          dispose();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$K.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }

    function formatear(numero) {
      if (numero >= 1000000) return `${(numero / 1000000).toFixed(2)}M`;
      if (numero >= 1000) return `${(numero / 1000).toFixed(2)}K`;
      return numero;
    }

    function instance$K($$self, $$props, $$invalidate) {
      let $estadisticasStore;
      let {
        $$slots: slots = {},
        $$scope
      } = $$props;
      validate_slots("Estadisticas", slots, []);
      let computadorasConectadas = window.estadisticas.computadorasConectadas;
      let rozCreados = window.estadisticas.hilosCreados;
      let comentariosCreados = window.estadisticas.comentariosCreados;
      let estabilidad = window.estadisticas.estabilidad;
      let estadisticasStore = localStore("Estadisticas", {
        visible: false
      });
      validate_store(estadisticasStore, "estadisticasStore");
      component_subscribe($$self, estadisticasStore, value => $$invalidate(4, $estadisticasStore = value));
      Signal.coneccion.on("estadisticasActualizadas", estadisticas => {
        $$invalidate(0, computadorasConectadas = estadisticas.computadorasConectadas);
        $$invalidate(1, rozCreados = estadisticas.hilosCreados);
        $$invalidate(2, comentariosCreados = estadisticas.comentariosCreados);
        $$invalidate(3, estabilidad = estadisticas.estabilidad);
      });
      const writable_props = [];
      Object.keys($$props).forEach(key => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Estadisticas> was created with unknown prop '${key}'`);
      });

      const click_handler = () => set_store_value(estadisticasStore, $estadisticasStore.visible = false, $estadisticasStore);

      const click_handler_1 = () => set_store_value(estadisticasStore, $estadisticasStore.visible = true, $estadisticasStore);

      $$self.$capture_state = () => ({
        Ripple: he,
        fly,
        Signal,
        localStore,
        computadorasConectadas,
        rozCreados,
        comentariosCreados,
        estabilidad,
        estadisticasStore,
        formatear,
        $estadisticasStore
      });

      $$self.$inject_state = $$props => {
        if ("computadorasConectadas" in $$props) $$invalidate(0, computadorasConectadas = $$props.computadorasConectadas);
        if ("rozCreados" in $$props) $$invalidate(1, rozCreados = $$props.rozCreados);
        if ("comentariosCreados" in $$props) $$invalidate(2, comentariosCreados = $$props.comentariosCreados);
        if ("estabilidad" in $$props) $$invalidate(3, estabilidad = $$props.estabilidad);
        if ("estadisticasStore" in $$props) $$invalidate(5, estadisticasStore = $$props.estadisticasStore);
      };

      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }

      return [computadorasConectadas, rozCreados, comentariosCreados, estabilidad, $estadisticasStore, estadisticasStore, click_handler, click_handler_1];
    }

    class Estadisticas extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$K, create_fragment$K, safe_not_equal, {});
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "Estadisticas",
          options,
          id: create_fragment$K.name
        });
      }

    }

    /* src\components\Navbar.svelte generated by Svelte v3.29.0 */
    const {
      window: window_1$1
    } = globals;
    const file$I = "src\\components\\Navbar.svelte"; // (134:40) 

    function create_if_block_6$5(ctx) {
      const block = {
        c: noop,
        m: noop,
        d: noop
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_6$5.name,
        type: "if",
        source: "(134:40) ",
        ctx
      });
      return block;
    } // (132:12) {#if protocoloMessi}


    function create_if_block_5$7(ctx) {
      let div;
      const block = {
        c: function create() {
          div = element("div");
          attr_dev(div, "class", "messi svelte-zbcya8");
          add_location(div, file$I, 132, 16, 5016);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_5$7.name,
        type: "if",
        source: "(132:12) {#if protocoloMessi}",
        ctx
      });
      return block;
    } // (139:16) {#if $globalStore.usuario.esMod || $globalStore.usuario.esAuxiliar}


    function create_if_block_4$8(ctx) {
      let a;
      let button;
      let current;
      button = new ye({
        props: {
          icon: true,
          dense: true,
          $$slots: {
            default: [create_default_slot_2$j]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          a = element("a");
          create_component(button.$$.fragment);
          attr_dev(a, "href", "/Moderacion");
          attr_dev(a, "class", "svelte-zbcya8");
          add_location(a, file$I, 139, 20, 5329);
        },
        m: function mount(target, anchor) {
          insert_dev(target, a, anchor);
          mount_component(button, a, null);
          current = true;
        },
        i: function intro(local) {
          if (current) return;
          transition_in(button.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(button.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(a);
          destroy_component(button);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_4$8.name,
        type: "if",
        source: "(139:16) {#if $globalStore.usuario.esMod || $globalStore.usuario.esAuxiliar}",
        ctx
      });
      return block;
    } // (146:24) <Button icon dense>


    function create_default_slot_2$j(ctx) {
      let span;
      const block = {
        c: function create() {
          span = element("span");
          span.textContent = "✡";
          set_style(span, "top", "-1px");
          set_style(span, "font-size", "24px");
          set_style(span, "padding", "0 4px");
          attr_dev(span, "class", "svelte-zbcya8");
          add_location(span, file$I, 146, 28, 5703);
        },
        m: function mount(target, anchor) {
          insert_dev(target, span, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(span);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_2$j.name,
        type: "slot",
        source: "(146:24) <Button icon dense>",
        ctx
      });
      return block;
    } // (155:16) {#if $globalStore.usuario.esMod || $globalStore.usuario.esAuxiliar}


    function create_if_block_3$f(ctx) {
      let denunciasnav;
      let current;
      denunciasnav = new DenunciasNav({
        $$inline: true
      });
      const block = {
        c: function create() {
          create_component(denunciasnav.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(denunciasnav, target, anchor);
          current = true;
        },
        i: function intro(local) {
          if (current) return;
          transition_in(denunciasnav.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(denunciasnav.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(denunciasnav, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_3$f.name,
        type: "if",
        source: "(155:16) {#if $globalStore.usuario.esMod || $globalStore.usuario.esAuxiliar}",
        ctx
      });
      return block;
    } // (161:20) <Button icon dense>


    function create_default_slot_1$m(ctx) {
      let span;
      const block = {
        c: function create() {
          span = element("span");
          attr_dev(span, "class", "fe fe-search svelte-zbcya8");
          add_location(span, file$I, 161, 24, 6303);
        },
        m: function mount(target, anchor) {
          insert_dev(target, span, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(span);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_1$m.name,
        type: "slot",
        source: "(161:20) <Button icon dense>",
        ctx
      });
      return block;
    } // (167:16) {:else}


    function create_else_block$a(ctx) {
      let a;
      let button;
      let current;
      button = new ye({
        props: {
          icon: true,
          dense: true,
          $$slots: {
            default: [create_default_slot$q]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          a = element("a");
          create_component(button.$$.fragment);
          attr_dev(a, "href", "/Login");
          attr_dev(a, "class", "nav-boton svelte-zbcya8");
          set_style(a, "height", "100%");
          add_location(a, file$I, 167, 20, 6552);
        },
        m: function mount(target, anchor) {
          insert_dev(target, a, anchor);
          mount_component(button, a, null);
          current = true;
        },
        p: function update(ctx, dirty) {
          const button_changes = {};

          if (dirty &
          /*$$scope*/
          33554432) {
            button_changes.$$scope = {
              dirty,
              ctx
            };
          }

          button.$set(button_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(button.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(button.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(a);
          destroy_component(button);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_else_block$a.name,
        type: "else",
        source: "(167:16) {:else}",
        ctx
      });
      return block;
    } // (165:16) {#if $globalStore.usuario.estaAutenticado}


    function create_if_block_2$m(ctx) {
      let notificaciones_1;
      let updating_notificaciones;
      let current;

      function notificaciones_1_notificaciones_binding(value) {
        /*notificaciones_1_notificaciones_binding*/
        ctx[14].call(null, value);
      }

      let notificaciones_1_props = {};

      if (
      /*notificaciones*/
      ctx[0] !== void 0) {
        notificaciones_1_props.notificaciones =
        /*notificaciones*/
        ctx[0];
      }

      notificaciones_1 = new Notificaciones({
        props: notificaciones_1_props,
        $$inline: true
      });
      binding_callbacks.push(() => bind(notificaciones_1, "notificaciones", notificaciones_1_notificaciones_binding));
      const block = {
        c: function create() {
          create_component(notificaciones_1.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(notificaciones_1, target, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          const notificaciones_1_changes = {};

          if (!updating_notificaciones && dirty &
          /*notificaciones*/
          1) {
            updating_notificaciones = true;
            notificaciones_1_changes.notificaciones =
            /*notificaciones*/
            ctx[0];
            add_flush_callback(() => updating_notificaciones = false);
          }

          notificaciones_1.$set(notificaciones_1_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(notificaciones_1.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(notificaciones_1.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(notificaciones_1, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_2$m.name,
        type: "if",
        source: "(165:16) {#if $globalStore.usuario.estaAutenticado}",
        ctx
      });
      return block;
    } // (170:24) <Button icon dense>


    function create_default_slot$q(ctx) {
      let span;
      const block = {
        c: function create() {
          span = element("span");
          attr_dev(span, "class", "fe fe-user svelte-zbcya8");
          add_location(span, file$I, 170, 28, 6726);
        },
        m: function mount(target, anchor) {
          insert_dev(target, span, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(span);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot$q.name,
        type: "slot",
        source: "(170:24) <Button icon dense>",
        ctx
      });
      return block;
    } // (176:12) {#if !protocoloMessi || $globalStore.usuario.esMod}


    function create_if_block_1$n(ctx) {
      let span2;
      let span0;
      let t1;
      let span1;
      let t2;
      let ripple;
      let current;
      let mounted;
      let dispose;
      ripple = new he({
        $$inline: true
      });
      const block = {
        c: function create() {
          span2 = element("span");
          span0 = element("span");
          span0.textContent = "ROZ";
          t1 = space();
          span1 = element("span");
          t2 = space();
          create_component(ripple.$$.fragment);
          set_style(span0, "width", "max-content");
          set_style(span0, "margin-right", "6px");
          set_style(span0, "cursor", "pointer");
          attr_dev(span0, "class", "svelte-zbcya8");
          add_location(span0, file$I, 180, 20, 7111);
          attr_dev(span1, "class", "fe fe-plus-square svelte-zbcya8");
          add_location(span1, file$I, 184, 20, 7284);
          attr_dev(span2, "class", "nav-boton crear-hilo-boton svelte-zbcya8");
          add_location(span2, file$I, 176, 16, 6940);
        },
        m: function mount(target, anchor) {
          insert_dev(target, span2, anchor);
          append_dev(span2, span0);
          append_dev(span2, t1);
          append_dev(span2, span1);
          append_dev(span2, t2);
          mount_component(ripple, span2, null);
          current = true;

          if (!mounted) {
            dispose = listen_dev(span2, "click",
            /*click_handler_1*/
            ctx[15], false, false, false);
            mounted = true;
          }
        },
        p: noop,
        i: function intro(local) {
          if (current) return;
          transition_in(ripple.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(ripple.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(span2);
          destroy_component(ripple);
          mounted = false;
          dispose();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_1$n.name,
        type: "if",
        source: "(176:12) {#if !protocoloMessi || $globalStore.usuario.esMod}",
        ctx
      });
      return block;
    } // (202:0) {#if $globalStore.usuario.estaAutenticado && $globalStore.usuario.esMod}


    function create_if_block$y(ctx) {
      let selectordecomentarios;
      let current;
      selectordecomentarios = new SelectorDeComentarios({
        $$inline: true
      });
      const block = {
        c: function create() {
          create_component(selectordecomentarios.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(selectordecomentarios, target, anchor);
          current = true;
        },
        i: function intro(local) {
          if (current) return;
          transition_in(selectordecomentarios.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(selectordecomentarios.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(selectordecomentarios, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block$y.name,
        type: "if",
        source: "(202:0) {#if $globalStore.usuario.estaAutenticado && $globalStore.usuario.esMod}",
        ctx
      });
      return block;
    }

    function create_fragment$L(ctx) {
      let scrolling = false;

      let clear_scrolling = () => {
        scrolling = false;
      };

      let scrolling_timeout;
      let nadielosabra;
      let t0;
      let alertaportenho;
      let t1;
      let halloween;
      let t2;
      let header;
      let nav;
      let div3;
      let div0;
      let estadisticas;
      let t3;
      let span0;
      let icon;
      let t4;
      let ripple0;
      let t5;
      let a0;
      let h3;
      let t6_value = window.config.general.nombre.toUpperCase() + "";
      let t6;
      let t7;
      let span1;
      let t8;
      let t9;
      let ripple1;
      let t10;
      let div1;
      let t11;
      let t12;
      let div2;
      let t13;
      let t14;
      let a1;
      let button;
      let t15;
      let current_block_type_index;
      let if_block3;
      let t16;
      let t17;
      let formulariohilo;
      let updating_mostrar;
      let t18;
      let formulariologin;
      let t19;
      let div4;
      let t20;
      let navcategorias;
      let header_resize_listener;
      let t21;
      let menuprincipal;
      let updating_mostrar_1;
      let t22;
      let dialogos;
      let t23;
      let t24;
      let subir;
      let current;
      let mounted;
      let dispose;
      add_render_callback(
      /*onwindowscroll*/
      ctx[12]);
      nadielosabra = new NadieLoSabra({
        $$inline: true
      });
      alertaportenho = new AlertaPortenho({
        $$inline: true
      });
      halloween = new Halloween({
        $$inline: true
      });
      estadisticas = new Estadisticas({
        $$inline: true
      });
      ripple0 = new he({
        $$inline: true
      });
      ripple1 = new he({
        $$inline: true
      });

      function select_block_type(ctx, dirty) {
        if (
        /*protocoloMessi*/
        ctx[3]) return create_if_block_5$7;
        if (
        /*protocoloSerenito*/
        ctx[10]) return create_if_block_6$5;
      }

      let current_block_type = select_block_type(ctx);
      let if_block0 = current_block_type && current_block_type(ctx);
      let if_block1 = (
      /*$globalStore*/
      ctx[9].usuario.esMod ||
      /*$globalStore*/
      ctx[9].usuario.esAuxiliar) && create_if_block_4$8(ctx);
      let if_block2 = (
      /*$globalStore*/
      ctx[9].usuario.esMod ||
      /*$globalStore*/
      ctx[9].usuario.esAuxiliar) && create_if_block_3$f(ctx);
      button = new ye({
        props: {
          icon: true,
          dense: true,
          $$slots: {
            default: [create_default_slot_1$m]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      const if_block_creators = [create_if_block_2$m, create_else_block$a];
      const if_blocks = [];

      function select_block_type_1(ctx, dirty) {
        if (
        /*$globalStore*/
        ctx[9].usuario.estaAutenticado) return 0;
        return 1;
      }

      current_block_type_index = select_block_type_1(ctx);
      if_block3 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
      let if_block4 = (!
      /*protocoloMessi*/
      ctx[3] ||
      /*$globalStore*/
      ctx[9].usuario.esMod) && create_if_block_1$n(ctx);

      function formulariohilo_mostrar_binding(value) {
        /*formulariohilo_mostrar_binding*/
        ctx[16].call(null, value);
      }

      let formulariohilo_props = {};

      if (
      /*mostrarFormularioHilo*/
      ctx[2] !== void 0) {
        formulariohilo_props.mostrar =
        /*mostrarFormularioHilo*/
        ctx[2];
      }

      formulariohilo = new FormularioHilo({
        props: formulariohilo_props,
        $$inline: true
      });
      binding_callbacks.push(() => bind(formulariohilo, "mostrar", formulariohilo_mostrar_binding));
      formulariologin = new FormularioLogin({
        $$inline: true
      });
      navcategorias = new NavCategorias({
        props: {
          visible: !
          /*ocultarCategorias*/
          ctx[5]
        },
        $$inline: true
      });

      function menuprincipal_mostrar_binding(value) {
        /*menuprincipal_mostrar_binding*/
        ctx[18].call(null, value);
      }

      let menuprincipal_props = {};

      if (
      /*mostrarMenu*/
      ctx[1] !== void 0) {
        menuprincipal_props.mostrar =
        /*mostrarMenu*/
        ctx[1];
      }

      menuprincipal = new MenuPrincipal({
        props: menuprincipal_props,
        $$inline: true
      });
      binding_callbacks.push(() => bind(menuprincipal, "mostrar", menuprincipal_mostrar_binding));
      dialogos = new Dialogos({
        $$inline: true
      });
      let if_block5 =
      /*$globalStore*/
      ctx[9].usuario.estaAutenticado &&
      /*$globalStore*/
      ctx[9].usuario.esMod && create_if_block$y(ctx);
      subir = new Subir({
        $$inline: true
      });
      const block = {
        c: function create() {
          create_component(nadielosabra.$$.fragment);
          t0 = space();
          create_component(alertaportenho.$$.fragment);
          t1 = space();
          create_component(halloween.$$.fragment);
          t2 = space();
          header = element("header");
          nav = element("nav");
          div3 = element("div");
          div0 = element("div");
          create_component(estadisticas.$$.fragment);
          t3 = space();
          span0 = element("span");
          icon = element("icon");
          t4 = space();
          create_component(ripple0.$$.fragment);
          t5 = space();
          a0 = element("a");
          h3 = element("h3");
          t6 = text(t6_value);
          t7 = space();
          span1 = element("span");
          t8 = text(
          /*version*/
          ctx[8]);
          t9 = space();
          create_component(ripple1.$$.fragment);
          t10 = space();
          div1 = element("div");
          t11 = space();
          if (if_block0) if_block0.c();
          t12 = space();
          div2 = element("div");
          if (if_block1) if_block1.c();
          t13 = space();
          if (if_block2) if_block2.c();
          t14 = space();
          a1 = element("a");
          create_component(button.$$.fragment);
          t15 = space();
          if_block3.c();
          t16 = space();
          if (if_block4) if_block4.c();
          t17 = space();
          create_component(formulariohilo.$$.fragment);
          t18 = space();
          create_component(formulariologin.$$.fragment);
          t19 = space();
          div4 = element("div");
          t20 = space();
          create_component(navcategorias.$$.fragment);
          t21 = space();
          create_component(menuprincipal.$$.fragment);
          t22 = space();
          create_component(dialogos.$$.fragment);
          t23 = space();
          if (if_block5) if_block5.c();
          t24 = space();
          create_component(subir.$$.fragment);
          attr_dev(div0, "class", "fondo svelte-zbcya8");
          set_style(div0, "position", "absolute");
          set_style(div0, "left", "0");
          set_style(div0, "top", "0");
          set_style(div0, "width", "100%");
          add_location(div0, file$I, 100, 12, 3665);
          attr_dev(icon, "class", "fe fe-menu");
          add_location(icon, file$I, 112, 16, 4075);
          set_style(span0, "padding", "0 8px");
          attr_dev(span0, "class", "svelte-zbcya8");
          add_location(span0, file$I, 108, 12, 3933);
          attr_dev(span1, "class", "version svelte-zbcya8");
          add_location(span1, file$I, 118, 20, 4334);
          attr_dev(h3, "class", "rozed svelte-zbcya8");
          add_location(h3, file$I, 116, 16, 4228);
          attr_dev(a0, "href", "/");
          set_style(a0, "font-family", "euroFighter");
          attr_dev(a0, "class", "svelte-zbcya8");
          add_location(a0, file$I, 115, 12, 4165);
          attr_dev(div1, "class", "estadisticas svelte-zbcya8");
          add_location(div1, file$I, 124, 12, 4538);
          attr_dev(a1, "href", "/Buscar");
          attr_dev(a1, "class", "nav-boton svelte-zbcya8");
          set_style(a1, "height", "100%");
          add_location(a1, file$I, 158, 16, 6140);
          attr_dev(div2, "class", "nav-botones svelte-zbcya8");
          set_style(div2, "position", "relative");
          add_location(div2, file$I, 137, 12, 5169);
          attr_dev(div3, "class", "nav-principal svelte-zbcya8");
          toggle_class(div3, "modoSticky",
          /*scrollY*/
          ctx[7] > 50);
          add_location(div3, file$I, 99, 8, 3592);
          set_style(nav, "height", "0");
          add_location(nav, file$I, 97, 4, 3529);
          attr_dev(div4, "class", "separador");
          set_style(div4, "height", "48px");
          add_location(div4, file$I, 193, 4, 7532);
          attr_dev(header, "class", "svelte-zbcya8");
          add_render_callback(() =>
          /*header_elementresize_handler*/
          ctx[17].call(header));
          toggle_class(header, "oculta",
          /*oculta*/
          ctx[4]);
          toggle_class(header, "protocoloMessi",
          /*protocoloMessi*/
          ctx[3]);
          toggle_class(header, "protocoloSerenito",
          /*protocoloSerenito*/
          ctx[10]);
          add_location(header, file$I, 91, 0, 3408);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          mount_component(nadielosabra, target, anchor);
          insert_dev(target, t0, anchor);
          mount_component(alertaportenho, target, anchor);
          insert_dev(target, t1, anchor);
          mount_component(halloween, target, anchor);
          insert_dev(target, t2, anchor);
          insert_dev(target, header, anchor);
          append_dev(header, nav);
          append_dev(nav, div3);
          append_dev(div3, div0);
          mount_component(estadisticas, div0, null);
          append_dev(div3, t3);
          append_dev(div3, span0);
          append_dev(span0, icon);
          append_dev(span0, t4);
          mount_component(ripple0, span0, null);
          append_dev(div3, t5);
          append_dev(div3, a0);
          append_dev(a0, h3);
          append_dev(h3, t6);
          append_dev(h3, t7);
          append_dev(h3, span1);
          append_dev(span1, t8);
          append_dev(a0, t9);
          mount_component(ripple1, a0, null);
          append_dev(div3, t10);
          append_dev(div3, div1);
          append_dev(div3, t11);
          if (if_block0) if_block0.m(div3, null);
          append_dev(div3, t12);
          append_dev(div3, div2);
          if (if_block1) if_block1.m(div2, null);
          append_dev(div2, t13);
          if (if_block2) if_block2.m(div2, null);
          append_dev(div2, t14);
          append_dev(div2, a1);
          mount_component(button, a1, null);
          append_dev(div2, t15);
          if_blocks[current_block_type_index].m(div2, null);
          append_dev(div3, t16);
          if (if_block4) if_block4.m(div3, null);
          append_dev(div3, t17);
          mount_component(formulariohilo, div3, null);
          append_dev(div3, t18);
          mount_component(formulariologin, div3, null);
          append_dev(header, t19);
          append_dev(header, div4);
          append_dev(header, t20);
          mount_component(navcategorias, header, null);
          header_resize_listener = add_resize_listener(header,
          /*header_elementresize_handler*/
          ctx[17].bind(header));
          insert_dev(target, t21, anchor);
          mount_component(menuprincipal, target, anchor);
          insert_dev(target, t22, anchor);
          mount_component(dialogos, target, anchor);
          insert_dev(target, t23, anchor);
          if (if_block5) if_block5.m(target, anchor);
          insert_dev(target, t24, anchor);
          mount_component(subir, target, anchor);
          current = true;

          if (!mounted) {
            dispose = [listen_dev(window_1$1, "scroll",
            /*onScroll*/
            ctx[11], false, false, false), listen_dev(window_1$1, "scroll", () => {
              scrolling = true;
              clearTimeout(scrolling_timeout);
              scrolling_timeout = setTimeout(clear_scrolling, 100);
              /*onwindowscroll*/

              ctx[12]();
            }), listen_dev(span0, "click",
            /*click_handler*/
            ctx[13], false, false, false)];
            mounted = true;
          }
        },
        p: function update(ctx, [dirty]) {
          if (dirty &
          /*scrollY*/
          128 && !scrolling) {
            scrolling = true;
            clearTimeout(scrolling_timeout);
            scrollTo(window_1$1.pageXOffset,
            /*scrollY*/
            ctx[7]);
            scrolling_timeout = setTimeout(clear_scrolling, 100);
          }

          if (!current || dirty &
          /*version*/
          256) set_data_dev(t8,
          /*version*/
          ctx[8]);

          if (current_block_type !== (current_block_type = select_block_type(ctx))) {
            if (if_block0) if_block0.d(1);
            if_block0 = current_block_type && current_block_type(ctx);

            if (if_block0) {
              if_block0.c();
              if_block0.m(div3, t12);
            }
          }

          if (
          /*$globalStore*/
          ctx[9].usuario.esMod ||
          /*$globalStore*/
          ctx[9].usuario.esAuxiliar) {
            if (if_block1) {
              if (dirty &
              /*$globalStore*/
              512) {
                transition_in(if_block1, 1);
              }
            } else {
              if_block1 = create_if_block_4$8(ctx);
              if_block1.c();
              transition_in(if_block1, 1);
              if_block1.m(div2, t13);
            }
          } else if (if_block1) {
            group_outros();
            transition_out(if_block1, 1, 1, () => {
              if_block1 = null;
            });
            check_outros();
          }

          if (
          /*$globalStore*/
          ctx[9].usuario.esMod ||
          /*$globalStore*/
          ctx[9].usuario.esAuxiliar) {
            if (if_block2) {
              if (dirty &
              /*$globalStore*/
              512) {
                transition_in(if_block2, 1);
              }
            } else {
              if_block2 = create_if_block_3$f(ctx);
              if_block2.c();
              transition_in(if_block2, 1);
              if_block2.m(div2, t14);
            }
          } else if (if_block2) {
            group_outros();
            transition_out(if_block2, 1, 1, () => {
              if_block2 = null;
            });
            check_outros();
          }

          const button_changes = {};

          if (dirty &
          /*$$scope*/
          33554432) {
            button_changes.$$scope = {
              dirty,
              ctx
            };
          }

          button.$set(button_changes);
          let previous_block_index = current_block_type_index;
          current_block_type_index = select_block_type_1(ctx);

          if (current_block_type_index === previous_block_index) {
            if_blocks[current_block_type_index].p(ctx, dirty);
          } else {
            group_outros();
            transition_out(if_blocks[previous_block_index], 1, 1, () => {
              if_blocks[previous_block_index] = null;
            });
            check_outros();
            if_block3 = if_blocks[current_block_type_index];

            if (!if_block3) {
              if_block3 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
              if_block3.c();
            }

            transition_in(if_block3, 1);
            if_block3.m(div2, null);
          }

          if (!
          /*protocoloMessi*/
          ctx[3] ||
          /*$globalStore*/
          ctx[9].usuario.esMod) {
            if (if_block4) {
              if_block4.p(ctx, dirty);

              if (dirty &
              /*protocoloMessi, $globalStore*/
              520) {
                transition_in(if_block4, 1);
              }
            } else {
              if_block4 = create_if_block_1$n(ctx);
              if_block4.c();
              transition_in(if_block4, 1);
              if_block4.m(div3, t17);
            }
          } else if (if_block4) {
            group_outros();
            transition_out(if_block4, 1, 1, () => {
              if_block4 = null;
            });
            check_outros();
          }

          const formulariohilo_changes = {};

          if (!updating_mostrar && dirty &
          /*mostrarFormularioHilo*/
          4) {
            updating_mostrar = true;
            formulariohilo_changes.mostrar =
            /*mostrarFormularioHilo*/
            ctx[2];
            add_flush_callback(() => updating_mostrar = false);
          }

          formulariohilo.$set(formulariohilo_changes);

          if (dirty &
          /*scrollY*/
          128) {
            toggle_class(div3, "modoSticky",
            /*scrollY*/
            ctx[7] > 50);
          }

          const navcategorias_changes = {};
          if (dirty &
          /*ocultarCategorias*/
          32) navcategorias_changes.visible = !
          /*ocultarCategorias*/
          ctx[5];
          navcategorias.$set(navcategorias_changes);

          if (dirty &
          /*oculta*/
          16) {
            toggle_class(header, "oculta",
            /*oculta*/
            ctx[4]);
          }

          if (dirty &
          /*protocoloMessi*/
          8) {
            toggle_class(header, "protocoloMessi",
            /*protocoloMessi*/
            ctx[3]);
          }

          if (dirty &
          /*protocoloSerenito*/
          1024) {
            toggle_class(header, "protocoloSerenito",
            /*protocoloSerenito*/
            ctx[10]);
          }

          const menuprincipal_changes = {};

          if (!updating_mostrar_1 && dirty &
          /*mostrarMenu*/
          2) {
            updating_mostrar_1 = true;
            menuprincipal_changes.mostrar =
            /*mostrarMenu*/
            ctx[1];
            add_flush_callback(() => updating_mostrar_1 = false);
          }

          menuprincipal.$set(menuprincipal_changes);

          if (
          /*$globalStore*/
          ctx[9].usuario.estaAutenticado &&
          /*$globalStore*/
          ctx[9].usuario.esMod) {
            if (if_block5) {
              if (dirty &
              /*$globalStore*/
              512) {
                transition_in(if_block5, 1);
              }
            } else {
              if_block5 = create_if_block$y(ctx);
              if_block5.c();
              transition_in(if_block5, 1);
              if_block5.m(t24.parentNode, t24);
            }
          } else if (if_block5) {
            group_outros();
            transition_out(if_block5, 1, 1, () => {
              if_block5 = null;
            });
            check_outros();
          }
        },
        i: function intro(local) {
          if (current) return;
          transition_in(nadielosabra.$$.fragment, local);
          transition_in(alertaportenho.$$.fragment, local);
          transition_in(halloween.$$.fragment, local);
          transition_in(estadisticas.$$.fragment, local);
          transition_in(ripple0.$$.fragment, local);
          transition_in(ripple1.$$.fragment, local);
          transition_in(if_block1);
          transition_in(if_block2);
          transition_in(button.$$.fragment, local);
          transition_in(if_block3);
          transition_in(if_block4);
          transition_in(formulariohilo.$$.fragment, local);
          transition_in(formulariologin.$$.fragment, local);
          transition_in(navcategorias.$$.fragment, local);
          transition_in(menuprincipal.$$.fragment, local);
          transition_in(dialogos.$$.fragment, local);
          transition_in(if_block5);
          transition_in(subir.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(nadielosabra.$$.fragment, local);
          transition_out(alertaportenho.$$.fragment, local);
          transition_out(halloween.$$.fragment, local);
          transition_out(estadisticas.$$.fragment, local);
          transition_out(ripple0.$$.fragment, local);
          transition_out(ripple1.$$.fragment, local);
          transition_out(if_block1);
          transition_out(if_block2);
          transition_out(button.$$.fragment, local);
          transition_out(if_block3);
          transition_out(if_block4);
          transition_out(formulariohilo.$$.fragment, local);
          transition_out(formulariologin.$$.fragment, local);
          transition_out(navcategorias.$$.fragment, local);
          transition_out(menuprincipal.$$.fragment, local);
          transition_out(dialogos.$$.fragment, local);
          transition_out(if_block5);
          transition_out(subir.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(nadielosabra, detaching);
          if (detaching) detach_dev(t0);
          destroy_component(alertaportenho, detaching);
          if (detaching) detach_dev(t1);
          destroy_component(halloween, detaching);
          if (detaching) detach_dev(t2);
          if (detaching) detach_dev(header);
          destroy_component(estadisticas);
          destroy_component(ripple0);
          destroy_component(ripple1);

          if (if_block0) {
            if_block0.d();
          }

          if (if_block1) if_block1.d();
          if (if_block2) if_block2.d();
          destroy_component(button);
          if_blocks[current_block_type_index].d();
          if (if_block4) if_block4.d();
          destroy_component(formulariohilo);
          destroy_component(formulariologin);
          destroy_component(navcategorias);
          header_resize_listener();
          if (detaching) detach_dev(t21);
          destroy_component(menuprincipal, detaching);
          if (detaching) detach_dev(t22);
          destroy_component(dialogos, detaching);
          if (detaching) detach_dev(t23);
          if (if_block5) if_block5.d(detaching);
          if (detaching) detach_dev(t24);
          destroy_component(subir, detaching);
          mounted = false;
          run_all(dispose);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$L.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }

    function instance$L($$self, $$props, $$invalidate) {
      let $configStore;
      let $globalStore;
      validate_store(configStore, "configStore");
      component_subscribe($$self, configStore, $$value => $$invalidate(21, $configStore = $$value));
      validate_store(globalStore, "globalStore");
      component_subscribe($$self, globalStore, $$value => $$invalidate(9, $globalStore = $$value));
      let {
        $$slots: slots = {},
        $$scope
      } = $$props;
      validate_slots("Navbar", slots, []);
      let {
        notificaciones = window.notificaciones || []
      } = $$props;
      let mostrarMenu = false;
      let mostrarFormularioHilo = false;
      let computadorasConectadas = window.estadisticas.computadorasConectadas;
      let protocoloMessi = false;
      let protocoloSerenito = false; //$: protocoloSerenito = $configStore.general.modoSerenito;

      let mostrarComputadorasConectadas = false;
      let oculta;
      let ocultarCategorias = false;
      let compacta = false;
      let prevScrollpos = window.pageYOffset;

      function onScroll(e) {
        compacta = !(window.pageYOffset == 0);
        $$invalidate(5, ocultarCategorias = compacta);
        let currentScrollPos = window.pageYOffset;
        $$invalidate(4, oculta = currentScrollPos > prevScrollpos);
        prevScrollpos = currentScrollPos;
      }

      let height = 0; // $: if(height) {
      //     try {
      //         document.querySelector("main").style.marginTop = (height - 17) + "px"
      //     } catch (error) {console.log(error)}
      // }

      let style = window.document.styleSheets[0];
      let scrollY;
      let version = `${window.config.general.mensaje} - Version Chad ${window.config.general.version}`;
      if (protocoloMessi) version = `Protocolo Messi activado - Version Chad ${window.config.general.version}`;else if (protocoloSerenito) version = `Protocolo Serenito activado - Version Chad ${window.config.general.version}`;
      const writable_props = ["notificaciones"];
      Object.keys($$props).forEach(key => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Navbar> was created with unknown prop '${key}'`);
      });

      function onwindowscroll() {
        $$invalidate(7, scrollY = window_1$1.pageYOffset);
      }

      const click_handler = () => $$invalidate(1, mostrarMenu = !mostrarMenu);

      function notificaciones_1_notificaciones_binding(value) {
        notificaciones = value;
        $$invalidate(0, notificaciones);
      }

      const click_handler_1 = () => $$invalidate(2, mostrarFormularioHilo = true);

      function formulariohilo_mostrar_binding(value) {
        mostrarFormularioHilo = value;
        $$invalidate(2, mostrarFormularioHilo);
      }

      function header_elementresize_handler() {
        height = this.offsetHeight;
        $$invalidate(6, height);
      }

      function menuprincipal_mostrar_binding(value) {
        mostrarMenu = value;
        $$invalidate(1, mostrarMenu);
      }

      $$self.$$set = $$props => {
        if ("notificaciones" in $$props) $$invalidate(0, notificaciones = $$props.notificaciones);
      };

      $$self.$capture_state = () => ({
        Ripple: he,
        Button: ye,
        config,
        configStore,
        FormularioHilo,
        Notificaciones,
        MenuPrincipal,
        FormularioLogin,
        globalStore,
        MensajeRotativo,
        Dialogos,
        DenunciasNav,
        Signal,
        SelectorDeComentarios,
        Subir,
        onMount,
        NavCategorias,
        NadieLoSabra,
        AlertaPortenho,
        Halloween,
        Estadisticas,
        RChanClient,
        notificaciones,
        mostrarMenu,
        mostrarFormularioHilo,
        computadorasConectadas,
        protocoloMessi,
        protocoloSerenito,
        mostrarComputadorasConectadas,
        oculta,
        ocultarCategorias,
        compacta,
        prevScrollpos,
        onScroll,
        height,
        style,
        scrollY,
        version,
        $configStore,
        $globalStore
      });

      $$self.$inject_state = $$props => {
        if ("notificaciones" in $$props) $$invalidate(0, notificaciones = $$props.notificaciones);
        if ("mostrarMenu" in $$props) $$invalidate(1, mostrarMenu = $$props.mostrarMenu);
        if ("mostrarFormularioHilo" in $$props) $$invalidate(2, mostrarFormularioHilo = $$props.mostrarFormularioHilo);
        if ("computadorasConectadas" in $$props) computadorasConectadas = $$props.computadorasConectadas;
        if ("protocoloMessi" in $$props) $$invalidate(3, protocoloMessi = $$props.protocoloMessi);
        if ("protocoloSerenito" in $$props) $$invalidate(10, protocoloSerenito = $$props.protocoloSerenito);
        if ("mostrarComputadorasConectadas" in $$props) mostrarComputadorasConectadas = $$props.mostrarComputadorasConectadas;
        if ("oculta" in $$props) $$invalidate(4, oculta = $$props.oculta);
        if ("ocultarCategorias" in $$props) $$invalidate(5, ocultarCategorias = $$props.ocultarCategorias);
        if ("compacta" in $$props) compacta = $$props.compacta;
        if ("prevScrollpos" in $$props) prevScrollpos = $$props.prevScrollpos;
        if ("height" in $$props) $$invalidate(6, height = $$props.height);
        if ("style" in $$props) $$invalidate(24, style = $$props.style);
        if ("scrollY" in $$props) $$invalidate(7, scrollY = $$props.scrollY);
        if ("version" in $$props) $$invalidate(8, version = $$props.version);
      };

      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }

      $$self.$$.update = () => {
        if ($$self.$$.dirty &
        /*$configStore*/
        2097152) {
           $$invalidate(3, protocoloMessi = $configStore.general.modoMessi);
        }

        if ($$self.$$.dirty &
        /*protocoloMessi*/
        8) {
           if (protocoloMessi) {
            style.insertRule("body {--color5:rgb(28 185 208)!important}", style.cssRules.length);
          } else if (protocoloSerenito) {
            style.insertRule("body {--color5:rgb(255 124 36)!important}", style.cssRules.length);
          }
        }

        if ($$self.$$.dirty &
        /*mostrarFormularioHilo, $globalStore*/
        516) {
           if (mostrarFormularioHilo && !$globalStore.usuario.estaAutenticado) {
            window.location = "/Inicio";
          }
        }
      };

      return [notificaciones, mostrarMenu, mostrarFormularioHilo, protocoloMessi, oculta, ocultarCategorias, height, scrollY, version, $globalStore, protocoloSerenito, onScroll, onwindowscroll, click_handler, notificaciones_1_notificaciones_binding, click_handler_1, formulariohilo_mostrar_binding, header_elementresize_handler, menuprincipal_mostrar_binding];
    }

    class Navbar extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$L, create_fragment$L, safe_not_equal, {
          notificaciones: 0
        });
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "Navbar",
          options,
          id: create_fragment$L.name
        });
      }

      get notificaciones() {
        throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set notificaciones(value) {
        throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

    }

    /* src\components\Hilos\HiloList.svelte generated by Svelte v3.29.0 */
    const file$J = "src\\components\\Hilos\\HiloList.svelte";

    function get_each_context$i(ctx, list, i) {
      const child_ctx = ctx.slice();
      child_ctx[13] = list[i];
      child_ctx[14] = list;
      child_ctx[15] = i;
      return child_ctx;
    } // (116:4) {#if nuevoshilos.length > 0}


    function create_if_block$z(ctx) {
      let div;
      let icon;
      let t0;
      let t1_value =
      /*nuevoshilos*/
      ctx[1].length + "";
      let t1;
      let t2;
      let t3_value = (
      /*nuevoshilos*/
      ctx[1].length == 1 ? "roz nuevo" : "rozes nuevos") + "";
      let t3;
      let t4;
      let ripple;
      let div_transition;
      let current;
      let mounted;
      let dispose;
      ripple = new he({
        $$inline: true
      });
      const block = {
        c: function create() {
          div = element("div");
          icon = element("icon");
          t0 = text(" \n            Cargar ");
          t1 = text(t1_value);
          t2 = space();
          t3 = text(t3_value);
          t4 = space();
          create_component(ripple.$$.fragment);
          attr_dev(icon, "class", "fe fe-rotate-cw");
          set_style(icon, "margin-right", "8px");
          add_location(icon, file$J, 117, 12, 4047);
          attr_dev(div, "class", "cargar-nuevos-hilos svelte-1ppblzz");
          add_location(div, file$J, 116, 8, 3946);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          append_dev(div, icon);
          append_dev(div, t0);
          append_dev(div, t1);
          append_dev(div, t2);
          append_dev(div, t3);
          append_dev(div, t4);
          mount_component(ripple, div, null);
          current = true;

          if (!mounted) {
            dispose = listen_dev(div, "click",
            /*cargarNuevos*/
            ctx[2], false, false, false);
            mounted = true;
          }
        },
        p: function update(ctx, dirty) {
          if ((!current || dirty &
          /*nuevoshilos*/
          2) && t1_value !== (t1_value =
          /*nuevoshilos*/
          ctx[1].length + "")) set_data_dev(t1, t1_value);
          if ((!current || dirty &
          /*nuevoshilos*/
          2) && t3_value !== (t3_value = (
          /*nuevoshilos*/
          ctx[1].length == 1 ? "roz nuevo" : "rozes nuevos") + "")) set_data_dev(t3, t3_value);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(ripple.$$.fragment, local);

          if (local) {
            add_render_callback(() => {
              if (!div_transition) div_transition = create_bidirectional_transition(div, fly, {
                x: 100
              }, true);
              div_transition.run(1);
            });
          }

          current = true;
        },
        o: function outro(local) {
          transition_out(ripple.$$.fragment, local);

          if (local) {
            if (!div_transition) div_transition = create_bidirectional_transition(div, fly, {
              x: 100
            }, false);
            div_transition.run(0);
          }

          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
          destroy_component(ripple);
          if (detaching && div_transition) div_transition.end();
          mounted = false;
          dispose();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block$z.name,
        type: "if",
        source: "(116:4) {#if nuevoshilos.length > 0}",
        ctx
      });
      return block;
    } // (123:4) {#each hiloList.hilos as hilo (hilo.id)}


    function create_each_block$i(key_1, ctx) {
      let first;
      let hilopreview;
      let updating_hilo;
      let current;

      function hilopreview_hilo_binding(value) {
        /*hilopreview_hilo_binding*/
        ctx[5].call(null, value,
        /*hilo*/
        ctx[13],
        /*each_value*/
        ctx[14],
        /*hilo_index*/
        ctx[15]);
      }

      let hilopreview_props = {};

      if (
      /*hilo*/
      ctx[13] !== void 0) {
        hilopreview_props.hilo =
        /*hilo*/
        ctx[13];
      }

      hilopreview = new HiloPreview({
        props: hilopreview_props,
        $$inline: true
      });
      binding_callbacks.push(() => bind(hilopreview, "hilo", hilopreview_hilo_binding));
      hilopreview.$on("click", hiloCliqueado);
      const block = {
        key: key_1,
        first: null,
        c: function create() {
          first = empty();
          create_component(hilopreview.$$.fragment);
          this.first = first;
        },
        m: function mount(target, anchor) {
          insert_dev(target, first, anchor);
          mount_component(hilopreview, target, anchor);
          current = true;
        },
        p: function update(new_ctx, dirty) {
          ctx = new_ctx;
          const hilopreview_changes = {};

          if (!updating_hilo && dirty &
          /*hiloList*/
          1) {
            updating_hilo = true;
            hilopreview_changes.hilo =
            /*hilo*/
            ctx[13];
            add_flush_callback(() => updating_hilo = false);
          }

          hilopreview.$set(hilopreview_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(hilopreview.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(hilopreview.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(first);
          destroy_component(hilopreview, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_each_block$i.name,
        type: "each",
        source: "(123:4) {#each hiloList.hilos as hilo (hilo.id)}",
        ctx
      });
      return block;
    } // (128:4) <div style="text-align:center" slot="noMore">


    function create_noMore_slot$1(ctx) {
      let div;
      const block = {
        c: function create() {
          div = element("div");
          div.textContent = "No hay mas hilos padre, recargue la pagina";
          set_style(div, "text-align", "center");
          attr_dev(div, "slot", "noMore");
          add_location(div, file$J, 127, 4, 4439);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_noMore_slot$1.name,
        type: "slot",
        source: "(128:4) <div style=\\\"text-align:center\\\" slot=\\\"noMore\\\">",
        ctx
      });
      return block;
    } // (129:4) <div style="text-align:center" slot="noResults">


    function create_noResults_slot$1(ctx) {
      let div;
      const block = {
        c: function create() {
          div = element("div");
          set_style(div, "text-align", "center");
          attr_dev(div, "slot", "noResults");
          add_location(div, file$J, 128, 4, 4537);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_noResults_slot$1.name,
        type: "slot",
        source: "(129:4) <div style=\\\"text-align:center\\\" slot=\\\"noResults\\\">",
        ctx
      });
      return block;
    } // (127:0) <InfiniteLoading on:infinite={cargarViejos} distance={600}>


    function create_default_slot$r(ctx) {
      let t;
      const block = {
        c: function create() {
          t = space();
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        p: noop,
        d: function destroy(detaching) {
          if (detaching) detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot$r.name,
        type: "slot",
        source: "(127:0) <InfiniteLoading on:infinite={cargarViejos} distance={600}>",
        ctx
      });
      return block;
    }

    function create_fragment$M(ctx) {
      let ul;
      let t0;
      let each_blocks = [];
      let each_1_lookup = new Map();
      let t1;
      let infiniteloading;
      let current;
      let if_block =
      /*nuevoshilos*/
      ctx[1].length > 0 && create_if_block$z(ctx);
      let each_value =
      /*hiloList*/
      ctx[0].hilos;
      validate_each_argument(each_value);

      const get_key = ctx =>
      /*hilo*/
      ctx[13].id;

      validate_each_keys(ctx, each_value, get_each_context$i, get_key);

      for (let i = 0; i < each_value.length; i += 1) {
        let child_ctx = get_each_context$i(ctx, each_value, i);
        let key = get_key(child_ctx);
        each_1_lookup.set(key, each_blocks[i] = create_each_block$i(key, child_ctx));
      }

      infiniteloading = new InfiniteLoading({
        props: {
          distance: 600,
          $$slots: {
            default: [create_default_slot$r],
            noResults: [create_noResults_slot$1],
            noMore: [create_noMore_slot$1]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      infiniteloading.$on("infinite",
      /*cargarViejos*/
      ctx[3]);
      const block = {
        c: function create() {
          ul = element("ul");
          if (if_block) if_block.c();
          t0 = space();

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].c();
          }

          t1 = space();
          create_component(infiniteloading.$$.fragment);
          attr_dev(ul, "class", "hilo-list");
          add_location(ul, file$J, 114, 0, 3882);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, ul, anchor);
          if (if_block) if_block.m(ul, null);
          append_dev(ul, t0);

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].m(ul, null);
          }

          insert_dev(target, t1, anchor);
          mount_component(infiniteloading, target, anchor);
          current = true;
        },
        p: function update(ctx, [dirty]) {
          if (
          /*nuevoshilos*/
          ctx[1].length > 0) {
            if (if_block) {
              if_block.p(ctx, dirty);

              if (dirty &
              /*nuevoshilos*/
              2) {
                transition_in(if_block, 1);
              }
            } else {
              if_block = create_if_block$z(ctx);
              if_block.c();
              transition_in(if_block, 1);
              if_block.m(ul, t0);
            }
          } else if (if_block) {
            group_outros();
            transition_out(if_block, 1, 1, () => {
              if_block = null;
            });
            check_outros();
          }

          if (dirty &
          /*hiloList, hiloCliqueado*/
          1) {
            const each_value =
            /*hiloList*/
            ctx[0].hilos;
            validate_each_argument(each_value);
            group_outros();
            validate_each_keys(ctx, each_value, get_each_context$i, get_key);
            each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, ul, outro_and_destroy_block, create_each_block$i, null, get_each_context$i);
            check_outros();
          }

          const infiniteloading_changes = {};

          if (dirty &
          /*$$scope*/
          65536) {
            infiniteloading_changes.$$scope = {
              dirty,
              ctx
            };
          }

          infiniteloading.$set(infiniteloading_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(if_block);

          for (let i = 0; i < each_value.length; i += 1) {
            transition_in(each_blocks[i]);
          }

          transition_in(infiniteloading.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(if_block);

          for (let i = 0; i < each_blocks.length; i += 1) {
            transition_out(each_blocks[i]);
          }

          transition_out(infiniteloading.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(ul);
          if (if_block) if_block.d();

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].d();
          }

          if (detaching) detach_dev(t1);
          destroy_component(infiniteloading, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$M.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }

    function hiloCliqueado(params) {}

    function instance$M($$self, $$props, $$invalidate) {
      let $ajustesConfigStore;
      validate_store(ajustesConfigStore, "ajustesConfigStore");
      component_subscribe($$self, ajustesConfigStore, $$value => $$invalidate(6, $ajustesConfigStore = $$value));
      let {
        $$slots: slots = {},
        $$scope
      } = $$props;
      validate_slots("HiloList", slots, []);
      let {
        hiloList
      } = $$props;
      let {
        noCargarNuevos = false
      } = $$props;
      hiloList.categoriasActivas == hiloList.categoriasActivas || $ajustesConfigStore.palabrasHideadasglobalStore.categoriasActivas.includes(hilo.categoriaId); //??quitado
      // let palabrasHideadasString = localStore("palabrasHideadas", "")
      // $:if($pahi) {hiloList.hilos = hiloList.hilos.filter(h => !estaOculto(h))}

      let nuevoshilos = [];
      Signal.subscribirAHome();
      Signal.coneccion.on("HiloCreado", onHiloCreado);
      Signal.coneccion.on("HiloComentado", onHiloComentado);
      Signal.coneccion.on("HilosEliminados", ids => {
        $$invalidate(0, hiloList.hilos = hiloList.hilos.filter(h => !ids.includes(h.id)), hiloList);
        $$invalidate(1, nuevoshilos = nuevoshilos.filter(h => !ids.includes(h.id)));
      });
      Signal.coneccion.on("categoriaCambiada", data => {
        var hilo = hiloList.hilos.filter(h => h.id == data.hiloId);

        if (hilo.length != 0) {
          hilo[0].categoriaId = data.categoriaId;
          $$invalidate(0, hiloList);
        }

        if (!hiloList.categoriasActivas.includes(data.categoriaId)) {
          $$invalidate(0, hiloList.hilos = hiloList.hilos.filter(h => h.id != data.hiloId), hiloList);
        }
      });

      function onHiloCreado(hilo) {
        if (noCargarNuevos) return;

        if (hiloList.categoriasActivas.includes(hilo.categoriaId)) {
          $$invalidate(1, nuevoshilos = [hilo, ...nuevoshilos]);
        }
      }

      function onHiloComentado(id, comentario) {
        let hiloComentado = [...hiloList.hilos, ...nuevoshilos].filter(h => h.id == id);

        if (hiloComentado.length != 0) {
          hiloComentado[0].cantidadComentarios += 1;
        }

        $$invalidate(0, hiloList);
      }

      function cargarNuevos() {
        let stickies = [];

        while (hiloList.hilos.length != 0 && hiloList.hilos[0].sticky != 0) {
          stickies.push(hiloList.hilos.shift());
        }

        $$invalidate(0, hiloList.hilos = [...stickies, ...nuevoshilos, ...hiloList.hilos], hiloList);
        $$invalidate(1, nuevoshilos = []);
        window.document.body.scrollTop = 0;
        window.document.documentElement.scrollTop = 0;
      }

      async function cargarViejos({
        detail: {
          loaded,
          complete
        }
      }) {
        if (hiloList.hilos.length == 0) complete();

        try {
          let {
            data
          } = await RChanClient.cargarMasHilos(hiloList.hilos[hiloList.hilos.length - 1].bump, hiloList.categoriasActivas, hiloList.serios);
          $$invalidate(0, hiloList.hilos = [...hiloList.hilos, ...data], hiloList);
          if (data.length == 0) complete();
          loaded();
        } catch {
          complete();
        }
      }

      if (!$ajustesConfigStore.palabrasHideadas) set_store_value(ajustesConfigStore, $ajustesConfigStore.palabrasHideadas = "", $ajustesConfigStore);
      let palabrasHideadas = $ajustesConfigStore.palabrasHideadas.toLowerCase().split(" ").map(p => p.trim()).map(p => p.replace(/\_/g, " ")).filter(p => p);

      function estaOculto(hilo) {
        let titulo = hilo.titulo.toLowerCase();

        for (const palabra of palabrasHideadas) {
          if (titulo.includes(palabra)) return true;
        }

        return false;
      }

      let tienaMas = true;
      let accionesRapidas = null;
      const writable_props = ["hiloList", "noCargarNuevos"];
      Object.keys($$props).forEach(key => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<HiloList> was created with unknown prop '${key}'`);
      });

      function hilopreview_hilo_binding(value, hilo, each_value, hilo_index) {
        each_value[hilo_index] = value;
        $$invalidate(0, hiloList);
      }

      $$self.$$set = $$props => {
        if ("hiloList" in $$props) $$invalidate(0, hiloList = $$props.hiloList);
        if ("noCargarNuevos" in $$props) $$invalidate(4, noCargarNuevos = $$props.noCargarNuevos);
      };

      $$self.$capture_state = () => ({
        HiloPreview,
        globalStore,
        Ripple: he,
        fly,
        InfiniteLoading,
        HubConnectionBuilder,
        RChanClient,
        Signal,
        localStore,
        ajustesConfigStore,
        hiloList,
        noCargarNuevos,
        nuevoshilos,
        onHiloCreado,
        onHiloComentado,
        cargarNuevos,
        cargarViejos,
        palabrasHideadas,
        estaOculto,
        tienaMas,
        accionesRapidas,
        hiloCliqueado,
        $ajustesConfigStore
      });

      $$self.$inject_state = $$props => {
        if ("hiloList" in $$props) $$invalidate(0, hiloList = $$props.hiloList);
        if ("noCargarNuevos" in $$props) $$invalidate(4, noCargarNuevos = $$props.noCargarNuevos);
        if ("nuevoshilos" in $$props) $$invalidate(1, nuevoshilos = $$props.nuevoshilos);
        if ("palabrasHideadas" in $$props) palabrasHideadas = $$props.palabrasHideadas;
        if ("tienaMas" in $$props) tienaMas = $$props.tienaMas;
        if ("accionesRapidas" in $$props) accionesRapidas = $$props.accionesRapidas;
      };

      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }

      $$self.$$.update = () => {
        if ($$self.$$.dirty &
        /*hiloList*/
        1) {
           $$invalidate(0, hiloList.hilos = hiloList.hilos.filter(h => !estaOculto(h)), hiloList);
        }
      };

      return [hiloList, nuevoshilos, cargarNuevos, cargarViejos, noCargarNuevos, hilopreview_hilo_binding];
    }

    class HiloList extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$M, create_fragment$M, safe_not_equal, {
          hiloList: 0,
          noCargarNuevos: 4
        });
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "HiloList",
          options,
          id: create_fragment$M.name
        });
        const {
          ctx
        } = this.$$;
        const props = options.props || {};

        if (
        /*hiloList*/
        ctx[0] === undefined && !("hiloList" in props)) {
          console.warn("<HiloList> was created without expected prop 'hiloList'");
        }
      }

      get hiloList() {
        throw new Error("<HiloList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set hiloList(value) {
        throw new Error("<HiloList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      get noCargarNuevos() {
        throw new Error("<HiloList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set noCargarNuevos(value) {
        throw new Error("<HiloList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

    }

    /* src\components\Administracion\Administracion.svelte generated by Svelte v3.29.0 */
    const {
      Object: Object_1$6,
      console: console_1$c
    } = globals;
    const file$K = "src\\components\\Administracion\\Administracion.svelte";

    function get_each_context$j(ctx, list, i) {
      const child_ctx = ctx.slice();
      child_ctx[40] = list[i];
      return child_ctx;
    }

    function get_each_context_1$8(ctx, list, i) {
      const child_ctx = ctx.slice();
      child_ctx[43] = list[i][0];
      child_ctx[44] = list[i][1];
      return child_ctx;
    }

    function get_each_context_2$4(ctx, list, i) {
      const child_ctx = ctx.slice();
      child_ctx[43] = list[i][0];
      child_ctx[44] = list[i][1];
      return child_ctx;
    }

    function get_each_context_3$2(ctx, list, i) {
      const child_ctx = ctx.slice();
      child_ctx[49] = list[i];
      return child_ctx;
    }

    function get_each_context_4(ctx, list, i) {
      const child_ctx = ctx.slice();
      child_ctx[49] = list[i];
      return child_ctx;
    }

    function get_each_context_5(ctx, list, i) {
      const child_ctx = ctx.slice();
      child_ctx[54] = list[i];
      return child_ctx;
    } // (96:20) <Button on:click={() => añadir(nickAdmin, "admin")}                          >


    function create_default_slot_11$2(ctx) {
      let t;
      const block = {
        c: function create() {
          t = text("Añadir");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_11$2.name,
        type: "slot",
        source: "(96:20) <Button on:click={() => añadir(nickAdmin, \\\"admin\\\")}                          >",
        ctx
      });
      return block;
    } // (102:57) <Button                              on:click={() => eliminar(a.id, "admin")}                              >


    function create_default_slot_10$3(ctx) {
      let t;
      const block = {
        c: function create() {
          t = text("Eliminar");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_10$3.name,
        type: "slot",
        source: "(102:57) <Button                              on:click={() => eliminar(a.id, \\\"admin\\\")}                              >",
        ctx
      });
      return block;
    } // (100:16) {#each model.admins as a (a.id)}


    function create_each_block_5(key_1, ctx) {
      let li;
      let t0_value =
      /*a*/
      ctx[54].userName + "";
      let t0;
      let t1;
      let span;
      let button;
      let current;

      function click_handler_1(...args) {
        return (
          /*click_handler_1*/
          ctx[13](
          /*a*/
          ctx[54], ...args)
        );
      }

      button = new ye({
        props: {
          $$slots: {
            default: [create_default_slot_10$3]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      button.$on("click", click_handler_1);
      const block = {
        key: key_1,
        first: null,
        c: function create() {
          li = element("li");
          t0 = text(t0_value);
          t1 = space();
          span = element("span");
          create_component(button.$$.fragment);
          attr_dev(span, "class", "sep svelte-wp842r");
          add_location(span, file$K, 101, 37, 3028);
          add_location(li, file$K, 100, 20, 2985);
          this.first = li;
        },
        m: function mount(target, anchor) {
          insert_dev(target, li, anchor);
          append_dev(li, t0);
          append_dev(li, t1);
          append_dev(li, span);
          mount_component(button, li, null);
          current = true;
        },
        p: function update(new_ctx, dirty) {
          ctx = new_ctx;
          if ((!current || dirty[0] &
          /*model*/
          1) && t0_value !== (t0_value =
          /*a*/
          ctx[54].userName + "")) set_data_dev(t0, t0_value);
          const button_changes = {};

          if (dirty[1] &
          /*$$scope*/
          67108864) {
            button_changes.$$scope = {
              dirty,
              ctx
            };
          }

          button.$set(button_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(button.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(button.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(li);
          destroy_component(button);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_each_block_5.name,
        type: "each",
        source: "(100:16) {#each model.admins as a (a.id)}",
        ctx
      });
      return block;
    } // (116:20) <Button on:click={() => añadir(nickMod, "mod")}                          >


    function create_default_slot_9$4(ctx) {
      let t;
      const block = {
        c: function create() {
          t = text("Añadir");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_9$4.name,
        type: "slot",
        source: "(116:20) <Button on:click={() => añadir(nickMod, \\\"mod\\\")}                          >",
        ctx
      });
      return block;
    } // (122:57) <Button                              on:click={() => eliminar(m.id, "mod")}                              >


    function create_default_slot_8$4(ctx) {
      let t;
      const block = {
        c: function create() {
          t = text("Eliminar");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_8$4.name,
        type: "slot",
        source: "(122:57) <Button                              on:click={() => eliminar(m.id, \\\"mod\\\")}                              >",
        ctx
      });
      return block;
    } // (120:16) {#each model.mods as m (m.id)}


    function create_each_block_4(key_1, ctx) {
      let li;
      let t0_value =
      /*m*/
      ctx[49].userName + "";
      let t0;
      let t1;
      let span;
      let button;
      let current;

      function click_handler_3(...args) {
        return (
          /*click_handler_3*/
          ctx[16](
          /*m*/
          ctx[49], ...args)
        );
      }

      button = new ye({
        props: {
          $$slots: {
            default: [create_default_slot_8$4]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      button.$on("click", click_handler_3);
      const block = {
        key: key_1,
        first: null,
        c: function create() {
          li = element("li");
          t0 = text(t0_value);
          t1 = space();
          span = element("span");
          create_component(button.$$.fragment);
          attr_dev(span, "class", "sep svelte-wp842r");
          add_location(span, file$K, 121, 37, 3836);
          add_location(li, file$K, 120, 20, 3793);
          this.first = li;
        },
        m: function mount(target, anchor) {
          insert_dev(target, li, anchor);
          append_dev(li, t0);
          append_dev(li, t1);
          append_dev(li, span);
          mount_component(button, li, null);
          current = true;
        },
        p: function update(new_ctx, dirty) {
          ctx = new_ctx;
          if ((!current || dirty[0] &
          /*model*/
          1) && t0_value !== (t0_value =
          /*m*/
          ctx[49].userName + "")) set_data_dev(t0, t0_value);
          const button_changes = {};

          if (dirty[1] &
          /*$$scope*/
          67108864) {
            button_changes.$$scope = {
              dirty,
              ctx
            };
          }

          button.$set(button_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(button.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(button.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(li);
          destroy_component(button);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_each_block_4.name,
        type: "each",
        source: "(120:16) {#each model.mods as m (m.id)}",
        ctx
      });
      return block;
    } // (135:20) <Button on:click={() => añadir(nickAux, "auxiliar")}                          >


    function create_default_slot_7$4(ctx) {
      let t;
      const block = {
        c: function create() {
          t = text("Añadir");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_7$4.name,
        type: "slot",
        source: "(135:20) <Button on:click={() => añadir(nickAux, \\\"auxiliar\\\")}                          >",
        ctx
      });
      return block;
    } // (141:57) <Button                              on:click={() => eliminar(m.id, "auxiliar")}                              >


    function create_default_slot_6$7(ctx) {
      let t;
      const block = {
        c: function create() {
          t = text("Eliminar");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_6$7.name,
        type: "slot",
        source: "(141:57) <Button                              on:click={() => eliminar(m.id, \\\"auxiliar\\\")}                              >",
        ctx
      });
      return block;
    } // (139:16) {#each model.auxiliares as m (m.id)}


    function create_each_block_3$2(key_1, ctx) {
      let li;
      let t0_value =
      /*m*/
      ctx[49].userName + "";
      let t0;
      let t1;
      let span;
      let button;
      let current;

      function click_handler_5(...args) {
        return (
          /*click_handler_5*/
          ctx[19](
          /*m*/
          ctx[49], ...args)
        );
      }

      button = new ye({
        props: {
          $$slots: {
            default: [create_default_slot_6$7]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      button.$on("click", click_handler_5);
      const block = {
        key: key_1,
        first: null,
        c: function create() {
          li = element("li");
          t0 = text(t0_value);
          t1 = space();
          span = element("span");
          create_component(button.$$.fragment);
          attr_dev(span, "class", "sep svelte-wp842r");
          add_location(span, file$K, 140, 37, 4627);
          add_location(li, file$K, 139, 20, 4584);
          this.first = li;
        },
        m: function mount(target, anchor) {
          insert_dev(target, li, anchor);
          append_dev(li, t0);
          append_dev(li, t1);
          append_dev(li, span);
          mount_component(button, li, null);
          current = true;
        },
        p: function update(new_ctx, dirty) {
          ctx = new_ctx;
          if ((!current || dirty[0] &
          /*model*/
          1) && t0_value !== (t0_value =
          /*m*/
          ctx[49].userName + "")) set_data_dev(t0, t0_value);
          const button_changes = {};

          if (dirty[1] &
          /*$$scope*/
          67108864) {
            button_changes.$$scope = {
              dirty,
              ctx
            };
          }

          button.$set(button_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(button.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(button.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(li);
          destroy_component(button);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_each_block_3$2.name,
        type: "each",
        source: "(139:16) {#each model.auxiliares as m (m.id)}",
        ctx
      });
      return block;
    } // (149:20) {#if data.nConexiones > 0}


    function create_if_block_2$n(ctx) {
      let li;
      let t0_value =
      /*nombre*/
      ctx[43] + "";
      let t0;
      let t1;
      let span;
      let tiempo;
      let current;
      tiempo = new Tiempo({
        props: {
          date:
          /*data*/
          ctx[44].ultimaConexion
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          li = element("li");
          t0 = text(t0_value);
          t1 = space();
          span = element("span");
          create_component(tiempo.$$.fragment);
          attr_dev(span, "class", "tiempo svelte-wp842r");
          add_location(span, file$K, 151, 28, 5118);
          add_location(li, file$K, 149, 24, 5046);
        },
        m: function mount(target, anchor) {
          insert_dev(target, li, anchor);
          append_dev(li, t0);
          append_dev(li, t1);
          append_dev(li, span);
          mount_component(tiempo, span, null);
          current = true;
        },
        p: function update(ctx, dirty) {
          if ((!current || dirty[0] &
          /*onlines*/
          32) && t0_value !== (t0_value =
          /*nombre*/
          ctx[43] + "")) set_data_dev(t0, t0_value);
          const tiempo_changes = {};
          if (dirty[0] &
          /*onlines*/
          32) tiempo_changes.date =
          /*data*/
          ctx[44].ultimaConexion;
          tiempo.$set(tiempo_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(tiempo.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(tiempo.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(li);
          destroy_component(tiempo);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_2$n.name,
        type: "if",
        source: "(149:20) {#if data.nConexiones > 0}",
        ctx
      });
      return block;
    } // (148:16) {#each Object.entries(onlines) as [nombre, data]}


    function create_each_block_2$4(ctx) {
      let if_block_anchor;
      let current;
      let if_block =
      /*data*/
      ctx[44].nConexiones > 0 && create_if_block_2$n(ctx);
      const block = {
        c: function create() {
          if (if_block) if_block.c();
          if_block_anchor = empty();
        },
        m: function mount(target, anchor) {
          if (if_block) if_block.m(target, anchor);
          insert_dev(target, if_block_anchor, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          if (
          /*data*/
          ctx[44].nConexiones > 0) {
            if (if_block) {
              if_block.p(ctx, dirty);

              if (dirty[0] &
              /*onlines*/
              32) {
                transition_in(if_block, 1);
              }
            } else {
              if_block = create_if_block_2$n(ctx);
              if_block.c();
              transition_in(if_block, 1);
              if_block.m(if_block_anchor.parentNode, if_block_anchor);
            }
          } else if (if_block) {
            group_outros();
            transition_out(if_block, 1, 1, () => {
              if_block = null;
            });
            check_outros();
          }
        },
        i: function intro(local) {
          if (current) return;
          transition_in(if_block);
          current = true;
        },
        o: function outro(local) {
          transition_out(if_block);
          current = false;
        },
        d: function destroy(detaching) {
          if (if_block) if_block.d(detaching);
          if (detaching) detach_dev(if_block_anchor);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_each_block_2$4.name,
        type: "each",
        source: "(148:16) {#each Object.entries(onlines) as [nombre, data]}",
        ctx
      });
      return block;
    } // (160:20) {#if data.nConexiones < 1}


    function create_if_block_1$o(ctx) {
      let li;
      let t0_value =
      /*nombre*/
      ctx[43] + "";
      let t0;
      let t1;
      let span;
      let tiempo;
      let t2;
      let current;
      tiempo = new Tiempo({
        props: {
          date:
          /*data*/
          ctx[44].ultimaConexion
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          li = element("li");
          t0 = text(t0_value);
          t1 = space();
          span = element("span");
          create_component(tiempo.$$.fragment);
          t2 = space();
          attr_dev(span, "class", "tiempo svelte-wp842r");
          add_location(span, file$K, 162, 28, 5598);
          add_location(li, file$K, 160, 24, 5526);
        },
        m: function mount(target, anchor) {
          insert_dev(target, li, anchor);
          append_dev(li, t0);
          append_dev(li, t1);
          append_dev(li, span);
          mount_component(tiempo, span, null);
          append_dev(li, t2);
          current = true;
        },
        p: function update(ctx, dirty) {
          if ((!current || dirty[0] &
          /*onlines*/
          32) && t0_value !== (t0_value =
          /*nombre*/
          ctx[43] + "")) set_data_dev(t0, t0_value);
          const tiempo_changes = {};
          if (dirty[0] &
          /*onlines*/
          32) tiempo_changes.date =
          /*data*/
          ctx[44].ultimaConexion;
          tiempo.$set(tiempo_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(tiempo.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(tiempo.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(li);
          destroy_component(tiempo);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_1$o.name,
        type: "if",
        source: "(160:20) {#if data.nConexiones < 1}",
        ctx
      });
      return block;
    } // (159:16) {#each Object.entries(onlines) as [nombre, data]}


    function create_each_block_1$8(ctx) {
      let if_block_anchor;
      let current;
      let if_block =
      /*data*/
      ctx[44].nConexiones < 1 && create_if_block_1$o(ctx);
      const block = {
        c: function create() {
          if (if_block) if_block.c();
          if_block_anchor = empty();
        },
        m: function mount(target, anchor) {
          if (if_block) if_block.m(target, anchor);
          insert_dev(target, if_block_anchor, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          if (
          /*data*/
          ctx[44].nConexiones < 1) {
            if (if_block) {
              if_block.p(ctx, dirty);

              if (dirty[0] &
              /*onlines*/
              32) {
                transition_in(if_block, 1);
              }
            } else {
              if_block = create_if_block_1$o(ctx);
              if_block.c();
              transition_in(if_block, 1);
              if_block.m(if_block_anchor.parentNode, if_block_anchor);
            }
          } else if (if_block) {
            group_outros();
            transition_out(if_block, 1, 1, () => {
              if_block = null;
            });
            check_outros();
          }
        },
        i: function intro(local) {
          if (current) return;
          transition_in(if_block);
          current = true;
        },
        o: function outro(local) {
          transition_out(if_block);
          current = false;
        },
        d: function destroy(detaching) {
          if (if_block) if_block.d(detaching);
          if (detaching) detach_dev(if_block_anchor);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_each_block_1$8.name,
        type: "each",
        source: "(159:16) {#each Object.entries(onlines) as [nombre, data]}",
        ctx
      });
      return block;
    } // (235:24) <Button on:click={actualizarConfig}>


    function create_default_slot_5$9(ctx) {
      let t;
      const block = {
        c: function create() {
          t = text("Guardar");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_5$9.name,
        type: "slot",
        source: "(235:24) <Button on:click={actualizarConfig}>",
        ctx
      });
      return block;
    } // (258:20) {#if !model.config.registroAbierto}


    function create_if_block$A(ctx) {
      let li0;
      let h4;
      let t1;
      let li1;
      let a;
      let t2;
      let t3_value =
      /*model*/
      ctx[0].config.linkDeInvitacion + "";
      let t3;
      let a_href_value;
      let t4;
      let button;
      let current;
      button = new ye({
        props: {
          $$slots: {
            default: [create_default_slot_4$e]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      button.$on("click",
      /*generarLink*/
      ctx[9]);
      const block = {
        c: function create() {
          li0 = element("li");
          h4 = element("h4");
          h4.textContent = "Link de invitacion";
          t1 = space();
          li1 = element("li");
          a = element("a");
          t2 = text("/Registro?codigoDeInvitacion=");
          t3 = text(t3_value);
          t4 = space();
          create_component(button.$$.fragment);
          add_location(h4, file$K, 259, 28, 9352);
          add_location(li0, file$K, 258, 24, 9318);
          set_style(a, "color", "var(--color5)");
          attr_dev(a, "href", a_href_value = "/Registro?codigoDeInvitacion=" +
          /*model*/
          ctx[0].config.linkDeInvitacion);
          add_location(a, file$K, 262, 28, 9470);
          add_location(li1, file$K, 261, 24, 9436);
        },
        m: function mount(target, anchor) {
          insert_dev(target, li0, anchor);
          append_dev(li0, h4);
          insert_dev(target, t1, anchor);
          insert_dev(target, li1, anchor);
          append_dev(li1, a);
          append_dev(a, t2);
          append_dev(a, t3);
          insert_dev(target, t4, anchor);
          mount_component(button, target, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          if ((!current || dirty[0] &
          /*model*/
          1) && t3_value !== (t3_value =
          /*model*/
          ctx[0].config.linkDeInvitacion + "")) set_data_dev(t3, t3_value);

          if (!current || dirty[0] &
          /*model*/
          1 && a_href_value !== (a_href_value = "/Registro?codigoDeInvitacion=" +
          /*model*/
          ctx[0].config.linkDeInvitacion)) {
            attr_dev(a, "href", a_href_value);
          }

          const button_changes = {};

          if (dirty[1] &
          /*$$scope*/
          67108864) {
            button_changes.$$scope = {
              dirty,
              ctx
            };
          }

          button.$set(button_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(button.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(button.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(li0);
          if (detaching) detach_dev(t1);
          if (detaching) detach_dev(li1);
          if (detaching) detach_dev(t4);
          destroy_component(button, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block$A.name,
        type: "if",
        source: "(258:20) {#if !model.config.registroAbierto}",
        ctx
      });
      return block;
    } // (271:24) <Button on:click={generarLink}>


    function create_default_slot_4$e(ctx) {
      let t;
      const block = {
        c: function create() {
          t = text("Nuevo link");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_4$e.name,
        type: "slot",
        source: "(271:24) <Button on:click={generarLink}>",
        ctx
      });
      return block;
    } // (275:24) <Button on:click={actualizarConfig}>


    function create_default_slot_3$i(ctx) {
      let t;
      const block = {
        c: function create() {
          t = text("Guardar");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_3$i.name,
        type: "slot",
        source: "(275:24) <Button on:click={actualizarConfig}>",
        ctx
      });
      return block;
    } // (300:24) <Radio                              right                              bind:group={model.config.restriccionDeAcceso}                              value={restriccionesDeAcesso[key]}                          >


    function create_default_slot_2$k(ctx) {
      let span;
      let t_value =
      /*key*/
      ctx[40] + "";
      let t;
      const block = {
        c: function create() {
          span = element("span");
          t = text(t_value);
          add_location(span, file$K, 304, 28, 11162);
        },
        m: function mount(target, anchor) {
          insert_dev(target, span, anchor);
          append_dev(span, t);
        },
        p: noop,
        d: function destroy(detaching) {
          if (detaching) detach_dev(span);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_2$k.name,
        type: "slot",
        source: "(300:24) <Radio                              right                              bind:group={model.config.restriccionDeAcceso}                              value={restriccionesDeAcesso[key]}                          >",
        ctx
      });
      return block;
    } // (298:16) {#each Object.keys(restriccionesDeAcesso) as key}


    function create_each_block$j(ctx) {
      let li;
      let radio;
      let updating_group;
      let current;

      function radio_group_binding(value) {
        /*radio_group_binding*/
        ctx[33].call(null, value);
      }

      let radio_props = {
        right: true,
        value:
        /*restriccionesDeAcesso*/
        ctx[10][
        /*key*/
        ctx[40]],
        $$slots: {
          default: [create_default_slot_2$k]
        },
        $$scope: {
          ctx
        }
      };

      if (
      /*model*/
      ctx[0].config.restriccionDeAcceso !== void 0) {
        radio_props.group =
        /*model*/
        ctx[0].config.restriccionDeAcceso;
      }

      radio = new Fn({
        props: radio_props,
        $$inline: true
      });
      binding_callbacks.push(() => bind(radio, "group", radio_group_binding));
      const block = {
        c: function create() {
          li = element("li");
          create_component(radio.$$.fragment);
          add_location(li, file$K, 298, 20, 10895);
        },
        m: function mount(target, anchor) {
          insert_dev(target, li, anchor);
          mount_component(radio, li, null);
          current = true;
        },
        p: function update(ctx, dirty) {
          const radio_changes = {};

          if (dirty[1] &
          /*$$scope*/
          67108864) {
            radio_changes.$$scope = {
              dirty,
              ctx
            };
          }

          if (!updating_group && dirty[0] &
          /*model*/
          1) {
            updating_group = true;
            radio_changes.group =
            /*model*/
            ctx[0].config.restriccionDeAcceso;
            add_flush_callback(() => updating_group = false);
          }

          radio.$set(radio_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(radio.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(radio.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(li);
          destroy_component(radio);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_each_block$j.name,
        type: "each",
        source: "(298:16) {#each Object.keys(restriccionesDeAcesso) as key}",
        ctx
      });
      return block;
    } // (321:20) <Button on:click={actualizarConfig}>


    function create_default_slot_1$n(ctx) {
      let t;
      const block = {
        c: function create() {
          t = text("Guardar");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_1$n.name,
        type: "slot",
        source: "(321:20) <Button on:click={actualizarConfig}>",
        ctx
      });
      return block;
    } // (351:16) <Button on:click={actualizarConfig}>


    function create_default_slot$s(ctx) {
      let t;
      const block = {
        c: function create() {
          t = text("Guardar");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot$s.name,
        type: "slot",
        source: "(351:16) <Button on:click={actualizarConfig}>",
        ctx
      });
      return block;
    }

    function create_fragment$N(ctx) {
      let main;
      let section0;
      let h30;
      let t1;
      let errorvalidacion0;
      let t2;
      let div0;
      let ul0;
      let li0;
      let t4;
      let li1;
      let input0;
      let t5;
      let button0;
      let t6;
      let each_blocks_5 = [];
      let each0_lookup = new Map();
      let t7;
      let hr;
      let t8;
      let li2;
      let t10;
      let li3;
      let input1;
      let t11;
      let button1;
      let t12;
      let each_blocks_4 = [];
      let each1_lookup = new Map();
      let t13;
      let li4;
      let t15;
      let li5;
      let input2;
      let t16;
      let button2;
      let t17;
      let each_blocks_3 = [];
      let each2_lookup = new Map();
      let t18;
      let li6;
      let t20;
      let t21;
      let li7;
      let t23;
      let t24;
      let section3;
      let section1;
      let h31;
      let t26;
      let errorvalidacion1;
      let t27;
      let div1;
      let ul1;
      let li8;
      let t28;
      let input3;
      let t29;
      let li9;
      let t30;
      let input4;
      let t31;
      let li10;
      let t32;
      let input5;
      let t33;
      let li11;
      let t34;
      let input6;
      let t35;
      let li12;
      let t36;
      let input7;
      let t37;
      let li13;
      let t38;
      let checkbox0;
      let updating_checked;
      let t39;
      let li14;
      let t40;
      let checkbox1;
      let updating_checked_1;
      let t41;
      let li15;
      let t42;
      let checkbox2;
      let updating_checked_2;
      let t43;
      let li16;
      let t44;
      let checkbox3;
      let updating_checked_3;
      let t45;
      let li17;
      let span0;
      let t46;
      let button3;
      let t47;
      let section2;
      let h32;
      let t49;
      let errorvalidacion2;
      let t50;
      let div2;
      let ul2;
      let li18;
      let t51;
      let input8;
      let t52;
      let li19;
      let t53;
      let checkbox4;
      let updating_checked_4;
      let t54;
      let t55;
      let li20;
      let span1;
      let t56;
      let button4;
      let t57;
      let section4;
      let h33;
      let t59;
      let errorvalidacion3;
      let t60;
      let div3;
      let ul3;
      let li21;
      let t61;
      let checkbox5;
      let updating_checked_5;
      let t62;
      let li22;
      let t63;
      let checkbox6;
      let updating_checked_6;
      let t64;
      let t65;
      let li23;
      let t67;
      let textarea0;
      let t68;
      let li24;
      let t69;
      let input9;
      let t70;
      let li25;
      let span2;
      let t71;
      let button5;
      let t72;
      let section5;
      let h34;
      let t74;
      let div4;
      let ul4;
      let a;
      let li26;
      let t76;
      let section6;
      let h35;
      let t78;
      let ul5;
      let li27;
      let t80;
      let li28;
      let textarea1;
      let t81;
      let li29;
      let span3;
      let t82;
      let button6;
      let current;
      let mounted;
      let dispose;
      errorvalidacion0 = new ErrorValidacion({
        props: {
          error:
          /*error*/
          ctx[1]
        },
        $$inline: true
      });
      button0 = new ye({
        props: {
          $$slots: {
            default: [create_default_slot_11$2]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      button0.$on("click",
      /*click_handler*/
      ctx[12]);
      let each_value_5 =
      /*model*/
      ctx[0].admins;
      validate_each_argument(each_value_5);

      const get_key = ctx =>
      /*a*/
      ctx[54].id;

      validate_each_keys(ctx, each_value_5, get_each_context_5, get_key);

      for (let i = 0; i < each_value_5.length; i += 1) {
        let child_ctx = get_each_context_5(ctx, each_value_5, i);
        let key = get_key(child_ctx);
        each0_lookup.set(key, each_blocks_5[i] = create_each_block_5(key, child_ctx));
      }

      button1 = new ye({
        props: {
          $$slots: {
            default: [create_default_slot_9$4]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      button1.$on("click",
      /*click_handler_2*/
      ctx[15]);
      let each_value_4 =
      /*model*/
      ctx[0].mods;
      validate_each_argument(each_value_4);

      const get_key_1 = ctx =>
      /*m*/
      ctx[49].id;

      validate_each_keys(ctx, each_value_4, get_each_context_4, get_key_1);

      for (let i = 0; i < each_value_4.length; i += 1) {
        let child_ctx = get_each_context_4(ctx, each_value_4, i);
        let key = get_key_1(child_ctx);
        each1_lookup.set(key, each_blocks_4[i] = create_each_block_4(key, child_ctx));
      }

      button2 = new ye({
        props: {
          $$slots: {
            default: [create_default_slot_7$4]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      button2.$on("click",
      /*click_handler_4*/
      ctx[18]);
      let each_value_3 =
      /*model*/
      ctx[0].auxiliares;
      validate_each_argument(each_value_3);

      const get_key_2 = ctx =>
      /*m*/
      ctx[49].id;

      validate_each_keys(ctx, each_value_3, get_each_context_3$2, get_key_2);

      for (let i = 0; i < each_value_3.length; i += 1) {
        let child_ctx = get_each_context_3$2(ctx, each_value_3, i);
        let key = get_key_2(child_ctx);
        each2_lookup.set(key, each_blocks_3[i] = create_each_block_3$2(key, child_ctx));
      }

      let each_value_2 = Object.entries(
      /*onlines*/
      ctx[5]);
      validate_each_argument(each_value_2);
      let each_blocks_2 = [];

      for (let i = 0; i < each_value_2.length; i += 1) {
        each_blocks_2[i] = create_each_block_2$4(get_each_context_2$4(ctx, each_value_2, i));
      }

      const out = i => transition_out(each_blocks_2[i], 1, 1, () => {
        each_blocks_2[i] = null;
      });

      let each_value_1 = Object.entries(
      /*onlines*/
      ctx[5]);
      validate_each_argument(each_value_1);
      let each_blocks_1 = [];

      for (let i = 0; i < each_value_1.length; i += 1) {
        each_blocks_1[i] = create_each_block_1$8(get_each_context_1$8(ctx, each_value_1, i));
      }

      const out_1 = i => transition_out(each_blocks_1[i], 1, 1, () => {
        each_blocks_1[i] = null;
      });

      errorvalidacion1 = new ErrorValidacion({
        props: {
          error:
          /*error*/
          ctx[1]
        },
        $$inline: true
      });

      function checkbox0_checked_binding(value) {
        /*checkbox0_checked_binding*/
        ctx[25].call(null, value);
      }

      let checkbox0_props = {
        right: true
      };

      if (
      /*model*/
      ctx[0].config.captchaRegistro !== void 0) {
        checkbox0_props.checked =
        /*model*/
        ctx[0].config.captchaRegistro;
      }

      checkbox0 = new Ne({
        props: checkbox0_props,
        $$inline: true
      });
      binding_callbacks.push(() => bind(checkbox0, "checked", checkbox0_checked_binding));

      function checkbox1_checked_binding(value) {
        /*checkbox1_checked_binding*/
        ctx[26].call(null, value);
      }

      let checkbox1_props = {
        right: true
      };

      if (
      /*model*/
      ctx[0].config.captchaHilo !== void 0) {
        checkbox1_props.checked =
        /*model*/
        ctx[0].config.captchaHilo;
      }

      checkbox1 = new Ne({
        props: checkbox1_props,
        $$inline: true
      });
      binding_callbacks.push(() => bind(checkbox1, "checked", checkbox1_checked_binding));

      function checkbox2_checked_binding(value) {
        /*checkbox2_checked_binding*/
        ctx[27].call(null, value);
      }

      let checkbox2_props = {
        right: true
      };

      if (
      /*model*/
      ctx[0].config.captchaComentario !== void 0) {
        checkbox2_props.checked =
        /*model*/
        ctx[0].config.captchaComentario;
      }

      checkbox2 = new Ne({
        props: checkbox2_props,
        $$inline: true
      });
      binding_callbacks.push(() => bind(checkbox2, "checked", checkbox2_checked_binding));

      function checkbox3_checked_binding(value) {
        /*checkbox3_checked_binding*/
        ctx[28].call(null, value);
      }

      let checkbox3_props = {
        right: true
      };

      if (
      /*model*/
      ctx[0].config.ignorarDenunciasAnonimas !== void 0) {
        checkbox3_props.checked =
        /*model*/
        ctx[0].config.ignorarDenunciasAnonimas;
      }

      checkbox3 = new Ne({
        props: checkbox3_props,
        $$inline: true
      });
      binding_callbacks.push(() => bind(checkbox3, "checked", checkbox3_checked_binding));
      button3 = new ye({
        props: {
          $$slots: {
            default: [create_default_slot_5$9]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      button3.$on("click",
      /*actualizarConfig*/
      ctx[8]);
      errorvalidacion2 = new ErrorValidacion({
        props: {
          error:
          /*error*/
          ctx[1]
        },
        $$inline: true
      });

      function checkbox4_checked_binding(value) {
        /*checkbox4_checked_binding*/
        ctx[30].call(null, value);
      }

      let checkbox4_props = {
        right: true
      };

      if (
      /*model*/
      ctx[0].config.registroAbierto !== void 0) {
        checkbox4_props.checked =
        /*model*/
        ctx[0].config.registroAbierto;
      }

      checkbox4 = new Ne({
        props: checkbox4_props,
        $$inline: true
      });
      binding_callbacks.push(() => bind(checkbox4, "checked", checkbox4_checked_binding));
      let if_block = !
      /*model*/
      ctx[0].config.registroAbierto && create_if_block$A(ctx);
      button4 = new ye({
        props: {
          $$slots: {
            default: [create_default_slot_3$i]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      button4.$on("click",
      /*actualizarConfig*/
      ctx[8]);
      errorvalidacion3 = new ErrorValidacion({
        props: {
          error:
          /*error*/
          ctx[1]
        },
        $$inline: true
      });

      function checkbox5_checked_binding(value) {
        /*checkbox5_checked_binding*/
        ctx[31].call(null, value);
      }

      let checkbox5_props = {
        right: true
      };

      if (
      /*model*/
      ctx[0].config.modoMessi !== void 0) {
        checkbox5_props.checked =
        /*model*/
        ctx[0].config.modoMessi;
      }

      checkbox5 = new Ne({
        props: checkbox5_props,
        $$inline: true
      });
      binding_callbacks.push(() => bind(checkbox5, "checked", checkbox5_checked_binding));

      function checkbox6_checked_binding(value) {
        /*checkbox6_checked_binding*/
        ctx[32].call(null, value);
      }

      let checkbox6_props = {
        right: true
      };

      if (
      /*model*/
      ctx[0].config.modoSerenito !== void 0) {
        checkbox6_props.checked =
        /*model*/
        ctx[0].config.modoSerenito;
      }

      checkbox6 = new Ne({
        props: checkbox6_props,
        $$inline: true
      });
      binding_callbacks.push(() => bind(checkbox6, "checked", checkbox6_checked_binding));
      let each_value = Object.keys(
      /*restriccionesDeAcesso*/
      ctx[10]);
      validate_each_argument(each_value);
      let each_blocks = [];

      for (let i = 0; i < each_value.length; i += 1) {
        each_blocks[i] = create_each_block$j(get_each_context$j(ctx, each_value, i));
      }

      const out_2 = i => transition_out(each_blocks[i], 1, 1, () => {
        each_blocks[i] = null;
      });

      button5 = new ye({
        props: {
          $$slots: {
            default: [create_default_slot_1$n]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      button5.$on("click",
      /*actualizarConfig*/
      ctx[8]);
      button6 = new ye({
        props: {
          $$slots: {
            default: [create_default_slot$s]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      button6.$on("click",
      /*actualizarConfig*/
      ctx[8]);
      const block = {
        c: function create() {
          main = element("main");
          section0 = element("section");
          h30 = element("h3");
          h30.textContent = "Equipo";
          t1 = space();
          create_component(errorvalidacion0.$$.fragment);
          t2 = space();
          div0 = element("div");
          ul0 = element("ul");
          li0 = element("li");
          li0.textContent = "Admninistradores";
          t4 = space();
          li1 = element("li");
          input0 = element("input");
          t5 = space();
          create_component(button0.$$.fragment);
          t6 = space();

          for (let i = 0; i < each_blocks_5.length; i += 1) {
            each_blocks_5[i].c();
          }

          t7 = space();
          hr = element("hr");
          t8 = space();
          li2 = element("li");
          li2.textContent = "Moderadores(mods)";
          t10 = space();
          li3 = element("li");
          input1 = element("input");
          t11 = space();
          create_component(button1.$$.fragment);
          t12 = space();

          for (let i = 0; i < each_blocks_4.length; i += 1) {
            each_blocks_4[i].c();
          }

          t13 = space();
          li4 = element("li");
          li4.textContent = "Auxiliares(aux)";
          t15 = space();
          li5 = element("li");
          input2 = element("input");
          t16 = space();
          create_component(button2.$$.fragment);
          t17 = space();

          for (let i = 0; i < each_blocks_3.length; i += 1) {
            each_blocks_3[i].c();
          }

          t18 = space();
          li6 = element("li");
          li6.textContent = "Conectados";
          t20 = space();

          for (let i = 0; i < each_blocks_2.length; i += 1) {
            each_blocks_2[i].c();
          }

          t21 = space();
          li7 = element("li");
          li7.textContent = "Desconectados";
          t23 = space();

          for (let i = 0; i < each_blocks_1.length; i += 1) {
            each_blocks_1[i].c();
          }

          t24 = space();
          section3 = element("section");
          section1 = element("section");
          h31 = element("h3");
          h31.textContent = "Configuracion";
          t26 = space();
          create_component(errorvalidacion1.$$.fragment);
          t27 = space();
          div1 = element("div");
          ul1 = element("ul");
          li8 = element("li");
          t28 = text("Limite bump ");
          input3 = element("input");
          t29 = space();
          li9 = element("li");
          t30 = text("Tiempo entre comentario ");
          input4 = element("input");
          t31 = space();
          li10 = element("li");
          t32 = text("Tiempo entre hilos");
          input5 = element("input");
          t33 = space();
          li11 = element("li");
          t34 = text("Hilos maximos por categoria");
          input6 = element("input");
          t35 = space();
          li12 = element("li");
          t36 = text("Limite archivo");
          input7 = element("input");
          t37 = space();
          li13 = element("li");
          t38 = text("Captcha registro ");
          create_component(checkbox0.$$.fragment);
          t39 = space();
          li14 = element("li");
          t40 = text("Captcha hilo ");
          create_component(checkbox1.$$.fragment);
          t41 = space();
          li15 = element("li");
          t42 = text("Captcha comentario ");
          create_component(checkbox2.$$.fragment);
          t43 = space();
          li16 = element("li");
          t44 = text("Ignorar denuncias anonimas");
          create_component(checkbox3.$$.fragment);
          t45 = space();
          li17 = element("li");
          span0 = element("span");
          t46 = space();
          create_component(button3.$$.fragment);
          t47 = space();
          section2 = element("section");
          h32 = element("h3");
          h32.textContent = "Registro";
          t49 = space();
          create_component(errorvalidacion2.$$.fragment);
          t50 = space();
          div2 = element("div");
          ul2 = element("ul");
          li18 = element("li");
          t51 = text("Registros maximos por ip");
          input8 = element("input");
          t52 = space();
          li19 = element("li");
          t53 = text("Registro publico ");
          create_component(checkbox4.$$.fragment);
          t54 = space();
          if (if_block) if_block.c();
          t55 = space();
          li20 = element("li");
          span1 = element("span");
          t56 = space();
          create_component(button4.$$.fragment);
          t57 = space();
          section4 = element("section");
          h33 = element("h3");
          h33.textContent = "Acceso";
          t59 = space();
          create_component(errorvalidacion3.$$.fragment);
          t60 = space();
          div3 = element("div");
          ul3 = element("ul");
          li21 = element("li");
          t61 = text("Protocolo Messi");
          create_component(checkbox5.$$.fragment);
          t62 = space();
          li22 = element("li");
          t63 = text("Protocolo Serenito");
          create_component(checkbox6.$$.fragment);
          t64 = space();

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].c();
          }

          t65 = space();
          li23 = element("li");
          li23.textContent = "Mensaje pagina de choque";
          t67 = space();
          textarea0 = element("textarea");
          t68 = space();
          li24 = element("li");
          t69 = text("Flags:\r\n                    ");
          input9 = element("input");
          t70 = space();
          li25 = element("li");
          span2 = element("span");
          t71 = space();
          create_component(button5.$$.fragment);
          t72 = space();
          section5 = element("section");
          h34 = element("h3");
          h34.textContent = "Otros";
          t74 = space();
          div4 = element("div");
          ul4 = element("ul");
          a = element("a");
          li26 = element("li");
          li26.textContent = "RozPams";
          t76 = space();
          section6 = element("section");
          h35 = element("h3");
          h35.textContent = "Censor";
          t78 = space();
          ul5 = element("ul");
          li27 = element("li");
          li27.textContent = "Lista negra";
          t80 = space();
          li28 = element("li");
          textarea1 = element("textarea");
          t81 = space();
          li29 = element("li");
          span3 = element("span");
          t82 = space();
          create_component(button6.$$.fragment);
          add_location(h30, file$K, 84, 8, 2362);
          attr_dev(li0, "class", "header svelte-wp842r");
          add_location(li0, file$K, 88, 16, 2478);
          attr_dev(input0, "type", "text");
          attr_dev(input0, "placeholder", "Id o nick del usuario");
          add_location(input0, file$K, 90, 20, 2577);
          attr_dev(li1, "class", "noback");
          add_location(li1, file$K, 89, 16, 2536);
          add_location(hr, file$K, 107, 16, 3269);
          attr_dev(li2, "class", "header svelte-wp842r");
          add_location(li2, file$K, 108, 16, 3293);
          attr_dev(input1, "type", "text");
          attr_dev(input1, "placeholder", "Id o nick del usuario");
          add_location(input1, file$K, 110, 20, 3393);
          attr_dev(li3, "class", "noback");
          add_location(li3, file$K, 109, 16, 3352);
          attr_dev(li4, "class", "header svelte-wp842r");
          add_location(li4, file$K, 127, 16, 4075);
          attr_dev(input2, "type", "text");
          attr_dev(input2, "placeholder", "Id o nick del usuario");
          add_location(input2, file$K, 129, 20, 4173);
          attr_dev(li5, "class", "noback");
          add_location(li5, file$K, 128, 16, 4132);
          attr_dev(li6, "class", "header svelte-wp842r");
          add_location(li6, file$K, 146, 16, 4871);
          attr_dev(li7, "class", "header svelte-wp842r");
          add_location(li7, file$K, 157, 16, 5348);
          add_location(ul0, file$K, 87, 12, 2456);
          attr_dev(div0, "class", "menu");
          add_location(div0, file$K, 86, 8, 2424);
          attr_dev(section0, "class", "svelte-wp842r");
          add_location(section0, file$K, 83, 4, 2343);
          add_location(h31, file$K, 174, 12, 5937);
          attr_dev(input3, "type", "number");
          add_location(input3, file$K, 179, 36, 6118);
          add_location(li8, file$K, 178, 20, 6076);
          attr_dev(input4, "type", "number");
          add_location(input4, file$K, 185, 48, 6364);
          add_location(li9, file$K, 184, 20, 6310);
          attr_dev(input5, "type", "number");
          add_location(input5, file$K, 191, 42, 6616);
          add_location(li10, file$K, 190, 20, 6568);
          attr_dev(input6, "type", "number");
          add_location(input6, file$K, 197, 51, 6871);
          add_location(li11, file$K, 196, 20, 6814);
          attr_dev(input7, "type", "number");
          add_location(input7, file$K, 203, 38, 7121);
          add_location(li12, file$K, 202, 20, 7077);
          add_location(li13, file$K, 208, 20, 7316);
          add_location(li14, file$K, 214, 20, 7557);
          add_location(li15, file$K, 220, 20, 7790);
          add_location(li16, file$K, 226, 20, 8035);
          set_style(span0, "margin-right", "auto");
          add_location(span0, file$K, 233, 24, 8339);
          attr_dev(li17, "class", "header svelte-wp842r");
          add_location(li17, file$K, 232, 20, 8294);
          add_location(ul1, file$K, 177, 16, 6050);
          attr_dev(div1, "class", "menu");
          add_location(div1, file$K, 176, 12, 6014);
          set_style(section1, "width", "fit-content");
          attr_dev(section1, "class", "svelte-wp842r");
          add_location(section1, file$K, 173, 8, 5888);
          add_location(h32, file$K, 240, 12, 8618);
          attr_dev(input8, "type", "number");
          add_location(input8, file$K, 245, 48, 8806);
          add_location(li18, file$K, 244, 20, 8752);
          add_location(li19, file$K, 250, 20, 9014);
          set_style(span1, "margin-right", "auto");
          add_location(span1, file$K, 273, 24, 10040);
          attr_dev(li20, "class", "header svelte-wp842r");
          add_location(li20, file$K, 272, 20, 9995);
          add_location(ul2, file$K, 243, 16, 8726);
          attr_dev(div2, "class", "menu");
          add_location(div2, file$K, 242, 12, 8690);
          set_style(section2, "width", "fit-content");
          set_style(section2, "margin-top", "10px");
          attr_dev(section2, "class", "svelte-wp842r");
          add_location(section2, file$K, 239, 8, 8552);
          attr_dev(section3, "class", "svelte-wp842r");
          add_location(section3, file$K, 172, 4, 5869);
          add_location(h33, file$K, 281, 8, 10284);
          add_location(li21, file$K, 285, 16, 10400);
          add_location(li22, file$K, 291, 16, 10609);
          add_location(li23, file$K, 308, 16, 11284);
          attr_dev(textarea0, "cols", "30");
          attr_dev(textarea0, "rows", "10");
          attr_dev(textarea0, "class", "svelte-wp842r");
          add_location(textarea0, file$K, 309, 16, 11335);
          attr_dev(input9, "type", "text");
          add_location(input9, file$K, 316, 20, 11567);
          add_location(li24, file$K, 314, 16, 11513);
          set_style(span2, "margin-right", "auto");
          add_location(span2, file$K, 319, 20, 11702);
          attr_dev(li25, "class", "header svelte-wp842r");
          add_location(li25, file$K, 318, 16, 11661);
          add_location(ul3, file$K, 284, 12, 10378);
          attr_dev(div3, "class", "menu");
          add_location(div3, file$K, 283, 8, 10346);
          attr_dev(section4, "class", "svelte-wp842r");
          add_location(section4, file$K, 280, 4, 10265);
          add_location(h34, file$K, 326, 8, 11910);
          add_location(li26, file$K, 330, 20, 12042);
          attr_dev(a, "href", "/Administracion/Spams");
          add_location(a, file$K, 329, 16, 11988);
          add_location(ul4, file$K, 328, 12, 11966);
          attr_dev(div4, "class", "menu");
          add_location(div4, file$K, 327, 8, 11934);
          attr_dev(section5, "class", "svelte-wp842r");
          add_location(section5, file$K, 325, 4, 11891);
          add_location(h35, file$K, 336, 8, 12156);
          add_location(li27, file$K, 338, 12, 12199);
          attr_dev(textarea1, "spellcheck", "false");
          attr_dev(textarea1, "placeholder", "Las palabras van separadas por espacios. Si se agrega * al final de la palabra va detectar todas las palabras que empiecen con esa palabra. Si se agrega * al inicio va a detectar todas las palabras que terminen con esa palabra. Reemplazar una letra dentro de la palabra por ? la convierte en comodín.");
          attr_dev(textarea1, "cols", "30");
          attr_dev(textarea1, "rows", "10");
          attr_dev(textarea1, "class", "svelte-wp842r");
          add_location(textarea1, file$K, 340, 16, 12255);
          add_location(li28, file$K, 339, 12, 12233);
          set_style(span3, "margin-right", "auto");
          add_location(span3, file$K, 349, 16, 12858);
          attr_dev(li29, "class", "header svelte-wp842r");
          add_location(li29, file$K, 348, 12, 12821);
          add_location(ul5, file$K, 337, 8, 12181);
          attr_dev(section6, "class", "svelte-wp842r");
          add_location(section6, file$K, 335, 4, 12137);
          attr_dev(main, "class", "administracion svelte-wp842r");
          add_location(main, file$K, 82, 0, 2308);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, main, anchor);
          append_dev(main, section0);
          append_dev(section0, h30);
          append_dev(section0, t1);
          mount_component(errorvalidacion0, section0, null);
          append_dev(section0, t2);
          append_dev(section0, div0);
          append_dev(div0, ul0);
          append_dev(ul0, li0);
          append_dev(ul0, t4);
          append_dev(ul0, li1);
          append_dev(li1, input0);
          set_input_value(input0,
          /*nickAdmin*/
          ctx[2]);
          append_dev(li1, t5);
          mount_component(button0, li1, null);
          append_dev(ul0, t6);

          for (let i = 0; i < each_blocks_5.length; i += 1) {
            each_blocks_5[i].m(ul0, null);
          }

          append_dev(ul0, t7);
          append_dev(ul0, hr);
          append_dev(ul0, t8);
          append_dev(ul0, li2);
          append_dev(ul0, t10);
          append_dev(ul0, li3);
          append_dev(li3, input1);
          set_input_value(input1,
          /*nickMod*/
          ctx[3]);
          append_dev(li3, t11);
          mount_component(button1, li3, null);
          append_dev(ul0, t12);

          for (let i = 0; i < each_blocks_4.length; i += 1) {
            each_blocks_4[i].m(ul0, null);
          }

          append_dev(ul0, t13);
          append_dev(ul0, li4);
          append_dev(ul0, t15);
          append_dev(ul0, li5);
          append_dev(li5, input2);
          set_input_value(input2,
          /*nickAux*/
          ctx[4]);
          append_dev(li5, t16);
          mount_component(button2, li5, null);
          append_dev(ul0, t17);

          for (let i = 0; i < each_blocks_3.length; i += 1) {
            each_blocks_3[i].m(ul0, null);
          }

          append_dev(ul0, t18);
          append_dev(ul0, li6);
          append_dev(ul0, t20);

          for (let i = 0; i < each_blocks_2.length; i += 1) {
            each_blocks_2[i].m(ul0, null);
          }

          append_dev(ul0, t21);
          append_dev(ul0, li7);
          append_dev(ul0, t23);

          for (let i = 0; i < each_blocks_1.length; i += 1) {
            each_blocks_1[i].m(ul0, null);
          }

          append_dev(main, t24);
          append_dev(main, section3);
          append_dev(section3, section1);
          append_dev(section1, h31);
          append_dev(section1, t26);
          mount_component(errorvalidacion1, section1, null);
          append_dev(section1, t27);
          append_dev(section1, div1);
          append_dev(div1, ul1);
          append_dev(ul1, li8);
          append_dev(li8, t28);
          append_dev(li8, input3);
          set_input_value(input3,
          /*model*/
          ctx[0].config.limiteBump);
          append_dev(ul1, t29);
          append_dev(ul1, li9);
          append_dev(li9, t30);
          append_dev(li9, input4);
          set_input_value(input4,
          /*model*/
          ctx[0].config.tiempoEntreComentarios);
          append_dev(ul1, t31);
          append_dev(ul1, li10);
          append_dev(li10, t32);
          append_dev(li10, input5);
          set_input_value(input5,
          /*model*/
          ctx[0].config.tiempoEntreHilos);
          append_dev(ul1, t33);
          append_dev(ul1, li11);
          append_dev(li11, t34);
          append_dev(li11, input6);
          set_input_value(input6,
          /*model*/
          ctx[0].config.hilosMaximosPorCategoria);
          append_dev(ul1, t35);
          append_dev(ul1, li12);
          append_dev(li12, t36);
          append_dev(li12, input7);
          set_input_value(input7,
          /*model*/
          ctx[0].config.limiteArchivo);
          append_dev(ul1, t37);
          append_dev(ul1, li13);
          append_dev(li13, t38);
          mount_component(checkbox0, li13, null);
          append_dev(ul1, t39);
          append_dev(ul1, li14);
          append_dev(li14, t40);
          mount_component(checkbox1, li14, null);
          append_dev(ul1, t41);
          append_dev(ul1, li15);
          append_dev(li15, t42);
          mount_component(checkbox2, li15, null);
          append_dev(ul1, t43);
          append_dev(ul1, li16);
          append_dev(li16, t44);
          mount_component(checkbox3, li16, null);
          append_dev(ul1, t45);
          append_dev(ul1, li17);
          append_dev(li17, span0);
          append_dev(li17, t46);
          mount_component(button3, li17, null);
          append_dev(section3, t47);
          append_dev(section3, section2);
          append_dev(section2, h32);
          append_dev(section2, t49);
          mount_component(errorvalidacion2, section2, null);
          append_dev(section2, t50);
          append_dev(section2, div2);
          append_dev(div2, ul2);
          append_dev(ul2, li18);
          append_dev(li18, t51);
          append_dev(li18, input8);
          set_input_value(input8,
          /*model*/
          ctx[0].config.numeroMaximoDeCuentasPorIp);
          append_dev(ul2, t52);
          append_dev(ul2, li19);
          append_dev(li19, t53);
          mount_component(checkbox4, li19, null);
          append_dev(ul2, t54);
          if (if_block) if_block.m(ul2, null);
          append_dev(ul2, t55);
          append_dev(ul2, li20);
          append_dev(li20, span1);
          append_dev(li20, t56);
          mount_component(button4, li20, null);
          append_dev(main, t57);
          append_dev(main, section4);
          append_dev(section4, h33);
          append_dev(section4, t59);
          mount_component(errorvalidacion3, section4, null);
          append_dev(section4, t60);
          append_dev(section4, div3);
          append_dev(div3, ul3);
          append_dev(ul3, li21);
          append_dev(li21, t61);
          mount_component(checkbox5, li21, null);
          append_dev(ul3, t62);
          append_dev(ul3, li22);
          append_dev(li22, t63);
          mount_component(checkbox6, li22, null);
          append_dev(ul3, t64);

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].m(ul3, null);
          }

          append_dev(ul3, t65);
          append_dev(ul3, li23);
          append_dev(ul3, t67);
          append_dev(ul3, textarea0);
          set_input_value(textarea0,
          /*model*/
          ctx[0].config.mensajePaginaDeChoque);
          append_dev(ul3, t68);
          append_dev(ul3, li24);
          append_dev(li24, t69);
          append_dev(li24, input9);
          set_input_value(input9,
          /*model*/
          ctx[0].config.flags);
          append_dev(ul3, t70);
          append_dev(ul3, li25);
          append_dev(li25, span2);
          append_dev(li25, t71);
          mount_component(button5, li25, null);
          append_dev(main, t72);
          append_dev(main, section5);
          append_dev(section5, h34);
          append_dev(section5, t74);
          append_dev(section5, div4);
          append_dev(div4, ul4);
          append_dev(ul4, a);
          append_dev(a, li26);
          append_dev(main, t76);
          append_dev(main, section6);
          append_dev(section6, h35);
          append_dev(section6, t78);
          append_dev(section6, ul5);
          append_dev(ul5, li27);
          append_dev(ul5, t80);
          append_dev(ul5, li28);
          append_dev(li28, textarea1);
          set_input_value(textarea1,
          /*model*/
          ctx[0].config.palabrasCensuradas);
          append_dev(ul5, t81);
          append_dev(ul5, li29);
          append_dev(li29, span3);
          append_dev(li29, t82);
          mount_component(button6, li29, null);
          current = true;

          if (!mounted) {
            dispose = [listen_dev(input0, "input",
            /*input0_input_handler*/
            ctx[11]), listen_dev(input1, "input",
            /*input1_input_handler*/
            ctx[14]), listen_dev(input2, "input",
            /*input2_input_handler*/
            ctx[17]), listen_dev(input3, "input",
            /*input3_input_handler*/
            ctx[20]), listen_dev(input4, "input",
            /*input4_input_handler*/
            ctx[21]), listen_dev(input5, "input",
            /*input5_input_handler*/
            ctx[22]), listen_dev(input6, "input",
            /*input6_input_handler*/
            ctx[23]), listen_dev(input7, "input",
            /*input7_input_handler*/
            ctx[24]), listen_dev(input8, "input",
            /*input8_input_handler*/
            ctx[29]), listen_dev(textarea0, "input",
            /*textarea0_input_handler*/
            ctx[34]), listen_dev(input9, "input",
            /*input9_input_handler*/
            ctx[35]), listen_dev(textarea1, "input",
            /*textarea1_input_handler*/
            ctx[36])];
            mounted = true;
          }
        },
        p: function update(ctx, dirty) {
          const errorvalidacion0_changes = {};
          if (dirty[0] &
          /*error*/
          2) errorvalidacion0_changes.error =
          /*error*/
          ctx[1];
          errorvalidacion0.$set(errorvalidacion0_changes);

          if (dirty[0] &
          /*nickAdmin*/
          4 && input0.value !==
          /*nickAdmin*/
          ctx[2]) {
            set_input_value(input0,
            /*nickAdmin*/
            ctx[2]);
          }

          const button0_changes = {};

          if (dirty[1] &
          /*$$scope*/
          67108864) {
            button0_changes.$$scope = {
              dirty,
              ctx
            };
          }

          button0.$set(button0_changes);

          if (dirty[0] &
          /*eliminar, model*/
          65) {
            const each_value_5 =
            /*model*/
            ctx[0].admins;
            validate_each_argument(each_value_5);
            group_outros();
            validate_each_keys(ctx, each_value_5, get_each_context_5, get_key);
            each_blocks_5 = update_keyed_each(each_blocks_5, dirty, get_key, 1, ctx, each_value_5, each0_lookup, ul0, outro_and_destroy_block, create_each_block_5, t7, get_each_context_5);
            check_outros();
          }

          if (dirty[0] &
          /*nickMod*/
          8 && input1.value !==
          /*nickMod*/
          ctx[3]) {
            set_input_value(input1,
            /*nickMod*/
            ctx[3]);
          }

          const button1_changes = {};

          if (dirty[1] &
          /*$$scope*/
          67108864) {
            button1_changes.$$scope = {
              dirty,
              ctx
            };
          }

          button1.$set(button1_changes);

          if (dirty[0] &
          /*eliminar, model*/
          65) {
            const each_value_4 =
            /*model*/
            ctx[0].mods;
            validate_each_argument(each_value_4);
            group_outros();
            validate_each_keys(ctx, each_value_4, get_each_context_4, get_key_1);
            each_blocks_4 = update_keyed_each(each_blocks_4, dirty, get_key_1, 1, ctx, each_value_4, each1_lookup, ul0, outro_and_destroy_block, create_each_block_4, t13, get_each_context_4);
            check_outros();
          }

          if (dirty[0] &
          /*nickAux*/
          16 && input2.value !==
          /*nickAux*/
          ctx[4]) {
            set_input_value(input2,
            /*nickAux*/
            ctx[4]);
          }

          const button2_changes = {};

          if (dirty[1] &
          /*$$scope*/
          67108864) {
            button2_changes.$$scope = {
              dirty,
              ctx
            };
          }

          button2.$set(button2_changes);

          if (dirty[0] &
          /*eliminar, model*/
          65) {
            const each_value_3 =
            /*model*/
            ctx[0].auxiliares;
            validate_each_argument(each_value_3);
            group_outros();
            validate_each_keys(ctx, each_value_3, get_each_context_3$2, get_key_2);
            each_blocks_3 = update_keyed_each(each_blocks_3, dirty, get_key_2, 1, ctx, each_value_3, each2_lookup, ul0, outro_and_destroy_block, create_each_block_3$2, t18, get_each_context_3$2);
            check_outros();
          }

          if (dirty[0] &
          /*onlines*/
          32) {
            each_value_2 = Object.entries(
            /*onlines*/
            ctx[5]);
            validate_each_argument(each_value_2);
            let i;

            for (i = 0; i < each_value_2.length; i += 1) {
              const child_ctx = get_each_context_2$4(ctx, each_value_2, i);

              if (each_blocks_2[i]) {
                each_blocks_2[i].p(child_ctx, dirty);
                transition_in(each_blocks_2[i], 1);
              } else {
                each_blocks_2[i] = create_each_block_2$4(child_ctx);
                each_blocks_2[i].c();
                transition_in(each_blocks_2[i], 1);
                each_blocks_2[i].m(ul0, t21);
              }
            }

            group_outros();

            for (i = each_value_2.length; i < each_blocks_2.length; i += 1) {
              out(i);
            }

            check_outros();
          }

          if (dirty[0] &
          /*onlines*/
          32) {
            each_value_1 = Object.entries(
            /*onlines*/
            ctx[5]);
            validate_each_argument(each_value_1);
            let i;

            for (i = 0; i < each_value_1.length; i += 1) {
              const child_ctx = get_each_context_1$8(ctx, each_value_1, i);

              if (each_blocks_1[i]) {
                each_blocks_1[i].p(child_ctx, dirty);
                transition_in(each_blocks_1[i], 1);
              } else {
                each_blocks_1[i] = create_each_block_1$8(child_ctx);
                each_blocks_1[i].c();
                transition_in(each_blocks_1[i], 1);
                each_blocks_1[i].m(ul0, null);
              }
            }

            group_outros();

            for (i = each_value_1.length; i < each_blocks_1.length; i += 1) {
              out_1(i);
            }

            check_outros();
          }

          const errorvalidacion1_changes = {};
          if (dirty[0] &
          /*error*/
          2) errorvalidacion1_changes.error =
          /*error*/
          ctx[1];
          errorvalidacion1.$set(errorvalidacion1_changes);

          if (dirty[0] &
          /*model*/
          1 && to_number(input3.value) !==
          /*model*/
          ctx[0].config.limiteBump) {
            set_input_value(input3,
            /*model*/
            ctx[0].config.limiteBump);
          }

          if (dirty[0] &
          /*model*/
          1 && to_number(input4.value) !==
          /*model*/
          ctx[0].config.tiempoEntreComentarios) {
            set_input_value(input4,
            /*model*/
            ctx[0].config.tiempoEntreComentarios);
          }

          if (dirty[0] &
          /*model*/
          1 && to_number(input5.value) !==
          /*model*/
          ctx[0].config.tiempoEntreHilos) {
            set_input_value(input5,
            /*model*/
            ctx[0].config.tiempoEntreHilos);
          }

          if (dirty[0] &
          /*model*/
          1 && to_number(input6.value) !==
          /*model*/
          ctx[0].config.hilosMaximosPorCategoria) {
            set_input_value(input6,
            /*model*/
            ctx[0].config.hilosMaximosPorCategoria);
          }

          if (dirty[0] &
          /*model*/
          1 && to_number(input7.value) !==
          /*model*/
          ctx[0].config.limiteArchivo) {
            set_input_value(input7,
            /*model*/
            ctx[0].config.limiteArchivo);
          }

          const checkbox0_changes = {};

          if (!updating_checked && dirty[0] &
          /*model*/
          1) {
            updating_checked = true;
            checkbox0_changes.checked =
            /*model*/
            ctx[0].config.captchaRegistro;
            add_flush_callback(() => updating_checked = false);
          }

          checkbox0.$set(checkbox0_changes);
          const checkbox1_changes = {};

          if (!updating_checked_1 && dirty[0] &
          /*model*/
          1) {
            updating_checked_1 = true;
            checkbox1_changes.checked =
            /*model*/
            ctx[0].config.captchaHilo;
            add_flush_callback(() => updating_checked_1 = false);
          }

          checkbox1.$set(checkbox1_changes);
          const checkbox2_changes = {};

          if (!updating_checked_2 && dirty[0] &
          /*model*/
          1) {
            updating_checked_2 = true;
            checkbox2_changes.checked =
            /*model*/
            ctx[0].config.captchaComentario;
            add_flush_callback(() => updating_checked_2 = false);
          }

          checkbox2.$set(checkbox2_changes);
          const checkbox3_changes = {};

          if (!updating_checked_3 && dirty[0] &
          /*model*/
          1) {
            updating_checked_3 = true;
            checkbox3_changes.checked =
            /*model*/
            ctx[0].config.ignorarDenunciasAnonimas;
            add_flush_callback(() => updating_checked_3 = false);
          }

          checkbox3.$set(checkbox3_changes);
          const button3_changes = {};

          if (dirty[1] &
          /*$$scope*/
          67108864) {
            button3_changes.$$scope = {
              dirty,
              ctx
            };
          }

          button3.$set(button3_changes);
          const errorvalidacion2_changes = {};
          if (dirty[0] &
          /*error*/
          2) errorvalidacion2_changes.error =
          /*error*/
          ctx[1];
          errorvalidacion2.$set(errorvalidacion2_changes);

          if (dirty[0] &
          /*model*/
          1 && to_number(input8.value) !==
          /*model*/
          ctx[0].config.numeroMaximoDeCuentasPorIp) {
            set_input_value(input8,
            /*model*/
            ctx[0].config.numeroMaximoDeCuentasPorIp);
          }

          const checkbox4_changes = {};

          if (!updating_checked_4 && dirty[0] &
          /*model*/
          1) {
            updating_checked_4 = true;
            checkbox4_changes.checked =
            /*model*/
            ctx[0].config.registroAbierto;
            add_flush_callback(() => updating_checked_4 = false);
          }

          checkbox4.$set(checkbox4_changes);

          if (!
          /*model*/
          ctx[0].config.registroAbierto) {
            if (if_block) {
              if_block.p(ctx, dirty);

              if (dirty[0] &
              /*model*/
              1) {
                transition_in(if_block, 1);
              }
            } else {
              if_block = create_if_block$A(ctx);
              if_block.c();
              transition_in(if_block, 1);
              if_block.m(ul2, t55);
            }
          } else if (if_block) {
            group_outros();
            transition_out(if_block, 1, 1, () => {
              if_block = null;
            });
            check_outros();
          }

          const button4_changes = {};

          if (dirty[1] &
          /*$$scope*/
          67108864) {
            button4_changes.$$scope = {
              dirty,
              ctx
            };
          }

          button4.$set(button4_changes);
          const errorvalidacion3_changes = {};
          if (dirty[0] &
          /*error*/
          2) errorvalidacion3_changes.error =
          /*error*/
          ctx[1];
          errorvalidacion3.$set(errorvalidacion3_changes);
          const checkbox5_changes = {};

          if (!updating_checked_5 && dirty[0] &
          /*model*/
          1) {
            updating_checked_5 = true;
            checkbox5_changes.checked =
            /*model*/
            ctx[0].config.modoMessi;
            add_flush_callback(() => updating_checked_5 = false);
          }

          checkbox5.$set(checkbox5_changes);
          const checkbox6_changes = {};

          if (!updating_checked_6 && dirty[0] &
          /*model*/
          1) {
            updating_checked_6 = true;
            checkbox6_changes.checked =
            /*model*/
            ctx[0].config.modoSerenito;
            add_flush_callback(() => updating_checked_6 = false);
          }

          checkbox6.$set(checkbox6_changes);

          if (dirty[0] &
          /*restriccionesDeAcesso, model*/
          1025) {
            each_value = Object.keys(
            /*restriccionesDeAcesso*/
            ctx[10]);
            validate_each_argument(each_value);
            let i;

            for (i = 0; i < each_value.length; i += 1) {
              const child_ctx = get_each_context$j(ctx, each_value, i);

              if (each_blocks[i]) {
                each_blocks[i].p(child_ctx, dirty);
                transition_in(each_blocks[i], 1);
              } else {
                each_blocks[i] = create_each_block$j(child_ctx);
                each_blocks[i].c();
                transition_in(each_blocks[i], 1);
                each_blocks[i].m(ul3, t65);
              }
            }

            group_outros();

            for (i = each_value.length; i < each_blocks.length; i += 1) {
              out_2(i);
            }

            check_outros();
          }

          if (dirty[0] &
          /*model*/
          1) {
            set_input_value(textarea0,
            /*model*/
            ctx[0].config.mensajePaginaDeChoque);
          }

          if (dirty[0] &
          /*model*/
          1 && input9.value !==
          /*model*/
          ctx[0].config.flags) {
            set_input_value(input9,
            /*model*/
            ctx[0].config.flags);
          }

          const button5_changes = {};

          if (dirty[1] &
          /*$$scope*/
          67108864) {
            button5_changes.$$scope = {
              dirty,
              ctx
            };
          }

          button5.$set(button5_changes);

          if (dirty[0] &
          /*model*/
          1) {
            set_input_value(textarea1,
            /*model*/
            ctx[0].config.palabrasCensuradas);
          }

          const button6_changes = {};

          if (dirty[1] &
          /*$$scope*/
          67108864) {
            button6_changes.$$scope = {
              dirty,
              ctx
            };
          }

          button6.$set(button6_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(errorvalidacion0.$$.fragment, local);
          transition_in(button0.$$.fragment, local);

          for (let i = 0; i < each_value_5.length; i += 1) {
            transition_in(each_blocks_5[i]);
          }

          transition_in(button1.$$.fragment, local);

          for (let i = 0; i < each_value_4.length; i += 1) {
            transition_in(each_blocks_4[i]);
          }

          transition_in(button2.$$.fragment, local);

          for (let i = 0; i < each_value_3.length; i += 1) {
            transition_in(each_blocks_3[i]);
          }

          for (let i = 0; i < each_value_2.length; i += 1) {
            transition_in(each_blocks_2[i]);
          }

          for (let i = 0; i < each_value_1.length; i += 1) {
            transition_in(each_blocks_1[i]);
          }

          transition_in(errorvalidacion1.$$.fragment, local);
          transition_in(checkbox0.$$.fragment, local);
          transition_in(checkbox1.$$.fragment, local);
          transition_in(checkbox2.$$.fragment, local);
          transition_in(checkbox3.$$.fragment, local);
          transition_in(button3.$$.fragment, local);
          transition_in(errorvalidacion2.$$.fragment, local);
          transition_in(checkbox4.$$.fragment, local);
          transition_in(if_block);
          transition_in(button4.$$.fragment, local);
          transition_in(errorvalidacion3.$$.fragment, local);
          transition_in(checkbox5.$$.fragment, local);
          transition_in(checkbox6.$$.fragment, local);

          for (let i = 0; i < each_value.length; i += 1) {
            transition_in(each_blocks[i]);
          }

          transition_in(button5.$$.fragment, local);
          transition_in(button6.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(errorvalidacion0.$$.fragment, local);
          transition_out(button0.$$.fragment, local);

          for (let i = 0; i < each_blocks_5.length; i += 1) {
            transition_out(each_blocks_5[i]);
          }

          transition_out(button1.$$.fragment, local);

          for (let i = 0; i < each_blocks_4.length; i += 1) {
            transition_out(each_blocks_4[i]);
          }

          transition_out(button2.$$.fragment, local);

          for (let i = 0; i < each_blocks_3.length; i += 1) {
            transition_out(each_blocks_3[i]);
          }

          each_blocks_2 = each_blocks_2.filter(Boolean);

          for (let i = 0; i < each_blocks_2.length; i += 1) {
            transition_out(each_blocks_2[i]);
          }

          each_blocks_1 = each_blocks_1.filter(Boolean);

          for (let i = 0; i < each_blocks_1.length; i += 1) {
            transition_out(each_blocks_1[i]);
          }

          transition_out(errorvalidacion1.$$.fragment, local);
          transition_out(checkbox0.$$.fragment, local);
          transition_out(checkbox1.$$.fragment, local);
          transition_out(checkbox2.$$.fragment, local);
          transition_out(checkbox3.$$.fragment, local);
          transition_out(button3.$$.fragment, local);
          transition_out(errorvalidacion2.$$.fragment, local);
          transition_out(checkbox4.$$.fragment, local);
          transition_out(if_block);
          transition_out(button4.$$.fragment, local);
          transition_out(errorvalidacion3.$$.fragment, local);
          transition_out(checkbox5.$$.fragment, local);
          transition_out(checkbox6.$$.fragment, local);
          each_blocks = each_blocks.filter(Boolean);

          for (let i = 0; i < each_blocks.length; i += 1) {
            transition_out(each_blocks[i]);
          }

          transition_out(button5.$$.fragment, local);
          transition_out(button6.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(main);
          destroy_component(errorvalidacion0);
          destroy_component(button0);

          for (let i = 0; i < each_blocks_5.length; i += 1) {
            each_blocks_5[i].d();
          }

          destroy_component(button1);

          for (let i = 0; i < each_blocks_4.length; i += 1) {
            each_blocks_4[i].d();
          }

          destroy_component(button2);

          for (let i = 0; i < each_blocks_3.length; i += 1) {
            each_blocks_3[i].d();
          }

          destroy_each(each_blocks_2, detaching);
          destroy_each(each_blocks_1, detaching);
          destroy_component(errorvalidacion1);
          destroy_component(checkbox0);
          destroy_component(checkbox1);
          destroy_component(checkbox2);
          destroy_component(checkbox3);
          destroy_component(button3);
          destroy_component(errorvalidacion2);
          destroy_component(checkbox4);
          if (if_block) if_block.d();
          destroy_component(button4);
          destroy_component(errorvalidacion3);
          destroy_component(checkbox5);
          destroy_component(checkbox6);
          destroy_each(each_blocks, detaching);
          destroy_component(button5);
          destroy_component(button6);
          mounted = false;
          run_all(dispose);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$N.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }

    function instance$N($$self, $$props, $$invalidate) {
      let {
        $$slots: slots = {},
        $$scope
      } = $$props;
      validate_slots("Administracion", slots, []);
      let model = window.model;
      let error = null;
      let nickAdmin = "";
      let nickMod = "";
      let nickAux = "";
      let restAcc = 0;

      async function eliminar(nick, rol) {
        try {
          let res = await RChanClient.removerRol(nick, rol);
          console.log(res);
          alert(res.data.mensaje);
        } catch (e) {
          console.log(e.response);
          $$invalidate(1, error = e.response.data);
          return;
        }
      }

      async function añadir(nick, rol) {
        try {
          let res = await RChanClient.añadirRol(nick, rol);
          console.log(res);
          alert(res.data.mensaje);
        } catch (e) {
          console.log(e.response);
          $$invalidate(1, error = e.response.data);
          return;
        }
      }

      async function actualizarConfig() {
        try {
          let res = await RChanClient.ActualizarConfiguracion(model.config);
          console.log(res);
          alert(res.data.mensaje);
        } catch (e) {
          console.log(e.response);
          $$invalidate(1, error = e.response.data);
          return;
        }
      }

      async function generarLink() {
        try {
          const res = await RChanClient.generarNuevoLinkDeInvitacion();
          $$invalidate(0, model.config.linkDeInvitacion = res.data.link, model);
          alert("Nuevo link generado");
        } catch (error) {}
      }

      let onlines = {};

      async function refrescar() {
        try {
          let res = await RChanClient.refrescarOnlines();
          $$invalidate(5, onlines = res.data);
        } catch (e) {
          console.log(e.response);
          $$invalidate(1, error = e.response.data);
          return;
        }
      }

      setInterval(refrescar, 10000);
      setTimeout(refrescar, 1000);
      let restriccionDeAcesso = 2;
      let restriccionesDeAcesso = {
        Libre: 0,
        Registrados: 1,
        Administradores: 2
      };
      const writable_props = [];
      Object_1$6.keys($$props).forEach(key => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$c.warn(`<Administracion> was created with unknown prop '${key}'`);
      });

      function input0_input_handler() {
        nickAdmin = this.value;
        $$invalidate(2, nickAdmin);
      }

      const click_handler = () => añadir(nickAdmin, "admin");

      const click_handler_1 = a => eliminar(a.id, "admin");

      function input1_input_handler() {
        nickMod = this.value;
        $$invalidate(3, nickMod);
      }

      const click_handler_2 = () => añadir(nickMod, "mod");

      const click_handler_3 = m => eliminar(m.id, "mod");

      function input2_input_handler() {
        nickAux = this.value;
        $$invalidate(4, nickAux);
      }

      const click_handler_4 = () => añadir(nickAux, "auxiliar");

      const click_handler_5 = m => eliminar(m.id, "auxiliar");

      function input3_input_handler() {
        model.config.limiteBump = to_number(this.value);
        $$invalidate(0, model);
      }

      function input4_input_handler() {
        model.config.tiempoEntreComentarios = to_number(this.value);
        $$invalidate(0, model);
      }

      function input5_input_handler() {
        model.config.tiempoEntreHilos = to_number(this.value);
        $$invalidate(0, model);
      }

      function input6_input_handler() {
        model.config.hilosMaximosPorCategoria = to_number(this.value);
        $$invalidate(0, model);
      }

      function input7_input_handler() {
        model.config.limiteArchivo = to_number(this.value);
        $$invalidate(0, model);
      }

      function checkbox0_checked_binding(value) {
        model.config.captchaRegistro = value;
        $$invalidate(0, model);
      }

      function checkbox1_checked_binding(value) {
        model.config.captchaHilo = value;
        $$invalidate(0, model);
      }

      function checkbox2_checked_binding(value) {
        model.config.captchaComentario = value;
        $$invalidate(0, model);
      }

      function checkbox3_checked_binding(value) {
        model.config.ignorarDenunciasAnonimas = value;
        $$invalidate(0, model);
      }

      function input8_input_handler() {
        model.config.numeroMaximoDeCuentasPorIp = to_number(this.value);
        $$invalidate(0, model);
      }

      function checkbox4_checked_binding(value) {
        model.config.registroAbierto = value;
        $$invalidate(0, model);
      }

      function checkbox5_checked_binding(value) {
        model.config.modoMessi = value;
        $$invalidate(0, model);
      }

      function checkbox6_checked_binding(value) {
        model.config.modoSerenito = value;
        $$invalidate(0, model);
      }

      function radio_group_binding(value) {
        model.config.restriccionDeAcceso = value;
        $$invalidate(0, model);
      }

      function textarea0_input_handler() {
        model.config.mensajePaginaDeChoque = this.value;
        $$invalidate(0, model);
      }

      function input9_input_handler() {
        model.config.flags = this.value;
        $$invalidate(0, model);
      }

      function textarea1_input_handler() {
        model.config.palabrasCensuradas = this.value;
        $$invalidate(0, model);
      }

      $$self.$capture_state = () => ({
        Button: ye,
        Checkbox: Ne,
        Radio: Fn,
        config,
        RChanClient,
        Dialogo,
        ErrorValidacion,
        Sigal: Signal,
        Tiempo,
        model,
        error,
        nickAdmin,
        nickMod,
        nickAux,
        restAcc,
        eliminar,
        añadir,
        actualizarConfig,
        generarLink,
        onlines,
        refrescar,
        restriccionDeAcesso,
        restriccionesDeAcesso
      });

      $$self.$inject_state = $$props => {
        if ("model" in $$props) $$invalidate(0, model = $$props.model);
        if ("error" in $$props) $$invalidate(1, error = $$props.error);
        if ("nickAdmin" in $$props) $$invalidate(2, nickAdmin = $$props.nickAdmin);
        if ("nickMod" in $$props) $$invalidate(3, nickMod = $$props.nickMod);
        if ("nickAux" in $$props) $$invalidate(4, nickAux = $$props.nickAux);
        if ("restAcc" in $$props) restAcc = $$props.restAcc;
        if ("onlines" in $$props) $$invalidate(5, onlines = $$props.onlines);
        if ("restriccionDeAcesso" in $$props) restriccionDeAcesso = $$props.restriccionDeAcesso;
        if ("restriccionesDeAcesso" in $$props) $$invalidate(10, restriccionesDeAcesso = $$props.restriccionesDeAcesso);
      };

      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }

      return [model, error, nickAdmin, nickMod, nickAux, onlines, eliminar, añadir, actualizarConfig, generarLink, restriccionesDeAcesso, input0_input_handler, click_handler, click_handler_1, input1_input_handler, click_handler_2, click_handler_3, input2_input_handler, click_handler_4, click_handler_5, input3_input_handler, input4_input_handler, input5_input_handler, input6_input_handler, input7_input_handler, checkbox0_checked_binding, checkbox1_checked_binding, checkbox2_checked_binding, checkbox3_checked_binding, input8_input_handler, checkbox4_checked_binding, checkbox5_checked_binding, checkbox6_checked_binding, radio_group_binding, textarea0_input_handler, input9_input_handler, textarea1_input_handler];
    }

    class Administracion extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$N, create_fragment$N, safe_not_equal, {}, [-1, -1]);
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "Administracion",
          options,
          id: create_fragment$N.name
        });
      }

    }

    /* src\components\Moderacion\BarraModeracion.svelte generated by Svelte v3.29.0 */
    const file$L = "src\\components\\Moderacion\\BarraModeracion.svelte"; // (8:30) <Button outlined>

    function create_default_slot_5$a(ctx) {
      let t;
      const block = {
        c: function create() {
          t = text("Pagina principal");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_5$a.name,
        type: "slot",
        source: "(8:30) <Button outlined>",
        ctx
      });
      return block;
    } // (10:13) <Button outlined>


    function create_default_slot_4$f(ctx) {
      let t;
      const block = {
        c: function create() {
          t = text("Imagenes y videos");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_4$f.name,
        type: "slot",
        source: "(10:13) <Button outlined>",
        ctx
      });
      return block;
    } // (12:8) {#if $globalStore.usuario.esAdmin}


    function create_if_block$B(ctx) {
      let a0;
      let button0;
      let t0;
      let a1;
      let button1;
      let t1;
      let a2;
      let button2;
      let current;
      button0 = new ye({
        props: {
          outlined: true,
          $$slots: {
            default: [create_default_slot_3$j]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      button1 = new ye({
        props: {
          outlined: true,
          $$slots: {
            default: [create_default_slot_2$l]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      button2 = new ye({
        props: {
          outlined: true,
          $$slots: {
            default: [create_default_slot_1$o]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          a0 = element("a");
          create_component(button0.$$.fragment);
          t0 = space();
          a1 = element("a");
          create_component(button1.$$.fragment);
          t1 = space();
          a2 = element("a");
          create_component(button2.$$.fragment);
          attr_dev(a0, "href", "/Moderacion/ListaDeUsuarios");
          add_location(a0, file$L, 12, 12, 477);
          attr_dev(a1, "href", "/Moderacion/EliminadosYDesactivados");
          add_location(a1, file$L, 15, 12, 608);
          attr_dev(a2, "href", "/Moderacion/Historial");
          add_location(a2, file$L, 18, 12, 755);
        },
        m: function mount(target, anchor) {
          insert_dev(target, a0, anchor);
          mount_component(button0, a0, null);
          insert_dev(target, t0, anchor);
          insert_dev(target, a1, anchor);
          mount_component(button1, a1, null);
          insert_dev(target, t1, anchor);
          insert_dev(target, a2, anchor);
          mount_component(button2, a2, null);
          current = true;
        },
        i: function intro(local) {
          if (current) return;
          transition_in(button0.$$.fragment, local);
          transition_in(button1.$$.fragment, local);
          transition_in(button2.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(button0.$$.fragment, local);
          transition_out(button1.$$.fragment, local);
          transition_out(button2.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(a0);
          destroy_component(button0);
          if (detaching) detach_dev(t0);
          if (detaching) detach_dev(a1);
          destroy_component(button1);
          if (detaching) detach_dev(t1);
          if (detaching) detach_dev(a2);
          destroy_component(button2);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block$B.name,
        type: "if",
        source: "(12:8) {#if $globalStore.usuario.esAdmin}",
        ctx
      });
      return block;
    } // (14:17) <Button outlined>


    function create_default_slot_3$j(ctx) {
      let t;
      const block = {
        c: function create() {
          t = text("Usuarios y baneos");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_3$j.name,
        type: "slot",
        source: "(14:17) <Button outlined>",
        ctx
      });
      return block;
    } // (17:17) <Button outlined>


    function create_default_slot_2$l(ctx) {
      let t;
      const block = {
        c: function create() {
          t = text("Eliminados y desactivados");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_2$l.name,
        type: "slot",
        source: "(17:17) <Button outlined>",
        ctx
      });
      return block;
    } // (20:17) <Button outlined>


    function create_default_slot_1$o(ctx) {
      let t;
      const block = {
        c: function create() {
          t = text("Historial");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_1$o.name,
        type: "slot",
        source: "(20:17) <Button outlined>",
        ctx
      });
      return block;
    } // (7:4) <ButtonGroup color="var(--color7)">


    function create_default_slot$t(ctx) {
      let a0;
      let button0;
      let t0;
      let a1;
      let button1;
      let t1;
      let if_block_anchor;
      let current;
      button0 = new ye({
        props: {
          outlined: true,
          $$slots: {
            default: [create_default_slot_5$a]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      button1 = new ye({
        props: {
          outlined: true,
          $$slots: {
            default: [create_default_slot_4$f]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      let if_block =
      /*$globalStore*/
      ctx[0].usuario.esAdmin && create_if_block$B(ctx);
      const block = {
        c: function create() {
          a0 = element("a");
          create_component(button0.$$.fragment);
          t0 = space();
          a1 = element("a");
          create_component(button1.$$.fragment);
          t1 = space();
          if (if_block) if_block.c();
          if_block_anchor = empty();
          attr_dev(a0, "href", "/Moderacion");
          add_location(a0, file$L, 7, 8, 241);
          attr_dev(a1, "href", "/Moderacion/Media");
          add_location(a1, file$L, 8, 8, 320);
        },
        m: function mount(target, anchor) {
          insert_dev(target, a0, anchor);
          mount_component(button0, a0, null);
          insert_dev(target, t0, anchor);
          insert_dev(target, a1, anchor);
          mount_component(button1, a1, null);
          insert_dev(target, t1, anchor);
          if (if_block) if_block.m(target, anchor);
          insert_dev(target, if_block_anchor, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          const button0_changes = {};

          if (dirty &
          /*$$scope*/
          2) {
            button0_changes.$$scope = {
              dirty,
              ctx
            };
          }

          button0.$set(button0_changes);
          const button1_changes = {};

          if (dirty &
          /*$$scope*/
          2) {
            button1_changes.$$scope = {
              dirty,
              ctx
            };
          }

          button1.$set(button1_changes);

          if (
          /*$globalStore*/
          ctx[0].usuario.esAdmin) {
            if (if_block) {
              if (dirty &
              /*$globalStore*/
              1) {
                transition_in(if_block, 1);
              }
            } else {
              if_block = create_if_block$B(ctx);
              if_block.c();
              transition_in(if_block, 1);
              if_block.m(if_block_anchor.parentNode, if_block_anchor);
            }
          } else if (if_block) {
            group_outros();
            transition_out(if_block, 1, 1, () => {
              if_block = null;
            });
            check_outros();
          }
        },
        i: function intro(local) {
          if (current) return;
          transition_in(button0.$$.fragment, local);
          transition_in(button1.$$.fragment, local);
          transition_in(if_block);
          current = true;
        },
        o: function outro(local) {
          transition_out(button0.$$.fragment, local);
          transition_out(button1.$$.fragment, local);
          transition_out(if_block);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(a0);
          destroy_component(button0);
          if (detaching) detach_dev(t0);
          if (detaching) detach_dev(a1);
          destroy_component(button1);
          if (detaching) detach_dev(t1);
          if (if_block) if_block.d(detaching);
          if (detaching) detach_dev(if_block_anchor);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot$t.name,
        type: "slot",
        source: "(7:4) <ButtonGroup color=\\\"var(--color7)\\\">",
        ctx
      });
      return block;
    }

    function create_fragment$O(ctx) {
      let nav;
      let buttongroup;
      let current;
      buttongroup = new $e({
        props: {
          color: "var(--color7)",
          $$slots: {
            default: [create_default_slot$t]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          nav = element("nav");
          create_component(buttongroup.$$.fragment);
          attr_dev(nav, "class", "moderacion-nav svelte-ebkvgx");
          set_style(nav, "width", "100%");
          set_style(nav, "margin", "0 auto");
          add_location(nav, file$L, 5, 0, 128);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, nav, anchor);
          mount_component(buttongroup, nav, null);
          current = true;
        },
        p: function update(ctx, [dirty]) {
          const buttongroup_changes = {};

          if (dirty &
          /*$$scope, $globalStore*/
          3) {
            buttongroup_changes.$$scope = {
              dirty,
              ctx
            };
          }

          buttongroup.$set(buttongroup_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(buttongroup.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(buttongroup.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(nav);
          destroy_component(buttongroup);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$O.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }

    function instance$O($$self, $$props, $$invalidate) {
      let $globalStore;
      validate_store(globalStore, "globalStore");
      component_subscribe($$self, globalStore, $$value => $$invalidate(0, $globalStore = $$value));
      let {
        $$slots: slots = {},
        $$scope
      } = $$props;
      validate_slots("BarraModeracion", slots, []);
      const writable_props = [];
      Object.keys($$props).forEach(key => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<BarraModeracion> was created with unknown prop '${key}'`);
      });

      $$self.$capture_state = () => ({
        ButtonGroup: $e,
        Button: ye,
        globalStore,
        $globalStore
      });

      return [$globalStore];
    }

    class BarraModeracion extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$O, create_fragment$O, safe_not_equal, {});
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "BarraModeracion",
          options,
          id: create_fragment$O.name
        });
      }

    }

    /* src\components\Moderacion\ComentarioMod.svelte generated by Svelte v3.29.0 */
    const file$M = "src\\components\\Moderacion\\ComentarioMod.svelte";

    function create_fragment$P(ctx) {
      let div;
      let comentario_1;
      let current;
      comentario_1 = new Comentario({
        props: {
          hilo: {
            id:
            /*comentario*/
            ctx[0].hiloId
          },
          comentario:
          /*comentario*/
          ctx[0]
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          div = element("div");
          create_component(comentario_1.$$.fragment);
          toggle_class(div, "eliminado",
          /*comentario*/
          ctx[0].estado == ComentarioEstado.eliminado);
          add_location(div, file$M, 6, 0, 168);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          mount_component(comentario_1, div, null);
          current = true;
        },
        p: function update(ctx, [dirty]) {
          const comentario_1_changes = {};
          if (dirty &
          /*comentario*/
          1) comentario_1_changes.hilo = {
            id:
            /*comentario*/
            ctx[0].hiloId
          };
          if (dirty &
          /*comentario*/
          1) comentario_1_changes.comentario =
          /*comentario*/
          ctx[0];
          comentario_1.$set(comentario_1_changes);

          if (dirty &
          /*comentario, ComentarioEstado*/
          1) {
            toggle_class(div, "eliminado",
            /*comentario*/
            ctx[0].estado == ComentarioEstado.eliminado);
          }
        },
        i: function intro(local) {
          if (current) return;
          transition_in(comentario_1.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(comentario_1.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
          destroy_component(comentario_1);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$P.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }

    function instance$P($$self, $$props, $$invalidate) {
      let {
        $$slots: slots = {},
        $$scope
      } = $$props;
      validate_slots("ComentarioMod", slots, []);
      let {
        comentario
      } = $$props;
      const writable_props = ["comentario"];
      Object.keys($$props).forEach(key => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ComentarioMod> was created with unknown prop '${key}'`);
      });

      $$self.$$set = $$props => {
        if ("comentario" in $$props) $$invalidate(0, comentario = $$props.comentario);
      };

      $$self.$capture_state = () => ({
        ComentarioEstado,
        Comentario,
        comentario
      });

      $$self.$inject_state = $$props => {
        if ("comentario" in $$props) $$invalidate(0, comentario = $$props.comentario);
      };

      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }

      return [comentario];
    }

    class ComentarioMod extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$P, create_fragment$P, safe_not_equal, {
          comentario: 0
        });
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "ComentarioMod",
          options,
          id: create_fragment$P.name
        });
        const {
          ctx
        } = this.$$;
        const props = options.props || {};

        if (
        /*comentario*/
        ctx[0] === undefined && !("comentario" in props)) {
          console.warn("<ComentarioMod> was created without expected prop 'comentario'");
        }
      }

      get comentario() {
        throw new Error("<ComentarioMod>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set comentario(value) {
        throw new Error("<ComentarioMod>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

    }

    /* src\components\Paginas\Moderacion.svelte generated by Svelte v3.29.0 */
    const {
      window: window_1$2
    } = globals;
    const file$N = "src\\components\\Paginas\\Moderacion.svelte";

    function get_each_context$k(ctx, list, i) {
      const child_ctx = ctx.slice();
      child_ctx[10] = list[i];
      return child_ctx;
    }

    function get_each_context_1$9(ctx, list, i) {
      const child_ctx = ctx.slice();
      child_ctx[13] = list[i];
      return child_ctx;
    }

    function get_each_context_2$5(ctx, list, i) {
      const child_ctx = ctx.slice();
      child_ctx[16] = list[i];
      return child_ctx;
    }

    function get_each_context_3$3(ctx, list, i) {
      const child_ctx = ctx.slice();
      child_ctx[10] = list[i];
      return child_ctx;
    } // (94:12) {#each comentariosMedia as c}


    function create_each_block_3$3(ctx) {
      let li;
      let a;
      let img;
      let img_src_value;
      let a_href_value;
      let t;
      const block = {
        c: function create() {
          li = element("li");
          a = element("a");
          img = element("img");
          t = space();
          if (img.src !== (img_src_value =
          /*c*/
          ctx[10].media.vistaPreviaCuadrado)) attr_dev(img, "src", img_src_value);
          attr_dev(img, "alt", "");
          attr_dev(img, "class", "svelte-x3q4q5");
          add_location(img, file$N, 96, 24, 3381);
          attr_dev(a, "href", a_href_value = "/Hilo/" +
          /*c*/
          ctx[10].hiloId + "#" +
          /*c*/
          ctx[10].id);
          add_location(a, file$N, 95, 20, 3321);
          add_location(li, file$N, 94, 16, 3295);
        },
        m: function mount(target, anchor) {
          insert_dev(target, li, anchor);
          append_dev(li, a);
          append_dev(a, img);
          append_dev(li, t);
        },
        p: noop,
        d: function destroy(detaching) {
          if (detaching) detach_dev(li);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_each_block_3$3.name,
        type: "each",
        source: "(94:12) {#each comentariosMedia as c}",
        ctx
      });
      return block;
    } // (103:4) {#if innerWidth < 956}


    function create_if_block_3$g(ctx) {
      let div;
      let button0;
      let t0;
      let button0_class_value;
      let t1;
      let button1;
      let t2;
      let button1_class_value;
      let t3;
      let button2;
      let t4;
      let button2_class_value;
      let mounted;
      let dispose;
      const block = {
        c: function create() {
          div = element("div");
          button0 = element("button");
          t0 = text("Denuncias");
          t1 = space();
          button1 = element("button");
          t2 = text("Hilos");
          t3 = space();
          button2 = element("button");
          t4 = text("Comentarios");
          attr_dev(button0, "id", "tab1");
          attr_dev(button0, "class", button0_class_value = "boton " + (
          /*current*/
          ctx[1] === 1 ? "active" : "") + " svelte-x3q4q5");
          add_location(button0, file$N, 104, 12, 3608);
          attr_dev(button1, "id", "tab2");
          attr_dev(button1, "class", button1_class_value = "boton " + (
          /*current*/
          ctx[1] === 2 ? "active" : "") + " svelte-x3q4q5");
          add_location(button1, file$N, 111, 12, 3832);
          attr_dev(button2, "id", "tab3");
          attr_dev(button2, "class", button2_class_value = "boton " + (
          /*current*/
          ctx[1] === 3 ? "active" : "") + " svelte-x3q4q5");
          add_location(button2, file$N, 118, 12, 4052);
          attr_dev(div, "id", "botones");
          attr_dev(div, "class", "tab svelte-x3q4q5");
          add_location(div, file$N, 103, 8, 3564);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          append_dev(div, button0);
          append_dev(button0, t0);
          append_dev(div, t1);
          append_dev(div, button1);
          append_dev(button1, t2);
          append_dev(div, t3);
          append_dev(div, button2);
          append_dev(button2, t4);

          if (!mounted) {
            dispose = [listen_dev(button0, "click",
            /*click_handler*/
            ctx[7], false, false, false), listen_dev(button1, "click",
            /*click_handler_1*/
            ctx[8], false, false, false), listen_dev(button2, "click",
            /*click_handler_2*/
            ctx[9], false, false, false)];
            mounted = true;
          }
        },
        p: function update(ctx, dirty) {
          if (dirty &
          /*current*/
          2 && button0_class_value !== (button0_class_value = "boton " + (
          /*current*/
          ctx[1] === 1 ? "active" : "") + " svelte-x3q4q5")) {
            attr_dev(button0, "class", button0_class_value);
          }

          if (dirty &
          /*current*/
          2 && button1_class_value !== (button1_class_value = "boton " + (
          /*current*/
          ctx[1] === 2 ? "active" : "") + " svelte-x3q4q5")) {
            attr_dev(button1, "class", button1_class_value);
          }

          if (dirty &
          /*current*/
          2 && button2_class_value !== (button2_class_value = "boton " + (
          /*current*/
          ctx[1] === 3 ? "active" : "") + " svelte-x3q4q5")) {
            attr_dev(button2, "class", button2_class_value);
          }
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
          mounted = false;
          run_all(dispose);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_3$g.name,
        type: "if",
        source: "(103:4) {#if innerWidth < 956}",
        ctx
      });
      return block;
    } // (129:8) {#if innerWidth > 956 || current === 1}


    function create_if_block_2$o(ctx) {
      let ul;
      let h3;
      let t1;
      let each_blocks = [];
      let each_1_lookup = new Map();
      let ul_class_value;
      let current;
      let each_value_2 =
      /*denuncias*/
      ctx[4];
      validate_each_argument(each_value_2);

      const get_key = ctx =>
      /*d*/
      ctx[16].id;

      validate_each_keys(ctx, each_value_2, get_each_context_2$5, get_key);

      for (let i = 0; i < each_value_2.length; i += 1) {
        let child_ctx = get_each_context_2$5(ctx, each_value_2, i);
        let key = get_key(child_ctx);
        each_1_lookup.set(key, each_blocks[i] = create_each_block_2$5(key, child_ctx));
      }

      const block = {
        c: function create() {
          ul = element("ul");
          h3 = element("h3");
          h3.textContent = "Ultimas denuncias";
          t1 = space();

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].c();
          }

          set_style(h3, "height", "40px");
          add_location(h3, file$N, 133, 16, 4588);
          set_style(ul, "width", "33%");
          set_style(ul, "background", "#711c08");
          set_style(ul, "font-size", "0.7em");
          set_style(ul, "min-width", "33%");
          attr_dev(ul, "class", ul_class_value = "" + (null_to_empty(
          /*innerWidth*/
          ctx[0] <= 956 ? "resize" : "") + " svelte-x3q4q5"));
          add_location(ul, file$N, 129, 12, 4405);
        },
        m: function mount(target, anchor) {
          insert_dev(target, ul, anchor);
          append_dev(ul, h3);
          append_dev(ul, t1);

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].m(ul, null);
          }

          current = true;
        },
        p: function update(ctx, dirty) {
          if (dirty &
          /*denuncias*/
          16) {
            const each_value_2 =
            /*denuncias*/
            ctx[4];
            validate_each_argument(each_value_2);
            group_outros();
            validate_each_keys(ctx, each_value_2, get_each_context_2$5, get_key);
            each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value_2, each_1_lookup, ul, outro_and_destroy_block, create_each_block_2$5, null, get_each_context_2$5);
            check_outros();
          }

          if (!current || dirty &
          /*innerWidth*/
          1 && ul_class_value !== (ul_class_value = "" + (null_to_empty(
          /*innerWidth*/
          ctx[0] <= 956 ? "resize" : "") + " svelte-x3q4q5"))) {
            attr_dev(ul, "class", ul_class_value);
          }
        },
        i: function intro(local) {
          if (current) return;

          for (let i = 0; i < each_value_2.length; i += 1) {
            transition_in(each_blocks[i]);
          }

          current = true;
        },
        o: function outro(local) {
          for (let i = 0; i < each_blocks.length; i += 1) {
            transition_out(each_blocks[i]);
          }

          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(ul);

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].d();
          }
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_2$o.name,
        type: "if",
        source: "(129:8) {#if innerWidth > 956 || current === 1}",
        ctx
      });
      return block;
    } // (135:16) {#each denuncias as d (d.id)}


    function create_each_block_2$5(key_1, ctx) {
      let first;
      let denuncia;
      let current;
      denuncia = new Denuncia({
        props: {
          denuncia:
          /*d*/
          ctx[16]
        },
        $$inline: true
      });
      const block = {
        key: key_1,
        first: null,
        c: function create() {
          first = empty();
          create_component(denuncia.$$.fragment);
          this.first = first;
        },
        m: function mount(target, anchor) {
          insert_dev(target, first, anchor);
          mount_component(denuncia, target, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          const denuncia_changes = {};
          if (dirty &
          /*denuncias*/
          16) denuncia_changes.denuncia =
          /*d*/
          ctx[16];
          denuncia.$set(denuncia_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(denuncia.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(denuncia.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(first);
          destroy_component(denuncia, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_each_block_2$5.name,
        type: "each",
        source: "(135:16) {#each denuncias as d (d.id)}",
        ctx
      });
      return block;
    } // (140:8) {#if innerWidth > 956 || current === 2}


    function create_if_block_1$p(ctx) {
      let ul;
      let h3;
      let t1;
      let each_blocks = [];
      let each_1_lookup = new Map();
      let ul_class_value;
      let current;
      let each_value_1 =
      /*hilos*/
      ctx[2];
      validate_each_argument(each_value_1);

      const get_key = ctx =>
      /*h*/
      ctx[13].id;

      validate_each_keys(ctx, each_value_1, get_each_context_1$9, get_key);

      for (let i = 0; i < each_value_1.length; i += 1) {
        let child_ctx = get_each_context_1$9(ctx, each_value_1, i);
        let key = get_key(child_ctx);
        each_1_lookup.set(key, each_blocks[i] = create_each_block_1$9(key, child_ctx));
      }

      const block = {
        c: function create() {
          ul = element("ul");
          h3 = element("h3");
          h3.textContent = "Ultimos hilos";
          t1 = space();

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].c();
          }

          set_style(h3, "height", "40px");
          add_location(h3, file$N, 144, 16, 4995);
          set_style(ul, "width", "33%");
          set_style(ul, "min-width", "33%");
          attr_dev(ul, "class", ul_class_value = "" + (null_to_empty(
          /*innerWidth*/
          ctx[0] <= 956 ? "resize" : "") + " svelte-x3q4q5"));
          add_location(ul, file$N, 140, 12, 4850);
        },
        m: function mount(target, anchor) {
          insert_dev(target, ul, anchor);
          append_dev(ul, h3);
          append_dev(ul, t1);

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].m(ul, null);
          }

          current = true;
        },
        p: function update(ctx, dirty) {
          if (dirty &
          /*hilos*/
          4) {
            const each_value_1 =
            /*hilos*/
            ctx[2];
            validate_each_argument(each_value_1);
            group_outros();
            validate_each_keys(ctx, each_value_1, get_each_context_1$9, get_key);
            each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value_1, each_1_lookup, ul, outro_and_destroy_block, create_each_block_1$9, null, get_each_context_1$9);
            check_outros();
          }

          if (!current || dirty &
          /*innerWidth*/
          1 && ul_class_value !== (ul_class_value = "" + (null_to_empty(
          /*innerWidth*/
          ctx[0] <= 956 ? "resize" : "") + " svelte-x3q4q5"))) {
            attr_dev(ul, "class", ul_class_value);
          }
        },
        i: function intro(local) {
          if (current) return;

          for (let i = 0; i < each_value_1.length; i += 1) {
            transition_in(each_blocks[i]);
          }

          current = true;
        },
        o: function outro(local) {
          for (let i = 0; i < each_blocks.length; i += 1) {
            transition_out(each_blocks[i]);
          }

          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(ul);

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].d();
          }
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_1$p.name,
        type: "if",
        source: "(140:8) {#if innerWidth > 956 || current === 2}",
        ctx
      });
      return block;
    } // (146:16) {#each hilos as h (h.id)}


    function create_each_block_1$9(key_1, ctx) {
      let first;
      let hilopreviewmod;
      let current;
      hilopreviewmod = new HiloPreviewMod({
        props: {
          hilo:
          /*h*/
          ctx[13]
        },
        $$inline: true
      });
      const block = {
        key: key_1,
        first: null,
        c: function create() {
          first = empty();
          create_component(hilopreviewmod.$$.fragment);
          this.first = first;
        },
        m: function mount(target, anchor) {
          insert_dev(target, first, anchor);
          mount_component(hilopreviewmod, target, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          const hilopreviewmod_changes = {};
          if (dirty &
          /*hilos*/
          4) hilopreviewmod_changes.hilo =
          /*h*/
          ctx[13];
          hilopreviewmod.$set(hilopreviewmod_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(hilopreviewmod.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(hilopreviewmod.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(first);
          destroy_component(hilopreviewmod, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_each_block_1$9.name,
        type: "each",
        source: "(146:16) {#each hilos as h (h.id)}",
        ctx
      });
      return block;
    } // (151:8) {#if innerWidth > 956 || current === 3}


    function create_if_block$C(ctx) {
      let ul;
      let h3;
      let t1;
      let each_blocks = [];
      let each_1_lookup = new Map();
      let ul_class_value;
      let current;
      let each_value =
      /*comentarios*/
      ctx[3];
      validate_each_argument(each_value);

      const get_key = ctx =>
      /*c*/
      ctx[10].id;

      validate_each_keys(ctx, each_value, get_each_context$k, get_key);

      for (let i = 0; i < each_value.length; i += 1) {
        let child_ctx = get_each_context$k(ctx, each_value, i);
        let key = get_key(child_ctx);
        each_1_lookup.set(key, each_blocks[i] = create_each_block$k(key, child_ctx));
      }

      const block = {
        c: function create() {
          ul = element("ul");
          h3 = element("h3");
          h3.textContent = "Ultimos comentarios";
          t1 = space();

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].c();
          }

          set_style(h3, "height", "40px");
          add_location(h3, file$N, 155, 16, 5396);
          set_style(ul, "width", "33%");
          set_style(ul, "min-width", "33%");
          attr_dev(ul, "class", ul_class_value = "" + (null_to_empty(
          /*innerWidth*/
          ctx[0] <= 956 ? "resize" : "") + " svelte-x3q4q5"));
          add_location(ul, file$N, 151, 12, 5251);
        },
        m: function mount(target, anchor) {
          insert_dev(target, ul, anchor);
          append_dev(ul, h3);
          append_dev(ul, t1);

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].m(ul, null);
          }

          current = true;
        },
        p: function update(ctx, dirty) {
          if (dirty &
          /*comentarios*/
          8) {
            const each_value =
            /*comentarios*/
            ctx[3];
            validate_each_argument(each_value);
            group_outros();
            validate_each_keys(ctx, each_value, get_each_context$k, get_key);
            each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, ul, outro_and_destroy_block, create_each_block$k, null, get_each_context$k);
            check_outros();
          }

          if (!current || dirty &
          /*innerWidth*/
          1 && ul_class_value !== (ul_class_value = "" + (null_to_empty(
          /*innerWidth*/
          ctx[0] <= 956 ? "resize" : "") + " svelte-x3q4q5"))) {
            attr_dev(ul, "class", ul_class_value);
          }
        },
        i: function intro(local) {
          if (current) return;

          for (let i = 0; i < each_value.length; i += 1) {
            transition_in(each_blocks[i]);
          }

          current = true;
        },
        o: function outro(local) {
          for (let i = 0; i < each_blocks.length; i += 1) {
            transition_out(each_blocks[i]);
          }

          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(ul);

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].d();
          }
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block$C.name,
        type: "if",
        source: "(151:8) {#if innerWidth > 956 || current === 3}",
        ctx
      });
      return block;
    } // (157:16) {#each comentarios as c (c.id)}


    function create_each_block$k(key_1, ctx) {
      let li;
      let a;
      let comentariomod;
      let a_href_value;
      let t;
      let li_transition;
      let current;
      comentariomod = new ComentarioMod({
        props: {
          comentario:
          /*c*/
          ctx[10]
        },
        $$inline: true
      });
      const block = {
        key: key_1,
        first: null,
        c: function create() {
          li = element("li");
          a = element("a");
          create_component(comentariomod.$$.fragment);
          t = space();
          attr_dev(a, "href", a_href_value = "/Hilo/" +
          /*c*/
          ctx[10].hiloId + "#" +
          /*c*/
          ctx[10].id);
          add_location(a, file$N, 158, 24, 5594);
          add_location(li, file$N, 157, 20, 5515);
          this.first = li;
        },
        m: function mount(target, anchor) {
          insert_dev(target, li, anchor);
          append_dev(li, a);
          mount_component(comentariomod, a, null);
          append_dev(li, t);
          current = true;
        },
        p: function update(ctx, dirty) {
          const comentariomod_changes = {};
          if (dirty &
          /*comentarios*/
          8) comentariomod_changes.comentario =
          /*c*/
          ctx[10];
          comentariomod.$set(comentariomod_changes);

          if (!current || dirty &
          /*comentarios*/
          8 && a_href_value !== (a_href_value = "/Hilo/" +
          /*c*/
          ctx[10].hiloId + "#" +
          /*c*/
          ctx[10].id)) {
            attr_dev(a, "href", a_href_value);
          }
        },
        i: function intro(local) {
          if (current) return;
          transition_in(comentariomod.$$.fragment, local);

          if (local) {
            add_render_callback(() => {
              if (!li_transition) li_transition = create_bidirectional_transition(li, fly, {
                y: -50,
                duration: 250
              }, true);
              li_transition.run(1);
            });
          }

          current = true;
        },
        o: function outro(local) {
          transition_out(comentariomod.$$.fragment, local);

          if (local) {
            if (!li_transition) li_transition = create_bidirectional_transition(li, fly, {
              y: -50,
              duration: 250
            }, false);
            li_transition.run(0);
          }

          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(li);
          destroy_component(comentariomod);
          if (detaching && li_transition) li_transition.end();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_each_block$k.name,
        type: "each",
        source: "(157:16) {#each comentarios as c (c.id)}",
        ctx
      });
      return block;
    }

    function create_fragment$Q(ctx) {
      let main;
      let barramoderacion;
      let t0;
      let div0;
      let ul;
      let t1;
      let t2;
      let div1;
      let t3;
      let t4;
      let current;
      let mounted;
      let dispose;
      add_render_callback(
      /*onwindowresize*/
      ctx[6]);
      barramoderacion = new BarraModeracion({
        $$inline: true
      });
      let each_value_3 =
      /*comentariosMedia*/
      ctx[5];
      validate_each_argument(each_value_3);
      let each_blocks = [];

      for (let i = 0; i < each_value_3.length; i += 1) {
        each_blocks[i] = create_each_block_3$3(get_each_context_3$3(ctx, each_value_3, i));
      }

      let if_block0 =
      /*innerWidth*/
      ctx[0] < 956 && create_if_block_3$g(ctx);
      let if_block1 = (
      /*innerWidth*/
      ctx[0] > 956 ||
      /*current*/
      ctx[1] === 1) && create_if_block_2$o(ctx);
      let if_block2 = (
      /*innerWidth*/
      ctx[0] > 956 ||
      /*current*/
      ctx[1] === 2) && create_if_block_1$p(ctx);
      let if_block3 = (
      /*innerWidth*/
      ctx[0] > 956 ||
      /*current*/
      ctx[1] === 3) && create_if_block$C(ctx);
      const block = {
        c: function create() {
          main = element("main");
          create_component(barramoderacion.$$.fragment);
          t0 = space();
          div0 = element("div");
          ul = element("ul");

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].c();
          }

          t1 = space();
          if (if_block0) if_block0.c();
          t2 = space();
          div1 = element("div");
          if (if_block1) if_block1.c();
          t3 = space();
          if (if_block2) if_block2.c();
          t4 = space();
          if (if_block3) if_block3.c();
          attr_dev(ul, "class", "svelte-x3q4q5");
          add_location(ul, file$N, 92, 8, 3230);
          attr_dev(div0, "class", "ultimos-medias svelte-x3q4q5");
          add_location(div0, file$N, 91, 4, 3192);
          attr_dev(div1, "class", "seccion2 svelte-x3q4q5");
          set_style(div1, "min-width", "33%");
          add_location(div1, file$N, 127, 4, 4297);
          attr_dev(main, "class", "svelte-x3q4q5");
          add_location(main, file$N, 89, 0, 3155);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, main, anchor);
          mount_component(barramoderacion, main, null);
          append_dev(main, t0);
          append_dev(main, div0);
          append_dev(div0, ul);

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].m(ul, null);
          }

          append_dev(main, t1);
          if (if_block0) if_block0.m(main, null);
          append_dev(main, t2);
          append_dev(main, div1);
          if (if_block1) if_block1.m(div1, null);
          append_dev(div1, t3);
          if (if_block2) if_block2.m(div1, null);
          append_dev(div1, t4);
          if (if_block3) if_block3.m(div1, null);
          current = true;

          if (!mounted) {
            dispose = listen_dev(window_1$2, "resize",
            /*onwindowresize*/
            ctx[6]);
            mounted = true;
          }
        },
        p: function update(ctx, [dirty]) {
          if (dirty &
          /*comentariosMedia*/
          32) {
            each_value_3 =
            /*comentariosMedia*/
            ctx[5];
            validate_each_argument(each_value_3);
            let i;

            for (i = 0; i < each_value_3.length; i += 1) {
              const child_ctx = get_each_context_3$3(ctx, each_value_3, i);

              if (each_blocks[i]) {
                each_blocks[i].p(child_ctx, dirty);
              } else {
                each_blocks[i] = create_each_block_3$3(child_ctx);
                each_blocks[i].c();
                each_blocks[i].m(ul, null);
              }
            }

            for (; i < each_blocks.length; i += 1) {
              each_blocks[i].d(1);
            }

            each_blocks.length = each_value_3.length;
          }

          if (
          /*innerWidth*/
          ctx[0] < 956) {
            if (if_block0) {
              if_block0.p(ctx, dirty);
            } else {
              if_block0 = create_if_block_3$g(ctx);
              if_block0.c();
              if_block0.m(main, t2);
            }
          } else if (if_block0) {
            if_block0.d(1);
            if_block0 = null;
          }

          if (
          /*innerWidth*/
          ctx[0] > 956 ||
          /*current*/
          ctx[1] === 1) {
            if (if_block1) {
              if_block1.p(ctx, dirty);

              if (dirty &
              /*innerWidth, current*/
              3) {
                transition_in(if_block1, 1);
              }
            } else {
              if_block1 = create_if_block_2$o(ctx);
              if_block1.c();
              transition_in(if_block1, 1);
              if_block1.m(div1, t3);
            }
          } else if (if_block1) {
            group_outros();
            transition_out(if_block1, 1, 1, () => {
              if_block1 = null;
            });
            check_outros();
          }

          if (
          /*innerWidth*/
          ctx[0] > 956 ||
          /*current*/
          ctx[1] === 2) {
            if (if_block2) {
              if_block2.p(ctx, dirty);

              if (dirty &
              /*innerWidth, current*/
              3) {
                transition_in(if_block2, 1);
              }
            } else {
              if_block2 = create_if_block_1$p(ctx);
              if_block2.c();
              transition_in(if_block2, 1);
              if_block2.m(div1, t4);
            }
          } else if (if_block2) {
            group_outros();
            transition_out(if_block2, 1, 1, () => {
              if_block2 = null;
            });
            check_outros();
          }

          if (
          /*innerWidth*/
          ctx[0] > 956 ||
          /*current*/
          ctx[1] === 3) {
            if (if_block3) {
              if_block3.p(ctx, dirty);

              if (dirty &
              /*innerWidth, current*/
              3) {
                transition_in(if_block3, 1);
              }
            } else {
              if_block3 = create_if_block$C(ctx);
              if_block3.c();
              transition_in(if_block3, 1);
              if_block3.m(div1, null);
            }
          } else if (if_block3) {
            group_outros();
            transition_out(if_block3, 1, 1, () => {
              if_block3 = null;
            });
            check_outros();
          }
        },
        i: function intro(local) {
          if (current) return;
          transition_in(barramoderacion.$$.fragment, local);
          transition_in(if_block1);
          transition_in(if_block2);
          transition_in(if_block3);
          current = true;
        },
        o: function outro(local) {
          transition_out(barramoderacion.$$.fragment, local);
          transition_out(if_block1);
          transition_out(if_block2);
          transition_out(if_block3);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(main);
          destroy_component(barramoderacion);
          destroy_each(each_blocks, detaching);
          if (if_block0) if_block0.d();
          if (if_block1) if_block1.d();
          if (if_block2) if_block2.d();
          if (if_block3) if_block3.d();
          mounted = false;
          dispose();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$Q.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }

    function instance$Q($$self, $$props, $$invalidate) {
      let {
        $$slots: slots = {},
        $$scope
      } = $$props;
      validate_slots("Moderacion", slots, []);
      let innerWidth = window.innerWidth;
      let current = 2;
      let hilos = window.model.hilos;
      let comentarios = window.model.comentarios;
      let denuncias = window.model.denuncias;
      let comentariosMedia = window.model.medias;
      comentarios = comentarios.map(c => {
        c.respuestas = [];
        return c;
      });
      Signal.subscribirAModeracion();
      Signal.subscribirAHome();
      Signal.coneccion.on("NuevoComentarioMod", comentario => {
        comentario.respuestas = [];
        comentarios.unshift(comentario);
        comentarios.pop();
        $$invalidate(3, comentarios);
      });
      Signal.coneccion.on("HiloCreadoMod", hilo => {
        hilos.pop();
        $$invalidate(2, hilos = [hilo, ...hilos]);
      });
      Signal.coneccion.on("categoriaCambiada", data => {
        let hilo = hilos.filter(h => h.id == data.hiloId);

        if (hilo.length != 0) {
          hilo[0].categoriaId = data.categoriaId;
          $$invalidate(2, hilos);
        }
      });
      Signal.coneccion.on("HiloComentado", (id, comentario) => {
        let hiloComentado = hilos.filter(h => h.id == id);

        if (hiloComentado.length != 0) {
          hiloComentado[0].cantidadComentarios += 1;
        }

        $$invalidate(2, hilos);
      });
      Signal.coneccion.on("HilosEliminados", ids => {
        let hs = hilos.filter(h => ids.includes(h.id));

        if (hs.length != 0) {
          hs.map(h => h.estado = HiloEstado.eliminado);
          $$invalidate(2, hilos);
        }
      });
      Signal.coneccion.on("nuevaDenuncia", denuncia => {
        $$invalidate(4, denuncias = [denuncia, ...denuncias]);
      });
      Signal.coneccion.on("denunciasRechazadas", ids => {
        if (ids.length == 0) return;
        $$invalidate(4, denuncias = denuncias.map(d => {
          if (ids.includes(d.id)) d.estado = EstadoDenuncia.Rechazada;
          return d;
        }));
      });
      Signal.coneccion.on("denunciasAceptadas", ids => {
        if (ids.length == 0) return;
        $$invalidate(4, denuncias = denuncias.map(d => {
          if (ids.includes(d.id)) d.estado = EstadoDenuncia.Aceptada;
          return d;
        }));
      });
      Signal.coneccion.on("ComentariosEliminados", ids => {
        let cs = comentarios.filter(c => ids.includes(c.id));

        if (cs.length != 0) {
          cs.map(c => {
            c.estado = ComentarioEstado.eliminado;
          });
          $$invalidate(3, comentarios);
        }
      });
      const writable_props = [];
      Object.keys($$props).forEach(key => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Moderacion> was created with unknown prop '${key}'`);
      });

      function onwindowresize() {
        $$invalidate(0, innerWidth = window_1$2.innerWidth);
      }

      const click_handler = () => $$invalidate(1, current = 1);

      const click_handler_1 = () => $$invalidate(1, current = 2);

      const click_handler_2 = () => $$invalidate(1, current = 3);

      $$self.$capture_state = () => ({
        Comentario,
        fly,
        Denuncia,
        HiloPreview,
        BarraModeracion,
        ComentarioMod,
        HiloPreviewMod,
        Sigal: Signal,
        HiloEstado,
        EstadoDenuncia,
        ComentarioEstado,
        innerWidth,
        current,
        hilos,
        comentarios,
        denuncias,
        comentariosMedia
      });

      $$self.$inject_state = $$props => {
        if ("innerWidth" in $$props) $$invalidate(0, innerWidth = $$props.innerWidth);
        if ("current" in $$props) $$invalidate(1, current = $$props.current);
        if ("hilos" in $$props) $$invalidate(2, hilos = $$props.hilos);
        if ("comentarios" in $$props) $$invalidate(3, comentarios = $$props.comentarios);
        if ("denuncias" in $$props) $$invalidate(4, denuncias = $$props.denuncias);
        if ("comentariosMedia" in $$props) $$invalidate(5, comentariosMedia = $$props.comentariosMedia);
      };

      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }

      return [innerWidth, current, hilos, comentarios, denuncias, comentariosMedia, onwindowresize, click_handler, click_handler_1, click_handler_2];
    }

    class Moderacion extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$Q, create_fragment$Q, safe_not_equal, {});
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "Moderacion",
          options,
          id: create_fragment$Q.name
        });
      }

    }

    /* src\components\Paginas\Login.svelte generated by Svelte v3.29.0 */
    const {
      console: console_1$d
    } = globals;
    const file$O = "src\\components\\Paginas\\Login.svelte"; // (52:12) <Checkbox bind:checked={usarToken}>

    function create_default_slot_1$p(ctx) {
      let t;
      const block = {
        c: function create() {
          t = text("Usar Token");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_1$p.name,
        type: "slot",
        source: "(52:12) <Checkbox bind:checked={usarToken}>",
        ctx
      });
      return block;
    } // (70:16) {:else}


    function create_else_block$b(ctx) {
      let textfield;
      let updating_value;
      let current;

      function textfield_value_binding(value) {
        /*textfield_value_binding*/
        ctx[9].call(null, value);
      }

      let textfield_props = {
        autocomplete: "off",
        label: "Token de sesion"
      };

      if (
      /*token*/
      ctx[4] !== void 0) {
        textfield_props.value =
        /*token*/
        ctx[4];
      }

      textfield = new Ve({
        props: textfield_props,
        $$inline: true
      });
      binding_callbacks.push(() => bind(textfield, "value", textfield_value_binding));
      const block = {
        c: function create() {
          create_component(textfield.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(textfield, target, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          const textfield_changes = {};

          if (!updating_value && dirty &
          /*token*/
          16) {
            updating_value = true;
            textfield_changes.value =
            /*token*/
            ctx[4];
            add_flush_callback(() => updating_value = false);
          }

          textfield.$set(textfield_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(textfield.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(textfield.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(textfield, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_else_block$b.name,
        type: "else",
        source: "(70:16) {:else}",
        ctx
      });
      return block;
    } // (53:12) {#if !usarToken}


    function create_if_block$D(ctx) {
      let errorvalidacion;
      let t0;
      let textfield0;
      let updating_value;
      let t1;
      let textfield1;
      let updating_value_1;
      let current;
      errorvalidacion = new ErrorValidacion({
        props: {
          error:
          /*error*/
          ctx[2]
        },
        $$inline: true
      });

      function textfield0_value_binding(value) {
        /*textfield0_value_binding*/
        ctx[7].call(null, value);
      }

      let textfield0_props = {
        autocomplete: "off",
        label: "Nombre de usuario",
        required: true,
        message: "kikefoster4000"
      };

      if (
      /*username*/
      ctx[0] !== void 0) {
        textfield0_props.value =
        /*username*/
        ctx[0];
      }

      textfield0 = new Ve({
        props: textfield0_props,
        $$inline: true
      });
      binding_callbacks.push(() => bind(textfield0, "value", textfield0_value_binding));

      function textfield1_value_binding(value) {
        /*textfield1_value_binding*/
        ctx[8].call(null, value);
      }

      let textfield1_props = {
        autocomplete: "off",
        label: "Contraseña",
        type: "password",
        required: true,
        message: "aynose1234"
      };

      if (
      /*password*/
      ctx[1] !== void 0) {
        textfield1_props.value =
        /*password*/
        ctx[1];
      }

      textfield1 = new Ve({
        props: textfield1_props,
        $$inline: true
      });
      binding_callbacks.push(() => bind(textfield1, "value", textfield1_value_binding));
      const block = {
        c: function create() {
          create_component(errorvalidacion.$$.fragment);
          t0 = space();
          create_component(textfield0.$$.fragment);
          t1 = space();
          create_component(textfield1.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(errorvalidacion, target, anchor);
          insert_dev(target, t0, anchor);
          mount_component(textfield0, target, anchor);
          insert_dev(target, t1, anchor);
          mount_component(textfield1, target, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          const errorvalidacion_changes = {};
          if (dirty &
          /*error*/
          4) errorvalidacion_changes.error =
          /*error*/
          ctx[2];
          errorvalidacion.$set(errorvalidacion_changes);
          const textfield0_changes = {};

          if (!updating_value && dirty &
          /*username*/
          1) {
            updating_value = true;
            textfield0_changes.value =
            /*username*/
            ctx[0];
            add_flush_callback(() => updating_value = false);
          }

          textfield0.$set(textfield0_changes);
          const textfield1_changes = {};

          if (!updating_value_1 && dirty &
          /*password*/
          2) {
            updating_value_1 = true;
            textfield1_changes.value =
            /*password*/
            ctx[1];
            add_flush_callback(() => updating_value_1 = false);
          }

          textfield1.$set(textfield1_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(errorvalidacion.$$.fragment, local);
          transition_in(textfield0.$$.fragment, local);
          transition_in(textfield1.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(errorvalidacion.$$.fragment, local);
          transition_out(textfield0.$$.fragment, local);
          transition_out(textfield1.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(errorvalidacion, detaching);
          if (detaching) detach_dev(t0);
          destroy_component(textfield0, detaching);
          if (detaching) detach_dev(t1);
          destroy_component(textfield1, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block$D.name,
        type: "if",
        source: "(53:12) {#if !usarToken}",
        ctx
      });
      return block;
    } // (79:20) <Button >


    function create_default_slot$u(ctx) {
      let t;
      const block = {
        c: function create() {
          t = text("Entrar");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot$u.name,
        type: "slot",
        source: "(79:20) <Button >",
        ctx
      });
      return block;
    }

    function create_fragment$R(ctx) {
      let div0;
      let t0;
      let main;
      let section;
      let errorvalidacion;
      let t1;
      let h1;
      let t3;
      let h2;
      let t7;
      let h3;
      let t8;
      let a0;
      let t10;
      let a1;
      let t12;
      let form;
      let checkbox;
      let updating_checked;
      let t13;
      let current_block_type_index;
      let if_block;
      let t14;
      let div1;
      let button;
      let current;
      let mounted;
      let dispose;
      errorvalidacion = new ErrorValidacion({
        props: {
          error:
          /*error*/
          ctx[2]
        },
        $$inline: true
      });

      function checkbox_checked_binding(value) {
        /*checkbox_checked_binding*/
        ctx[6].call(null, value);
      }

      let checkbox_props = {
        $$slots: {
          default: [create_default_slot_1$p]
        },
        $$scope: {
          ctx
        }
      };

      if (
      /*usarToken*/
      ctx[3] !== void 0) {
        checkbox_props.checked =
        /*usarToken*/
        ctx[3];
      }

      checkbox = new Ne({
        props: checkbox_props,
        $$inline: true
      });
      binding_callbacks.push(() => bind(checkbox, "checked", checkbox_checked_binding));
      const if_block_creators = [create_if_block$D, create_else_block$b];
      const if_blocks = [];

      function select_block_type(ctx, dirty) {
        if (!
        /*usarToken*/
        ctx[3]) return 0;
        return 1;
      }

      current_block_type_index = select_block_type(ctx);
      if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
      button = new ye({
        props: {
          $$slots: {
            default: [create_default_slot$u]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          div0 = element("div");
          t0 = space();
          main = element("main");
          section = element("section");
          create_component(errorvalidacion.$$.fragment);
          t1 = space();
          h1 = element("h1");
          h1.textContent = "Hola anon!";
          t3 = space();
          h2 = element("h2");
          h2.textContent = `Para crear y responder rozes en ${config.nombre} debes iniciar una sesion`;
          t7 = space();
          h3 = element("h3");
          t8 = text("No tenes un token o una cuenta? Enfermo!,  podes ");
          a0 = element("a");
          a0.textContent = "Iniciar Sesion";
          t10 = text(" o ");
          a1 = element("a");
          a1.textContent = "registrate";
          t12 = space();
          form = element("form");
          create_component(checkbox.$$.fragment);
          t13 = space();
          if_block.c();
          t14 = space();
          div1 = element("div");
          create_component(button.$$.fragment);
          attr_dev(div0, "class", "fondo svelte-t1g0rt");
          add_location(div0, file$O, 38, 0, 1042);
          add_location(h1, file$O, 45, 8, 1228);
          add_location(h2, file$O, 46, 8, 1256);
          attr_dev(a0, "href", "/Inicio");
          set_style(a0, "color", "var(--color5) ");
          add_location(a0, file$O, 47, 61, 1399);
          attr_dev(a1, "href", "/Registro");
          set_style(a1, "color", "var(--color5) ");
          add_location(a1, file$O, 47, 128, 1466);
          add_location(h3, file$O, 47, 8, 1346);
          set_style(div1, "display", "flex");
          set_style(div1, "justify-content", "center");
          add_location(div1, file$O, 77, 16, 2469);
          attr_dev(form, "class", "svelte-t1g0rt");
          add_location(form, file$O, 50, 8, 1553);
          attr_dev(section, "class", "svelte-t1g0rt");
          add_location(section, file$O, 43, 4, 1173);
          attr_dev(main, "class", "svelte-t1g0rt");
          add_location(main, file$O, 40, 0, 1069);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, div0, anchor);
          insert_dev(target, t0, anchor);
          insert_dev(target, main, anchor);
          append_dev(main, section);
          mount_component(errorvalidacion, section, null);
          append_dev(section, t1);
          append_dev(section, h1);
          append_dev(section, t3);
          append_dev(section, h2);
          append_dev(section, t7);
          append_dev(section, h3);
          append_dev(h3, t8);
          append_dev(h3, a0);
          append_dev(h3, t10);
          append_dev(h3, a1);
          append_dev(section, t12);
          append_dev(section, form);
          mount_component(checkbox, form, null);
          append_dev(form, t13);
          if_blocks[current_block_type_index].m(form, null);
          append_dev(form, t14);
          append_dev(form, div1);
          mount_component(button, div1, null);
          current = true;

          if (!mounted) {
            dispose = listen_dev(form, "submit", prevent_default(
            /*accion*/
            ctx[5]), false, true, false);
            mounted = true;
          }
        },
        p: function update(ctx, [dirty]) {
          const errorvalidacion_changes = {};
          if (dirty &
          /*error*/
          4) errorvalidacion_changes.error =
          /*error*/
          ctx[2];
          errorvalidacion.$set(errorvalidacion_changes);
          const checkbox_changes = {};

          if (dirty &
          /*$$scope*/
          2048) {
            checkbox_changes.$$scope = {
              dirty,
              ctx
            };
          }

          if (!updating_checked && dirty &
          /*usarToken*/
          8) {
            updating_checked = true;
            checkbox_changes.checked =
            /*usarToken*/
            ctx[3];
            add_flush_callback(() => updating_checked = false);
          }

          checkbox.$set(checkbox_changes);
          let previous_block_index = current_block_type_index;
          current_block_type_index = select_block_type(ctx);

          if (current_block_type_index === previous_block_index) {
            if_blocks[current_block_type_index].p(ctx, dirty);
          } else {
            group_outros();
            transition_out(if_blocks[previous_block_index], 1, 1, () => {
              if_blocks[previous_block_index] = null;
            });
            check_outros();
            if_block = if_blocks[current_block_type_index];

            if (!if_block) {
              if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
              if_block.c();
            }

            transition_in(if_block, 1);
            if_block.m(form, t14);
          }

          const button_changes = {};

          if (dirty &
          /*$$scope*/
          2048) {
            button_changes.$$scope = {
              dirty,
              ctx
            };
          }

          button.$set(button_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(errorvalidacion.$$.fragment, local);
          transition_in(checkbox.$$.fragment, local);
          transition_in(if_block);
          transition_in(button.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(errorvalidacion.$$.fragment, local);
          transition_out(checkbox.$$.fragment, local);
          transition_out(if_block);
          transition_out(button.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div0);
          if (detaching) detach_dev(t0);
          if (detaching) detach_dev(main);
          destroy_component(errorvalidacion);
          destroy_component(checkbox);
          if_blocks[current_block_type_index].d();
          destroy_component(button);
          mounted = false;
          dispose();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$R.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }

    function instance$R($$self, $$props, $$invalidate) {
      let {
        $$slots: slots = {},
        $$scope
      } = $$props;
      validate_slots("Login", slots, []);
      let username = "";
      let password = "";
      let captcha = "";
      let error = null;
      let usarToken = false;
      let token = "";

      async function accion(e) {
        console.log(captcha);

        try {
          let res = null;

          if (!usarToken) {
            res = await RChanClient.logearse(username, password);
          } else {
            res = await RChanClient.restaurarSesion(token);
          }
        } catch (e) {
          console.log(e); // if(res.data.redirect) {

          $$invalidate(2, error = e.response.data);
          return;
        }

        console.log("chan");
        window.location = "/";
      } // location.reload();


      const writable_props = [];
      Object.keys($$props).forEach(key => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$d.warn(`<Login> was created with unknown prop '${key}'`);
      });

      function checkbox_checked_binding(value) {
        usarToken = value;
        $$invalidate(3, usarToken);
      }

      function textfield0_value_binding(value) {
        username = value;
        $$invalidate(0, username);
      }

      function textfield1_value_binding(value) {
        password = value;
        $$invalidate(1, password);
      }

      function textfield_value_binding(value) {
        token = value;
        $$invalidate(4, token);
      }

      $$self.$capture_state = () => ({
        Textfield: Ve,
        Button: ye,
        Ripple: he,
        Checkbox: Ne,
        RChanClient,
        Captcha,
        ErrorValidacion,
        config,
        username,
        password,
        captcha,
        error,
        usarToken,
        token,
        accion
      });

      $$self.$inject_state = $$props => {
        if ("username" in $$props) $$invalidate(0, username = $$props.username);
        if ("password" in $$props) $$invalidate(1, password = $$props.password);
        if ("captcha" in $$props) captcha = $$props.captcha;
        if ("error" in $$props) $$invalidate(2, error = $$props.error);
        if ("usarToken" in $$props) $$invalidate(3, usarToken = $$props.usarToken);
        if ("token" in $$props) $$invalidate(4, token = $$props.token);
      };

      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }

      return [username, password, error, usarToken, token, accion, checkbox_checked_binding, textfield0_value_binding, textfield1_value_binding, textfield_value_binding];
    }

    class Login extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$R, create_fragment$R, safe_not_equal, {});
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "Login",
          options,
          id: create_fragment$R.name
        });
      }

    }

    /* src\components\Paginas\Registro.svelte generated by Svelte v3.29.0 */
    const {
      console: console_1$e
    } = globals;
    const file$P = "src\\components\\Paginas\\Registro.svelte"; // (67:8) {:else}

    function create_else_block$c(ctx) {
      let h2;
      const block = {
        c: function create() {
          h2 = element("h2");
          h2.textContent = "Lo siento anon, el registro esta temporalmente deshabilitado";
          add_location(h2, file$P, 67, 12, 2442);
        },
        m: function mount(target, anchor) {
          insert_dev(target, h2, anchor);
        },
        p: noop,
        i: noop,
        o: noop,
        d: function destroy(detaching) {
          if (detaching) detach_dev(h2);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_else_block$c.name,
        type: "else",
        source: "(67:8) {:else}",
        ctx
      });
      return block;
    } // (38:8) {#if config.general.registroAbierto || codigo}


    function create_if_block$E(ctx) {
      let h2;
      let t1;
      let h4;
      let t3;
      let errorvalidacion;
      let t4;
      let form;
      let textfield0;
      let updating_value;
      let t5;
      let textfield1;
      let updating_value_1;
      let t6;
      let a;
      let t8;
      let checkbox;
      let updating_checked;
      let t9;
      let captcha_1;
      let updating_token;
      let t10;
      let div;
      let button;
      let current;
      let mounted;
      let dispose;
      errorvalidacion = new ErrorValidacion({
        props: {
          error:
          /*error*/
          ctx[4]
        },
        $$inline: true
      });

      function textfield0_value_binding(value) {
        /*textfield0_value_binding*/
        ctx[7].call(null, value);
      }

      let textfield0_props = {
        autocomplete: "off",
        label: "Nombre de usuario",
        required: true,
        message: "kikefoster4000"
      };

      if (
      /*username*/
      ctx[0] !== void 0) {
        textfield0_props.value =
        /*username*/
        ctx[0];
      }

      textfield0 = new Ve({
        props: textfield0_props,
        $$inline: true
      });
      binding_callbacks.push(() => bind(textfield0, "value", textfield0_value_binding));

      function textfield1_value_binding(value) {
        /*textfield1_value_binding*/
        ctx[8].call(null, value);
      }

      let textfield1_props = {
        autocomplete: "off",
        label: "Contraseña",
        type: "password",
        required: true,
        message: "Si te la olvidas, domado"
      };

      if (
      /*password*/
      ctx[1] !== void 0) {
        textfield1_props.value =
        /*password*/
        ctx[1];
      }

      textfield1 = new Ve({
        props: textfield1_props,
        $$inline: true
      });
      binding_callbacks.push(() => bind(textfield1, "value", textfield1_value_binding));

      function checkbox_checked_binding(value) {
        /*checkbox_checked_binding*/
        ctx[9].call(null, value);
      }

      let checkbox_props = {
        right: true,
        $$slots: {
          default: [create_default_slot_1$q]
        },
        $$scope: {
          ctx
        }
      };

      if (
      /*terminos*/
      ctx[2] !== void 0) {
        checkbox_props.checked =
        /*terminos*/
        ctx[2];
      }

      checkbox = new Ne({
        props: checkbox_props,
        $$inline: true
      });
      binding_callbacks.push(() => bind(checkbox, "checked", checkbox_checked_binding));

      function captcha_1_token_binding(value) {
        /*captcha_1_token_binding*/
        ctx[10].call(null, value);
      }

      let captcha_1_props = {
        visible: config.general.captchaRegistro
      };

      if (
      /*captcha*/
      ctx[3] !== void 0) {
        captcha_1_props.token =
        /*captcha*/
        ctx[3];
      }

      captcha_1 = new Captcha({
        props: captcha_1_props,
        $$inline: true
      });
      binding_callbacks.push(() => bind(captcha_1, "token", captcha_1_token_binding));
      button = new ye({
        props: {
          disabled: !
          /*terminos*/
          ctx[2],
          $$slots: {
            default: [create_default_slot$v]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          h2 = element("h2");
          h2.textContent = "Registrate con cofianza";
          t1 = space();
          h4 = element("h4");
          h4.textContent = "Tu ip esta a salvo, desde ya que si";
          t3 = space();
          create_component(errorvalidacion.$$.fragment);
          t4 = space();
          form = element("form");
          create_component(textfield0.$$.fragment);
          t5 = space();
          create_component(textfield1.$$.fragment);
          t6 = space();
          a = element("a");
          a.textContent = "Ver reglas";
          t8 = space();
          create_component(checkbox.$$.fragment);
          t9 = space();
          create_component(captcha_1.$$.fragment);
          t10 = space();
          div = element("div");
          create_component(button.$$.fragment);
          add_location(h2, file$P, 38, 12, 1070);
          add_location(h4, file$P, 39, 12, 1115);
          set_style(a, "color", "var(--color5)");
          set_style(a, "text-align", "center");
          set_style(a, "display", "block");
          set_style(a, "font-weight", "bold");
          set_style(a, "font-size", "19px");
          attr_dev(a, "target", "_blanck");
          attr_dev(a, "href", "/reglas.html");
          add_location(a, file$P, 57, 16, 1781);
          set_style(div, "display", "flex");
          set_style(div, "justify-content", "center");
          set_style(div, "margin-top", "8px");
          add_location(div, file$P, 61, 16, 2231);
          attr_dev(form, "class", "svelte-15jfbxr");
          add_location(form, file$P, 41, 12, 1211);
        },
        m: function mount(target, anchor) {
          insert_dev(target, h2, anchor);
          insert_dev(target, t1, anchor);
          insert_dev(target, h4, anchor);
          insert_dev(target, t3, anchor);
          mount_component(errorvalidacion, target, anchor);
          insert_dev(target, t4, anchor);
          insert_dev(target, form, anchor);
          mount_component(textfield0, form, null);
          append_dev(form, t5);
          mount_component(textfield1, form, null);
          append_dev(form, t6);
          append_dev(form, a);
          append_dev(form, t8);
          mount_component(checkbox, form, null);
          append_dev(form, t9);
          mount_component(captcha_1, form, null);
          append_dev(form, t10);
          append_dev(form, div);
          mount_component(button, div, null);
          current = true;

          if (!mounted) {
            dispose = listen_dev(form, "submit", prevent_default(
            /*accion*/
            ctx[6]), false, true, false);
            mounted = true;
          }
        },
        p: function update(ctx, dirty) {
          const errorvalidacion_changes = {};
          if (dirty &
          /*error*/
          16) errorvalidacion_changes.error =
          /*error*/
          ctx[4];
          errorvalidacion.$set(errorvalidacion_changes);
          const textfield0_changes = {};

          if (!updating_value && dirty &
          /*username*/
          1) {
            updating_value = true;
            textfield0_changes.value =
            /*username*/
            ctx[0];
            add_flush_callback(() => updating_value = false);
          }

          textfield0.$set(textfield0_changes);
          const textfield1_changes = {};

          if (!updating_value_1 && dirty &
          /*password*/
          2) {
            updating_value_1 = true;
            textfield1_changes.value =
            /*password*/
            ctx[1];
            add_flush_callback(() => updating_value_1 = false);
          }

          textfield1.$set(textfield1_changes);
          const checkbox_changes = {};

          if (dirty &
          /*$$scope*/
          2048) {
            checkbox_changes.$$scope = {
              dirty,
              ctx
            };
          }

          if (!updating_checked && dirty &
          /*terminos*/
          4) {
            updating_checked = true;
            checkbox_changes.checked =
            /*terminos*/
            ctx[2];
            add_flush_callback(() => updating_checked = false);
          }

          checkbox.$set(checkbox_changes);
          const captcha_1_changes = {};

          if (!updating_token && dirty &
          /*captcha*/
          8) {
            updating_token = true;
            captcha_1_changes.token =
            /*captcha*/
            ctx[3];
            add_flush_callback(() => updating_token = false);
          }

          captcha_1.$set(captcha_1_changes);
          const button_changes = {};
          if (dirty &
          /*terminos*/
          4) button_changes.disabled = !
          /*terminos*/
          ctx[2];

          if (dirty &
          /*$$scope*/
          2048) {
            button_changes.$$scope = {
              dirty,
              ctx
            };
          }

          button.$set(button_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(errorvalidacion.$$.fragment, local);
          transition_in(textfield0.$$.fragment, local);
          transition_in(textfield1.$$.fragment, local);
          transition_in(checkbox.$$.fragment, local);
          transition_in(captcha_1.$$.fragment, local);
          transition_in(button.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(errorvalidacion.$$.fragment, local);
          transition_out(textfield0.$$.fragment, local);
          transition_out(textfield1.$$.fragment, local);
          transition_out(checkbox.$$.fragment, local);
          transition_out(captcha_1.$$.fragment, local);
          transition_out(button.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(h2);
          if (detaching) detach_dev(t1);
          if (detaching) detach_dev(h4);
          if (detaching) detach_dev(t3);
          destroy_component(errorvalidacion, detaching);
          if (detaching) detach_dev(t4);
          if (detaching) detach_dev(form);
          destroy_component(textfield0);
          destroy_component(textfield1);
          destroy_component(checkbox);
          destroy_component(captcha_1);
          destroy_component(button);
          mounted = false;
          dispose();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block$E.name,
        type: "if",
        source: "(38:8) {#if config.general.registroAbierto || codigo}",
        ctx
      });
      return block;
    } // (59:16) <Checkbox right bind:checked={terminos}>


    function create_default_slot_1$q(ctx) {
      let div;
      const block = {
        c: function create() {
          div = element("div");
          div.textContent = `Yo Anon juro solemnemente seguir las reglas de ${config.nombre}`;
          set_style(div, "white-space", "normal");
          set_style(div, "text-align", "center");
          add_location(div, file$P, 58, 56, 1989);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
        },
        p: noop,
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_1$q.name,
        type: "slot",
        source: "(59:16) <Checkbox right bind:checked={terminos}>",
        ctx
      });
      return block;
    } // (63:20) <Button disabled={!terminos}>


    function create_default_slot$v(ctx) {
      let t;
      const block = {
        c: function create() {
          t = text("Registrarse");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot$v.name,
        type: "slot",
        source: "(63:20) <Button disabled={!terminos}>",
        ctx
      });
      return block;
    }

    function create_fragment$S(ctx) {
      let div;
      let t;
      let main;
      let section;
      let current_block_type_index;
      let if_block;
      let current;
      const if_block_creators = [create_if_block$E, create_else_block$c];
      const if_blocks = [];

      function select_block_type(ctx, dirty) {
        if (config.general.registroAbierto ||
        /*codigo*/
        ctx[5]) return 0;
        return 1;
      }

      current_block_type_index = select_block_type(ctx);
      if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
      const block = {
        c: function create() {
          div = element("div");
          t = space();
          main = element("main");
          section = element("section");
          if_block.c();
          attr_dev(div, "class", "fondo svelte-15jfbxr");
          add_location(div, file$P, 32, 0, 862);
          attr_dev(section, "class", "svelte-15jfbxr");
          add_location(section, file$P, 36, 4, 992);
          attr_dev(main, "class", "svelte-15jfbxr");
          add_location(main, file$P, 33, 0, 888);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          insert_dev(target, t, anchor);
          insert_dev(target, main, anchor);
          append_dev(main, section);
          if_blocks[current_block_type_index].m(section, null);
          current = true;
        },
        p: function update(ctx, [dirty]) {
          let previous_block_index = current_block_type_index;
          current_block_type_index = select_block_type(ctx);

          if (current_block_type_index === previous_block_index) {
            if_blocks[current_block_type_index].p(ctx, dirty);
          } else {
            group_outros();
            transition_out(if_blocks[previous_block_index], 1, 1, () => {
              if_blocks[previous_block_index] = null;
            });
            check_outros();
            if_block = if_blocks[current_block_type_index];

            if (!if_block) {
              if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
              if_block.c();
            }

            transition_in(if_block, 1);
            if_block.m(section, null);
          }
        },
        i: function intro(local) {
          if (current) return;
          transition_in(if_block);
          current = true;
        },
        o: function outro(local) {
          transition_out(if_block);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
          if (detaching) detach_dev(t);
          if (detaching) detach_dev(main);
          if_blocks[current_block_type_index].d();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$S.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }

    function instance$S($$self, $$props, $$invalidate) {
      let {
        $$slots: slots = {},
        $$scope
      } = $$props;
      validate_slots("Registro", slots, []);
      let username = "";
      let password = "";
      let terminos = false;
      let captcha = "";
      let error = null;
      let codigo = "";

      if (window.model && window.model.codigoDeInvitacion) {
        codigo = window.model.codigoDeInvitacion;
      }

      async function accion(e) {
        console.log(captcha);

        try {
          await RChanClient.registrase(username, password, captcha, codigo);
        } catch (e) {
          console.log(e);
          $$invalidate(4, error = e.response.data);
          return;
        }

        window.location = "/";
      } // location.reload();


      const writable_props = [];
      Object.keys($$props).forEach(key => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$e.warn(`<Registro> was created with unknown prop '${key}'`);
      });

      function textfield0_value_binding(value) {
        username = value;
        $$invalidate(0, username);
      }

      function textfield1_value_binding(value) {
        password = value;
        $$invalidate(1, password);
      }

      function checkbox_checked_binding(value) {
        terminos = value;
        $$invalidate(2, terminos);
      }

      function captcha_1_token_binding(value) {
        captcha = value;
        $$invalidate(3, captcha);
      }

      $$self.$capture_state = () => ({
        Textfield: Ve,
        Button: ye,
        Ripple: he,
        Checkbox: Ne,
        RChanClient,
        Captcha,
        ErrorValidacion,
        config,
        username,
        password,
        terminos,
        captcha,
        error,
        codigo,
        accion
      });

      $$self.$inject_state = $$props => {
        if ("username" in $$props) $$invalidate(0, username = $$props.username);
        if ("password" in $$props) $$invalidate(1, password = $$props.password);
        if ("terminos" in $$props) $$invalidate(2, terminos = $$props.terminos);
        if ("captcha" in $$props) $$invalidate(3, captcha = $$props.captcha);
        if ("error" in $$props) $$invalidate(4, error = $$props.error);
        if ("codigo" in $$props) $$invalidate(5, codigo = $$props.codigo);
      };

      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }

      return [username, password, terminos, captcha, error, codigo, accion, textfield0_value_binding, textfield1_value_binding, checkbox_checked_binding, captcha_1_token_binding];
    }

    class Registro extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$S, create_fragment$S, safe_not_equal, {});
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "Registro",
          options,
          id: create_fragment$S.name
        });
      }

    }

    /* src\components\Paginas\Inicio.svelte generated by Svelte v3.29.0 */
    const {
      console: console_1$f
    } = globals;
    const file$Q = "src\\components\\Paginas\\Inicio.svelte"; // (53:8) {:else}

    function create_else_block$d(ctx) {
      let h2;
      const block = {
        c: function create() {
          h2 = element("h2");
          h2.textContent = "Lo siento anon, el inicio de sesiones esta temporalmente deshabilitado";
          add_location(h2, file$Q, 53, 12, 2053);
        },
        m: function mount(target, anchor) {
          insert_dev(target, h2, anchor);
        },
        p: noop,
        i: noop,
        o: noop,
        d: function destroy(detaching) {
          if (detaching) detach_dev(h2);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_else_block$d.name,
        type: "else",
        source: "(53:8) {:else}",
        ctx
      });
      return block;
    } // (37:8) {#if config.general.registroAbierto || codigo}


    function create_if_block$F(ctx) {
      let h2;
      let t3;
      let h40;
      let t5;
      let h41;
      let t6;
      let a0;
      let t8;
      let errorvalidacion;
      let t9;
      let form;
      let a1;
      let t11;
      let checkbox;
      let updating_checked;
      let t12;
      let captcha_1;
      let updating_token;
      let t13;
      let div;
      let button;
      let current;
      let mounted;
      let dispose;
      errorvalidacion = new ErrorValidacion({
        props: {
          error:
          /*error*/
          ctx[2]
        },
        $$inline: true
      });

      function checkbox_checked_binding(value) {
        /*checkbox_checked_binding*/
        ctx[5].call(null, value);
      }

      let checkbox_props = {
        right: true,
        $$slots: {
          default: [create_default_slot_1$r]
        },
        $$scope: {
          ctx
        }
      };

      if (
      /*terminos*/
      ctx[0] !== void 0) {
        checkbox_props.checked =
        /*terminos*/
        ctx[0];
      }

      checkbox = new Ne({
        props: checkbox_props,
        $$inline: true
      });
      binding_callbacks.push(() => bind(checkbox, "checked", checkbox_checked_binding));

      function captcha_1_token_binding(value) {
        /*captcha_1_token_binding*/
        ctx[6].call(null, value);
      }

      let captcha_1_props = {
        visible: config.general.captchaRegistro
      };

      if (
      /*captcha*/
      ctx[1] !== void 0) {
        captcha_1_props.token =
        /*captcha*/
        ctx[1];
      }

      captcha_1 = new Captcha({
        props: captcha_1_props,
        $$inline: true
      });
      binding_callbacks.push(() => bind(captcha_1, "token", captcha_1_token_binding));
      button = new ye({
        props: {
          disabled: !
          /*terminos*/
          ctx[0],
          $$slots: {
            default: [create_default_slot$w]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          h2 = element("h2");
          h2.textContent = `Para usar ${config.nombre} debes leer y aceptar las reglas`;
          t3 = space();
          h40 = element("h4");
          h40.textContent = "Tu ip esta a salvo, desde ya que si";
          t5 = space();
          h41 = element("h4");
          t6 = text("Preferis crear una sesion con usuario y contraseña?   ");
          a0 = element("a");
          a0.textContent = "Registro";
          t8 = space();
          create_component(errorvalidacion.$$.fragment);
          t9 = space();
          form = element("form");
          a1 = element("a");
          a1.textContent = "Ver reglas";
          t11 = space();
          create_component(checkbox.$$.fragment);
          t12 = space();
          create_component(captcha_1.$$.fragment);
          t13 = space();
          div = element("div");
          create_component(button.$$.fragment);
          add_location(h2, file$Q, 37, 12, 1010);
          add_location(h40, file$Q, 38, 12, 1089);
          set_style(a0, "color", "var(--color5)");
          set_style(a0, "text-align", "center");
          attr_dev(a0, "href", "/Registro");
          add_location(a0, file$Q, 39, 70, 1204);
          add_location(h41, file$Q, 39, 12, 1146);
          set_style(a1, "color", "var(--color5)");
          set_style(a1, "text-align", "center");
          set_style(a1, "display", "block");
          set_style(a1, "font-weight", "bold");
          set_style(a1, "font-size", "19px");
          attr_dev(a1, "target", "_blank");
          attr_dev(a1, "href", "/reglas.html");
          add_location(a1, file$Q, 43, 12, 1408);
          set_style(div, "display", "flex");
          set_style(div, "justify-content", "center");
          set_style(div, "margin-top", "8px");
          add_location(div, file$Q, 47, 12, 1845);
          attr_dev(form, "class", "svelte-15jfbxr");
          add_location(form, file$Q, 41, 12, 1342);
        },
        m: function mount(target, anchor) {
          insert_dev(target, h2, anchor);
          insert_dev(target, t3, anchor);
          insert_dev(target, h40, anchor);
          insert_dev(target, t5, anchor);
          insert_dev(target, h41, anchor);
          append_dev(h41, t6);
          append_dev(h41, a0);
          insert_dev(target, t8, anchor);
          mount_component(errorvalidacion, target, anchor);
          insert_dev(target, t9, anchor);
          insert_dev(target, form, anchor);
          append_dev(form, a1);
          append_dev(form, t11);
          mount_component(checkbox, form, null);
          append_dev(form, t12);
          mount_component(captcha_1, form, null);
          append_dev(form, t13);
          append_dev(form, div);
          mount_component(button, div, null);
          current = true;

          if (!mounted) {
            dispose = listen_dev(form, "submit", prevent_default(
            /*accion*/
            ctx[4]), false, true, false);
            mounted = true;
          }
        },
        p: function update(ctx, dirty) {
          const errorvalidacion_changes = {};
          if (dirty &
          /*error*/
          4) errorvalidacion_changes.error =
          /*error*/
          ctx[2];
          errorvalidacion.$set(errorvalidacion_changes);
          const checkbox_changes = {};

          if (dirty &
          /*$$scope*/
          128) {
            checkbox_changes.$$scope = {
              dirty,
              ctx
            };
          }

          if (!updating_checked && dirty &
          /*terminos*/
          1) {
            updating_checked = true;
            checkbox_changes.checked =
            /*terminos*/
            ctx[0];
            add_flush_callback(() => updating_checked = false);
          }

          checkbox.$set(checkbox_changes);
          const captcha_1_changes = {};

          if (!updating_token && dirty &
          /*captcha*/
          2) {
            updating_token = true;
            captcha_1_changes.token =
            /*captcha*/
            ctx[1];
            add_flush_callback(() => updating_token = false);
          }

          captcha_1.$set(captcha_1_changes);
          const button_changes = {};
          if (dirty &
          /*terminos*/
          1) button_changes.disabled = !
          /*terminos*/
          ctx[0];

          if (dirty &
          /*$$scope*/
          128) {
            button_changes.$$scope = {
              dirty,
              ctx
            };
          }

          button.$set(button_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(errorvalidacion.$$.fragment, local);
          transition_in(checkbox.$$.fragment, local);
          transition_in(captcha_1.$$.fragment, local);
          transition_in(button.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(errorvalidacion.$$.fragment, local);
          transition_out(checkbox.$$.fragment, local);
          transition_out(captcha_1.$$.fragment, local);
          transition_out(button.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(h2);
          if (detaching) detach_dev(t3);
          if (detaching) detach_dev(h40);
          if (detaching) detach_dev(t5);
          if (detaching) detach_dev(h41);
          if (detaching) detach_dev(t8);
          destroy_component(errorvalidacion, detaching);
          if (detaching) detach_dev(t9);
          if (detaching) detach_dev(form);
          destroy_component(checkbox);
          destroy_component(captcha_1);
          destroy_component(button);
          mounted = false;
          dispose();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block$F.name,
        type: "if",
        source: "(37:8) {#if config.general.registroAbierto || codigo}",
        ctx
      });
      return block;
    } // (45:12) <Checkbox right bind:checked={terminos}>


    function create_default_slot_1$r(ctx) {
      let div;
      const block = {
        c: function create() {
          div = element("div");
          div.textContent = `Yo Anon juro solemnemente seguir las reglas de ${config.nombre}`;
          set_style(div, "white-space", "normal");
          set_style(div, "text-align", "center");
          add_location(div, file$Q, 44, 52, 1611);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
        },
        p: noop,
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_1$r.name,
        type: "slot",
        source: "(45:12) <Checkbox right bind:checked={terminos}>",
        ctx
      });
      return block;
    } // (49:16) <Button disabled={!terminos}>


    function create_default_slot$w(ctx) {
      let t;
      const block = {
        c: function create() {
          t = text("Empezar a rozear");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot$w.name,
        type: "slot",
        source: "(49:16) <Button disabled={!terminos}>",
        ctx
      });
      return block;
    }

    function create_fragment$T(ctx) {
      let div;
      let t;
      let main;
      let section;
      let current_block_type_index;
      let if_block;
      let current;
      const if_block_creators = [create_if_block$F, create_else_block$d];
      const if_blocks = [];

      function select_block_type(ctx, dirty) {
        if (config.general.registroAbierto ||
        /*codigo*/
        ctx[3]) return 0;
        return 1;
      }

      current_block_type_index = select_block_type(ctx);
      if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
      const block = {
        c: function create() {
          div = element("div");
          t = space();
          main = element("main");
          section = element("section");
          if_block.c();
          attr_dev(div, "class", "fondo svelte-15jfbxr");
          add_location(div, file$Q, 31, 0, 802);
          attr_dev(section, "class", "svelte-15jfbxr");
          add_location(section, file$Q, 35, 4, 932);
          attr_dev(main, "class", "svelte-15jfbxr");
          add_location(main, file$Q, 32, 0, 828);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          insert_dev(target, t, anchor);
          insert_dev(target, main, anchor);
          append_dev(main, section);
          if_blocks[current_block_type_index].m(section, null);
          current = true;
        },
        p: function update(ctx, [dirty]) {
          let previous_block_index = current_block_type_index;
          current_block_type_index = select_block_type(ctx);

          if (current_block_type_index === previous_block_index) {
            if_blocks[current_block_type_index].p(ctx, dirty);
          } else {
            group_outros();
            transition_out(if_blocks[previous_block_index], 1, 1, () => {
              if_blocks[previous_block_index] = null;
            });
            check_outros();
            if_block = if_blocks[current_block_type_index];

            if (!if_block) {
              if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
              if_block.c();
            }

            transition_in(if_block, 1);
            if_block.m(section, null);
          }
        },
        i: function intro(local) {
          if (current) return;
          transition_in(if_block);
          current = true;
        },
        o: function outro(local) {
          transition_out(if_block);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
          if (detaching) detach_dev(t);
          if (detaching) detach_dev(main);
          if_blocks[current_block_type_index].d();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$T.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }

    function instance$T($$self, $$props, $$invalidate) {
      let {
        $$slots: slots = {},
        $$scope
      } = $$props;
      validate_slots("Inicio", slots, []);
      let terminos = false;
      let captcha = "";
      let error = null;
      let codigo = "";

      if (window.model && window.model.codigoDeInvitacion) {
        codigo = window.model.codigoDeInvitacion;
      }

      async function accion(e) {
        console.log(captcha);

        try {
          await RChanClient.inicio(captcha, codigo);
        } catch (e) {
          console.log(e);
          $$invalidate(2, error = e.response.data);
          return;
        }
      } // window.location = "/"
      // location.reload();


      const writable_props = [];
      Object.keys($$props).forEach(key => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$f.warn(`<Inicio> was created with unknown prop '${key}'`);
      });

      function checkbox_checked_binding(value) {
        terminos = value;
        $$invalidate(0, terminos);
      }

      function captcha_1_token_binding(value) {
        captcha = value;
        $$invalidate(1, captcha);
      }

      $$self.$capture_state = () => ({
        Textfield: Ve,
        Button: ye,
        Ripple: he,
        Checkbox: Ne,
        RChanClient,
        Captcha,
        ErrorValidacion,
        config,
        terminos,
        captcha,
        error,
        codigo,
        accion
      });

      $$self.$inject_state = $$props => {
        if ("terminos" in $$props) $$invalidate(0, terminos = $$props.terminos);
        if ("captcha" in $$props) $$invalidate(1, captcha = $$props.captcha);
        if ("error" in $$props) $$invalidate(2, error = $$props.error);
        if ("codigo" in $$props) $$invalidate(3, codigo = $$props.codigo);
      };

      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }

      return [terminos, captcha, error, codigo, accion, checkbox_checked_binding, captcha_1_token_binding];
    }

    class Inicio extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$T, create_fragment$T, safe_not_equal, {});
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "Inicio",
          options,
          id: create_fragment$T.name
        });
      }

    }

    /* src\components\Paginas\Token.svelte generated by Svelte v3.29.0 */
    const file$R = "src\\components\\Paginas\\Token.svelte";

    function create_fragment$U(ctx) {
      let div;
      let t0;
      let main;
      let section;
      let h2;
      let t2;
      let p0;
      let t4;
      let h4;
      let t6;
      let p1;
      let t7;
      let a;
      let t9;
      const block = {
        c: function create() {
          div = element("div");
          t0 = space();
          main = element("main");
          section = element("section");
          h2 = element("h2");
          h2.textContent = "Este es tu token de sesion";
          t2 = space();
          p0 = element("p");
          p0.textContent = `${
      /*token*/
      ctx[0]}`;
          t4 = space();
          h4 = element("h4");
          h4.textContent = "Sirve para poder usar la misma sesion en diferentes navegadores y dispositivos";
          t6 = space();
          p1 = element("p");
          t7 = text("Para utilizarlo tenes que dirigirte al ");
          a = element("a");
          a.textContent = "login";
          t9 = text(" y cliquear la opcion usar token");
          attr_dev(div, "class", "fondo svelte-1dkqzt0");
          add_location(div, file$R, 11, 0, 317);
          add_location(h2, file$R, 16, 8, 496);
          add_location(p0, file$R, 17, 8, 540);
          add_location(h4, file$R, 18, 8, 563);
          attr_dev(a, "href", "/Login");
          add_location(a, file$R, 19, 50, 701);
          add_location(p1, file$R, 19, 8, 659);
          set_style(section, "word-break", "break-all");
          attr_dev(section, "class", "svelte-1dkqzt0");
          add_location(section, file$R, 15, 4, 447);
          attr_dev(main, "class", "svelte-1dkqzt0");
          add_location(main, file$R, 12, 0, 343);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          insert_dev(target, t0, anchor);
          insert_dev(target, main, anchor);
          append_dev(main, section);
          append_dev(section, h2);
          append_dev(section, t2);
          append_dev(section, p0);
          append_dev(section, t4);
          append_dev(section, h4);
          append_dev(section, t6);
          append_dev(section, p1);
          append_dev(p1, t7);
          append_dev(p1, a);
          append_dev(p1, t9);
        },
        p: noop,
        i: noop,
        o: noop,
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
          if (detaching) detach_dev(t0);
          if (detaching) detach_dev(main);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$U.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }

    function instance$U($$self, $$props, $$invalidate) {
      let {
        $$slots: slots = {},
        $$scope
      } = $$props;
      validate_slots("Token", slots, []);
      let token = window.model.token;
      const writable_props = [];
      Object.keys($$props).forEach(key => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Token> was created with unknown prop '${key}'`);
      });

      $$self.$capture_state = () => ({
        Textfield: Ve,
        Button: ye,
        Ripple: he,
        Checkbox: Ne,
        RChanClient,
        Captcha,
        ErrorValidacion,
        config,
        token
      });

      $$self.$inject_state = $$props => {
        if ("token" in $$props) $$invalidate(0, token = $$props.token);
      };

      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }

      return [token];
    }

    class Token extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$U, create_fragment$U, safe_not_equal, {});
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "Token",
          options,
          id: create_fragment$U.name
        });
      }

    }

    function formatearTiempo(tiempo) {
      return new Date(Date.parse(tiempo)).toLocaleString();
    }
    function formatearTimeSpan(timespan) {
      // 69444.10:39:00.0000010
      //"00:05:00.0000010",
      let minutos = Array.from(timespan.matchAll(/(\d\d):/g))[1][1];
      let horas = Array.from(timespan.matchAll(/(\d\d):/g))[0][1];
      let dias = timespan.split(".")[0];
      minutos = minutos[0] == "0" ? minutos[1] : minutos;
      horas = horas[0] == "0" ? horas[1] : horas;
      let ret = "";
      if (dias > 0) ret += `${dias}D `;
      if (horas > 0) ret += `${horas}H `;
      if (minutos > 0) ret += `${minutos} min `;
      return ret;
    }

    /* src\components\Moderacion\BanPreview.svelte generated by Svelte v3.29.0 */
    const file$S = "src\\components\\Moderacion\\BanPreview.svelte"; // (18:4) {#if ban.comentario}

    function create_if_block_1$q(ctx) {
      let comentario;
      let current;
      comentario = new Comentario({
        props: {
          comentario:
          /*ban*/
          ctx[0].comentario
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          create_component(comentario.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(comentario, target, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          const comentario_changes = {};
          if (dirty &
          /*ban*/
          1) comentario_changes.comentario =
          /*ban*/
          ctx[0].comentario;
          comentario.$set(comentario_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(comentario.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(comentario.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(comentario, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_1$q.name,
        type: "if",
        source: "(18:4) {#if ban.comentario}",
        ctx
      });
      return block;
    } // (21:4) {#if ban.hilo}


    function create_if_block$G(ctx) {
      let hilopreviewmod;
      let current;
      hilopreviewmod = new HiloPreviewMod({
        props: {
          hilo:
          /*ban*/
          ctx[0].hilo
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          create_component(hilopreviewmod.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(hilopreviewmod, target, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          const hilopreviewmod_changes = {};
          if (dirty &
          /*ban*/
          1) hilopreviewmod_changes.hilo =
          /*ban*/
          ctx[0].hilo;
          hilopreviewmod.$set(hilopreviewmod_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(hilopreviewmod.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(hilopreviewmod.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(hilopreviewmod, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block$G.name,
        type: "if",
        source: "(21:4) {#if ban.hilo}",
        ctx
      });
      return block;
    }

    function create_fragment$V(ctx) {
      let div;
      let p0;
      let t0;
      let a;
      let t1_value =
      /*ban*/
      ctx[0].modId + "";
      let t1;
      let a_href_value;
      let t2;
      let p1;
      let t3;
      let t4_value = (
      /*ban*/
      ctx[0].aclaracion || " ") + "";
      let t4;
      let t5;
      let p2;
      let t6;
      let t7_value = MotivoDenuncia.aString(
      /*ban*/
      ctx[0].motivo) + "";
      let t7;
      let t8;
      let p3;
      let t9;
      let t10_value = formatearTiempo(
      /*ban*/
      ctx[0].creacion) + "";
      let t10;
      let t11;
      let p4;
      let t12;
      let t13_value = formatearTimeSpan(
      /*ban*/
      ctx[0].duracion) + "";
      let t13;
      let t14;
      let p5;
      let t15;
      let t16_value =
      /*ban*/
      ctx[0].id + "";
      let t16;
      let t17;
      let t18;
      let current;
      let if_block0 =
      /*ban*/
      ctx[0].comentario && create_if_block_1$q(ctx);
      let if_block1 =
      /*ban*/
      ctx[0].hilo && create_if_block$G(ctx);
      const block = {
        c: function create() {
          div = element("div");
          p0 = element("p");
          t0 = text("Mod: ");
          a = element("a");
          t1 = text(t1_value);
          t2 = space();
          p1 = element("p");
          t3 = text("Aclaracion: ");
          t4 = text(t4_value);
          t5 = space();
          p2 = element("p");
          t6 = text("Motivo: ");
          t7 = text(t7_value);
          t8 = space();
          p3 = element("p");
          t9 = text("Fecha: ");
          t10 = text(t10_value);
          t11 = space();
          p4 = element("p");
          t12 = text("Duracion: ");
          t13 = text(t13_value);
          t14 = space();
          p5 = element("p");
          t15 = text("Id del ban: ");
          t16 = text(t16_value);
          t17 = space();
          if (if_block0) if_block0.c();
          t18 = space();
          if (if_block1) if_block1.c();
          set_style(a, "color", "var(--color6)");
          attr_dev(a, "href", a_href_value = "/Moderacion/HistorialDeUsuario/" +
          /*ban*/
          ctx[0].modId);
          add_location(a, file$S, 10, 12, 322);
          attr_dev(p0, "class", "svelte-1o1jpaz");
          add_location(p0, file$S, 10, 4, 314);
          attr_dev(p1, "class", "svelte-1o1jpaz");
          add_location(p1, file$S, 11, 4, 427);
          attr_dev(p2, "class", "svelte-1o1jpaz");
          add_location(p2, file$S, 12, 4, 473);
          attr_dev(p3, "class", "svelte-1o1jpaz");
          add_location(p3, file$S, 13, 4, 530);
          attr_dev(p4, "class", "svelte-1o1jpaz");
          add_location(p4, file$S, 14, 4, 580);
          attr_dev(p5, "class", "svelte-1o1jpaz");
          add_location(p5, file$S, 15, 4, 635);
          attr_dev(div, "class", "ban svelte-1o1jpaz");
          add_location(div, file$S, 9, 0, 292);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          append_dev(div, p0);
          append_dev(p0, t0);
          append_dev(p0, a);
          append_dev(a, t1);
          append_dev(div, t2);
          append_dev(div, p1);
          append_dev(p1, t3);
          append_dev(p1, t4);
          append_dev(div, t5);
          append_dev(div, p2);
          append_dev(p2, t6);
          append_dev(p2, t7);
          append_dev(div, t8);
          append_dev(div, p3);
          append_dev(p3, t9);
          append_dev(p3, t10);
          append_dev(div, t11);
          append_dev(div, p4);
          append_dev(p4, t12);
          append_dev(p4, t13);
          append_dev(div, t14);
          append_dev(div, p5);
          append_dev(p5, t15);
          append_dev(p5, t16);
          append_dev(div, t17);
          if (if_block0) if_block0.m(div, null);
          append_dev(div, t18);
          if (if_block1) if_block1.m(div, null);
          current = true;
        },
        p: function update(ctx, [dirty]) {
          if ((!current || dirty &
          /*ban*/
          1) && t1_value !== (t1_value =
          /*ban*/
          ctx[0].modId + "")) set_data_dev(t1, t1_value);

          if (!current || dirty &
          /*ban*/
          1 && a_href_value !== (a_href_value = "/Moderacion/HistorialDeUsuario/" +
          /*ban*/
          ctx[0].modId)) {
            attr_dev(a, "href", a_href_value);
          }

          if ((!current || dirty &
          /*ban*/
          1) && t4_value !== (t4_value = (
          /*ban*/
          ctx[0].aclaracion || " ") + "")) set_data_dev(t4, t4_value);
          if ((!current || dirty &
          /*ban*/
          1) && t7_value !== (t7_value = MotivoDenuncia.aString(
          /*ban*/
          ctx[0].motivo) + "")) set_data_dev(t7, t7_value);
          if ((!current || dirty &
          /*ban*/
          1) && t10_value !== (t10_value = formatearTiempo(
          /*ban*/
          ctx[0].creacion) + "")) set_data_dev(t10, t10_value);
          if ((!current || dirty &
          /*ban*/
          1) && t13_value !== (t13_value = formatearTimeSpan(
          /*ban*/
          ctx[0].duracion) + "")) set_data_dev(t13, t13_value);
          if ((!current || dirty &
          /*ban*/
          1) && t16_value !== (t16_value =
          /*ban*/
          ctx[0].id + "")) set_data_dev(t16, t16_value);

          if (
          /*ban*/
          ctx[0].comentario) {
            if (if_block0) {
              if_block0.p(ctx, dirty);

              if (dirty &
              /*ban*/
              1) {
                transition_in(if_block0, 1);
              }
            } else {
              if_block0 = create_if_block_1$q(ctx);
              if_block0.c();
              transition_in(if_block0, 1);
              if_block0.m(div, t18);
            }
          } else if (if_block0) {
            group_outros();
            transition_out(if_block0, 1, 1, () => {
              if_block0 = null;
            });
            check_outros();
          }

          if (
          /*ban*/
          ctx[0].hilo) {
            if (if_block1) {
              if_block1.p(ctx, dirty);

              if (dirty &
              /*ban*/
              1) {
                transition_in(if_block1, 1);
              }
            } else {
              if_block1 = create_if_block$G(ctx);
              if_block1.c();
              transition_in(if_block1, 1);
              if_block1.m(div, null);
            }
          } else if (if_block1) {
            group_outros();
            transition_out(if_block1, 1, 1, () => {
              if_block1 = null;
            });
            check_outros();
          }
        },
        i: function intro(local) {
          if (current) return;
          transition_in(if_block0);
          transition_in(if_block1);
          current = true;
        },
        o: function outro(local) {
          transition_out(if_block0);
          transition_out(if_block1);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
          if (if_block0) if_block0.d();
          if (if_block1) if_block1.d();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$V.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }

    function instance$V($$self, $$props, $$invalidate) {
      let {
        $$slots: slots = {},
        $$scope
      } = $$props;
      validate_slots("BanPreview", slots, []);
      let {
        ban
      } = $$props;
      const writable_props = ["ban"];
      Object.keys($$props).forEach(key => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<BanPreview> was created with unknown prop '${key}'`);
      });

      $$self.$$set = $$props => {
        if ("ban" in $$props) $$invalidate(0, ban = $$props.ban);
      };

      $$self.$capture_state = () => ({
        MotivoDenuncia,
        formatearTiempo,
        formatearTimeSpan,
        Comentario,
        HiloPreviewMod,
        ban
      });

      $$self.$inject_state = $$props => {
        if ("ban" in $$props) $$invalidate(0, ban = $$props.ban);
      };

      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }

      return [ban];
    }

    class BanPreview extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$V, create_fragment$V, safe_not_equal, {
          ban: 0
        });
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "BanPreview",
          options,
          id: create_fragment$V.name
        });
        const {
          ctx
        } = this.$$;
        const props = options.props || {};

        if (
        /*ban*/
        ctx[0] === undefined && !("ban" in props)) {
          console.warn("<BanPreview> was created without expected prop 'ban'");
        }
      }

      get ban() {
        throw new Error("<BanPreview>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

      set ban(value) {
        throw new Error("<BanPreview>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
      }

    }

    /* src\components\Paginas\HistorialUsuario.svelte generated by Svelte v3.29.0 */
    const {
      Object: Object_1$7,
      console: console_1$g,
      window: window_1$3
    } = globals;
    const file$T = "src\\components\\Paginas\\HistorialUsuario.svelte";

    function get_each_context$l(ctx, list, i) {
      const child_ctx = ctx.slice();
      child_ctx[11] = list[i];
      return child_ctx;
    }

    function get_each_context_1$a(ctx, list, i) {
      const child_ctx = ctx.slice();
      child_ctx[14] = list[i];
      return child_ctx;
    }

    function get_each_context_2$6(ctx, list, i) {
      const child_ctx = ctx.slice();
      child_ctx[17] = list[i];
      return child_ctx;
    } // (85:4) {#if innerWidth < 956}


    function create_if_block_3$h(ctx) {
      let div;
      let button0;
      let t0;
      let button0_class_value;
      let t1;
      let button1;
      let t2;
      let button1_class_value;
      let t3;
      let button2;
      let t4;
      let button2_class_value;
      let mounted;
      let dispose;
      const block = {
        c: function create() {
          div = element("div");
          button0 = element("button");
          t0 = text("Últimos hilos");
          t1 = space();
          button1 = element("button");
          t2 = text("Últimos comentarios");
          t3 = space();
          button2 = element("button");
          t4 = text("Baneos");
          attr_dev(button0, "id", "tab1");
          attr_dev(button0, "class", button0_class_value = "boton " + (
          /*current*/
          ctx[1] === 1 ? "active" : "") + " svelte-ksrjjm");
          add_location(button0, file$T, 86, 12, 2907);
          attr_dev(button1, "id", "tab2");
          attr_dev(button1, "class", button1_class_value = "boton " + (
          /*current*/
          ctx[1] === 2 ? "active" : "") + " svelte-ksrjjm");
          add_location(button1, file$T, 94, 12, 3137);
          attr_dev(button2, "id", "tab3");
          attr_dev(button2, "class", button2_class_value = "boton " + (
          /*current*/
          ctx[1] === 3 ? "active" : "") + " svelte-ksrjjm");
          add_location(button2, file$T, 101, 12, 3371);
          attr_dev(div, "id", "botones");
          attr_dev(div, "class", "tab svelte-ksrjjm");
          add_location(div, file$T, 85, 8, 2863);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          append_dev(div, button0);
          append_dev(button0, t0);
          append_dev(div, t1);
          append_dev(div, button1);
          append_dev(button1, t2);
          append_dev(div, t3);
          append_dev(div, button2);
          append_dev(button2, t4);

          if (!mounted) {
            dispose = [listen_dev(button0, "click",
            /*click_handler*/
            ctx[7], false, false, false), listen_dev(button1, "click",
            /*click_handler_1*/
            ctx[8], false, false, false), listen_dev(button2, "click",
            /*click_handler_2*/
            ctx[9], false, false, false)];
            mounted = true;
          }
        },
        p: function update(ctx, dirty) {
          if (dirty &
          /*current*/
          2 && button0_class_value !== (button0_class_value = "boton " + (
          /*current*/
          ctx[1] === 1 ? "active" : "") + " svelte-ksrjjm")) {
            attr_dev(button0, "class", button0_class_value);
          }

          if (dirty &
          /*current*/
          2 && button1_class_value !== (button1_class_value = "boton " + (
          /*current*/
          ctx[1] === 2 ? "active" : "") + " svelte-ksrjjm")) {
            attr_dev(button1, "class", button1_class_value);
          }

          if (dirty &
          /*current*/
          2 && button2_class_value !== (button2_class_value = "boton " + (
          /*current*/
          ctx[1] === 3 ? "active" : "") + " svelte-ksrjjm")) {
            attr_dev(button2, "class", button2_class_value);
          }
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
          mounted = false;
          run_all(dispose);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_3$h.name,
        type: "if",
        source: "(85:4) {#if innerWidth < 956}",
        ctx
      });
      return block;
    } // (112:8) {#if innerWidth > 956 || current === 1}


    function create_if_block_2$p(ctx) {
      let ul;
      let h3;
      let t1;
      let each_blocks = [];
      let each_1_lookup = new Map();
      let ul_class_value;
      let current;
      let each_value_2 =
      /*hilos*/
      ctx[2];
      validate_each_argument(each_value_2);

      const get_key = ctx =>
      /*h*/
      ctx[17].id;

      validate_each_keys(ctx, each_value_2, get_each_context_2$6, get_key);

      for (let i = 0; i < each_value_2.length; i += 1) {
        let child_ctx = get_each_context_2$6(ctx, each_value_2, i);
        let key = get_key(child_ctx);
        each_1_lookup.set(key, each_blocks[i] = create_each_block_2$6(key, child_ctx));
      }

      const block = {
        c: function create() {
          ul = element("ul");
          h3 = element("h3");
          h3.textContent = "Ultimos hilos";
          t1 = space();

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].c();
          }

          set_style(h3, "height", "40px");
          add_location(h3, file$T, 116, 16, 3868);
          set_style(ul, "width", "33%");
          set_style(ul, "min-width", "33%");
          attr_dev(ul, "class", ul_class_value = "" + (null_to_empty(
          /*innerWidth*/
          ctx[0] <= 956 ? "resize" : "") + " svelte-ksrjjm"));
          add_location(ul, file$T, 112, 12, 3721);
        },
        m: function mount(target, anchor) {
          insert_dev(target, ul, anchor);
          append_dev(ul, h3);
          append_dev(ul, t1);

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].m(ul, null);
          }

          current = true;
        },
        p: function update(ctx, dirty) {
          if (dirty &
          /*hilos*/
          4) {
            const each_value_2 =
            /*hilos*/
            ctx[2];
            validate_each_argument(each_value_2);
            group_outros();
            validate_each_keys(ctx, each_value_2, get_each_context_2$6, get_key);
            each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value_2, each_1_lookup, ul, outro_and_destroy_block, create_each_block_2$6, null, get_each_context_2$6);
            check_outros();
          }

          if (!current || dirty &
          /*innerWidth*/
          1 && ul_class_value !== (ul_class_value = "" + (null_to_empty(
          /*innerWidth*/
          ctx[0] <= 956 ? "resize" : "") + " svelte-ksrjjm"))) {
            attr_dev(ul, "class", ul_class_value);
          }
        },
        i: function intro(local) {
          if (current) return;

          for (let i = 0; i < each_value_2.length; i += 1) {
            transition_in(each_blocks[i]);
          }

          current = true;
        },
        o: function outro(local) {
          for (let i = 0; i < each_blocks.length; i += 1) {
            transition_out(each_blocks[i]);
          }

          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(ul);

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].d();
          }
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_2$p.name,
        type: "if",
        source: "(112:8) {#if innerWidth > 956 || current === 1}",
        ctx
      });
      return block;
    } // (118:16) {#each hilos as h (h.id)}


    function create_each_block_2$6(key_1, ctx) {
      let first;
      let hilopreviewmod;
      let current;
      hilopreviewmod = new HiloPreviewMod({
        props: {
          hilo:
          /*h*/
          ctx[17]
        },
        $$inline: true
      });
      const block = {
        key: key_1,
        first: null,
        c: function create() {
          first = empty();
          create_component(hilopreviewmod.$$.fragment);
          this.first = first;
        },
        m: function mount(target, anchor) {
          insert_dev(target, first, anchor);
          mount_component(hilopreviewmod, target, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          const hilopreviewmod_changes = {};
          if (dirty &
          /*hilos*/
          4) hilopreviewmod_changes.hilo =
          /*h*/
          ctx[17];
          hilopreviewmod.$set(hilopreviewmod_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(hilopreviewmod.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(hilopreviewmod.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(first);
          destroy_component(hilopreviewmod, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_each_block_2$6.name,
        type: "each",
        source: "(118:16) {#each hilos as h (h.id)}",
        ctx
      });
      return block;
    } // (123:8) {#if innerWidth > 956 || current === 2}


    function create_if_block_1$r(ctx) {
      let ul;
      let h3;
      let t1;
      let each_blocks = [];
      let each_1_lookup = new Map();
      let ul_class_value;
      let current;
      let each_value_1 =
      /*comentarios*/
      ctx[3];
      validate_each_argument(each_value_1);

      const get_key = ctx =>
      /*c*/
      ctx[14].id;

      validate_each_keys(ctx, each_value_1, get_each_context_1$a, get_key);

      for (let i = 0; i < each_value_1.length; i += 1) {
        let child_ctx = get_each_context_1$a(ctx, each_value_1, i);
        let key = get_key(child_ctx);
        each_1_lookup.set(key, each_blocks[i] = create_each_block_1$a(key, child_ctx));
      }

      const block = {
        c: function create() {
          ul = element("ul");
          h3 = element("h3");
          h3.textContent = "Ultimos comentarios";
          t1 = space();

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].c();
          }

          set_style(h3, "height", "40px");
          add_location(h3, file$T, 127, 16, 4271);
          set_style(ul, "width", "33%");
          set_style(ul, "min-width", "33%");
          attr_dev(ul, "class", ul_class_value = "" + (null_to_empty(
          /*innerWidth*/
          ctx[0] <= 956 ? "resize" : "") + " svelte-ksrjjm"));
          add_location(ul, file$T, 123, 12, 4124);
        },
        m: function mount(target, anchor) {
          insert_dev(target, ul, anchor);
          append_dev(ul, h3);
          append_dev(ul, t1);

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].m(ul, null);
          }

          current = true;
        },
        p: function update(ctx, dirty) {
          if (dirty &
          /*comentarios*/
          8) {
            const each_value_1 =
            /*comentarios*/
            ctx[3];
            validate_each_argument(each_value_1);
            group_outros();
            validate_each_keys(ctx, each_value_1, get_each_context_1$a, get_key);
            each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value_1, each_1_lookup, ul, outro_and_destroy_block, create_each_block_1$a, null, get_each_context_1$a);
            check_outros();
          }

          if (!current || dirty &
          /*innerWidth*/
          1 && ul_class_value !== (ul_class_value = "" + (null_to_empty(
          /*innerWidth*/
          ctx[0] <= 956 ? "resize" : "") + " svelte-ksrjjm"))) {
            attr_dev(ul, "class", ul_class_value);
          }
        },
        i: function intro(local) {
          if (current) return;

          for (let i = 0; i < each_value_1.length; i += 1) {
            transition_in(each_blocks[i]);
          }

          current = true;
        },
        o: function outro(local) {
          for (let i = 0; i < each_blocks.length; i += 1) {
            transition_out(each_blocks[i]);
          }

          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(ul);

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].d();
          }
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_1$r.name,
        type: "if",
        source: "(123:8) {#if innerWidth > 956 || current === 2}",
        ctx
      });
      return block;
    } // (129:16) {#each comentarios as c (c.id)}


    function create_each_block_1$a(key_1, ctx) {
      let first;
      let comentariomod;
      let current;
      comentariomod = new ComentarioMod({
        props: {
          comentario:
          /*c*/
          ctx[14]
        },
        $$inline: true
      });
      const block = {
        key: key_1,
        first: null,
        c: function create() {
          first = empty();
          create_component(comentariomod.$$.fragment);
          this.first = first;
        },
        m: function mount(target, anchor) {
          insert_dev(target, first, anchor);
          mount_component(comentariomod, target, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          const comentariomod_changes = {};
          if (dirty &
          /*comentarios*/
          8) comentariomod_changes.comentario =
          /*c*/
          ctx[14];
          comentariomod.$set(comentariomod_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(comentariomod.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(comentariomod.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(first);
          destroy_component(comentariomod, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_each_block_1$a.name,
        type: "each",
        source: "(129:16) {#each comentarios as c (c.id)}",
        ctx
      });
      return block;
    } // (134:8) {#if innerWidth > 956 || current === 3}


    function create_if_block$H(ctx) {
      let ul;
      let h3;
      let t1;
      let ul_class_value;
      let current;
      let each_value =
      /*baneos*/
      ctx[5];
      validate_each_argument(each_value);
      let each_blocks = [];

      for (let i = 0; i < each_value.length; i += 1) {
        each_blocks[i] = create_each_block$l(get_each_context$l(ctx, each_value, i));
      }

      const out = i => transition_out(each_blocks[i], 1, 1, () => {
        each_blocks[i] = null;
      });

      const block = {
        c: function create() {
          ul = element("ul");
          h3 = element("h3");
          h3.textContent = "Baneos";
          t1 = space();

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].c();
          }

          set_style(h3, "height", "40px");
          add_location(h3, file$T, 138, 16, 4691);
          set_style(ul, "width", "33%");
          set_style(ul, "min-width", "33%");
          attr_dev(ul, "class", ul_class_value = "" + (null_to_empty(
          /*innerWidth*/
          ctx[0] <= 956 ? "resize" : "") + " svelte-ksrjjm"));
          add_location(ul, file$T, 134, 12, 4544);
        },
        m: function mount(target, anchor) {
          insert_dev(target, ul, anchor);
          append_dev(ul, h3);
          append_dev(ul, t1);

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].m(ul, null);
          }

          current = true;
        },
        p: function update(ctx, dirty) {
          if (dirty &
          /*baneos*/
          32) {
            each_value =
            /*baneos*/
            ctx[5];
            validate_each_argument(each_value);
            let i;

            for (i = 0; i < each_value.length; i += 1) {
              const child_ctx = get_each_context$l(ctx, each_value, i);

              if (each_blocks[i]) {
                each_blocks[i].p(child_ctx, dirty);
                transition_in(each_blocks[i], 1);
              } else {
                each_blocks[i] = create_each_block$l(child_ctx);
                each_blocks[i].c();
                transition_in(each_blocks[i], 1);
                each_blocks[i].m(ul, null);
              }
            }

            group_outros();

            for (i = each_value.length; i < each_blocks.length; i += 1) {
              out(i);
            }

            check_outros();
          }

          if (!current || dirty &
          /*innerWidth*/
          1 && ul_class_value !== (ul_class_value = "" + (null_to_empty(
          /*innerWidth*/
          ctx[0] <= 956 ? "resize" : "") + " svelte-ksrjjm"))) {
            attr_dev(ul, "class", ul_class_value);
          }
        },
        i: function intro(local) {
          if (current) return;

          for (let i = 0; i < each_value.length; i += 1) {
            transition_in(each_blocks[i]);
          }

          current = true;
        },
        o: function outro(local) {
          each_blocks = each_blocks.filter(Boolean);

          for (let i = 0; i < each_blocks.length; i += 1) {
            transition_out(each_blocks[i]);
          }

          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(ul);
          destroy_each(each_blocks, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block$H.name,
        type: "if",
        source: "(134:8) {#if innerWidth > 956 || current === 3}",
        ctx
      });
      return block;
    } // (140:16) {#each baneos as ban}


    function create_each_block$l(ctx) {
      let li;
      let banpreview;
      let t;
      let current;
      banpreview = new BanPreview({
        props: {
          ban:
          /*ban*/
          ctx[11]
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          li = element("li");
          create_component(banpreview.$$.fragment);
          t = space();
          set_style(li, "margin-bottom", "4px");
          add_location(li, file$T, 140, 20, 4787);
        },
        m: function mount(target, anchor) {
          insert_dev(target, li, anchor);
          mount_component(banpreview, li, null);
          append_dev(li, t);
          current = true;
        },
        p: noop,
        i: function intro(local) {
          if (current) return;
          transition_in(banpreview.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(banpreview.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(li);
          destroy_component(banpreview);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_each_block$l.name,
        type: "each",
        source: "(140:16) {#each baneos as ban}",
        ctx
      });
      return block;
    }

    function create_fragment$W(ctx) {
      let barramoderacion;
      let t0;
      let main;
      let div0;
      let h1;
      let t2;
      let div1;
      let p0;
      let t5;
      let p1;
      let t8;
      let p2;
      let t11;
      let p3;
      let t14;
      let t15;
      let div2;
      let t16;
      let t17;
      let current;
      let mounted;
      let dispose;
      add_render_callback(
      /*onwindowresize*/
      ctx[6]);
      barramoderacion = new BarraModeracion({
        $$inline: true
      });
      let if_block0 =
      /*innerWidth*/
      ctx[0] < 956 && create_if_block_3$h(ctx);
      let if_block1 = (
      /*innerWidth*/
      ctx[0] > 956 ||
      /*current*/
      ctx[1] === 1) && create_if_block_2$p(ctx);
      let if_block2 = (
      /*innerWidth*/
      ctx[0] > 956 ||
      /*current*/
      ctx[1] === 2) && create_if_block_1$r(ctx);
      let if_block3 = (
      /*innerWidth*/
      ctx[0] > 956 ||
      /*current*/
      ctx[1] === 3) && create_if_block$H(ctx);
      const block = {
        c: function create() {
          create_component(barramoderacion.$$.fragment);
          t0 = space();
          main = element("main");
          div0 = element("div");
          h1 = element("h1");
          h1.textContent = `${
      /*usuario*/
      ctx[4].userName}`;
          t2 = space();
          div1 = element("div");
          p0 = element("p");
          p0.textContent = `Id: ${
      /*usuario*/
      ctx[4].id}`;
          t5 = space();
          p1 = element("p");
          p1.textContent = `Registro: ${
      /*usuario*/
      ctx[4].creacion}`;
          t8 = space();
          p2 = element("p");
          p2.textContent = `Numero de rozs(en db): ${
      /*usuario*/
      ctx[4].rozs}`;
          t11 = space();
          p3 = element("p");
          p3.textContent = `Numero de comentarios(en db): ${
      /*usuario*/
      ctx[4].comentarios}`;
          t14 = space();
          if (if_block0) if_block0.c();
          t15 = space();
          div2 = element("div");
          if (if_block1) if_block1.c();
          t16 = space();
          if (if_block2) if_block2.c();
          t17 = space();
          if (if_block3) if_block3.c();
          attr_dev(h1, "class", "svelte-ksrjjm");
          add_location(h1, file$T, 76, 8, 2543);
          attr_dev(div0, "class", "panel svelte-ksrjjm");
          set_style(div0, "background", "var(--color6)", 1);
          set_style(div0, "color", "black");
          set_style(div0, "padding", "8px 16px");
          add_location(div0, file$T, 72, 4, 2415);
          add_location(p0, file$T, 79, 8, 2623);
          add_location(p1, file$T, 80, 8, 2656);
          add_location(p2, file$T, 81, 8, 2701);
          add_location(p3, file$T, 82, 8, 2755);
          attr_dev(div1, "class", "panel svelte-ksrjjm");
          add_location(div1, file$T, 78, 4, 2594);
          attr_dev(div2, "class", "historial svelte-ksrjjm");
          set_style(div2, "min-width", "33%");
          add_location(div2, file$T, 110, 4, 3611);
          attr_dev(main, "class", "svelte-ksrjjm");
          add_location(main, file$T, 71, 0, 2403);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          mount_component(barramoderacion, target, anchor);
          insert_dev(target, t0, anchor);
          insert_dev(target, main, anchor);
          append_dev(main, div0);
          append_dev(div0, h1);
          append_dev(main, t2);
          append_dev(main, div1);
          append_dev(div1, p0);
          append_dev(div1, t5);
          append_dev(div1, p1);
          append_dev(div1, t8);
          append_dev(div1, p2);
          append_dev(div1, t11);
          append_dev(div1, p3);
          append_dev(main, t14);
          if (if_block0) if_block0.m(main, null);
          append_dev(main, t15);
          append_dev(main, div2);
          if (if_block1) if_block1.m(div2, null);
          append_dev(div2, t16);
          if (if_block2) if_block2.m(div2, null);
          append_dev(div2, t17);
          if (if_block3) if_block3.m(div2, null);
          current = true;

          if (!mounted) {
            dispose = listen_dev(window_1$3, "resize",
            /*onwindowresize*/
            ctx[6]);
            mounted = true;
          }
        },
        p: function update(ctx, [dirty]) {
          if (
          /*innerWidth*/
          ctx[0] < 956) {
            if (if_block0) {
              if_block0.p(ctx, dirty);
            } else {
              if_block0 = create_if_block_3$h(ctx);
              if_block0.c();
              if_block0.m(main, t15);
            }
          } else if (if_block0) {
            if_block0.d(1);
            if_block0 = null;
          }

          if (
          /*innerWidth*/
          ctx[0] > 956 ||
          /*current*/
          ctx[1] === 1) {
            if (if_block1) {
              if_block1.p(ctx, dirty);

              if (dirty &
              /*innerWidth, current*/
              3) {
                transition_in(if_block1, 1);
              }
            } else {
              if_block1 = create_if_block_2$p(ctx);
              if_block1.c();
              transition_in(if_block1, 1);
              if_block1.m(div2, t16);
            }
          } else if (if_block1) {
            group_outros();
            transition_out(if_block1, 1, 1, () => {
              if_block1 = null;
            });
            check_outros();
          }

          if (
          /*innerWidth*/
          ctx[0] > 956 ||
          /*current*/
          ctx[1] === 2) {
            if (if_block2) {
              if_block2.p(ctx, dirty);

              if (dirty &
              /*innerWidth, current*/
              3) {
                transition_in(if_block2, 1);
              }
            } else {
              if_block2 = create_if_block_1$r(ctx);
              if_block2.c();
              transition_in(if_block2, 1);
              if_block2.m(div2, t17);
            }
          } else if (if_block2) {
            group_outros();
            transition_out(if_block2, 1, 1, () => {
              if_block2 = null;
            });
            check_outros();
          }

          if (
          /*innerWidth*/
          ctx[0] > 956 ||
          /*current*/
          ctx[1] === 3) {
            if (if_block3) {
              if_block3.p(ctx, dirty);

              if (dirty &
              /*innerWidth, current*/
              3) {
                transition_in(if_block3, 1);
              }
            } else {
              if_block3 = create_if_block$H(ctx);
              if_block3.c();
              transition_in(if_block3, 1);
              if_block3.m(div2, null);
            }
          } else if (if_block3) {
            group_outros();
            transition_out(if_block3, 1, 1, () => {
              if_block3 = null;
            });
            check_outros();
          }
        },
        i: function intro(local) {
          if (current) return;
          transition_in(barramoderacion.$$.fragment, local);
          transition_in(if_block1);
          transition_in(if_block2);
          transition_in(if_block3);
          current = true;
        },
        o: function outro(local) {
          transition_out(barramoderacion.$$.fragment, local);
          transition_out(if_block1);
          transition_out(if_block2);
          transition_out(if_block3);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(barramoderacion, detaching);
          if (detaching) detach_dev(t0);
          if (detaching) detach_dev(main);
          if (if_block0) if_block0.d();
          if (if_block1) if_block1.d();
          if (if_block2) if_block2.d();
          if (if_block3) if_block3.d();
          mounted = false;
          dispose();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$W.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }

    function instance$W($$self, $$props, $$invalidate) {
      let {
        $$slots: slots = {},
        $$scope
      } = $$props;
      validate_slots("HistorialUsuario", slots, []);
      let innerWidth = window.innerWidth;
      let current = 2;
      let hilos = window.model.hilos;
      let comentarios = window.model.comentarios;
      let usuario = window.model.usuario;
      let baneos = window.model.baneos; // let denuncias = window.model.denuncias

      const motivo = Object.keys(MotivoDenuncia);
      comentarios = comentarios.map(c => {
        c.respuestas = [];
        return c;
      });
      Signal.subscribirAModeracion();
      Signal.subscribirAHome();
      Signal.coneccion.on("NuevoComentarioMod", comentario => {
        if (comentario.usuarioId == usuario.id) {
          comentario.respuestas = [];
          comentarios.unshift(comentario);
          $$invalidate(3, comentarios);
        }
      });
      Signal.coneccion.on("HiloCreadoMod", hilo => {
        console.log(hilo);

        if (hilo.usuarioId == usuario.id) {
          $$invalidate(2, hilos = [hilo, ...hilos]);
        }
      });
      Signal.coneccion.on("categoriaCambiada", data => {
        let hilo = hilos.filter(h => h.id == data.hiloId);

        if (hilo.length != 0) {
          hilo[0].categoriaId = data.categoriaId;
          $$invalidate(2, hilos);
        }
      });
      Signal.coneccion.on("HilosEliminados", ids => {
        let hs = hilos.filter(h => ids.includes(h.id));

        if (hs.length != 0) {
          hs.map(h => h.estado = HiloEstado.eliminado);
          $$invalidate(2, hilos);
        }
      });
      Signal.coneccion.on("ComentariosEliminados", ids => {
        let cs = comentarios.filter(c => ids.includes(c.id));

        if (cs.length != 0) {
          cs.map(c => {
            c.estado = ComentarioEstado.eliminado;
          });
          $$invalidate(3, comentarios);
        }
      });
      const writable_props = [];
      Object_1$7.keys($$props).forEach(key => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$g.warn(`<HistorialUsuario> was created with unknown prop '${key}'`);
      });

      function onwindowresize() {
        $$invalidate(0, innerWidth = window_1$3.innerWidth);
      }

      const click_handler = () => $$invalidate(1, current = 1);

      const click_handler_1 = () => $$invalidate(1, current = 2);

      const click_handler_2 = () => $$invalidate(1, current = 3);

      $$self.$capture_state = () => ({
        BarraModeracion,
        ComentarioMod,
        HiloPreviewMod,
        MotivoDenuncia,
        formatearTiempo,
        formatearTimeSpan,
        BanPreview,
        HiloEstado,
        ComentarioEstado,
        Signal,
        innerWidth,
        current,
        hilos,
        comentarios,
        usuario,
        baneos,
        motivo
      });

      $$self.$inject_state = $$props => {
        if ("innerWidth" in $$props) $$invalidate(0, innerWidth = $$props.innerWidth);
        if ("current" in $$props) $$invalidate(1, current = $$props.current);
        if ("hilos" in $$props) $$invalidate(2, hilos = $$props.hilos);
        if ("comentarios" in $$props) $$invalidate(3, comentarios = $$props.comentarios);
        if ("usuario" in $$props) $$invalidate(4, usuario = $$props.usuario);
        if ("baneos" in $$props) $$invalidate(5, baneos = $$props.baneos);
      };

      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }

      return [innerWidth, current, hilos, comentarios, usuario, baneos, onwindowresize, click_handler, click_handler_1, click_handler_2];
    }

    class HistorialUsuario extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$W, create_fragment$W, safe_not_equal, {});
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "HistorialUsuario",
          options,
          id: create_fragment$W.name
        });
      }

    }

    /* src\components\Paginas\Domado.svelte generated by Svelte v3.29.0 */
    const file$U = "src\\components\\Paginas\\Domado.svelte"; // (17:8) {#if !esAdvertencia}

    function create_if_block$I(ctx) {
      let p0;
      let t2;
      let p1;
      let t5;
      let p2;
      const block = {
        c: function create() {
          p0 = element("p");
          p0.textContent = `Duracion: ${formatearTimeSpan(
      /*ban*/
      ctx[0].duracion)}`;
          t2 = space();
          p1 = element("p");
          p1.textContent = `Expira el: ${formatearTiempo(
      /*ban*/
      ctx[0].expiracion)}`;
          t5 = space();
          p2 = element("p");
          p2.textContent = `Id del ban: ${
      /*ban*/
      ctx[0].id}`;
          add_location(p0, file$U, 17, 12, 875);
          add_location(p1, file$U, 18, 12, 938);
          add_location(p2, file$U, 19, 12, 1002);
        },
        m: function mount(target, anchor) {
          insert_dev(target, p0, anchor);
          insert_dev(target, t2, anchor);
          insert_dev(target, p1, anchor);
          insert_dev(target, t5, anchor);
          insert_dev(target, p2, anchor);
        },
        p: noop,
        d: function destroy(detaching) {
          if (detaching) detach_dev(p0);
          if (detaching) detach_dev(t2);
          if (detaching) detach_dev(p1);
          if (detaching) detach_dev(t5);
          if (detaching) detach_dev(p2);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block$I.name,
        type: "if",
        source: "(17:8) {#if !esAdvertencia}",
        ctx
      });
      return block;
    } // (24:12) <Button>


    function create_default_slot_1$s(ctx) {
      let t;
      const block = {
        c: function create() {
          t = text("Aceptar");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_1$s.name,
        type: "slot",
        source: "(24:12) <Button>",
        ctx
      });
      return block;
    } // (27:12) <Button>


    function create_default_slot$x(ctx) {
      let t;
      const block = {
        c: function create() {
          t = text("Ver reglas");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot$x.name,
        type: "slot",
        source: "(27:12) <Button>",
        ctx
      });
      return block;
    }

    function create_fragment$X(ctx) {
      let div1;
      let div0;
      let h1;
      let t3;
      let h2;
      let t10;
      let h3;
      let t11;
      let strong;
      let t13;
      let p0;
      let t16;
      let p1;
      let t19;
      let t20;
      let a0;
      let button0;
      let t21;
      let a1;
      let button1;
      let current;
      let if_block = !
      /*esAdvertencia*/
      ctx[1] && create_if_block$I(ctx);
      button0 = new ye({
        props: {
          $$slots: {
            default: [create_default_slot_1$s]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      button1 = new ye({
        props: {
          $$slots: {
            default: [create_default_slot$x]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          div1 = element("div");
          div0 = element("div");
          h1 = element("h1");
          h1.textContent = `Has sido ${
      /*esAdvertencia*/
      ctx[1] ? "advertido" : "baneado"}!`;
          t3 = space();
          h2 = element("h2");
          h2.textContent = `Fuiste ${
      /*esAdvertencia*/
      ctx[1] ? "advertido" : "baneado"} por romper las reglas de ${config.nombre}  ${
      /*ban*/
      ctx[0].tipo == 0 ? `en el roz "${
      /*ban*/
      ctx[0].hilo}"` : `en un comentario en el roz "${
      /*ban*/
      ctx[0].hilo}"`}`;
          t10 = space();
          h3 = element("h3");
          t11 = text("Aclaracion: ");
          strong = element("strong");
          strong.textContent = `${
      /*ban*/
      ctx[0].aclaracion || " "}`;
          t13 = space();
          p0 = element("p");
          p0.textContent = `Motivo: ${
      /*ban*/
      ctx[0].motivo}`;
          t16 = space();
          p1 = element("p");
          p1.textContent = `Fecha: ${formatearTiempo(
      /*ban*/
      ctx[0].creacion)}`;
          t19 = space();
          if (if_block) if_block.c();
          t20 = space();
          a0 = element("a");
          create_component(button0.$$.fragment);
          t21 = space();
          a1 = element("a");
          create_component(button1.$$.fragment);
          add_location(h1, file$U, 10, 8, 401);
          set_style(h2, "margin-bottom", "10px");
          add_location(h2, file$U, 11, 8, 466);
          add_location(strong, file$U, 12, 24, 697);
          add_location(h3, file$U, 12, 8, 681);
          add_location(p0, file$U, 13, 8, 751);
          add_location(p1, file$U, 14, 8, 787);
          attr_dev(a0, "href", "/");
          add_location(a0, file$U, 22, 8, 1061);
          attr_dev(a1, "href", "/reglas.html");
          add_location(a1, file$U, 25, 8, 1132);
          attr_dev(div0, "class", "ban svelte-19dvpob");
          toggle_class(div0, "advertencia",
          /*esAdvertencia*/
          ctx[1]);
          add_location(div0, file$U, 9, 4, 341);
          attr_dev(div1, "class", "fondo svelte-19dvpob");
          add_location(div1, file$U, 8, 0, 317);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, div1, anchor);
          append_dev(div1, div0);
          append_dev(div0, h1);
          append_dev(div0, t3);
          append_dev(div0, h2);
          append_dev(div0, t10);
          append_dev(div0, h3);
          append_dev(h3, t11);
          append_dev(h3, strong);
          append_dev(div0, t13);
          append_dev(div0, p0);
          append_dev(div0, t16);
          append_dev(div0, p1);
          append_dev(div0, t19);
          if (if_block) if_block.m(div0, null);
          append_dev(div0, t20);
          append_dev(div0, a0);
          mount_component(button0, a0, null);
          append_dev(div0, t21);
          append_dev(div0, a1);
          mount_component(button1, a1, null);
          current = true;
        },
        p: function update(ctx, [dirty]) {
          if (!
          /*esAdvertencia*/
          ctx[1]) if_block.p(ctx, dirty);
          const button0_changes = {};

          if (dirty &
          /*$$scope*/
          4) {
            button0_changes.$$scope = {
              dirty,
              ctx
            };
          }

          button0.$set(button0_changes);
          const button1_changes = {};

          if (dirty &
          /*$$scope*/
          4) {
            button1_changes.$$scope = {
              dirty,
              ctx
            };
          }

          button1.$set(button1_changes);

          if (dirty &
          /*esAdvertencia*/
          2) {
            toggle_class(div0, "advertencia",
            /*esAdvertencia*/
            ctx[1]);
          }
        },
        i: function intro(local) {
          if (current) return;
          transition_in(button0.$$.fragment, local);
          transition_in(button1.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(button0.$$.fragment, local);
          transition_out(button1.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div1);
          if (if_block) if_block.d();
          destroy_component(button0);
          destroy_component(button1);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$X.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }

    function instance$X($$self, $$props, $$invalidate) {
      let {
        $$slots: slots = {},
        $$scope
      } = $$props;
      validate_slots("Domado", slots, []);
      const ban = window.model.ban;
      const esAdvertencia = ban.duracion.includes("00:00:00") && (ban.duracion.length == 16 || ban.duracion.length == 8);
      const writable_props = [];
      Object.keys($$props).forEach(key => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Domado> was created with unknown prop '${key}'`);
      });

      $$self.$capture_state = () => ({
        Button: ye,
        config,
        formatearTiempo,
        formatearTimeSpan,
        ban,
        esAdvertencia
      });

      return [ban, esAdvertencia];
    }

    class Domado extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$X, create_fragment$X, safe_not_equal, {});
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "Domado",
          options,
          id: create_fragment$X.name
        });
      }

    }

    /* src\components\Paginas\ListaDeUsuarios.svelte generated by Svelte v3.29.0 */
    const file$V = "src\\components\\Paginas\\ListaDeUsuarios.svelte";

    function get_each_context$m(ctx, list, i) {
      const child_ctx = ctx.slice();
      child_ctx[6] = list[i];
      return child_ctx;
    }

    function get_each_context_1$b(ctx, list, i) {
      const child_ctx = ctx.slice();
      child_ctx[9] = list[i];
      return child_ctx;
    } // (53:20) {#if b.hilo}


    function create_if_block_1$s(ctx) {
      let a;
      let t_value =
      /*b*/
      ctx[9].hilo.titulo + "";
      let t;
      let a_href_value;
      const block = {
        c: function create() {
          a = element("a");
          t = text(t_value);
          attr_dev(a, "href", a_href_value = "/Hilo/" +
          /*b*/
          ctx[9].hilo.id);
          attr_dev(a, "class", "svelte-1up7e9e");
          add_location(a, file$V, 53, 24, 2491);
        },
        m: function mount(target, anchor) {
          insert_dev(target, a, anchor);
          append_dev(a, t);
        },
        p: noop,
        d: function destroy(detaching) {
          if (detaching) detach_dev(a);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_1$s.name,
        type: "if",
        source: "(53:20) {#if b.hilo}",
        ctx
      });
      return block;
    } // (26:12) {#each ultimosBaneos as b}


    function create_each_block_1$b(ctx) {
      let li;
      let a;
      let t0;
      let a_href_value;
      let t1;
      let span0;
      let tiempo;
      let t2;
      let span1;
      let t3_value = (formatearTimeSpan(
      /*b*/
      ctx[9].duracion).includes("69444D ") ? "Perma" : formatearTimeSpan(
      /*b*/
      ctx[9].duracion)) + "";
      let t3;
      let t4;
      let t5;
      let li_style_value;
      let current;
      let mounted;
      let dispose;
      tiempo = new Tiempo({
        props: {
          date:
          /*b*/
          ctx[9].creacion
        },
        $$inline: true
      });
      let if_block =
      /*b*/
      ctx[9].hilo && create_if_block_1$s(ctx);

      function mouseenter_handler(...args) {
        return (
          /*mouseenter_handler*/
          ctx[4](
          /*b*/
          ctx[9], ...args)
        );
      }

      const block = {
        c: function create() {
          li = element("li");
          a = element("a");
          t0 = text("Mod");
          t1 = space();
          span0 = element("span");
          create_component(tiempo.$$.fragment);
          t2 = space();
          span1 = element("span");
          t3 = text(t3_value);
          t4 = space();
          if (if_block) if_block.c();
          t5 = space();
          attr_dev(a, "href", a_href_value = "/Moderacion/HistorialDeUsuario/" +
          /*b*/
          ctx[9].modId);
          set_style(a, "background", "var(--color3)");
          attr_dev(a, "class", "svelte-1up7e9e");
          add_location(a, file$V, 44, 20, 1896);
          set_style(span0, "background", "var(--color3)");
          attr_dev(span0, "class", "svelte-1up7e9e");
          add_location(span0, file$V, 45, 20, 2009);
          set_style(span1, "background", "var(--color3)");
          attr_dev(span1, "class", "svelte-1up7e9e");
          add_location(span1, file$V, 48, 20, 2152);
          attr_dev(li, "class", "accion svelte-1up7e9e");
          attr_dev(li, "style", li_style_value =
          /*b*/
          ctx[9] ==
          /*banVisto*/
          ctx[0] ? "background: var(--color6);" : "");
          add_location(li, file$V, 41, 16, 1724);
        },
        m: function mount(target, anchor) {
          insert_dev(target, li, anchor);
          append_dev(li, a);
          append_dev(a, t0);
          append_dev(li, t1);
          append_dev(li, span0);
          mount_component(tiempo, span0, null);
          append_dev(li, t2);
          append_dev(li, span1);
          append_dev(span1, t3);
          append_dev(li, t4);
          if (if_block) if_block.m(li, null);
          append_dev(li, t5);
          current = true;

          if (!mounted) {
            dispose = listen_dev(li, "mouseenter", mouseenter_handler, false, false, false);
            mounted = true;
          }
        },
        p: function update(new_ctx, dirty) {
          ctx = new_ctx;
          if (
          /*b*/
          ctx[9].hilo) if_block.p(ctx, dirty);

          if (!current || dirty &
          /*banVisto*/
          1 && li_style_value !== (li_style_value =
          /*b*/
          ctx[9] ==
          /*banVisto*/
          ctx[0] ? "background: var(--color6);" : "")) {
            attr_dev(li, "style", li_style_value);
          }
        },
        i: function intro(local) {
          if (current) return;
          transition_in(tiempo.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(tiempo.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(li);
          destroy_component(tiempo);
          if (if_block) if_block.d();
          mounted = false;
          dispose();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_each_block_1$b.name,
        type: "each",
        source: "(26:12) {#each ultimosBaneos as b}",
        ctx
      });
      return block;
    } // (62:12) {#if banVisto != null }


    function create_if_block$J(ctx) {
      let previous_key =
      /*banVisto*/
      ctx[0];
      let key_block_anchor;
      let current;
      let key_block = create_key_block(ctx);
      const block = {
        c: function create() {
          key_block.c();
          key_block_anchor = empty();
        },
        m: function mount(target, anchor) {
          key_block.m(target, anchor);
          insert_dev(target, key_block_anchor, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          if (dirty &
          /*banVisto*/
          1 && safe_not_equal(previous_key, previous_key =
          /*banVisto*/
          ctx[0])) {
            group_outros();
            transition_out(key_block, 1, 1, noop);
            check_outros();
            key_block = create_key_block(ctx);
            key_block.c();
            transition_in(key_block);
            key_block.m(key_block_anchor.parentNode, key_block_anchor);
          } else {
            key_block.p(ctx, dirty);
          }
        },
        i: function intro(local) {
          if (current) return;
          transition_in(key_block);
          current = true;
        },
        o: function outro(local) {
          transition_out(key_block);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(key_block_anchor);
          key_block.d(detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block$J.name,
        type: "if",
        source: "(62:12) {#if banVisto != null }",
        ctx
      });
      return block;
    } // (69:93) <Button>


    function create_default_slot_1$t(ctx) {
      let t;
      const block = {
        c: function create() {
          t = text("Desbanear");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_1$t.name,
        type: "slot",
        source: "(69:93) <Button>",
        ctx
      });
      return block;
    } // (69:24) <span slot="activador" style="display:flex;justify-content:center;">


    function create_activador_slot$5(ctx) {
      let span;
      let button;
      let current;
      button = new ye({
        props: {
          $$slots: {
            default: [create_default_slot_1$t]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          span = element("span");
          create_component(button.$$.fragment);
          attr_dev(span, "slot", "activador");
          set_style(span, "display", "flex");
          set_style(span, "justify-content", "center");
          add_location(span, file$V, 68, 24, 3033);
        },
        m: function mount(target, anchor) {
          insert_dev(target, span, anchor);
          mount_component(button, span, null);
          current = true;
        },
        p: function update(ctx, dirty) {
          const button_changes = {};

          if (dirty &
          /*$$scope*/
          4096) {
            button_changes.$$scope = {
              dirty,
              ctx
            };
          }

          button.$set(button_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(button.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(button.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(span);
          destroy_component(button);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_activador_slot$5.name,
        type: "slot",
        source: "(69:24) <span slot=\\\"activador\\\" style=\\\"display:flex;justify-content:center;\\\">",
        ctx
      });
      return block;
    } // (70:24) <div slot="body">


    function create_body_slot$4(ctx) {
      let div;
      const block = {
        c: function create() {
          div = element("div");
          div.textContent = "Remover ban?";
          attr_dev(div, "slot", "body");
          add_location(div, file$V, 69, 24, 3160);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_body_slot$4.name,
        type: "slot",
        source: "(70:24) <div slot=\\\"body\\\">",
        ctx
      });
      return block;
    } // (65:20) <Dialogo                         textoActivador="Desbanear"                         titulo="Desbanear gordo"                         accion={() => RChanClient.removerBan(banVisto.id)}>


    function create_default_slot$y(ctx) {
      let t;
      const block = {
        c: function create() {
          t = space();
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        p: noop,
        i: noop,
        o: noop,
        d: function destroy(detaching) {
          if (detaching) detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot$y.name,
        type: "slot",
        source: "(65:20) <Dialogo                         textoActivador=\\\"Desbanear\\\"                         titulo=\\\"Desbanear gordo\\\"                         accion={() => RChanClient.removerBan(banVisto.id)}>",
        ctx
      });
      return block;
    } // (63:16) {#key banVisto}


    function create_key_block(ctx) {
      let banpreview;
      let t;
      let dialogo;
      let current;
      banpreview = new BanPreview({
        props: {
          ban:
          /*banVisto*/
          ctx[0]
        },
        $$inline: true
      });
      dialogo = new Dialogo({
        props: {
          textoActivador: "Desbanear",
          titulo: "Desbanear gordo",
          accion:
          /*func*/
          ctx[5],
          $$slots: {
            default: [create_default_slot$y],
            body: [create_body_slot$4],
            activador: [create_activador_slot$5]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          create_component(banpreview.$$.fragment);
          t = space();
          create_component(dialogo.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(banpreview, target, anchor);
          insert_dev(target, t, anchor);
          mount_component(dialogo, target, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          const banpreview_changes = {};
          if (dirty &
          /*banVisto*/
          1) banpreview_changes.ban =
          /*banVisto*/
          ctx[0];
          banpreview.$set(banpreview_changes);
          const dialogo_changes = {};
          if (dirty &
          /*banVisto*/
          1) dialogo_changes.accion =
          /*func*/
          ctx[5];

          if (dirty &
          /*$$scope*/
          4096) {
            dialogo_changes.$$scope = {
              dirty,
              ctx
            };
          }

          dialogo.$set(dialogo_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(banpreview.$$.fragment, local);
          transition_in(dialogo.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(banpreview.$$.fragment, local);
          transition_out(dialogo.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(banpreview, detaching);
          if (detaching) detach_dev(t);
          destroy_component(dialogo, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_key_block.name,
        type: "key",
        source: "(63:16) {#key banVisto}",
        ctx
      });
      return block;
    } // (80:12) {#each ultimosRegistros as u}


    function create_each_block$m(ctx) {
      let li;
      let t0;
      let a;
      let t1_value =
      /*u*/
      ctx[6].userName + "";
      let t1;
      let a_href_value;
      let t2;
      let tiempo;
      let t3;
      let current;
      tiempo = new Tiempo({
        props: {
          date:
          /*u*/
          ctx[6].creacion
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          li = element("li");
          t0 = text("Se registro \n                    ");
          a = element("a");
          t1 = text(t1_value);
          t2 = text("  \n                    hace ");
          create_component(tiempo.$$.fragment);
          t3 = space();
          set_style(a, "color", "var(--color6)");
          attr_dev(a, "href", a_href_value = "/Moderacion/HistorialDeUsuario/" +
          /*u*/
          ctx[6].id);
          add_location(a, file$V, 81, 20, 3596);
          set_style(li, "padding", "4px 8px");
          attr_dev(li, "class", "svelte-1up7e9e");
          add_location(li, file$V, 80, 16, 3535);
        },
        m: function mount(target, anchor) {
          insert_dev(target, li, anchor);
          append_dev(li, t0);
          append_dev(li, a);
          append_dev(a, t1);
          append_dev(li, t2);
          mount_component(tiempo, li, null);
          append_dev(li, t3);
          current = true;
        },
        p: noop,
        i: function intro(local) {
          if (current) return;
          transition_in(tiempo.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(tiempo.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(li);
          destroy_component(tiempo);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_each_block$m.name,
        type: "each",
        source: "(80:12) {#each ultimosRegistros as u}",
        ctx
      });
      return block;
    }

    function create_fragment$Y(ctx) {
      let barramoderacion;
      let t0;
      let section;
      let div0;
      let h20;
      let t2;
      let ul0;
      let t3;
      let div1;
      let t4;
      let div2;
      let h21;
      let t6;
      let h4;
      let t10;
      let br;
      let t11;
      let ul1;
      let current;
      barramoderacion = new BarraModeracion({
        $$inline: true
      });
      let each_value_1 =
      /*ultimosBaneos*/
      ctx[2];
      validate_each_argument(each_value_1);
      let each_blocks_1 = [];

      for (let i = 0; i < each_value_1.length; i += 1) {
        each_blocks_1[i] = create_each_block_1$b(get_each_context_1$b(ctx, each_value_1, i));
      }

      const out = i => transition_out(each_blocks_1[i], 1, 1, () => {
        each_blocks_1[i] = null;
      });

      let if_block =
      /*banVisto*/
      ctx[0] != null && create_if_block$J(ctx);
      let each_value =
      /*ultimosRegistros*/
      ctx[1];
      validate_each_argument(each_value);
      let each_blocks = [];

      for (let i = 0; i < each_value.length; i += 1) {
        each_blocks[i] = create_each_block$m(get_each_context$m(ctx, each_value, i));
      }

      const out_1 = i => transition_out(each_blocks[i], 1, 1, () => {
        each_blocks[i] = null;
      });

      const block = {
        c: function create() {
          create_component(barramoderacion.$$.fragment);
          t0 = space();
          section = element("section");
          div0 = element("div");
          h20 = element("h2");
          h20.textContent = "Baneos activos";
          t2 = space();
          ul0 = element("ul");

          for (let i = 0; i < each_blocks_1.length; i += 1) {
            each_blocks_1[i].c();
          }

          t3 = space();
          div1 = element("div");
          if (if_block) if_block.c();
          t4 = space();
          div2 = element("div");
          h21 = element("h2");
          h21.textContent = "Ultimos 100 usuarios registrados";
          t6 = space();
          h4 = element("h4");
          h4.textContent = `Hay un total de ${
      /*cantidadDeUsuarios*/
      ctx[3]} usuarios registrados`;
          t10 = space();
          br = element("br");
          t11 = space();
          ul1 = element("ul");

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].c();
          }

          add_location(h20, file$V, 23, 8, 832);
          attr_dev(ul0, "class", "svelte-1up7e9e");
          add_location(ul0, file$V, 24, 8, 864);
          attr_dev(div0, "class", "lista-baneos panel svelte-1up7e9e");
          add_location(div0, file$V, 22, 4, 791);
          attr_dev(div1, "class", "vista-previa panel svelte-1up7e9e");
          add_location(div1, file$V, 60, 8, 2653);
          add_location(h21, file$V, 75, 8, 3330);
          add_location(h4, file$V, 76, 8, 3380);
          add_location(br, file$V, 77, 8, 3455);
          attr_dev(ul1, "class", "svelte-1up7e9e");
          add_location(ul1, file$V, 78, 8, 3468);
          attr_dev(div2, "class", "lista-usuarios panel svelte-1up7e9e");
          add_location(div2, file$V, 74, 4, 3287);
          attr_dev(section, "class", "svelte-1up7e9e");
          add_location(section, file$V, 21, 0, 777);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          mount_component(barramoderacion, target, anchor);
          insert_dev(target, t0, anchor);
          insert_dev(target, section, anchor);
          append_dev(section, div0);
          append_dev(div0, h20);
          append_dev(div0, t2);
          append_dev(div0, ul0);

          for (let i = 0; i < each_blocks_1.length; i += 1) {
            each_blocks_1[i].m(ul0, null);
          }

          append_dev(section, t3);
          append_dev(section, div1);
          if (if_block) if_block.m(div1, null);
          append_dev(section, t4);
          append_dev(section, div2);
          append_dev(div2, h21);
          append_dev(div2, t6);
          append_dev(div2, h4);
          append_dev(div2, t10);
          append_dev(div2, br);
          append_dev(div2, t11);
          append_dev(div2, ul1);

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].m(ul1, null);
          }

          current = true;
        },
        p: function update(ctx, [dirty]) {
          if (dirty &
          /*ultimosBaneos, banVisto, formatearTimeSpan*/
          5) {
            each_value_1 =
            /*ultimosBaneos*/
            ctx[2];
            validate_each_argument(each_value_1);
            let i;

            for (i = 0; i < each_value_1.length; i += 1) {
              const child_ctx = get_each_context_1$b(ctx, each_value_1, i);

              if (each_blocks_1[i]) {
                each_blocks_1[i].p(child_ctx, dirty);
                transition_in(each_blocks_1[i], 1);
              } else {
                each_blocks_1[i] = create_each_block_1$b(child_ctx);
                each_blocks_1[i].c();
                transition_in(each_blocks_1[i], 1);
                each_blocks_1[i].m(ul0, null);
              }
            }

            group_outros();

            for (i = each_value_1.length; i < each_blocks_1.length; i += 1) {
              out(i);
            }

            check_outros();
          }

          if (
          /*banVisto*/
          ctx[0] != null) {
            if (if_block) {
              if_block.p(ctx, dirty);

              if (dirty &
              /*banVisto*/
              1) {
                transition_in(if_block, 1);
              }
            } else {
              if_block = create_if_block$J(ctx);
              if_block.c();
              transition_in(if_block, 1);
              if_block.m(div1, null);
            }
          } else if (if_block) {
            group_outros();
            transition_out(if_block, 1, 1, () => {
              if_block = null;
            });
            check_outros();
          }

          if (dirty &
          /*ultimosRegistros*/
          2) {
            each_value =
            /*ultimosRegistros*/
            ctx[1];
            validate_each_argument(each_value);
            let i;

            for (i = 0; i < each_value.length; i += 1) {
              const child_ctx = get_each_context$m(ctx, each_value, i);

              if (each_blocks[i]) {
                each_blocks[i].p(child_ctx, dirty);
                transition_in(each_blocks[i], 1);
              } else {
                each_blocks[i] = create_each_block$m(child_ctx);
                each_blocks[i].c();
                transition_in(each_blocks[i], 1);
                each_blocks[i].m(ul1, null);
              }
            }

            group_outros();

            for (i = each_value.length; i < each_blocks.length; i += 1) {
              out_1(i);
            }

            check_outros();
          }
        },
        i: function intro(local) {
          if (current) return;
          transition_in(barramoderacion.$$.fragment, local);

          for (let i = 0; i < each_value_1.length; i += 1) {
            transition_in(each_blocks_1[i]);
          }

          transition_in(if_block);

          for (let i = 0; i < each_value.length; i += 1) {
            transition_in(each_blocks[i]);
          }

          current = true;
        },
        o: function outro(local) {
          transition_out(barramoderacion.$$.fragment, local);
          each_blocks_1 = each_blocks_1.filter(Boolean);

          for (let i = 0; i < each_blocks_1.length; i += 1) {
            transition_out(each_blocks_1[i]);
          }

          transition_out(if_block);
          each_blocks = each_blocks.filter(Boolean);

          for (let i = 0; i < each_blocks.length; i += 1) {
            transition_out(each_blocks[i]);
          }

          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(barramoderacion, detaching);
          if (detaching) detach_dev(t0);
          if (detaching) detach_dev(section);
          destroy_each(each_blocks_1, detaching);
          if (if_block) if_block.d();
          destroy_each(each_blocks, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$Y.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }

    function instance$Y($$self, $$props, $$invalidate) {
      let {
        $$slots: slots = {},
        $$scope
      } = $$props;
      validate_slots("ListaDeUsuarios", slots, []);
      let ultimosRegistros = window.model.ultimosRegistros;
      let ultimosBaneos = window.model.ultimosBaneos;
      let cantidadDeUsuarios = window.model.cantidadDeUsuarios;
      let banVisto = null;
      const writable_props = [];
      Object.keys($$props).forEach(key => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<ListaDeUsuarios> was created with unknown prop '${key}'`);
      });

      const mouseenter_handler = b => $$invalidate(0, banVisto = b);

      const func = () => RChanClient.removerBan(banVisto.id);

      $$self.$capture_state = () => ({
        formatearTimeSpan,
        Button: ye,
        Tiempo,
        Dialogo,
        RChanClient,
        BarraModeracion,
        Comentario,
        HiloPreviewMod,
        Denuncia,
        BanPreview,
        ultimosRegistros,
        ultimosBaneos,
        cantidadDeUsuarios,
        banVisto
      });

      $$self.$inject_state = $$props => {
        if ("ultimosRegistros" in $$props) $$invalidate(1, ultimosRegistros = $$props.ultimosRegistros);
        if ("ultimosBaneos" in $$props) $$invalidate(2, ultimosBaneos = $$props.ultimosBaneos);
        if ("cantidadDeUsuarios" in $$props) $$invalidate(3, cantidadDeUsuarios = $$props.cantidadDeUsuarios);
        if ("banVisto" in $$props) $$invalidate(0, banVisto = $$props.banVisto);
      };

      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }

      return [banVisto, ultimosRegistros, ultimosBaneos, cantidadDeUsuarios, mouseenter_handler, func];
    }

    class ListaDeUsuarios extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$Y, create_fragment$Y, safe_not_equal, {});
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "ListaDeUsuarios",
          options,
          id: create_fragment$Y.name
        });
      }

    }

    /* src\components\Paginas\Busqueda.svelte generated by Svelte v3.29.0 */
    const {
      console: console_1$h
    } = globals;
    const file$W = "src\\components\\Paginas\\Busqueda.svelte"; // (44:16) <Button on:click={buscar} raised color="var(--color5)">

    function create_default_slot_1$u(ctx) {
      let t;
      const block = {
        c: function create() {
          t = text("Buscar");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_1$u.name,
        type: "slot",
        source: "(44:16) <Button on:click={buscar} raised color=\\\"var(--color5)\\\">",
        ctx
      });
      return block;
    } // (43:12) <Spinner {cargando}>


    function create_default_slot$z(ctx) {
      let button;
      let current;
      button = new ye({
        props: {
          raised: true,
          color: "var(--color5)",
          $$slots: {
            default: [create_default_slot_1$u]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      button.$on("click",
      /*buscar*/
      ctx[4]);
      const block = {
        c: function create() {
          create_component(button.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(button, target, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          const button_changes = {};

          if (dirty &
          /*$$scope*/
          128) {
            button_changes.$$scope = {
              dirty,
              ctx
            };
          }

          button.$set(button_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(button.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(button.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(button, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot$z.name,
        type: "slot",
        source: "(43:12) <Spinner {cargando}>",
        ctx
      });
      return block;
    } // (49:4) {#if sinResultados}


    function create_if_block$K(ctx) {
      let h3;
      const block = {
        c: function create() {
          h3 = element("h3");
          h3.textContent = "No se encontraron rozs";
          set_style(h3, "text-align", "center");
          add_location(h3, file$W, 49, 8, 1342);
        },
        m: function mount(target, anchor) {
          insert_dev(target, h3, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(h3);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block$K.name,
        type: "if",
        source: "(49:4) {#if sinResultados}",
        ctx
      });
      return block;
    }

    function create_fragment$Z(ctx) {
      let main;
      let h3;
      let t1;
      let section;
      let form;
      let input;
      let t2;
      let spinner;
      let t3;
      let t4;
      let hilolist;
      let updating_hiloList;
      let current;
      let mounted;
      let dispose;
      spinner = new Spinner({
        props: {
          cargando:
          /*cargando*/
          ctx[3],
          $$slots: {
            default: [create_default_slot$z]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      let if_block =
      /*sinResultados*/
      ctx[2] && create_if_block$K(ctx);

      function hilolist_hiloList_binding(value) {
        /*hilolist_hiloList_binding*/
        ctx[6].call(null, value);
      }

      let hilolist_props = {};

      if (
      /*hiloList*/
      ctx[1] !== void 0) {
        hilolist_props.hiloList =
        /*hiloList*/
        ctx[1];
      }

      hilolist = new HiloList({
        props: hilolist_props,
        $$inline: true
      });
      binding_callbacks.push(() => bind(hilolist, "hiloList", hilolist_hiloList_binding));
      const block = {
        c: function create() {
          main = element("main");
          h3 = element("h3");
          h3.textContent = "Buscar Roz";
          t1 = space();
          section = element("section");
          form = element("form");
          input = element("input");
          t2 = space();
          create_component(spinner.$$.fragment);
          t3 = space();
          if (if_block) if_block.c();
          t4 = space();
          create_component(hilolist.$$.fragment);
          set_style(h3, "text-align", "center");
          set_style(h3, "margin", "16px 10px");
          add_location(h3, file$W, 31, 4, 713);
          attr_dev(input, "autocomplete", "off");
          attr_dev(input, "placeholder", "Alguna palabra en el titulo del roz");
          input.autofocus = true;
          add_location(input, file$W, 36, 12, 936);
          attr_dev(form, "class", "panel input-busqueda svelte-1cuxuj6");
          add_location(form, file$W, 34, 8, 804);
          attr_dev(section, "class", "svelte-1cuxuj6");
          add_location(section, file$W, 33, 4, 786);
          attr_dev(main, "class", "svelte-1cuxuj6");
          add_location(main, file$W, 30, 0, 702);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, main, anchor);
          append_dev(main, h3);
          append_dev(main, t1);
          append_dev(main, section);
          append_dev(section, form);
          append_dev(form, input);
          set_input_value(input,
          /*cadenaDeBusqueda*/
          ctx[0]);
          append_dev(form, t2);
          mount_component(spinner, form, null);
          append_dev(main, t3);
          if (if_block) if_block.m(main, null);
          append_dev(main, t4);
          mount_component(hilolist, main, null);
          current = true;
          input.focus();

          if (!mounted) {
            dispose = [listen_dev(input, "input",
            /*input_input_handler*/
            ctx[5]), listen_dev(form, "submit", prevent_default(
            /*buscar*/
            ctx[4]), false, true, false)];
            mounted = true;
          }
        },
        p: function update(ctx, [dirty]) {
          if (dirty &
          /*cadenaDeBusqueda*/
          1 && input.value !==
          /*cadenaDeBusqueda*/
          ctx[0]) {
            set_input_value(input,
            /*cadenaDeBusqueda*/
            ctx[0]);
          }

          const spinner_changes = {};

          if (dirty &
          /*$$scope*/
          128) {
            spinner_changes.$$scope = {
              dirty,
              ctx
            };
          }

          spinner.$set(spinner_changes);

          if (
          /*sinResultados*/
          ctx[2]) {
            if (if_block) ; else {
              if_block = create_if_block$K(ctx);
              if_block.c();
              if_block.m(main, t4);
            }
          } else if (if_block) {
            if_block.d(1);
            if_block = null;
          }

          const hilolist_changes = {};

          if (!updating_hiloList && dirty &
          /*hiloList*/
          2) {
            updating_hiloList = true;
            hilolist_changes.hiloList =
            /*hiloList*/
            ctx[1];
            add_flush_callback(() => updating_hiloList = false);
          }

          hilolist.$set(hilolist_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(spinner.$$.fragment, local);
          transition_in(hilolist.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(spinner.$$.fragment, local);
          transition_out(hilolist.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(main);
          destroy_component(spinner);
          if (if_block) if_block.d();
          destroy_component(hilolist);
          mounted = false;
          run_all(dispose);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$Z.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }

    function instance$Z($$self, $$props, $$invalidate) {
      let {
        $$slots: slots = {},
        $$scope
      } = $$props;
      validate_slots("Busqueda", slots, []);
      let cadenaDeBusqueda = "";
      let hiloList = {
        hilos: []
      };
      let cargando = false;
      let sinResultados = false;

      async function buscar() {
        try {
          $$invalidate(2, sinResultados = false);
          let cargando = true;
          let res = await RChanClient.buscar(cadenaDeBusqueda);
          $$invalidate(2, sinResultados = res.data.length == 0);
          $$invalidate(1, hiloList.hilos = res.data, hiloList);
        } catch (e) {
          console.log(e);
        }
      }

      const writable_props = [];
      Object.keys($$props).forEach(key => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1$h.warn(`<Busqueda> was created with unknown prop '${key}'`);
      });

      function input_input_handler() {
        cadenaDeBusqueda = this.value;
        $$invalidate(0, cadenaDeBusqueda);
      }

      function hilolist_hiloList_binding(value) {
        hiloList = value;
        $$invalidate(1, hiloList);
      }

      $$self.$capture_state = () => ({
        Button: ye,
        HiloList,
        RChanClient,
        Spinner,
        cadenaDeBusqueda,
        hiloList,
        cargando,
        sinResultados,
        buscar
      });

      $$self.$inject_state = $$props => {
        if ("cadenaDeBusqueda" in $$props) $$invalidate(0, cadenaDeBusqueda = $$props.cadenaDeBusqueda);
        if ("hiloList" in $$props) $$invalidate(1, hiloList = $$props.hiloList);
        if ("cargando" in $$props) $$invalidate(3, cargando = $$props.cargando);
        if ("sinResultados" in $$props) $$invalidate(2, sinResultados = $$props.sinResultados);
      };

      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }

      return [cadenaDeBusqueda, hiloList, sinResultados, cargando, buscar, input_input_handler, hilolist_hiloList_binding];
    }

    class Busqueda extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$Z, create_fragment$Z, safe_not_equal, {});
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "Busqueda",
          options,
          id: create_fragment$Z.name
        });
      }

    }

    /* src\components\Paginas\EliminadosYDesactivados.svelte generated by Svelte v3.29.0 */
    const file$X = "src\\components\\Paginas\\EliminadosYDesactivados.svelte";

    function get_each_context$n(ctx, list, i) {
      const child_ctx = ctx.slice();
      child_ctx[3] = list[i];
      return child_ctx;
    }

    function get_each_context_1$c(ctx, list, i) {
      const child_ctx = ctx.slice();
      child_ctx[6] = list[i];
      return child_ctx;
    } // (21:36) <Button on:click={() => abrir.restaurarHilo(h.id)}>


    function create_default_slot$A(ctx) {
      let t;
      const block = {
        c: function create() {
          t = text("Restaurar");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot$A.name,
        type: "slot",
        source: "(21:36) <Button on:click={() => abrir.restaurarHilo(h.id)}>",
        ctx
      });
      return block;
    } // (20:8) {#each hilos as h}


    function create_each_block_1$c(ctx) {
      let hilopreview;
      let t;
      let button;
      let current;
      hilopreview = new HiloPreview({
        props: {
          hilo:
          /*h*/
          ctx[6]
        },
        $$inline: true
      });

      function click_handler(...args) {
        return (
          /*click_handler*/
          ctx[2](
          /*h*/
          ctx[6], ...args)
        );
      }

      button = new ye({
        props: {
          $$slots: {
            default: [create_default_slot$A]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      button.$on("click", click_handler);
      const block = {
        c: function create() {
          create_component(hilopreview.$$.fragment);
          t = space();
          create_component(button.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(hilopreview, target, anchor);
          insert_dev(target, t, anchor);
          mount_component(button, target, anchor);
          current = true;
        },
        p: function update(new_ctx, dirty) {
          ctx = new_ctx;
          const button_changes = {};

          if (dirty &
          /*$$scope*/
          512) {
            button_changes.$$scope = {
              dirty,
              ctx
            };
          }

          button.$set(button_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(hilopreview.$$.fragment, local);
          transition_in(button.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(hilopreview.$$.fragment, local);
          transition_out(button.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(hilopreview, detaching);
          if (detaching) detach_dev(t);
          destroy_component(button, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_each_block_1$c.name,
        type: "each",
        source: "(20:8) {#each hilos as h}",
        ctx
      });
      return block;
    } // (26:8) {#each comentarios as c}


    function create_each_block$n(ctx) {
      let comentariomod;
      let current;
      comentariomod = new ComentarioMod({
        props: {
          comentario:
          /*c*/
          ctx[3]
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          create_component(comentariomod.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(comentariomod, target, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          const comentariomod_changes = {};
          if (dirty &
          /*comentarios*/
          1) comentariomod_changes.comentario =
          /*c*/
          ctx[3];
          comentariomod.$set(comentariomod_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(comentariomod.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(comentariomod.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(comentariomod, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_each_block$n.name,
        type: "each",
        source: "(26:8) {#each comentarios as c}",
        ctx
      });
      return block;
    }

    function create_fragment$_(ctx) {
      let barramoderacion;
      let t0;
      let main;
      let ul0;
      let h30;
      let t2;
      let t3;
      let ul1;
      let h31;
      let t5;
      let current;
      barramoderacion = new BarraModeracion({
        $$inline: true
      });
      let each_value_1 =
      /*hilos*/
      ctx[1];
      validate_each_argument(each_value_1);
      let each_blocks_1 = [];

      for (let i = 0; i < each_value_1.length; i += 1) {
        each_blocks_1[i] = create_each_block_1$c(get_each_context_1$c(ctx, each_value_1, i));
      }

      const out = i => transition_out(each_blocks_1[i], 1, 1, () => {
        each_blocks_1[i] = null;
      });

      let each_value =
      /*comentarios*/
      ctx[0];
      validate_each_argument(each_value);
      let each_blocks = [];

      for (let i = 0; i < each_value.length; i += 1) {
        each_blocks[i] = create_each_block$n(get_each_context$n(ctx, each_value, i));
      }

      const out_1 = i => transition_out(each_blocks[i], 1, 1, () => {
        each_blocks[i] = null;
      });

      const block = {
        c: function create() {
          create_component(barramoderacion.$$.fragment);
          t0 = space();
          main = element("main");
          ul0 = element("ul");
          h30 = element("h3");
          h30.textContent = "Rozs eliminados";
          t2 = space();

          for (let i = 0; i < each_blocks_1.length; i += 1) {
            each_blocks_1[i].c();
          }

          t3 = space();
          ul1 = element("ul");
          h31 = element("h3");
          h31.textContent = "Comentarios eliminados";
          t5 = space();

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].c();
          }

          set_style(h30, "height", "40px");
          add_location(h30, file$X, 18, 8, 545);
          set_style(ul0, "width", "33%");
          attr_dev(ul0, "class", "svelte-wvcmr6");
          add_location(ul0, file$X, 17, 4, 514);
          set_style(h31, "height", "40px");
          add_location(h31, file$X, 24, 8, 766);
          attr_dev(ul1, "class", "svelte-wvcmr6");
          add_location(ul1, file$X, 23, 4, 753);
          attr_dev(main, "class", "svelte-wvcmr6");
          add_location(main, file$X, 16, 0, 503);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          mount_component(barramoderacion, target, anchor);
          insert_dev(target, t0, anchor);
          insert_dev(target, main, anchor);
          append_dev(main, ul0);
          append_dev(ul0, h30);
          append_dev(ul0, t2);

          for (let i = 0; i < each_blocks_1.length; i += 1) {
            each_blocks_1[i].m(ul0, null);
          }

          append_dev(main, t3);
          append_dev(main, ul1);
          append_dev(ul1, h31);
          append_dev(ul1, t5);

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].m(ul1, null);
          }

          current = true;
        },
        p: function update(ctx, [dirty]) {
          if (dirty &
          /*abrir, hilos*/
          2) {
            each_value_1 =
            /*hilos*/
            ctx[1];
            validate_each_argument(each_value_1);
            let i;

            for (i = 0; i < each_value_1.length; i += 1) {
              const child_ctx = get_each_context_1$c(ctx, each_value_1, i);

              if (each_blocks_1[i]) {
                each_blocks_1[i].p(child_ctx, dirty);
                transition_in(each_blocks_1[i], 1);
              } else {
                each_blocks_1[i] = create_each_block_1$c(child_ctx);
                each_blocks_1[i].c();
                transition_in(each_blocks_1[i], 1);
                each_blocks_1[i].m(ul0, null);
              }
            }

            group_outros();

            for (i = each_value_1.length; i < each_blocks_1.length; i += 1) {
              out(i);
            }

            check_outros();
          }

          if (dirty &
          /*comentarios*/
          1) {
            each_value =
            /*comentarios*/
            ctx[0];
            validate_each_argument(each_value);
            let i;

            for (i = 0; i < each_value.length; i += 1) {
              const child_ctx = get_each_context$n(ctx, each_value, i);

              if (each_blocks[i]) {
                each_blocks[i].p(child_ctx, dirty);
                transition_in(each_blocks[i], 1);
              } else {
                each_blocks[i] = create_each_block$n(child_ctx);
                each_blocks[i].c();
                transition_in(each_blocks[i], 1);
                each_blocks[i].m(ul1, null);
              }
            }

            group_outros();

            for (i = each_value.length; i < each_blocks.length; i += 1) {
              out_1(i);
            }

            check_outros();
          }
        },
        i: function intro(local) {
          if (current) return;
          transition_in(barramoderacion.$$.fragment, local);

          for (let i = 0; i < each_value_1.length; i += 1) {
            transition_in(each_blocks_1[i]);
          }

          for (let i = 0; i < each_value.length; i += 1) {
            transition_in(each_blocks[i]);
          }

          current = true;
        },
        o: function outro(local) {
          transition_out(barramoderacion.$$.fragment, local);
          each_blocks_1 = each_blocks_1.filter(Boolean);

          for (let i = 0; i < each_blocks_1.length; i += 1) {
            transition_out(each_blocks_1[i]);
          }

          each_blocks = each_blocks.filter(Boolean);

          for (let i = 0; i < each_blocks.length; i += 1) {
            transition_out(each_blocks[i]);
          }

          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(barramoderacion, detaching);
          if (detaching) detach_dev(t0);
          if (detaching) detach_dev(main);
          destroy_each(each_blocks_1, detaching);
          destroy_each(each_blocks, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$_.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }

    function instance$_($$self, $$props, $$invalidate) {
      let {
        $$slots: slots = {},
        $$scope
      } = $$props;
      validate_slots("EliminadosYDesactivados", slots, []);
      let hilos = window.model.hilos;
      let comentarios = window.model.comentarios;
      comentarios = comentarios.map(c => {
        c.respuestas = [];
        return c;
      });
      const writable_props = [];
      Object.keys($$props).forEach(key => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<EliminadosYDesactivados> was created with unknown prop '${key}'`);
      });

      const click_handler = h => abrir.restaurarHilo(h.id);

      $$self.$capture_state = () => ({
        ComentarioMod,
        HiloPreview,
        abrir,
        Button: ye,
        BarraModeracion,
        hilos,
        comentarios
      });

      $$self.$inject_state = $$props => {
        if ("hilos" in $$props) $$invalidate(1, hilos = $$props.hilos);
        if ("comentarios" in $$props) $$invalidate(0, comentarios = $$props.comentarios);
      };

      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }

      return [comentarios, hilos, click_handler];
    }

    class EliminadosYDesactivados extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$_, create_fragment$_, safe_not_equal, {});
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "EliminadosYDesactivados",
          options,
          id: create_fragment$_.name
        });
      }

    }

    /* src\components\Paginas\MediaHome.svelte generated by Svelte v3.29.0 */
    const file$Y = "src\\components\\Paginas\\MediaHome.svelte";

    function get_each_context$o(ctx, list, i) {
      const child_ctx = ctx.slice();
      child_ctx[6] = list[i];
      child_ctx[7] = list;
      child_ctx[8] = i;
      return child_ctx;
    } // (34:4) {#if selecionados.length > 0 && $globalStore.usuario.esMod}


    function create_if_block$L(ctx) {
      let div;
      let button;
      let current;
      button = new ye({
        props: {
          color: "var(--color5)",
          disabled:
          /*eliminando*/
          ctx[1],
          raised: true,
          $$slots: {
            default: [create_default_slot$B]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      button.$on("click",
      /*eliminarMedias*/
      ctx[4]);
      const block = {
        c: function create() {
          div = element("div");
          create_component(button.$$.fragment);
          set_style(div, "justify-content", "center");
          set_style(div, "display", "flex");
          set_style(div, "margin", "8px");
          add_location(div, file$Y, 34, 8, 1121);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
          mount_component(button, div, null);
          current = true;
        },
        p: function update(ctx, dirty) {
          const button_changes = {};
          if (dirty &
          /*eliminando*/
          2) button_changes.disabled =
          /*eliminando*/
          ctx[1];

          if (dirty &
          /*$$scope, selecionados*/
          516) {
            button_changes.$$scope = {
              dirty,
              ctx
            };
          }

          button.$set(button_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(button.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(button.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
          destroy_component(button);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block$L.name,
        type: "if",
        source: "(34:4) {#if selecionados.length > 0 && $globalStore.usuario.esMod}",
        ctx
      });
      return block;
    } // (36:12) <Button                  on:click={eliminarMedias}                  color="var(--color5)"                  disabled={eliminando}                  raised>


    function create_default_slot$B(ctx) {
      let t0;
      let t1_value =
      /*selecionados*/
      ctx[2].length + "";
      let t1;
      let t2;
      const block = {
        c: function create() {
          t0 = text("Eliminar ");
          t1 = text(t1_value);
          t2 = text(" archivos");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t0, anchor);
          insert_dev(target, t1, anchor);
          insert_dev(target, t2, anchor);
        },
        p: function update(ctx, dirty) {
          if (dirty &
          /*selecionados*/
          4 && t1_value !== (t1_value =
          /*selecionados*/
          ctx[2].length + "")) set_data_dev(t1, t1_value);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(t0);
          if (detaching) detach_dev(t1);
          if (detaching) detach_dev(t2);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot$B.name,
        type: "slot",
        source: "(36:12) <Button                  on:click={eliminarMedias}                  color=\\\"var(--color5)\\\"                  disabled={eliminando}                  raised>",
        ctx
      });
      return block;
    } // (45:8) {#each medias as m}


    function create_each_block$o(ctx) {
      let li;
      let media;
      let t0;
      let div;
      let checkbox;
      let updating_checked;
      let t1;
      let current;
      media = new Media({
        props: {
          media:
          /*m*/
          ctx[6],
          modoCuadrado: true
        },
        $$inline: true
      });

      function checkbox_checked_binding(value) {
        /*checkbox_checked_binding*/
        ctx[5].call(null, value,
        /*m*/
        ctx[6]);
      }

      let checkbox_props = {};

      if (
      /*m*/
      ctx[6].seleccionado !== void 0) {
        checkbox_props.checked =
        /*m*/
        ctx[6].seleccionado;
      }

      checkbox = new Ne({
        props: checkbox_props,
        $$inline: true
      });
      binding_callbacks.push(() => bind(checkbox, "checked", checkbox_checked_binding));
      const block = {
        c: function create() {
          li = element("li");
          create_component(media.$$.fragment);
          t0 = space();
          div = element("div");
          create_component(checkbox.$$.fragment);
          t1 = space();
          attr_dev(div, "class", "check svelte-yl7va1");
          add_location(div, file$Y, 48, 16, 1717);
          attr_dev(li, "class", "svelte-yl7va1");
          add_location(li, file$Y, 45, 12, 1493);
        },
        m: function mount(target, anchor) {
          insert_dev(target, li, anchor);
          mount_component(media, li, null);
          append_dev(li, t0);
          append_dev(li, div);
          mount_component(checkbox, div, null);
          append_dev(li, t1);
          current = true;
        },
        p: function update(new_ctx, dirty) {
          ctx = new_ctx;
          const media_changes = {};
          if (dirty &
          /*medias*/
          1) media_changes.media =
          /*m*/
          ctx[6];
          media.$set(media_changes);
          const checkbox_changes = {};

          if (!updating_checked && dirty &
          /*medias*/
          1) {
            updating_checked = true;
            checkbox_changes.checked =
            /*m*/
            ctx[6].seleccionado;
            add_flush_callback(() => updating_checked = false);
          }

          checkbox.$set(checkbox_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(media.$$.fragment, local);
          transition_in(checkbox.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(media.$$.fragment, local);
          transition_out(checkbox.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(li);
          destroy_component(media);
          destroy_component(checkbox);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_each_block$o.name,
        type: "each",
        source: "(45:8) {#each medias as m}",
        ctx
      });
      return block;
    }

    function create_fragment$$(ctx) {
      let barramoderacion;
      let t0;
      let section;
      let t1;
      let ul;
      let current;
      barramoderacion = new BarraModeracion({
        $$inline: true
      });
      let if_block =
      /*selecionados*/
      ctx[2].length > 0 &&
      /*$globalStore*/
      ctx[3].usuario.esMod && create_if_block$L(ctx);
      let each_value =
      /*medias*/
      ctx[0];
      validate_each_argument(each_value);
      let each_blocks = [];

      for (let i = 0; i < each_value.length; i += 1) {
        each_blocks[i] = create_each_block$o(get_each_context$o(ctx, each_value, i));
      }

      const out = i => transition_out(each_blocks[i], 1, 1, () => {
        each_blocks[i] = null;
      });

      const block = {
        c: function create() {
          create_component(barramoderacion.$$.fragment);
          t0 = space();
          section = element("section");
          if (if_block) if_block.c();
          t1 = space();
          ul = element("ul");

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].c();
          }

          attr_dev(ul, "class", "svelte-yl7va1");
          add_location(ul, file$Y, 43, 4, 1446);
          attr_dev(section, "class", "media-home svelte-yl7va1");
          add_location(section, file$Y, 32, 0, 1018);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          mount_component(barramoderacion, target, anchor);
          insert_dev(target, t0, anchor);
          insert_dev(target, section, anchor);
          if (if_block) if_block.m(section, null);
          append_dev(section, t1);
          append_dev(section, ul);

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].m(ul, null);
          }

          current = true;
        },
        p: function update(ctx, [dirty]) {
          if (
          /*selecionados*/
          ctx[2].length > 0 &&
          /*$globalStore*/
          ctx[3].usuario.esMod) {
            if (if_block) {
              if_block.p(ctx, dirty);

              if (dirty &
              /*selecionados, $globalStore*/
              12) {
                transition_in(if_block, 1);
              }
            } else {
              if_block = create_if_block$L(ctx);
              if_block.c();
              transition_in(if_block, 1);
              if_block.m(section, t1);
            }
          } else if (if_block) {
            group_outros();
            transition_out(if_block, 1, 1, () => {
              if_block = null;
            });
            check_outros();
          }

          if (dirty &
          /*medias*/
          1) {
            each_value =
            /*medias*/
            ctx[0];
            validate_each_argument(each_value);
            let i;

            for (i = 0; i < each_value.length; i += 1) {
              const child_ctx = get_each_context$o(ctx, each_value, i);

              if (each_blocks[i]) {
                each_blocks[i].p(child_ctx, dirty);
                transition_in(each_blocks[i], 1);
              } else {
                each_blocks[i] = create_each_block$o(child_ctx);
                each_blocks[i].c();
                transition_in(each_blocks[i], 1);
                each_blocks[i].m(ul, null);
              }
            }

            group_outros();

            for (i = each_value.length; i < each_blocks.length; i += 1) {
              out(i);
            }

            check_outros();
          }
        },
        i: function intro(local) {
          if (current) return;
          transition_in(barramoderacion.$$.fragment, local);
          transition_in(if_block);

          for (let i = 0; i < each_value.length; i += 1) {
            transition_in(each_blocks[i]);
          }

          current = true;
        },
        o: function outro(local) {
          transition_out(barramoderacion.$$.fragment, local);
          transition_out(if_block);
          each_blocks = each_blocks.filter(Boolean);

          for (let i = 0; i < each_blocks.length; i += 1) {
            transition_out(each_blocks[i]);
          }

          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(barramoderacion, detaching);
          if (detaching) detach_dev(t0);
          if (detaching) detach_dev(section);
          if (if_block) if_block.d();
          destroy_each(each_blocks, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$$.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }

    function instance$$($$self, $$props, $$invalidate) {
      let $globalStore;
      validate_store(globalStore, "globalStore");
      component_subscribe($$self, globalStore, $$value => $$invalidate(3, $globalStore = $$value));
      let {
        $$slots: slots = {},
        $$scope
      } = $$props;
      validate_slots("MediaHome", slots, []);
      let medias = window.model.medias; // let comentarios = window.model.comentarios

      medias.forEach(m => m.seleccionado = false);
      medias = medias;
      let eliminando = false;

      async function eliminarMedias() {
        try {
          $$invalidate(1, eliminando = true);
          await RChanClient.eliminarMedias(selecionados.map(s => s.id));
          $$invalidate(0, medias = medias.filter(m => !selecionados.map(s => s.id).includes(m.id)));
          $$invalidate(2, selecionados = []);
        } catch (error) {}

        $$invalidate(1, eliminando = false);
      }

      const writable_props = [];
      Object.keys($$props).forEach(key => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<MediaHome> was created with unknown prop '${key}'`);
      });

      function checkbox_checked_binding(value, m) {
        m.seleccionado = value;
        $$invalidate(0, medias);
      }

      $$self.$capture_state = () => ({
        abrir,
        Button: ye,
        Checkbox: Ne,
        BarraModeracion,
        Media,
        RChanClient,
        globalStore,
        medias,
        eliminando,
        eliminarMedias,
        selecionados,
        $globalStore
      });

      $$self.$inject_state = $$props => {
        if ("medias" in $$props) $$invalidate(0, medias = $$props.medias);
        if ("eliminando" in $$props) $$invalidate(1, eliminando = $$props.eliminando);
        if ("selecionados" in $$props) $$invalidate(2, selecionados = $$props.selecionados);
      };

      let selecionados;

      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }

      $$self.$$.update = () => {
        if ($$self.$$.dirty &
        /*medias*/
        1) {
           $$invalidate(2, selecionados = medias.filter(m => m.seleccionado));
        }
      };

      return [medias, eliminando, selecionados, $globalStore, eliminarMedias, checkbox_checked_binding];
    }

    class MediaHome extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$$, create_fragment$$, safe_not_equal, {});
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "MediaHome",
          options,
          id: create_fragment$$.name
        });
      }

    }

    /* src\components\Paginas\Historial.svelte generated by Svelte v3.29.0 */
    const {
      Object: Object_1$8
    } = globals;
    const file$Z = "src\\components\\Paginas\\Historial.svelte";

    function get_each_context$p(ctx, list, i) {
      const child_ctx = ctx.slice();
      child_ctx[11] = list[i];
      return child_ctx;
    }

    function get_each_context_1$d(ctx, list, i) {
      const child_ctx = ctx.slice();
      child_ctx[11] = list[i];
      return child_ctx;
    }

    function get_each_context_2$7(ctx, list, i) {
      const child_ctx = ctx.slice();
      child_ctx[16] = list[i];
      return child_ctx;
    } // (51:12) {#each mods as m}


    function create_each_block_2$7(ctx) {
      let option;
      let t_value =
      /*m*/
      ctx[16] + "";
      let t;
      let option_value_value;
      const block = {
        c: function create() {
          option = element("option");
          t = text(t_value);
          option.__value = option_value_value =
          /*m*/
          ctx[16];
          option.value = option.__value;
          add_location(option, file$Z, 51, 16, 1756);
        },
        m: function mount(target, anchor) {
          insert_dev(target, option, anchor);
          append_dev(option, t);
        },
        p: noop,
        d: function destroy(detaching) {
          if (detaching) detach_dev(option);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_each_block_2$7.name,
        type: "each",
        source: "(51:12) {#each mods as m}",
        ctx
      });
      return block;
    } // (58:12) {#each Object.keys(TipoAccion) as a}


    function create_each_block_1$d(ctx) {
      let option;
      let t_value =
      /*a*/
      ctx[11] + "";
      let t;
      let option_value_value;
      const block = {
        c: function create() {
          option = element("option");
          t = text(t_value);
          option.__value = option_value_value = TipoAccion[
          /*a*/
          ctx[11]];
          option.value = option.__value;
          add_location(option, file$Z, 58, 16, 1989);
        },
        m: function mount(target, anchor) {
          insert_dev(target, option, anchor);
          append_dev(option, t);
        },
        p: noop,
        d: function destroy(detaching) {
          if (detaching) detach_dev(option);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_each_block_1$d.name,
        type: "each",
        source: "(58:12) {#each Object.keys(TipoAccion) as a}",
        ctx
      });
      return block;
    } // (80:20) {#if tiposConNotas.indexOf(a.tipo) > -1}


    function create_if_block_7$4(ctx) {
      let span;
      let t_value =
      /*a*/
      ctx[11].nota + "";
      let t;
      const block = {
        c: function create() {
          span = element("span");
          t = text(t_value);
          attr_dev(span, "class", "svelte-1p5f2c");
          add_location(span, file$Z, 80, 24, 2914);
        },
        m: function mount(target, anchor) {
          insert_dev(target, span, anchor);
          append_dev(span, t);
        },
        p: function update(ctx, dirty) {
          if (dirty &
          /*accionesFiltradas*/
          4 && t_value !== (t_value =
          /*a*/
          ctx[11].nota + "")) set_data_dev(t, t_value);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(span);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_7$4.name,
        type: "if",
        source: "(80:20) {#if tiposConNotas.indexOf(a.tipo) > -1}",
        ctx
      });
      return block;
    } // (83:20) {#if a.hilo}


    function create_if_block_6$6(ctx) {
      let a;
      let t_value =
      /*a*/
      ctx[11].hilo.titulo + "";
      let t;
      let a_href_value;
      const block = {
        c: function create() {
          a = element("a");
          t = text(t_value);
          attr_dev(a, "href", a_href_value = "/Hilo/" +
          /*a*/
          ctx[11].hilo.id);
          attr_dev(a, "class", "svelte-1p5f2c");
          add_location(a, file$Z, 83, 24, 3022);
        },
        m: function mount(target, anchor) {
          insert_dev(target, a, anchor);
          append_dev(a, t);
        },
        p: function update(ctx, dirty) {
          if (dirty &
          /*accionesFiltradas*/
          4 && t_value !== (t_value =
          /*a*/
          ctx[11].hilo.titulo + "")) set_data_dev(t, t_value);

          if (dirty &
          /*accionesFiltradas*/
          4 && a_href_value !== (a_href_value = "/Hilo/" +
          /*a*/
          ctx[11].hilo.id)) {
            attr_dev(a, "href", a_href_value);
          }
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(a);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_6$6.name,
        type: "if",
        source: "(83:20) {#if a.hilo}",
        ctx
      });
      return block;
    } // (65:12) {#each accionesFiltradas as a (a.id)}


    function create_each_block$p(key_1, ctx) {
      let li;
      let span0;
      let tiempo;
      let t0;
      let span1;
      let t1_value =
      /*a*/
      ctx[11].usuario.userName + "";
      let t1;
      let t2;
      let span2;
      let t3_value = TipoAccion.aString(
      /*a*/
      ctx[11].tipo) + "";
      let t3;
      let t4;
      let show_if =
      /*tiposConNotas*/
      ctx[4].indexOf(
      /*a*/
      ctx[11].tipo) > -1;
      let t5;
      let t6;
      let li_style_value;
      let current;
      let mounted;
      let dispose;
      tiempo = new Tiempo({
        props: {
          date:
          /*a*/
          ctx[11].creacion
        },
        $$inline: true
      });
      let if_block0 = show_if && create_if_block_7$4(ctx);
      let if_block1 =
      /*a*/
      ctx[11].hilo && create_if_block_6$6(ctx);

      function mouseenter_handler(...args) {
        return (
          /*mouseenter_handler*/
          ctx[7](
          /*a*/
          ctx[11], ...args)
        );
      }

      const block = {
        key: key_1,
        first: null,
        c: function create() {
          li = element("li");
          span0 = element("span");
          create_component(tiempo.$$.fragment);
          t0 = space();
          span1 = element("span");
          t1 = text(t1_value);
          t2 = space();
          span2 = element("span");
          t3 = text(t3_value);
          t4 = space();
          if (if_block0) if_block0.c();
          t5 = space();
          if (if_block1) if_block1.c();
          t6 = space();
          set_style(span0, "background", "var(--color3)");
          attr_dev(span0, "class", "svelte-1p5f2c");
          add_location(span0, file$Z, 70, 20, 2418);
          set_style(span1, "background", "var(--color6)");
          attr_dev(span1, "class", "svelte-1p5f2c");
          add_location(span1, file$Z, 73, 20, 2564);
          set_style(span2, "background", "var(--color5)");
          attr_dev(span2, "class", "svelte-1p5f2c");
          add_location(span2, file$Z, 76, 20, 2702);
          attr_dev(li, "class", "accion svelte-1p5f2c");
          attr_dev(li, "style", li_style_value =
          /*a*/
          ctx[11] ==
          /*accionVista*/
          ctx[1] ? "background: var(--color6);" : "");
          add_location(li, file$Z, 65, 16, 2195);
          this.first = li;
        },
        m: function mount(target, anchor) {
          insert_dev(target, li, anchor);
          append_dev(li, span0);
          mount_component(tiempo, span0, null);
          append_dev(li, t0);
          append_dev(li, span1);
          append_dev(span1, t1);
          append_dev(li, t2);
          append_dev(li, span2);
          append_dev(span2, t3);
          append_dev(li, t4);
          if (if_block0) if_block0.m(li, null);
          append_dev(li, t5);
          if (if_block1) if_block1.m(li, null);
          append_dev(li, t6);
          current = true;

          if (!mounted) {
            dispose = listen_dev(li, "mouseenter", mouseenter_handler, false, false, false);
            mounted = true;
          }
        },
        p: function update(new_ctx, dirty) {
          ctx = new_ctx;
          const tiempo_changes = {};
          if (dirty &
          /*accionesFiltradas*/
          4) tiempo_changes.date =
          /*a*/
          ctx[11].creacion;
          tiempo.$set(tiempo_changes);
          if ((!current || dirty &
          /*accionesFiltradas*/
          4) && t1_value !== (t1_value =
          /*a*/
          ctx[11].usuario.userName + "")) set_data_dev(t1, t1_value);
          if ((!current || dirty &
          /*accionesFiltradas*/
          4) && t3_value !== (t3_value = TipoAccion.aString(
          /*a*/
          ctx[11].tipo) + "")) set_data_dev(t3, t3_value);
          if (dirty &
          /*accionesFiltradas*/
          4) show_if =
          /*tiposConNotas*/
          ctx[4].indexOf(
          /*a*/
          ctx[11].tipo) > -1;

          if (show_if) {
            if (if_block0) {
              if_block0.p(ctx, dirty);
            } else {
              if_block0 = create_if_block_7$4(ctx);
              if_block0.c();
              if_block0.m(li, t5);
            }
          } else if (if_block0) {
            if_block0.d(1);
            if_block0 = null;
          }

          if (
          /*a*/
          ctx[11].hilo) {
            if (if_block1) {
              if_block1.p(ctx, dirty);
            } else {
              if_block1 = create_if_block_6$6(ctx);
              if_block1.c();
              if_block1.m(li, t6);
            }
          } else if (if_block1) {
            if_block1.d(1);
            if_block1 = null;
          }

          if (!current || dirty &
          /*accionesFiltradas, accionVista*/
          6 && li_style_value !== (li_style_value =
          /*a*/
          ctx[11] ==
          /*accionVista*/
          ctx[1] ? "background: var(--color6);" : "")) {
            attr_dev(li, "style", li_style_value);
          }
        },
        i: function intro(local) {
          if (current) return;
          transition_in(tiempo.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(tiempo.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(li);
          destroy_component(tiempo);
          if (if_block0) if_block0.d();
          if (if_block1) if_block1.d();
          mounted = false;
          dispose();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_each_block$p.name,
        type: "each",
        source: "(65:12) {#each accionesFiltradas as a (a.id)}",
        ctx
      });
      return block;
    } // (100:12) {#if accionVista != null}


    function create_if_block$M(ctx) {
      let previous_key =
      /*accionVista*/
      ctx[1];
      let key_block_anchor;
      let current;
      let key_block = create_key_block$1(ctx);
      const block = {
        c: function create() {
          key_block.c();
          key_block_anchor = empty();
        },
        m: function mount(target, anchor) {
          key_block.m(target, anchor);
          insert_dev(target, key_block_anchor, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          if (dirty &
          /*accionVista*/
          2 && safe_not_equal(previous_key, previous_key =
          /*accionVista*/
          ctx[1])) {
            group_outros();
            transition_out(key_block, 1, 1, noop);
            check_outros();
            key_block = create_key_block$1(ctx);
            key_block.c();
            transition_in(key_block);
            key_block.m(key_block_anchor.parentNode, key_block_anchor);
          } else {
            key_block.p(ctx, dirty);
          }
        },
        i: function intro(local) {
          if (current) return;
          transition_in(key_block);
          current = true;
        },
        o: function outro(local) {
          transition_out(key_block);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(key_block_anchor);
          key_block.d(detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block$M.name,
        type: "if",
        source: "(100:12) {#if accionVista != null}",
        ctx
      });
      return block;
    } // (102:20) {#if tiposConNotas.indexOf(accionVista.tipo) > -1}


    function create_if_block_5$8(ctx) {
      let span;
      let t_value =
      /*accionVista*/
      ctx[1].nota + "";
      let t;
      const block = {
        c: function create() {
          span = element("span");
          t = text(t_value);
          add_location(span, file$Z, 102, 24, 3836);
        },
        m: function mount(target, anchor) {
          insert_dev(target, span, anchor);
          append_dev(span, t);
        },
        p: function update(ctx, dirty) {
          if (dirty &
          /*accionVista*/
          2 && t_value !== (t_value =
          /*accionVista*/
          ctx[1].nota + "")) set_data_dev(t, t_value);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(span);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_5$8.name,
        type: "if",
        source: "(102:20) {#if tiposConNotas.indexOf(accionVista.tipo) > -1}",
        ctx
      });
      return block;
    } // (105:20) {#if accionVista.hilo}


    function create_if_block_4$9(ctx) {
      let hilopreviewmod;
      let current;
      hilopreviewmod = new HiloPreviewMod({
        props: {
          hilo:
          /*accionVista*/
          ctx[1].hilo
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          create_component(hilopreviewmod.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(hilopreviewmod, target, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          const hilopreviewmod_changes = {};
          if (dirty &
          /*accionVista*/
          2) hilopreviewmod_changes.hilo =
          /*accionVista*/
          ctx[1].hilo;
          hilopreviewmod.$set(hilopreviewmod_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(hilopreviewmod.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(hilopreviewmod.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(hilopreviewmod, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_4$9.name,
        type: "if",
        source: "(105:20) {#if accionVista.hilo}",
        ctx
      });
      return block;
    } // (108:20) {#if accionVista.comentario}


    function create_if_block_3$i(ctx) {
      let comentario;
      let current;
      comentario = new Comentario({
        props: {
          comentario:
          /*accionVista*/
          ctx[1].comentario
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          create_component(comentario.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(comentario, target, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          const comentario_changes = {};
          if (dirty &
          /*accionVista*/
          2) comentario_changes.comentario =
          /*accionVista*/
          ctx[1].comentario;
          comentario.$set(comentario_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(comentario.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(comentario.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(comentario, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_3$i.name,
        type: "if",
        source: "(108:20) {#if accionVista.comentario}",
        ctx
      });
      return block;
    } // (111:20) {#if accionVista.denuncia}


    function create_if_block_2$q(ctx) {
      let denuncia;
      let current;
      denuncia = new Denuncia({
        props: {
          denuncia:
          /*accionVista*/
          ctx[1].denuncia
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          create_component(denuncia.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(denuncia, target, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          const denuncia_changes = {};
          if (dirty &
          /*accionVista*/
          2) denuncia_changes.denuncia =
          /*accionVista*/
          ctx[1].denuncia;
          denuncia.$set(denuncia_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(denuncia.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(denuncia.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(denuncia, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_2$q.name,
        type: "if",
        source: "(111:20) {#if accionVista.denuncia}",
        ctx
      });
      return block;
    } // (114:20) {#if accionVista.ban}


    function create_if_block_1$t(ctx) {
      let banpreview;
      let t;
      let dialogo;
      let current;
      banpreview = new BanPreview({
        props: {
          ban:
          /*accionVista*/
          ctx[1].ban
        },
        $$inline: true
      });
      dialogo = new Dialogo({
        props: {
          textoActivador: "Desbanear",
          titulo: "Desbanear gordo",
          accion:
          /*func*/
          ctx[8],
          $$slots: {
            default: [create_default_slot$C],
            body: [create_body_slot$5],
            activador: [create_activador_slot$6]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          create_component(banpreview.$$.fragment);
          t = space();
          create_component(dialogo.$$.fragment);
        },
        m: function mount(target, anchor) {
          mount_component(banpreview, target, anchor);
          insert_dev(target, t, anchor);
          mount_component(dialogo, target, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          const banpreview_changes = {};
          if (dirty &
          /*accionVista*/
          2) banpreview_changes.ban =
          /*accionVista*/
          ctx[1].ban;
          banpreview.$set(banpreview_changes);
          const dialogo_changes = {};
          if (dirty &
          /*accionVista*/
          2) dialogo_changes.accion =
          /*func*/
          ctx[8];

          if (dirty &
          /*$$scope*/
          524288) {
            dialogo_changes.$$scope = {
              dirty,
              ctx
            };
          }

          dialogo.$set(dialogo_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(banpreview.$$.fragment, local);
          transition_in(dialogo.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(banpreview.$$.fragment, local);
          transition_out(dialogo.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          destroy_component(banpreview, detaching);
          if (detaching) detach_dev(t);
          destroy_component(dialogo, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_if_block_1$t.name,
        type: "if",
        source: "(114:20) {#if accionVista.ban}",
        ctx
      });
      return block;
    } // (126:32) <Button>


    function create_default_slot_1$v(ctx) {
      let t;
      const block = {
        c: function create() {
          t = text("Desbanear");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_1$v.name,
        type: "slot",
        source: "(126:32) <Button>",
        ctx
      });
      return block;
    } // (122:28) <span                                  slot="activador"                                  style="display:flex;justify-content:center;"                              >


    function create_activador_slot$6(ctx) {
      let span;
      let button;
      let current;
      button = new ye({
        props: {
          $$slots: {
            default: [create_default_slot_1$v]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      const block = {
        c: function create() {
          span = element("span");
          create_component(button.$$.fragment);
          attr_dev(span, "slot", "activador");
          set_style(span, "display", "flex");
          set_style(span, "justify-content", "center");
          add_location(span, file$Z, 121, 28, 4757);
        },
        m: function mount(target, anchor) {
          insert_dev(target, span, anchor);
          mount_component(button, span, null);
          current = true;
        },
        p: function update(ctx, dirty) {
          const button_changes = {};

          if (dirty &
          /*$$scope*/
          524288) {
            button_changes.$$scope = {
              dirty,
              ctx
            };
          }

          button.$set(button_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(button.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(button.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(span);
          destroy_component(button);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_activador_slot$6.name,
        type: "slot",
        source: "(122:28) <span                                  slot=\\\"activador\\\"                                  style=\\\"display:flex;justify-content:center;\\\"                              >",
        ctx
      });
      return block;
    } // (128:28) <div slot="body">


    function create_body_slot$5(ctx) {
      let div;
      const block = {
        c: function create() {
          div = element("div");
          div.textContent = "Remover ban?";
          attr_dev(div, "slot", "body");
          add_location(div, file$Z, 127, 28, 5048);
        },
        m: function mount(target, anchor) {
          insert_dev(target, div, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(div);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_body_slot$5.name,
        type: "slot",
        source: "(128:28) <div slot=\\\"body\\\">",
        ctx
      });
      return block;
    } // (116:24) <Dialogo                              textoActivador="Desbanear"                              titulo="Desbanear gordo"                              accion={() =>                                  RChanClient.removerBan(accionVista.ban.id)}                          >


    function create_default_slot$C(ctx) {
      let t;
      const block = {
        c: function create() {
          t = space();
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        p: noop,
        i: noop,
        o: noop,
        d: function destroy(detaching) {
          if (detaching) detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot$C.name,
        type: "slot",
        source: "(116:24) <Dialogo                              textoActivador=\\\"Desbanear\\\"                              titulo=\\\"Desbanear gordo\\\"                              accion={() =>                                  RChanClient.removerBan(accionVista.ban.id)}                          >",
        ctx
      });
      return block;
    } // (101:16) {#key accionVista}


    function create_key_block$1(ctx) {
      let show_if =
      /*tiposConNotas*/
      ctx[4].indexOf(
      /*accionVista*/
      ctx[1].tipo) > -1;
      let t0;
      let t1;
      let t2;
      let t3;
      let if_block4_anchor;
      let current;
      let if_block0 = show_if && create_if_block_5$8(ctx);
      let if_block1 =
      /*accionVista*/
      ctx[1].hilo && create_if_block_4$9(ctx);
      let if_block2 =
      /*accionVista*/
      ctx[1].comentario && create_if_block_3$i(ctx);
      let if_block3 =
      /*accionVista*/
      ctx[1].denuncia && create_if_block_2$q(ctx);
      let if_block4 =
      /*accionVista*/
      ctx[1].ban && create_if_block_1$t(ctx);
      const block = {
        c: function create() {
          if (if_block0) if_block0.c();
          t0 = space();
          if (if_block1) if_block1.c();
          t1 = space();
          if (if_block2) if_block2.c();
          t2 = space();
          if (if_block3) if_block3.c();
          t3 = space();
          if (if_block4) if_block4.c();
          if_block4_anchor = empty();
        },
        m: function mount(target, anchor) {
          if (if_block0) if_block0.m(target, anchor);
          insert_dev(target, t0, anchor);
          if (if_block1) if_block1.m(target, anchor);
          insert_dev(target, t1, anchor);
          if (if_block2) if_block2.m(target, anchor);
          insert_dev(target, t2, anchor);
          if (if_block3) if_block3.m(target, anchor);
          insert_dev(target, t3, anchor);
          if (if_block4) if_block4.m(target, anchor);
          insert_dev(target, if_block4_anchor, anchor);
          current = true;
        },
        p: function update(ctx, dirty) {
          if (dirty &
          /*accionVista*/
          2) show_if =
          /*tiposConNotas*/
          ctx[4].indexOf(
          /*accionVista*/
          ctx[1].tipo) > -1;

          if (show_if) {
            if (if_block0) {
              if_block0.p(ctx, dirty);
            } else {
              if_block0 = create_if_block_5$8(ctx);
              if_block0.c();
              if_block0.m(t0.parentNode, t0);
            }
          } else if (if_block0) {
            if_block0.d(1);
            if_block0 = null;
          }

          if (
          /*accionVista*/
          ctx[1].hilo) {
            if (if_block1) {
              if_block1.p(ctx, dirty);

              if (dirty &
              /*accionVista*/
              2) {
                transition_in(if_block1, 1);
              }
            } else {
              if_block1 = create_if_block_4$9(ctx);
              if_block1.c();
              transition_in(if_block1, 1);
              if_block1.m(t1.parentNode, t1);
            }
          } else if (if_block1) {
            group_outros();
            transition_out(if_block1, 1, 1, () => {
              if_block1 = null;
            });
            check_outros();
          }

          if (
          /*accionVista*/
          ctx[1].comentario) {
            if (if_block2) {
              if_block2.p(ctx, dirty);

              if (dirty &
              /*accionVista*/
              2) {
                transition_in(if_block2, 1);
              }
            } else {
              if_block2 = create_if_block_3$i(ctx);
              if_block2.c();
              transition_in(if_block2, 1);
              if_block2.m(t2.parentNode, t2);
            }
          } else if (if_block2) {
            group_outros();
            transition_out(if_block2, 1, 1, () => {
              if_block2 = null;
            });
            check_outros();
          }

          if (
          /*accionVista*/
          ctx[1].denuncia) {
            if (if_block3) {
              if_block3.p(ctx, dirty);

              if (dirty &
              /*accionVista*/
              2) {
                transition_in(if_block3, 1);
              }
            } else {
              if_block3 = create_if_block_2$q(ctx);
              if_block3.c();
              transition_in(if_block3, 1);
              if_block3.m(t3.parentNode, t3);
            }
          } else if (if_block3) {
            group_outros();
            transition_out(if_block3, 1, 1, () => {
              if_block3 = null;
            });
            check_outros();
          }

          if (
          /*accionVista*/
          ctx[1].ban) {
            if (if_block4) {
              if_block4.p(ctx, dirty);

              if (dirty &
              /*accionVista*/
              2) {
                transition_in(if_block4, 1);
              }
            } else {
              if_block4 = create_if_block_1$t(ctx);
              if_block4.c();
              transition_in(if_block4, 1);
              if_block4.m(if_block4_anchor.parentNode, if_block4_anchor);
            }
          } else if (if_block4) {
            group_outros();
            transition_out(if_block4, 1, 1, () => {
              if_block4 = null;
            });
            check_outros();
          }
        },
        i: function intro(local) {
          if (current) return;
          transition_in(if_block1);
          transition_in(if_block2);
          transition_in(if_block3);
          transition_in(if_block4);
          current = true;
        },
        o: function outro(local) {
          transition_out(if_block1);
          transition_out(if_block2);
          transition_out(if_block3);
          transition_out(if_block4);
          current = false;
        },
        d: function destroy(detaching) {
          if (if_block0) if_block0.d(detaching);
          if (detaching) detach_dev(t0);
          if (if_block1) if_block1.d(detaching);
          if (detaching) detach_dev(t1);
          if (if_block2) if_block2.d(detaching);
          if (detaching) detach_dev(t2);
          if (if_block3) if_block3.d(detaching);
          if (detaching) detach_dev(t3);
          if (if_block4) if_block4.d(detaching);
          if (detaching) detach_dev(if_block4_anchor);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_key_block$1.name,
        type: "key",
        source: "(101:16) {#key accionVista}",
        ctx
      });
      return block;
    }

    function create_fragment$10(ctx) {
      let main;
      let barramoderacion;
      let t0;
      let h3;
      let t2;
      let div0;
      let span;
      let t4;
      let select0;
      let option0;
      let option0_value_value;
      let t6;
      let select1;
      let option1;
      let option1_value_value;
      let t8;
      let div2;
      let ul;
      let each_blocks = [];
      let each2_lookup = new Map();
      let t9;
      let div1;
      let current;
      let mounted;
      let dispose;
      barramoderacion = new BarraModeracion({
        $$inline: true
      });
      let each_value_2 =
      /*mods*/
      ctx[3];
      validate_each_argument(each_value_2);
      let each_blocks_2 = [];

      for (let i = 0; i < each_value_2.length; i += 1) {
        each_blocks_2[i] = create_each_block_2$7(get_each_context_2$7(ctx, each_value_2, i));
      }

      let each_value_1 = Object.keys(TipoAccion);
      validate_each_argument(each_value_1);
      let each_blocks_1 = [];

      for (let i = 0; i < each_value_1.length; i += 1) {
        each_blocks_1[i] = create_each_block_1$d(get_each_context_1$d(ctx, each_value_1, i));
      }

      let each_value =
      /*accionesFiltradas*/
      ctx[2];
      validate_each_argument(each_value);

      const get_key = ctx =>
      /*a*/
      ctx[11].id;

      validate_each_keys(ctx, each_value, get_each_context$p, get_key);

      for (let i = 0; i < each_value.length; i += 1) {
        let child_ctx = get_each_context$p(ctx, each_value, i);
        let key = get_key(child_ctx);
        each2_lookup.set(key, each_blocks[i] = create_each_block$p(key, child_ctx));
      }

      let if_block =
      /*accionVista*/
      ctx[1] != null && create_if_block$M(ctx);
      const block = {
        c: function create() {
          main = element("main");
          create_component(barramoderacion.$$.fragment);
          t0 = space();
          h3 = element("h3");
          h3.textContent = "Ultimas acciones";
          t2 = space();
          div0 = element("div");
          span = element("span");
          span.textContent = "Filtrar:";
          t4 = space();
          select0 = element("select");
          option0 = element("option");
          option0.textContent = "Usuario";

          for (let i = 0; i < each_blocks_2.length; i += 1) {
            each_blocks_2[i].c();
          }

          t6 = space();
          select1 = element("select");
          option1 = element("option");
          option1.textContent = "Accion";

          for (let i = 0; i < each_blocks_1.length; i += 1) {
            each_blocks_1[i].c();
          }

          t8 = space();
          div2 = element("div");
          ul = element("ul");

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].c();
          }

          t9 = space();
          div1 = element("div");
          if (if_block) if_block.c();
          set_style(h3, "text-align", "center");
          set_style(h3, "margin-bottom", "10px");
          add_location(h3, file$Z, 42, 4, 1383);
          add_location(span, file$Z, 47, 8, 1590);
          option0.__value = option0_value_value = "";
          option0.value = option0.__value;
          add_location(option0, file$Z, 49, 12, 1672);
          if (
          /*filtro*/
          ctx[0].usuario === void 0) add_render_callback(() =>
          /*select0_change_handler*/
          ctx[5].call(select0));
          add_location(select0, file$Z, 48, 8, 1622);
          option1.__value = option1_value_value = "";
          option1.value = option1.__value;
          add_location(option1, file$Z, 56, 12, 1887);
          if (
          /*filtro*/
          ctx[0].accion === void 0) add_render_callback(() =>
          /*select1_change_handler*/
          ctx[6].call(select1));
          add_location(select1, file$Z, 55, 8, 1838);
          attr_dev(div0, "class", "filtros");
          set_style(div0, "display", "flex");
          set_style(div0, "width", "fit-content");
          set_style(div0, "margin", "0");
          set_style(div0, "align-items", "baseline");
          add_location(div0, file$Z, 43, 4, 1461);
          attr_dev(ul, "class", "svelte-1p5f2c");
          add_location(ul, file$Z, 63, 8, 2122);
          attr_dev(div1, "class", "vista-previa panel svelte-1p5f2c");
          add_location(div1, file$Z, 98, 8, 3631);
          attr_dev(div2, "class", "container svelte-1p5f2c");
          add_location(div2, file$Z, 62, 4, 2089);
          add_location(main, file$Z, 40, 0, 1346);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, main, anchor);
          mount_component(barramoderacion, main, null);
          append_dev(main, t0);
          append_dev(main, h3);
          append_dev(main, t2);
          append_dev(main, div0);
          append_dev(div0, span);
          append_dev(div0, t4);
          append_dev(div0, select0);
          append_dev(select0, option0);

          for (let i = 0; i < each_blocks_2.length; i += 1) {
            each_blocks_2[i].m(select0, null);
          }

          select_option(select0,
          /*filtro*/
          ctx[0].usuario);
          append_dev(div0, t6);
          append_dev(div0, select1);
          append_dev(select1, option1);

          for (let i = 0; i < each_blocks_1.length; i += 1) {
            each_blocks_1[i].m(select1, null);
          }

          select_option(select1,
          /*filtro*/
          ctx[0].accion);
          append_dev(main, t8);
          append_dev(main, div2);
          append_dev(div2, ul);

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].m(ul, null);
          }

          append_dev(div2, t9);
          append_dev(div2, div1);
          if (if_block) if_block.m(div1, null);
          current = true;

          if (!mounted) {
            dispose = [listen_dev(select0, "change",
            /*select0_change_handler*/
            ctx[5]), listen_dev(select1, "change",
            /*select1_change_handler*/
            ctx[6])];
            mounted = true;
          }
        },
        p: function update(ctx, [dirty]) {
          if (dirty &
          /*mods*/
          8) {
            each_value_2 =
            /*mods*/
            ctx[3];
            validate_each_argument(each_value_2);
            let i;

            for (i = 0; i < each_value_2.length; i += 1) {
              const child_ctx = get_each_context_2$7(ctx, each_value_2, i);

              if (each_blocks_2[i]) {
                each_blocks_2[i].p(child_ctx, dirty);
              } else {
                each_blocks_2[i] = create_each_block_2$7(child_ctx);
                each_blocks_2[i].c();
                each_blocks_2[i].m(select0, null);
              }
            }

            for (; i < each_blocks_2.length; i += 1) {
              each_blocks_2[i].d(1);
            }

            each_blocks_2.length = each_value_2.length;
          }

          if (dirty &
          /*filtro, mods*/
          9) {
            select_option(select0,
            /*filtro*/
            ctx[0].usuario);
          }

          if (dirty &
          /*TipoAccion, Object*/
          0) {
            each_value_1 = Object.keys(TipoAccion);
            validate_each_argument(each_value_1);
            let i;

            for (i = 0; i < each_value_1.length; i += 1) {
              const child_ctx = get_each_context_1$d(ctx, each_value_1, i);

              if (each_blocks_1[i]) {
                each_blocks_1[i].p(child_ctx, dirty);
              } else {
                each_blocks_1[i] = create_each_block_1$d(child_ctx);
                each_blocks_1[i].c();
                each_blocks_1[i].m(select1, null);
              }
            }

            for (; i < each_blocks_1.length; i += 1) {
              each_blocks_1[i].d(1);
            }

            each_blocks_1.length = each_value_1.length;
          }

          if (dirty &
          /*filtro, mods*/
          9) {
            select_option(select1,
            /*filtro*/
            ctx[0].accion);
          }

          if (dirty &
          /*accionesFiltradas, accionVista, tiposConNotas, TipoAccion*/
          22) {
            const each_value =
            /*accionesFiltradas*/
            ctx[2];
            validate_each_argument(each_value);
            group_outros();
            validate_each_keys(ctx, each_value, get_each_context$p, get_key);
            each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each2_lookup, ul, outro_and_destroy_block, create_each_block$p, null, get_each_context$p);
            check_outros();
          }

          if (
          /*accionVista*/
          ctx[1] != null) {
            if (if_block) {
              if_block.p(ctx, dirty);

              if (dirty &
              /*accionVista*/
              2) {
                transition_in(if_block, 1);
              }
            } else {
              if_block = create_if_block$M(ctx);
              if_block.c();
              transition_in(if_block, 1);
              if_block.m(div1, null);
            }
          } else if (if_block) {
            group_outros();
            transition_out(if_block, 1, 1, () => {
              if_block = null;
            });
            check_outros();
          }
        },
        i: function intro(local) {
          if (current) return;
          transition_in(barramoderacion.$$.fragment, local);

          for (let i = 0; i < each_value.length; i += 1) {
            transition_in(each_blocks[i]);
          }

          transition_in(if_block);
          current = true;
        },
        o: function outro(local) {
          transition_out(barramoderacion.$$.fragment, local);

          for (let i = 0; i < each_blocks.length; i += 1) {
            transition_out(each_blocks[i]);
          }

          transition_out(if_block);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(main);
          destroy_component(barramoderacion);
          destroy_each(each_blocks_2, detaching);
          destroy_each(each_blocks_1, detaching);

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].d();
          }

          if (if_block) if_block.d();
          mounted = false;
          run_all(dispose);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$10.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }

    function instance$10($$self, $$props, $$invalidate) {
      let {
        $$slots: slots = {},
        $$scope
      } = $$props;
      validate_slots("Historial", slots, []);
      const historial = window.model.acciones;
      let dialogoDesban = false;
      let filtro = {
        usuario: "",
        accion: ""
      };
      let mods = Array.from(new Set(historial.map(a => a.usuario.userName)));
      let accionVista = null;
      let tiposConNotas = [TipoAccion.CategoriaCambiada, TipoAccion.MediaEliminado];
      const writable_props = [];
      Object_1$8.keys($$props).forEach(key => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Historial> was created with unknown prop '${key}'`);
      });

      function select0_change_handler() {
        filtro.usuario = select_value(this);
        $$invalidate(0, filtro);
        $$invalidate(3, mods);
      }

      function select1_change_handler() {
        filtro.accion = select_value(this);
        $$invalidate(0, filtro);
        $$invalidate(3, mods);
      }

      const mouseenter_handler = a => $$invalidate(1, accionVista = a);

      const func = () => RChanClient.removerBan(accionVista.ban.id);

      $$self.$capture_state = () => ({
        TipoAccion,
        MotivoDenuncia,
        Button: ye,
        Comentario,
        HiloPreviewMod,
        Denuncia,
        formatearTiempo,
        formatearTimeSpan,
        Dialogo,
        RChanClient,
        Tiempo,
        BarraModeracion,
        BanPreview,
        historial,
        dialogoDesban,
        filtro,
        mods,
        accionVista,
        tiposConNotas,
        accionesFiltradas
      });

      $$self.$inject_state = $$props => {
        if ("dialogoDesban" in $$props) dialogoDesban = $$props.dialogoDesban;
        if ("filtro" in $$props) $$invalidate(0, filtro = $$props.filtro);
        if ("mods" in $$props) $$invalidate(3, mods = $$props.mods);
        if ("accionVista" in $$props) $$invalidate(1, accionVista = $$props.accionVista);
        if ("tiposConNotas" in $$props) $$invalidate(4, tiposConNotas = $$props.tiposConNotas);
        if ("accionesFiltradas" in $$props) $$invalidate(2, accionesFiltradas = $$props.accionesFiltradas);
      };

      let accionesFiltradas;

      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }

      $$self.$$.update = () => {
        if ($$self.$$.dirty &
        /*filtro*/
        1) {
           $$invalidate(2, accionesFiltradas = historial.filter(a => {
            let fUsuario = !filtro.usuario || a.usuario.userName == filtro.usuario;
            let fAccion = filtro.accion === "" || a.tipo === filtro.accion;
            return fUsuario && fAccion;
          }) || filtro);
        }
      };

      return [filtro, accionVista, accionesFiltradas, mods, tiposConNotas, select0_change_handler, select1_change_handler, mouseenter_handler, func];
    }

    class Historial extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$10, create_fragment$10, safe_not_equal, {});
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "Historial",
          options,
          id: create_fragment$10.name
        });
      }

    }

    /* src\components\Paginas\Archivo.svelte generated by Svelte v3.29.0 */
    const file$_ = "src\\components\\Paginas\\Archivo.svelte";

    function get_each_context$q(ctx, list, i) {
      const child_ctx = ctx.slice();
      child_ctx[4] = list[i];
      return child_ctx;
    } // (18:4) {#each hilosFiltrados as h (h.id)}


    function create_each_block$q(key_1, ctx) {
      let li;
      let a;
      let t0_value =
      /*h*/
      ctx[4].titulo + "";
      let t0;
      let a_href_value;
      let t1;
      let tiempo;
      let t2;
      let current;
      tiempo = new Tiempo({
        props: {
          date:
          /*h*/
          ctx[4].bump
        },
        $$inline: true
      });
      const block = {
        key: key_1,
        first: null,
        c: function create() {
          li = element("li");
          a = element("a");
          t0 = text(t0_value);
          t1 = space();
          create_component(tiempo.$$.fragment);
          t2 = space();
          attr_dev(a, "href", a_href_value = "/Hilo/" +
          /*h*/
          ctx[4].id);
          add_location(a, file$_, 19, 12, 579);
          attr_dev(li, "class", "svelte-l26iya");
          toggle_class(li, "historico",
          /*h*/
          ctx[4].historico);
          add_location(li, file$_, 18, 8, 532);
          this.first = li;
        },
        m: function mount(target, anchor) {
          insert_dev(target, li, anchor);
          append_dev(li, a);
          append_dev(a, t0);
          append_dev(li, t1);
          mount_component(tiempo, li, null);
          append_dev(li, t2);
          current = true;
        },
        p: function update(ctx, dirty) {
          if ((!current || dirty &
          /*hilosFiltrados*/
          2) && t0_value !== (t0_value =
          /*h*/
          ctx[4].titulo + "")) set_data_dev(t0, t0_value);

          if (!current || dirty &
          /*hilosFiltrados*/
          2 && a_href_value !== (a_href_value = "/Hilo/" +
          /*h*/
          ctx[4].id)) {
            attr_dev(a, "href", a_href_value);
          }

          const tiempo_changes = {};
          if (dirty &
          /*hilosFiltrados*/
          2) tiempo_changes.date =
          /*h*/
          ctx[4].bump;
          tiempo.$set(tiempo_changes);

          if (dirty &
          /*hilosFiltrados*/
          2) {
            toggle_class(li, "historico",
            /*h*/
            ctx[4].historico);
          }
        },
        i: function intro(local) {
          if (current) return;
          transition_in(tiempo.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(tiempo.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(li);
          destroy_component(tiempo);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_each_block$q.name,
        type: "each",
        source: "(18:4) {#each hilosFiltrados as h (h.id)}",
        ctx
      });
      return block;
    }

    function create_fragment$11(ctx) {
      let ul;
      let h1;
      let t2;
      let input;
      let t3;
      let each_blocks = [];
      let each_1_lookup = new Map();
      let current;
      let mounted;
      let dispose;
      let each_value =
      /*hilosFiltrados*/
      ctx[1];
      validate_each_argument(each_value);

      const get_key = ctx =>
      /*h*/
      ctx[4].id;

      validate_each_keys(ctx, each_value, get_each_context$q, get_key);

      for (let i = 0; i < each_value.length; i += 1) {
        let child_ctx = get_each_context$q(ctx, each_value, i);
        let key = get_key(child_ctx);
        each_1_lookup.set(key, each_blocks[i] = create_each_block$q(key, child_ctx));
      }

      const block = {
        c: function create() {
          ul = element("ul");
          h1 = element("h1");
          h1.textContent = `Roz archivados ${
      /*hilos*/
      ctx[2].length}`;
          t2 = space();
          input = element("input");
          t3 = space();

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].c();
          }

          attr_dev(h1, "class", "svelte-l26iya");
          add_location(h1, file$_, 10, 4, 278);
          attr_dev(input, "autocomplete", "off");
          attr_dev(input, "placeholder", "Filtrar: Alguna palabra en el titulo del roz");
          input.autofocus = true;
          attr_dev(input, "class", "svelte-l26iya");
          add_location(input, file$_, 11, 4, 321);
          attr_dev(ul, "class", "archivo-list svelte-l26iya");
          add_location(ul, file$_, 9, 0, 248);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, ul, anchor);
          append_dev(ul, h1);
          append_dev(ul, t2);
          append_dev(ul, input);
          set_input_value(input,
          /*cadenaDeBusqueda*/
          ctx[0]);
          append_dev(ul, t3);

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].m(ul, null);
          }

          current = true;
          input.focus();

          if (!mounted) {
            dispose = listen_dev(input, "input",
            /*input_input_handler*/
            ctx[3]);
            mounted = true;
          }
        },
        p: function update(ctx, [dirty]) {
          if (dirty &
          /*cadenaDeBusqueda*/
          1 && input.value !==
          /*cadenaDeBusqueda*/
          ctx[0]) {
            set_input_value(input,
            /*cadenaDeBusqueda*/
            ctx[0]);
          }

          if (dirty &
          /*hilosFiltrados*/
          2) {
            const each_value =
            /*hilosFiltrados*/
            ctx[1];
            validate_each_argument(each_value);
            group_outros();
            validate_each_keys(ctx, each_value, get_each_context$q, get_key);
            each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, ul, outro_and_destroy_block, create_each_block$q, null, get_each_context$q);
            check_outros();
          }
        },
        i: function intro(local) {
          if (current) return;

          for (let i = 0; i < each_value.length; i += 1) {
            transition_in(each_blocks[i]);
          }

          current = true;
        },
        o: function outro(local) {
          for (let i = 0; i < each_blocks.length; i += 1) {
            transition_out(each_blocks[i]);
          }

          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(ul);

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].d();
          }

          mounted = false;
          dispose();
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$11.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }

    function instance$11($$self, $$props, $$invalidate) {
      let {
        $$slots: slots = {},
        $$scope
      } = $$props;
      validate_slots("Archivo", slots, []);
      let hilos = window.model;
      let cadenaDeBusqueda = "";
      const writable_props = [];
      Object.keys($$props).forEach(key => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Archivo> was created with unknown prop '${key}'`);
      });

      function input_input_handler() {
        cadenaDeBusqueda = this.value;
        $$invalidate(0, cadenaDeBusqueda);
      }

      $$self.$capture_state = () => ({
        Tiempo,
        hilos,
        cadenaDeBusqueda,
        hilosFiltrados
      });

      $$self.$inject_state = $$props => {
        if ("hilos" in $$props) $$invalidate(2, hilos = $$props.hilos);
        if ("cadenaDeBusqueda" in $$props) $$invalidate(0, cadenaDeBusqueda = $$props.cadenaDeBusqueda);
        if ("hilosFiltrados" in $$props) $$invalidate(1, hilosFiltrados = $$props.hilosFiltrados);
      };

      let hilosFiltrados;

      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }

      $$self.$$.update = () => {
        if ($$self.$$.dirty &
        /*cadenaDeBusqueda*/
        1) {
           $$invalidate(1, hilosFiltrados = hilos.filter(h => cadenaDeBusqueda == "" || h.titulo.toLowerCase().includes(cadenaDeBusqueda)));
        }
      };

      return [cadenaDeBusqueda, hilosFiltrados, hilos, input_input_handler];
    }

    class Archivo extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$11, create_fragment$11, safe_not_equal, {});
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "Archivo",
          options,
          id: create_fragment$11.name
        });
      }

    }

    /* src\components\Paginas\Spams.svelte generated by Svelte v3.29.0 */
    const file$$ = "src\\components\\Paginas\\Spams.svelte";

    function get_each_context$r(ctx, list, i) {
      const child_ctx = ctx.slice();
      child_ctx[11] = list[i];
      return child_ctx;
    } // (40:12) <Button on:click={() => eliminarSpam(spam.id)}>


    function create_default_slot_1$w(ctx) {
      let t;
      const block = {
        c: function create() {
          t = text("Eliminar");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot_1$w.name,
        type: "slot",
        source: "(40:12) <Button on:click={() => eliminarSpam(spam.id)}>",
        ctx
      });
      return block;
    } // (36:12) {#each spams as spam (spam.id)}


    function create_each_block$r(key_1, ctx) {
      let a;
      let li;
      let a_href_value;
      let t;
      let button;
      let current;

      function click_handler(...args) {
        return (
          /*click_handler*/
          ctx[7](
          /*spam*/
          ctx[11], ...args)
        );
      }

      button = new ye({
        props: {
          $$slots: {
            default: [create_default_slot_1$w]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      button.$on("click", click_handler);
      const block = {
        key: key_1,
        first: null,
        c: function create() {
          a = element("a");
          li = element("li");
          t = space();
          create_component(button.$$.fragment);
          attr_dev(li, "class", "rozpam svelte-1ynta8");
          set_style(li, "background-image", "url(" +
          /*spam*/
          ctx[11].urlImagen + ")");
          add_location(li, file$$, 37, 16, 904);
          attr_dev(a, "href", a_href_value =
          /*spam*/
          ctx[11].link);
          add_location(a, file$$, 36, 12, 867);
          this.first = a;
        },
        m: function mount(target, anchor) {
          insert_dev(target, a, anchor);
          append_dev(a, li);
          insert_dev(target, t, anchor);
          mount_component(button, target, anchor);
          current = true;
        },
        p: function update(new_ctx, dirty) {
          ctx = new_ctx;
          const button_changes = {};

          if (dirty &
          /*$$scope*/
          16384) {
            button_changes.$$scope = {
              dirty,
              ctx
            };
          }

          button.$set(button_changes);
        },
        i: function intro(local) {
          if (current) return;
          transition_in(button.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          transition_out(button.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(a);
          if (detaching) detach_dev(t);
          destroy_component(button, detaching);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_each_block$r.name,
        type: "each",
        source: "(36:12) {#each spams as spam (spam.id)}",
        ctx
      });
      return block;
    } // (63:12) <Button on:click={crearSpam}>


    function create_default_slot$D(ctx) {
      let t;
      const block = {
        c: function create() {
          t = text("Aceptar");
        },
        m: function mount(target, anchor) {
          insert_dev(target, t, anchor);
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(t);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_default_slot$D.name,
        type: "slot",
        source: "(63:12) <Button on:click={crearSpam}>",
        ctx
      });
      return block;
    }

    function create_fragment$12(ctx) {
      let main;
      let section0;
      let h30;
      let t1;
      let ul;
      let each_blocks = [];
      let each_1_lookup = new Map();
      let t2;
      let section1;
      let errorvalidacion;
      let t3;
      let h31;
      let t5;
      let a;
      let t7;
      let input0;
      let t8;
      let input1;
      let t9;
      let select;
      let option0;
      let option1;
      let option2;
      let option3;
      let option4;
      let option5;
      let option6;
      let option7;
      let option8;
      let t19;
      let div;
      let button;
      let current;
      let mounted;
      let dispose;
      let each_value =
      /*spams*/
      ctx[4];
      validate_each_argument(each_value);

      const get_key = ctx =>
      /*spam*/
      ctx[11].id;

      validate_each_keys(ctx, each_value, get_each_context$r, get_key);

      for (let i = 0; i < each_value.length; i += 1) {
        let child_ctx = get_each_context$r(ctx, each_value, i);
        let key = get_key(child_ctx);
        each_1_lookup.set(key, each_blocks[i] = create_each_block$r(key, child_ctx));
      }

      errorvalidacion = new ErrorValidacion({
        props: {
          error:
          /*error*/
          ctx[3]
        },
        $$inline: true
      });
      button = new ye({
        props: {
          $$slots: {
            default: [create_default_slot$D]
          },
          $$scope: {
            ctx
          }
        },
        $$inline: true
      });
      button.$on("click",
      /*crearSpam*/
      ctx[5]);
      const block = {
        c: function create() {
          main = element("main");
          section0 = element("section");
          h30 = element("h3");
          h30.textContent = "RozpPams activos";
          t1 = space();
          ul = element("ul");

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].c();
          }

          t2 = space();
          section1 = element("section");
          create_component(errorvalidacion.$$.fragment);
          t3 = space();
          h31 = element("h3");
          h31.textContent = "Agregar RozPam";
          t5 = space();
          a = element("a");
          a.textContent = "Subir imagen";
          t7 = space();
          input0 = element("input");
          t8 = space();
          input1 = element("input");
          t9 = space();
          select = element("select");
          option0 = element("option");
          option0.textContent = "Duracion";
          option1 = element("option");
          option1.textContent = "5 min";
          option2 = element("option");
          option2.textContent = "10 min";
          option3 = element("option");
          option3.textContent = "30 min";
          option4 = element("option");
          option4.textContent = "1 hora";
          option5 = element("option");
          option5.textContent = "6 horas";
          option6 = element("option");
          option6.textContent = "1 dia";
          option7 = element("option");
          option7.textContent = "3 dia";
          option8 = element("option");
          option8.textContent = "1 semana";
          t19 = space();
          div = element("div");
          create_component(button.$$.fragment);
          attr_dev(h30, "class", "svelte-1ynta8");
          add_location(h30, file$$, 33, 8, 772);
          add_location(ul, file$$, 34, 8, 806);
          attr_dev(section0, "class", "panel svelte-1ynta8");
          add_location(section0, file$$, 32, 4, 740);
          attr_dev(h31, "class", "svelte-1ynta8");
          add_location(h31, file$$, 46, 8, 1211);
          attr_dev(a, "href", "https://imgur.com/upload");
          attr_dev(a, "target", "_blank");
          add_location(a, file$$, 47, 8, 1243);
          attr_dev(input0, "placeholder", "Link imagen");
          attr_dev(input0, "type", "text");
          add_location(input0, file$$, 48, 8, 1319);
          attr_dev(input1, "placeholder", "Link");
          attr_dev(input1, "type", "text");
          add_location(input1, file$$, 49, 8, 1396);
          option0.__value = "-1";
          option0.value = option0.__value;
          option0.selected = "selected";
          option0.disabled = "disabled";
          add_location(option0, file$$, 51, 12, 1522);
          option1.__value = "5";
          option1.value = option1.__value;
          add_location(option1, file$$, 52, 12, 1611);
          option2.__value = "10";
          option2.value = option2.__value;
          add_location(option2, file$$, 53, 12, 1656);
          option3.__value = "30";
          option3.value = option3.__value;
          add_location(option3, file$$, 54, 12, 1703);
          option4.__value = "60";
          option4.value = option4.__value;
          add_location(option4, file$$, 55, 12, 1750);
          option5.__value = "360";
          option5.value = option5.__value;
          add_location(option5, file$$, 56, 12, 1797);
          option6.__value = "1440";
          option6.value = option6.__value;
          add_location(option6, file$$, 57, 12, 1846);
          option7.__value = "4320";
          option7.value = option7.__value;
          add_location(option7, file$$, 58, 12, 1894);
          option8.__value = "10080";
          option8.value = option8.__value;
          add_location(option8, file$$, 59, 12, 1942);
          attr_dev(select, "name", "duracion");
          if (
          /*duracion*/
          ctx[0] === void 0) add_render_callback(() =>
          /*select_change_handler*/
          ctx[10].call(select));
          add_location(select, file$$, 50, 8, 1461);
          set_style(div, "margin", "0 auto");
          set_style(div, "width", "fit-content");
          add_location(div, file$$, 61, 8, 2008);
          attr_dev(section1, "class", "panel agregar-rozpam svelte-1ynta8");
          add_location(section1, file$$, 44, 4, 1129);
          attr_dev(main, "class", "svelte-1ynta8");
          add_location(main, file$$, 31, 0, 729);
        },
        l: function claim(nodes) {
          throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
        },
        m: function mount(target, anchor) {
          insert_dev(target, main, anchor);
          append_dev(main, section0);
          append_dev(section0, h30);
          append_dev(section0, t1);
          append_dev(section0, ul);

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].m(ul, null);
          }

          append_dev(main, t2);
          append_dev(main, section1);
          mount_component(errorvalidacion, section1, null);
          append_dev(section1, t3);
          append_dev(section1, h31);
          append_dev(section1, t5);
          append_dev(section1, a);
          append_dev(section1, t7);
          append_dev(section1, input0);
          set_input_value(input0,
          /*urlImagen*/
          ctx[1]);
          append_dev(section1, t8);
          append_dev(section1, input1);
          set_input_value(input1,
          /*link*/
          ctx[2]);
          append_dev(section1, t9);
          append_dev(section1, select);
          append_dev(select, option0);
          append_dev(select, option1);
          append_dev(select, option2);
          append_dev(select, option3);
          append_dev(select, option4);
          append_dev(select, option5);
          append_dev(select, option6);
          append_dev(select, option7);
          append_dev(select, option8);
          select_option(select,
          /*duracion*/
          ctx[0]);
          append_dev(section1, t19);
          append_dev(section1, div);
          mount_component(button, div, null);
          current = true;

          if (!mounted) {
            dispose = [listen_dev(input0, "input",
            /*input0_input_handler*/
            ctx[8]), listen_dev(input1, "input",
            /*input1_input_handler*/
            ctx[9]), listen_dev(select, "change",
            /*select_change_handler*/
            ctx[10])];
            mounted = true;
          }
        },
        p: function update(ctx, [dirty]) {
          if (dirty &
          /*eliminarSpam, spams*/
          80) {
            const each_value =
            /*spams*/
            ctx[4];
            validate_each_argument(each_value);
            group_outros();
            validate_each_keys(ctx, each_value, get_each_context$r, get_key);
            each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, ul, outro_and_destroy_block, create_each_block$r, null, get_each_context$r);
            check_outros();
          }

          const errorvalidacion_changes = {};
          if (dirty &
          /*error*/
          8) errorvalidacion_changes.error =
          /*error*/
          ctx[3];
          errorvalidacion.$set(errorvalidacion_changes);

          if (dirty &
          /*urlImagen*/
          2 && input0.value !==
          /*urlImagen*/
          ctx[1]) {
            set_input_value(input0,
            /*urlImagen*/
            ctx[1]);
          }

          if (dirty &
          /*link*/
          4 && input1.value !==
          /*link*/
          ctx[2]) {
            set_input_value(input1,
            /*link*/
            ctx[2]);
          }

          if (dirty &
          /*duracion*/
          1) {
            select_option(select,
            /*duracion*/
            ctx[0]);
          }

          const button_changes = {};

          if (dirty &
          /*$$scope*/
          16384) {
            button_changes.$$scope = {
              dirty,
              ctx
            };
          }

          button.$set(button_changes);
        },
        i: function intro(local) {
          if (current) return;

          for (let i = 0; i < each_value.length; i += 1) {
            transition_in(each_blocks[i]);
          }

          transition_in(errorvalidacion.$$.fragment, local);
          transition_in(button.$$.fragment, local);
          current = true;
        },
        o: function outro(local) {
          for (let i = 0; i < each_blocks.length; i += 1) {
            transition_out(each_blocks[i]);
          }

          transition_out(errorvalidacion.$$.fragment, local);
          transition_out(button.$$.fragment, local);
          current = false;
        },
        d: function destroy(detaching) {
          if (detaching) detach_dev(main);

          for (let i = 0; i < each_blocks.length; i += 1) {
            each_blocks[i].d();
          }

          destroy_component(errorvalidacion);
          destroy_component(button);
          mounted = false;
          run_all(dispose);
        }
      };
      dispatch_dev("SvelteRegisterBlock", {
        block,
        id: create_fragment$12.name,
        type: "component",
        source: "",
        ctx
      });
      return block;
    }

    function instance$12($$self, $$props, $$invalidate) {
      let {
        $$slots: slots = {},
        $$scope
      } = $$props;
      validate_slots("Spams", slots, []);
      let spams = window.model.spams;
      let duracion = 0;
      let urlImagen = "";
      let link = "";
      let error;

      async function crearSpam() {
        try {
          let res = await RChanClient.crearSpam(urlImagen, link, duracion);
          location.reload();
        } catch (e) {
          $$invalidate(3, error = e.response.data);
        }
      }

      async function eliminarSpam(id) {
        try {
          let res = await RChanClient.eliminarSpam(id);
          location.reload();
        } catch (e) {
          $$invalidate(3, error = e.response.data);
        }
      }

      const writable_props = [];
      Object.keys($$props).forEach(key => {
        if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Spams> was created with unknown prop '${key}'`);
      });

      const click_handler = spam => eliminarSpam(spam.id);

      function input0_input_handler() {
        urlImagen = this.value;
        $$invalidate(1, urlImagen);
      }

      function input1_input_handler() {
        link = this.value;
        $$invalidate(2, link);
      }

      function select_change_handler() {
        duracion = select_value(this);
        $$invalidate(0, duracion);
      }

      $$self.$capture_state = () => ({
        Button: ye,
        RChanClient,
        ErrorValidacion,
        spams,
        duracion,
        urlImagen,
        link,
        error,
        crearSpam,
        eliminarSpam
      });

      $$self.$inject_state = $$props => {
        if ("spams" in $$props) $$invalidate(4, spams = $$props.spams);
        if ("duracion" in $$props) $$invalidate(0, duracion = $$props.duracion);
        if ("urlImagen" in $$props) $$invalidate(1, urlImagen = $$props.urlImagen);
        if ("link" in $$props) $$invalidate(2, link = $$props.link);
        if ("error" in $$props) $$invalidate(3, error = $$props.error);
      };

      if ($$props && "$$inject" in $$props) {
        $$self.$inject_state($$props.$$inject);
      }

      return [duracion, urlImagen, link, error, spams, crearSpam, eliminarSpam, click_handler, input0_input_handler, input1_input_handler, select_change_handler];
    }

    class Spams extends SvelteComponentDev {
      constructor(options) {
        super(options);
        init(this, options, instance$12, create_fragment$12, safe_not_equal, {});
        dispatch_dev("SvelteRegisterComponent", {
          component: this,
          tagName: "Spams",
          options,
          id: create_fragment$12.name
        });
      }

    }

    store$1.applicarEstilo(); // const app = new App({
    // 	target: document.body,
    // 	props: {
    // 		name: 'world'
    // 	}
    // });

    let componentes = [["#svelte", App, {}], ["#svelte-navbar", Navbar, {}], ["#svelte-index", HiloList, {
      hiloList: window.hiloList
    }], ["#svelte-administracion", Administracion, {}], ["#svelte-moderacion", Moderacion, {}], ["#svelte-token", Token, {}], ["#svelte-login", Login, {}], ["#svelte-historialDeUsuario", HistorialUsuario, {}], ["#svelte-registro", Registro], ["#svelte-inicio", Inicio], ["#svelte-domado", Domado, {}], ["#svelte-listaDeUsuarios", ListaDeUsuarios, {}], ["#svelte-eliminadosYDesactivados", EliminadosYDesactivados, {}], ["#svelte-media-home", MediaHome, {}], ["#svelte-busqueda", Busqueda, {}], ["#svelte-historial", Historial, {}], ["#svelte-archivo", Archivo, {}], ["#svelte-spams", Spams, {}]];

    for (const c of componentes) {
      if (document.querySelector(c[0])) {
        new c[1]({
          target: document.querySelector(c[0]),
          props: c[2]
        });
      }
    }

}());
//# sourceMappingURL=bundle.js.map
